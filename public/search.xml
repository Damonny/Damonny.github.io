<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java实现代理模式</title>
    <url>//post/java-implementing-agent-mode-zxwpxc.html</url>
    <content><![CDATA[<h1 id="Java实现代理模式"><a href="#Java实现代理模式" class="headerlink" title="Java实现代理模式"></a>Java实现代理模式</h1><p>Java实现代理模式</p>
<p>1、代理模式</p>
<hr>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</p>
<p>代理模式有<strong>静态代理</strong>和<strong>动态代理</strong>两种实现方式。</p>
<p>2、静态代理</p>
<hr>
<p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
<p>下面通过代码展示！ <strong>1</strong>​ **.<strong>​ ** 定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2​-​-实现发送短信的接口"><a href="#2​-​-实现发送短信的接口" class="headerlink" title="2​ **.​ ** 实现发送短信的接口"></a><strong>2</strong>​ **.<strong>​ ** 实现发送短信的接口</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的 send message : &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3​-​-创建代理类并同样实现发送短信的接口"><a href="#3​-​-创建代理类并同样实现发送短信的接口" class="headerlink" title="3​ **.​ ** 创建代理类并同样实现发送短信的接口"></a><strong>3</strong>​ **.<strong>​ ** 创建代理类并同样实现发送短信的接口</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代理 before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代理 after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4​-​-实际使用"><a href="#4​-​-实际使用" class="headerlink" title="4​ **.​ ** 实际使用"></a><strong>4</strong>​ **.<strong>​ ** 实际使用</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 静态代理和动态代理 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代理</span></span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-执行结果："><a href="#5-执行结果：" class="headerlink" title="5.执行结果："></a>5.执行结果：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代理 before method <span class="title function_">send</span><span class="params">()</span></span><br><span class="line">真实的 send message : java</span><br><span class="line">静态代理 after method <span class="title function_">send</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>3、动态代理</p>
<hr>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类(CGLIB动态代理机制)。</p>
<p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>
<p>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。</p>
<p>guide-rpc-framework使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>
<p>另外，虽然 guide-rpc-framework 没有用到 CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和JDK 动态代理的对比。</p>
<h3 id="3-1-JDK-动态代理机制"><a href="#3-1-JDK-动态代理机制" class="headerlink" title="3.1 JDK 动态代理机制"></a>3.1 JDK 动态代理机制</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>在 Java 动态代理机制中 <code>*InvocationHandler*</code> 接口和 Proxy 类是核心。</p>
<p>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li>**loader：**类加载器，用于加载代理对象。</li>
<li>**interfaces：**被代理类实现的一些接口；</li>
<li>**h：**实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li>**proxy：**动态生成的代理类</li>
<li>**methoh：**与代理类对象调用的方法相对应</li>
<li>**args：**当前 method 方法的参数</li>
</ol>
<p>也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h5 id="3-1-2-JDK-动态代理类使用步骤"><a href="#3-1-2-JDK-动态代理类使用步骤" class="headerlink" title="3.1.2 JDK 动态代理类使用步骤"></a>3.1.2 JDK 动态代理类使用步骤</h5><p>定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</p>
<h5 id="3-1-2-代码示例"><a href="#3-1-2-代码示例" class="headerlink" title="3.1.2 代码示例"></a>3.1.2 代码示例</h5><ol>
<li>定义发送短信的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现发送短信的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的 send message : &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个JDK动态代理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类中的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理 before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;JDK动态代理 after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取代理对象的工厂类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">            target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实际使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 静态代理和动态代理 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService1</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">        smsService1.send(<span class="string">&quot;Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>执行结果：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK动态代理 before method send</span><br><span class="line">真实的 send message : Java!</span><br><span class="line">JDK动态代理 after method send</span><br></pre></td></tr></table></figure>

<h3 id="3-2-CGLIB-动态代理机制"><a href="#3-2-CGLIB-动态代理机制" class="headerlink" title="3.2. CGLIB 动态代理机制"></a>3.2. CGLIB 动态代理机制</h3><h4 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1. 介绍"></a>3.2.1. 介绍</h4><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>
<p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>
<p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="line"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>**obj：**被代理的对象（需要增强的对象）</li>
<li>**method：**被拦截的方法（需要增强的方法）</li>
<li>**args：**方法入参</li>
<li>**proxy：**用于调用原始方法</li>
</ol>
<p>你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</p>
<h4 id="3-2-2-CGLIB-动态代理类使用步骤"><a href="#3-2-2-CGLIB-动态代理类使用步骤" class="headerlink" title="3.2.2. CGLIB 动态代理类使用步骤"></a>3.2.2. CGLIB 动态代理类使用步骤</h4><ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="3-2-3-代码示例"><a href="#3-2-3-代码示例" class="headerlink" title="3.2.3. 代码示例"></a>3.2.3. 代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>实现一个使用阿里云发送短信的类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>自定义 MethodInterceptor（方法拦截器）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           代理对象（增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取代理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>实际使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 静态代理和动态代理 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">        aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行结果：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<h4 id="3-3-JDK动态代理和CGLIB动态代理对比"><a href="#3-3-JDK动态代理和CGLIB动态代理对比" class="headerlink" title="3.3. JDK动态代理和CGLIB动态代理对比"></a>3.3. JDK动态代理和CGLIB动态代理对比</h4><ol>
<li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<p>4、静态代理和动态代理的对比</p>
<hr>
<ol>
<li>灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Nacos配置中心并支持多配置文件</title>
    <url>//post/nacos-configuration-center-and-support-multi-configuration-files-zi2mmf.html</url>
    <content><![CDATA[<h1 id="Nacos配置中心并支持多配置文件"><a href="#Nacos配置中心并支持多配置文件" class="headerlink" title="Nacos配置中心并支持多配置文件"></a>Nacos配置中心并支持多配置文件</h1><h3 id="一、引入依赖包"><a href="#一、引入依赖包" class="headerlink" title="一、引入依赖包"></a>一、引入依赖包</h3><hr>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>discovery和config分别为注册中心客户端和配置中心客户端</p>
<p>注意：</p>
<ol>
<li>config，引入这个配置中心的依赖后，需要使用bootstrap.yml作为中转配置文件，读取的优先级为bootstrap.yml&gt;application.yml</li>
<li>配置中心地址结尾不能带斜杠 否者会报异常</li>
</ol>
</blockquote>
<h3 id="二、单文件配置"><a href="#二、单文件配置" class="headerlink" title="二、单文件配置"></a>二、单文件配置</h3><hr>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">onedata</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://172.20.23.140:80</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">         <span class="attr">server-addr:</span> <span class="string">http://172.20.23.140:80</span></span><br><span class="line">         <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">         <span class="attr">file-extension:</span> <span class="string">yml</span></span><br></pre></td></tr></table></figure>

<p>三、多文件配置</p>
<hr>
<p>1、创建bootstrap.yml,配置激活环境标识</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>2、创建bootstrap-dev.yml文件，配置连接nacos服务中心，加载多个配置文件</p>
<p><strong>写法一：</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mybatis-plus-join-practice</span></span><br><span class="line">  <span class="comment">#配置nacos注册中心和配置中心</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://xxx:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span>  <span class="comment"># yaml格式</span></span><br><span class="line">        <span class="attr">extension-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">application.yml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">datasource.yml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>写法二：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mybatis-plus-join-practice</span></span><br><span class="line">  <span class="comment">#配置nacos注册中心和配置中心</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://xxx:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class="line">        <span class="string">extension-configs[0]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">application.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class="line">          <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">file-extension:</span> <span class="string">yml</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">extension-configs[1]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">datasource.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class="line">          <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">file-extension:</span> <span class="string">yml</span></span><br></pre></td></tr></table></figure>

<p><strong>写法三：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mybatis-plus-join-practice</span></span><br><span class="line">  <span class="comment">#配置nacos注册中心和配置中心</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">http://xxx:8848</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class="line">        <span class="string">shared-configs[0]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">application.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class="line">          <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">file-extension:</span> <span class="string">yml</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">shared-configs[1]:</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">datasource.yml</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class="line">          <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">file-extension:</span> <span class="string">yml</span></span><br></pre></td></tr></table></figure>

<p>说明： 1、以上三种写法都支持加载多个配置文件 1、内容中 extension-configs[0]、shared-configs[0] 加载的是 application.yml 配置文件 2、内容中 extension-configs[1]、shared-configs[1] 加载的是 datasource.yml 配置文件 3、配置文件在激活标识的 dev 环境的 MYBATIS-PLUS-PRACTICE 分组下</p>
<blockquote>
<p>1、在实际应用中，可以使用多文件配置，把spring配置和数据源配置分开</p>
<p>2、可以使用命名空间区分不同的环境，例如：dev,sit,uat等环境</p>
<p>3、权限控制开启方式，在conf&#x2F;applicaiton.properties文件中修改属性值即可，如下</p>
<p><code>nacos.core.auth.enabled=true</code></p>
<p>4、如果服务端开启了权限控制，注册中心和配置中心需要明确指定访问用户名和密码，命名空间才可以正常访问</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>nginx安装部署</title>
    <url>//post/nginx-installation-deployment-z1jtjzq.html</url>
    <content><![CDATA[<h1 id="nginx安装部署"><a href="#nginx安装部署" class="headerlink" title="nginx安装部署"></a>nginx安装部署</h1><h1 id="nginx安装部署-1"><a href="#nginx安装部署-1" class="headerlink" title="nginx安装部署"></a>nginx安装部署</h1><h2 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h2><hr>
<p><strong>docker-compose.yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.23.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./conf.d:/etc/nginx/conf.d:Z</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./ssl:/etc/nginx/ssl_key:Z</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./logs:/var/log/nginx:Z</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./html:/etc/nginx/html:Z</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">nginx-debug</span>,<span class="string">&#x27;-g&#x27;</span>,<span class="string">&#x27;daemon off;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>文件夹规划 nginx</p>
<p>|-conf.d #文件夹，用于存放server的配置#​</p>
<p>|-ssl.conf ## https配置文件</p>
<p>|-docker-compose.yaml ## 主的docker-compose配置文件</p>
<p>|-html ## 作为前端服务器用于存放前端文件</p>
<p>|-logs ## 日志文件信息</p>
<p>|-nginx.conf ## nginx主的配置文件，通用的http配置都放在这里</p>
<p>|-ssl ## crt key的存放地址</p>
<h2 id="源码部署"><a href="#源码部署" class="headerlink" title="源码部署"></a>源码部署</h2><hr>
<h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install openssl openssl-devel make zlib zlib-devel gcc gcc-c++ libtool    pcre pcre-devel</span><br></pre></td></tr></table></figure>

<h3 id="创建没有登录的用户和用户组"><a href="#创建没有登录的用户和用户组" class="headerlink" title="创建没有登录的用户和用户组"></a>创建没有登录的用户和用户组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd -r nginx</span><br><span class="line"></span><br><span class="line">useradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>-r: 添加系统用户( 这里指将要被创建的系统用户<code>nginx</code>)</li>
<li>-g: 指定要创建的用户所属组( 这里指添加新系统用户<code>nginx</code>到<code>nginx</code>系统用户组 )</li>
<li>-s: 新帐户的登录<code>shell</code>( <code>/sbin/nologin</code> 这里设置为将要被创建系统用户<code>nginx</code>不能用来登录系统 )</li>
<li>-d: 新帐户的主目录( 这里指定将要被创建的系统用户<code>nginx</code>的家目录为 <code>/usr/local/nginx</code> )</li>
<li>-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户<code>nginx</code>不会在 <code>/home</code> 目录下创建 <code>nginx</code> 家目录 )</li>
</ul>
<h3 id="源码安装nginx"><a href="#源码安装nginx" class="headerlink" title="源码安装nginx"></a>源码安装nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.23.1.tar.gz</span><br><span class="line">tar -zvxf nginx-1.23.1.tar.gz -C ./nginx</span><br><span class="line">cd nginx/nginx-1.23.1</span><br><span class="line">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="查看内置模块"><a href="#查看内置模块" class="headerlink" title="查看内置模块"></a>查看内置模块</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ./auto/options |grep YES</span><br></pre></td></tr></table></figure>

<h3 id="查看自定义模块"><a href="#查看自定义模块" class="headerlink" title="查看自定义模块"></a>查看自定义模块</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>

<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/nginx/sbin</span><br><span class="line">nginx -c nginx.conf  <span class="comment"># 启动</span></span><br><span class="line">nginx -s stop  <span class="comment"># 关闭</span></span><br><span class="line">nginx -s reload <span class="comment"># 重新加载配置</span></span><br><span class="line">nginx -s quit <span class="comment"># 重启，先停止在启动</span></span><br></pre></td></tr></table></figure>

<h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>在<code>rc.local</code>增加启动代码即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line"> /usr/local/nignx/sbin/nginx  -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>设置rc.local的文件执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 rc.local</span><br></pre></td></tr></table></figure>

<h2 id="包管理工具安装"><a href="#包管理工具安装" class="headerlink" title="包管理工具安装"></a>包管理工具安装</h2><p>安装 Nginx 可以使用多种包管理工具，具体取决于你的操作系统。以下是常见操作系统的安装方法:</p>
<hr>
<h3 id="1-在-Ubuntu-Debian-上安装-Nginx"><a href="#1-在-Ubuntu-Debian-上安装-Nginx" class="headerlink" title="1. 在 Ubuntu&#x2F;Debian 上安装 Nginx"></a><strong>1. 在 Ubuntu&#x2F;Debian 上安装 Nginx</strong></h3><h4 id="使用-apt​-包管理工具："><a href="#使用-apt​-包管理工具：" class="headerlink" title="使用 apt​ 包管理工具："></a>使用 <code>apt</code>​ 包管理工具：</h4><ol>
<li><p><strong>更新包列表</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装 Nginx</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>启动 Nginx 服务</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置 Nginx 开机自启动</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>
</li>
</ol>
<hr>
<h3 id="2-在-CentOS-RHEL-上安装-Nginx"><a href="#2-在-CentOS-RHEL-上安装-Nginx" class="headerlink" title="2. 在 CentOS&#x2F;RHEL 上安装 Nginx"></a><strong>2. 在 CentOS&#x2F;RHEL 上安装 Nginx</strong></h3><h4 id="使用-yum​-或-dnf​-包管理工具："><a href="#使用-yum​-或-dnf​-包管理工具：" class="headerlink" title="使用 yum​ 或 dnf​ 包管理工具："></a>使用 <code>yum</code>​ 或 <code>dnf</code>​ 包管理工具：</h4><ol>
<li><p><strong>添加 Nginx 官方仓库</strong>：<br> 创建一个文件 <code>/etc/yum.repos.d/nginx.repo</code>​，并添加以下内容：</p>
 <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[nginx]</span><span class="attr">name</span>=nginx repobaseurl=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/gpgcheck=<span class="number">0</span>enabled=<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装 Nginx</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install nginx</span><br></pre></td></tr></table></figure>

<p> 或者使用 <code>dnf</code>​（适用于 CentOS 8+）：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>启动 Nginx 服务</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置 Nginx 开机自启动</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://&lt;服务器IP&gt;</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>
</li>
</ol>
<hr>
<h3 id="3-在-macOS-上安装-Nginx"><a href="#3-在-macOS-上安装-Nginx" class="headerlink" title="3. 在 macOS 上安装 Nginx"></a><strong>3. 在 macOS 上安装 Nginx</strong></h3><h4 id="使用-Homebrew​-包管理工具："><a href="#使用-Homebrew​-包管理工具：" class="headerlink" title="使用 Homebrew​ 包管理工具："></a>使用 <code>Homebrew</code>​ 包管理工具：</h4><ol>
<li><p><strong>安装 Homebrew</strong>（如果尚未安装）：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>安装 Nginx</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>启动 Nginx 服务</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew services start nginx</span><br></pre></td></tr></table></figure></li>
<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost:8080</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>
</li>
</ol>
<hr>
<h3 id="4-在-Windows-上安装-Nginx"><a href="#4-在-Windows-上安装-Nginx" class="headerlink" title="4. 在 Windows 上安装 Nginx"></a><strong>4. 在 Windows 上安装 Nginx</strong></h3><p>Windows 上没有直接的包管理工具安装 Nginx，但可以通过以下方式安装：</p>
<ol>
<li><p><strong>下载 Nginx</strong>：<br> 访问 <a href="http://nginx.org/en/download.html">Nginx 官方网站</a>，下载适合 Windows 的版本。</p>
</li>
<li><p><strong>解压并运行</strong>：</p>
<ul>
<li><p>将下载的压缩包解压到一个目录（例如 <code>C:\nginx</code>​）。</p>
</li>
<li><p>打开命令提示符，进入解压后的目录：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\nginx</span><br></pre></td></tr></table></figure></li>
<li><p>启动 Nginx：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span> nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>操作系统</th>
<th>包管理工具</th>
<th>安装命令</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu&#x2F;Debian</td>
<td>​<code>apt</code>​</td>
<td>​<code>sudo apt install nginx</code>​</td>
</tr>
<tr>
<td>CentOS&#x2F;RHEL</td>
<td>​<code>yum/dnf</code>​</td>
<td>​<code>sudo yum install nginx</code>​</td>
</tr>
<tr>
<td>macOS</td>
<td>​<code>Homebrew</code>​</td>
<td>​<code>brew install nginx</code>​</td>
</tr>
<tr>
<td>Windows</td>
<td>手动安装</td>
<td>下载并解压 Nginx 压缩包</td>
</tr>
</tbody></table>
<p>根据你的操作系统选择合适的安装方法即可。</p>
]]></content>
      <categories>
        <category>部署指南</category>
        <category>安装教程</category>
        <category>配置管理</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>docker</tag>
        <tag>源码部署</tag>
        <tag>包管理</tag>
        <tag>开机自启</tag>
      </tags>
  </entry>
  <entry>
    <title>is-a 、have-a、和 like-a 的区别</title>
    <url>//post/the-difference-between-isa-havea-and-likea-1u8avc.html</url>
    <content><![CDATA[<h1 id="is-a-、have-a、和-like-a-的区别"><a href="#is-a-、have-a、和-like-a-的区别" class="headerlink" title="is-a 、have-a、和 like-a 的区别"></a>is-a 、have-a、和 like-a 的区别</h1><h3 id="1、is-a，has-a，like-a-是什么"><a href="#1、is-a，has-a，like-a-是什么" class="headerlink" title="1、is-a，has-a，like-a 是什么"></a>1、is-a，has-a，like-a 是什么</h3><p>在面向对象设计的领域里，有若干种设计思路，主要有如下三种：<br>is-a、has-a、like-a<br>java 中在类、接口、抽象类中有很多体现。<br>了解 java 看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51931003">什么是 Java</a><br>了解类和对象看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51161448">类、对象到底有什么秘密</a><br>了解接口和抽象类看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51173179">接口和抽象类有什么区别</a></p>
<h3 id="2、is-a-是什么"><a href="#2、is-a-是什么" class="headerlink" title="2、is-a 是什么"></a>2、is-a 是什么</h3><p>is-a，顾名思义，是一个，代表继承关系。<br>如果 A is-a B，那么 B 就是 A 的父类。<br>一个类完全包含另一个类的所有属性及行为。<br>例如 PC 机是计算机，工作站也是计算机，PC 机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java 语言实现时，应该将 PC 机和工作站定义成两种类，均继承计算机类。<br>了解更多继承看这里：<a href="http://blog.csdn.net/ooppookid/article/details/51193477">java 类的继承有什么意义</a></p>
<h3 id="3、has-a-是什么"><a href="#3、has-a-是什么" class="headerlink" title="3、has-a 是什么"></a><em>3、has-a 是什么</em></h3><p>has-a，顾名思义，有一个，代表从属关系。<br>如果 A has a B，那么 B 就是 A 的组成部分。<br>同一种类的对象，通过它们的属性的不同值来区别。<br>例如一台 PC 机的操作系统是 Windows，另一台 PC 机的操作系统是 Linux。操作系统是 PC 机的一个成员变量，根据这一成员变量的不同值，可以区分不同的 PC 机对象。</p>
<h3 id="4、-like-a-是什么"><a href="#4、-like-a-是什么" class="headerlink" title="4、 like-a 是什么"></a>4、 like-a 是什么</h3><p>like-a，顾名思义，像一个，代表组合关系。<br>如果 A like a B，那么 B 就是 A 的接口。<br>新类型有老类型的接口，但还包含其他函数，所以不能说它们完全相同。<br>例如一台手机可以说是一个微型计算机，但是手机的通讯功能显然不是计算机具备的行为，所以手机继承了计算机的特性，同时需要实现通讯功能，而通讯功能需要作为单独接口，而不是计算机的行为。</p>
<h3 id="5、is-a，has-a，like-a-如何应用"><a href="#5、is-a，has-a，like-a-如何应用" class="headerlink" title="5、is-a，has-a，like-a 如何应用"></a>5、is-a，has-a，like-a 如何应用</h3><p>如果你确定两件对象之间是 is-a 的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承。<br>如果你确定两件对象之间是 has-a 的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。<br>如果你确定两件对象之间是 like-a 的关系，那么此时你应该使用组合；比如空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</p>
]]></content>
  </entry>
  <entry>
    <title>Nginx配置TCP代理指南</title>
    <url>//post/nginx-configuration-tcp-agency-guide-kqsal.html</url>
    <content><![CDATA[<h1 id="Nginx配置TCP代理指南"><a href="#Nginx配置TCP代理指南" class="headerlink" title="Nginx配置TCP代理指南"></a>Nginx配置TCP代理指南</h1><h1 id="Nginx配置TCP代理指南-1"><a href="#Nginx配置TCP代理指南-1" class="headerlink" title="Nginx配置TCP代理指南"></a>Nginx配置TCP代理指南</h1><p>使用Nginx作为TCP代理是一种有效的方式，可以实现高性能的负载均衡和反向代理。本篇指南将介绍如何配置Nginx以用作TCP代理。</p>
<h2 id="步骤1：安装Nginx"><a href="#步骤1：安装Nginx" class="headerlink" title="步骤1：安装Nginx"></a>步骤1：安装Nginx</h2><hr>
<p>首先，确保您的系统已经安装了Nginx。您可以从Nginx官方网站或适用于您的操作系统的软件包管理器中获取Nginx。</p>
<h2 id="步骤2：编辑Nginx配置文件"><a href="#步骤2：编辑Nginx配置文件" class="headerlink" title="步骤2：编辑Nginx配置文件"></a>步骤2：编辑Nginx配置文件</h2><hr>
<p>默认情况下，Nginx的主配置文件位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。在继续之前，请备份此文件，并确保具有root权限。</p>
<p>使用文本编辑器打开nginx.conf文件，并进行以下配置更改：</p>
<ul>
<li>在http块之后，添加一个新的stream块：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    # 配置项添加在这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在stream块内，添加upstream和server配置。例如，以下配置将将请求转发到两个后端服务器，端口分别为192.168.1.10:8080和192.168.1.11:8080：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream my_backend_servers &#123;</span><br><span class="line">        server 192.168.1.10:8080;</span><br><span class="line">        server 192.168.1.11:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        proxy_pass my_backend_servers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据您的需求，可以根据需要添加更多的upstream和server块。</li>
</ul>
<h2 id="步骤3：重新加载配置"><a href="#步骤3：重新加载配置" class="headerlink" title="步骤3：重新加载配置"></a>步骤3：重新加载配置</h2><hr>
<p>保存并关闭配置文件后，使用以下命令重新加载Nginx配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="步骤4：验证代理设置"><a href="#步骤4：验证代理设置" class="headerlink" title="步骤4：验证代理设置"></a>步骤4：验证代理设置</h2><hr>
<p>现在，您的Nginx已配置为TCP代理。您可以使用telnet工具或其他任何适合您需求的工具来验证代理是否正常工作。</p>
<p>例如，您可以使用以下命令将请求发送到Nginx代理服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet localhost 80</span><br></pre></td></tr></table></figure>

<p>根据您的实际配置，您可能需要更改”localhost”为相应的IP地址和端口号。</p>
<h2 id="步骤5：监控和调整配置"><a href="#步骤5：监控和调整配置" class="headerlink" title="步骤5：监控和调整配置"></a>步骤5：监控和调整配置</h2><hr>
<p>建议您定期监控Nginx的性能，并根据负载情况进行必要的调整。您可以使用Nginx的日志文件、监控工具和系统性能工具来跟踪Nginx的表现并作出相应的改进。</p>
<p>这就是使用Nginx作为TCP代理的简单指南。通过按照上述步骤，在您的环境中配置Nginx，您可以实现高效的TCP代理服务。</p>
]]></content>
      <categories>
        <category>网络配置</category>
        <category>性能监控</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tcp代理</tag>
        <tag>配置指南</tag>
        <tag>负载均衡</tag>
        <tag>性能监控</tag>
      </tags>
  </entry>
</search>
