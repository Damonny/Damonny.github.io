{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/css/bb.css","path":"css/bb.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/contact.png","path":"medias/contact.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/minivaline/MiniValine.js","path":"libs/minivaline/MiniValine.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/prism/prism.css","path":"libs/prism/prism.css","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/link.yml","hash":"ccc926b6ec16d16c2582f6145ba99e8ffe7235d8","modified":1751350775695},{"_id":"source/_posts/asynchronous-operation-after-spring-transaction-operation-z1rhawf.md","hash":"c8d42903b0a9550aad908c0814d1f92af8fedf68","modified":1754357526048},{"_id":"source/_posts/java-implementing-agent-mode-zxwpxc.md","hash":"0674689d2e8bbf8e6b3e8690373d2a042914916b","modified":1754357526052},{"_id":"source/_posts/java-list-itzf4.md","hash":"52709b0b4ba4ad72da320d11daec167ccc80f036","modified":1754357526052},{"_id":"source/_posts/computer-status-2pq0or.md","hash":"4fb10005263a725253e0c1376c9ea32012de6056","modified":1754357526049},{"_id":"source/_posts/nacos-configuration-center-and-support-multi-configuration-files-zi2mmf.md","hash":"c14465dd6d7f28930b6523e5871027f668839b79","modified":1754357526053},{"_id":"source/_posts/nginx-configuration-rtsp-service-1p9fjr.md","hash":"3b3b0437e3c254cf80c508ebfc704ad338facccc","modified":1754357526054},{"_id":"source/_posts/nginx-configuration-tcp-agency-guide-kqsal.md","hash":"66edf22dae0ea98c6c89a134387eaab4b8ff7c27","modified":1754357526055},{"_id":"source/_posts/nginx-installation-deployment-z1jtjzq.md","hash":"a691c28ead9939fbbf21bd1e7c7bdf4580b37cc5","modified":1754357526055},{"_id":"source/_posts/nginx-turn-on-the-webdav-service-zadzub.md","hash":"dfdae3cff1f4657c8c6f5fb7775412bfb1be81c2","modified":1754357526056},{"_id":"source/_posts/port-occupation-treatment-2ogd9p.md","hash":"77c6f895ad567459547c333234c121455672ca6b","modified":1754357526056},{"_id":"source/_posts/press-a-copy-component-z2ezflv.md","hash":"2de8ffaaba636ab34b49d1ac846c6fb653235a88","modified":1754358745505},{"_id":"source/_posts/siyuan-notedockercompose-oneclick-deployment-1wlgle.md","hash":"6c9f019c9cd01a265541c43c5a7a7ff7d153313b","modified":1754357526058},{"_id":"source/_posts/springboot-introduces-local-jar-packages-1lmxzy.md","hash":"3db70595ae3678534066e68d9e75873d1ab229b7","modified":1754357526058},{"_id":"source/_posts/the-difference-between-isa-havea-and-likea-1u8avc.md","hash":"cda709e79379bf41912620ed738d9d0db81e7456","modified":1754357526059},{"_id":"source/_posts/test-the-linux-system-disk-read-and-write-performance-linux-disk-read-and-write-test-z1eep63.md","hash":"1e7e736bc36e716e32e1d9829a3fa9c7343b33a7","modified":1754357526059},{"_id":"source/_posts/use-in-grammar-in-mybatisplus-1bihse.md","hash":"7df5ef553b13621904f3b0962e7c47751b608c86","modified":1754357526060},{"_id":"source/_posts/use-redis-as-a-message-queue-in-java-zniajv.md","hash":"f6f08308b0609b80a855b1b51255d24188444db8","modified":1754357526060},{"_id":"source/_posts/yum-source-replacement-1jg9tx.md","hash":"004b7f1e7ca20d00f1e8f4a796da10ab567d6a48","modified":1754357526061},{"_id":"source/about/index.md","hash":"19fa93fa17d722638870fe4f77d00ae6125cf102","modified":1751427497635},{"_id":"source/archives/index.md","hash":"a01add9c02ebbd621e30ada64612b53fcd1dc0df","modified":1751350775704},{"_id":"source/categories/index.md","hash":"15e7ac04d90487555bd2ceeb477cf0a0d8356577","modified":1751351794278},{"_id":"source/link/index.md","hash":"e7ab633d6c93563d5926aa75436bc5741ca64aa7","modified":1751350775705},{"_id":"source/tags/index.md","hash":"c94a02d36bddc95f1c4b1a722bf4d3122b5082a1","modified":1751351814888},{"_id":"themes/anzhiyu/source/css/_extra/home_top/random-banner.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1751351172605},{"_id":"themes/anzhiyu/LICENSE","hash":"1eba7caf09a39110ad2f542e3ed8700d1a69c6d3","modified":1751351172486},{"_id":"themes/anzhiyu/.gitignore","hash":"17b9594db1006e57f76e109924db33e54f0f2d87","modified":1751351172485},{"_id":"themes/anzhiyu/README.md","hash":"2342370ab20c202c24ee530d80749f158d416fc3","modified":1751351172486},{"_id":"themes/anzhiyu/README_EN.md","hash":"23597148859005cb89e9b6a0be708bf95ae557fb","modified":1751351172487},{"_id":"themes/anzhiyu/_config.yml","hash":"f37684d60a5159e264ff803b61185653748fc22d","modified":1751351172488},{"_id":"themes/anzhiyu/plugins.yml","hash":"1b66b55771dbac1866909fa306358d11b255821e","modified":1751351172557},{"_id":"themes/anzhiyu/package.json","hash":"a7f83155236c1dd6a309171efaa0680e78afd748","modified":1751351172556},{"_id":"themes/anzhiyu/sw-rules.js","hash":"91eb0c94682ce1bffdbbd07a5bb7e5c6e00aa8c6","modified":1751351172671},{"_id":"themes/anzhiyu/languages/default.yml","hash":"8f22a9946744a2a4682564cf2c7e5f8dde6f1c25","modified":1751351172488},{"_id":"themes/anzhiyu/languages/en.yml","hash":"824f3a5bfe0f5848cc4a919c183bae214e660242","modified":1751351172488},{"_id":"themes/anzhiyu/languages/zh-CN.yml","hash":"5f6fad5076023da2d1fae9f5277e081168b0c1eb","modified":1751351172489},{"_id":"themes/anzhiyu/languages/zh-TW.yml","hash":"00d538fc38c1a88fd126c2e57c29dd860e9bc2bd","modified":1751351172489},{"_id":"themes/anzhiyu/layout/archive.pug","hash":"6a61277de07cf2724c865f251cb6f2385a6664ae","modified":1751351172490},{"_id":"themes/anzhiyu/layout/page.pug","hash":"57db7a52cbf647256b0346e6c0cd1539732a77e8","modified":1751351172555},{"_id":"themes/anzhiyu/layout/index.pug","hash":"818aeebcd24466aade30e632ee5275f92e73baea","modified":1751351172554},{"_id":"themes/anzhiyu/layout/post.pug","hash":"666241d431679ea7f9c94ce345bac8405f6bc5e7","modified":1751351172555},{"_id":"themes/anzhiyu/layout/tag.pug","hash":"fe81f8e8193dae2db7693e5464d4746704bbecdf","modified":1751351172556},{"_id":"themes/anzhiyu/source/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1751351172648},{"_id":"themes/anzhiyu/layout/category.pug","hash":"3028789225ac853000b7a84aa3a0715afd7bfb0a","modified":1751351172490},{"_id":"themes/anzhiyu/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"1c50c14dd6b66ab636a8852e9b967c40671f1200","modified":1751351172481},{"_id":"themes/anzhiyu/.github/ISSUE_TEMPLATE/config.yml","hash":"9d8e5494501458ed1cfeb2eb9e9a57b124dc5010","modified":1751351172481},{"_id":"themes/anzhiyu/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"0aaafd614172a6ca77a9b41fd3e81e885e8cfec7","modified":1751351172482},{"_id":"themes/anzhiyu/.github/workflows/issue_close_question.yml","hash":"a83655836dee52bcec1470bc394aa7dbc2cb487e","modified":1751351172483},{"_id":"themes/anzhiyu/.github/workflows/issue_invalid.yml","hash":"a4f2e5af1651d4683e2988137c7b366f5dc37bdf","modified":1751351172483},{"_id":"themes/anzhiyu/.github/workflows/issue_duplicate.yml","hash":"9ce2c4845fd229e7a01d9f61da1c9b1fa0c030ec","modified":1751351172483},{"_id":"themes/anzhiyu/.github/workflows/issue_close_stale.yml","hash":"b7b75a00b86da3b9361d37e5e17926e66e376d13","modified":1751351172483},{"_id":"themes/anzhiyu/.github/workflows/issue_question.yml","hash":"7a10849dedf026ddcab8b0d3c8205ad6fe5b8327","modified":1751351172483},{"_id":"themes/anzhiyu/.github/workflows/issue_wontfix.yml","hash":"288b1971d78e4e6d284e96d924c87c264737830d","modified":1751351172484},{"_id":"themes/anzhiyu/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1751351172485},{"_id":"themes/anzhiyu/layout/includes/bbTimeList.pug","hash":"e5e64f90df68d2679dd6593b02fb6c64c8ce8620","modified":1751351172496},{"_id":"themes/anzhiyu/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1751351172485},{"_id":"themes/anzhiyu/layout/includes/404.pug","hash":"799817011e194e6b1fc9ccb5530f5d96d59cfcc0","modified":1751351172491},{"_id":"themes/anzhiyu/layout/includes/additional-js.pug","hash":"5940f3f42d441667ac3ad2ff76b7b9ba79343e9a","modified":1751351172491},{"_id":"themes/anzhiyu/layout/includes/categoryGroup.pug","hash":"e08a308acca100cec2ccc086b9c2cff047582fda","modified":1751351172497},{"_id":"themes/anzhiyu/layout/includes/footer.pug","hash":"bcc45f9b91ddaa561fc3239e834381238964aad7","modified":1751351172498},{"_id":"themes/anzhiyu/layout/includes/layout.pug","hash":"9b19516e186b6145441e38ed575eab6c065da001","modified":1751351172508},{"_id":"themes/anzhiyu/layout/includes/head.pug","hash":"c1c11b576897466aa5009dc32e884ee9b55162e3","modified":1751351172498},{"_id":"themes/anzhiyu/layout/includes/music.pug","hash":"f45cee9da98d854f78f7fdd8f14c4be427a09d51","modified":1751351172512},{"_id":"themes/anzhiyu/layout/includes/mourn.pug","hash":"fec8325d90968ccf376fc87b81671e26ba8fc702","modified":1751351172512},{"_id":"themes/anzhiyu/layout/includes/pagination.pug","hash":"7884c6ef7b71dd3f4ebb5a3de2c062d7668b96a5","modified":1751351172519},{"_id":"themes/anzhiyu/layout/includes/rightside.pug","hash":"5462d757964e470d1d7abe0a7ba3d6a9566e0e00","modified":1751351172522},{"_id":"themes/anzhiyu/layout/includes/shortcutKey.pug","hash":"738d2932e68a782be2a80a6af2db1014c272cfe7","modified":1751351172522},{"_id":"themes/anzhiyu/layout/includes/sidebar.pug","hash":"fc56ee028770e230d4705ab74cba054c174ae500","modified":1751351172523},{"_id":"themes/anzhiyu/scripts/events/404.js","hash":"16484d781b273f20c4fbddf27ca283e03d7c0910","modified":1751351172559},{"_id":"themes/anzhiyu/scripts/events/comment.js","hash":"176332aa4d01728d0bd084e9b02c60167dc307dd","modified":1751351172560},{"_id":"themes/anzhiyu/scripts/events/cdn.js","hash":"fec4fbd14b29611684cc5a9ec1ba7a5b8a5cc996","modified":1751351172560},{"_id":"themes/anzhiyu/scripts/events/init.js","hash":"404b1200a3be17dbc14ccbb293aa17389d3a834b","modified":1751351172561},{"_id":"themes/anzhiyu/scripts/events/merge_config.js","hash":"38de538f3398c1be907c91f611344f4cc1009555","modified":1751351172562},{"_id":"themes/anzhiyu/scripts/events/stylus.js","hash":"c4de22ef3e1e84a96f9e48d450b3dbaeb5b85ecf","modified":1751351172562},{"_id":"themes/anzhiyu/scripts/helpers/findArchiveLength.js","hash":"612acfe4fd0d1d86676496dbb8e3e78dba030605","modified":1751351172567},{"_id":"themes/anzhiyu/scripts/events/welcome.js","hash":"6c3f69381c11fdb651684bcc04c077bcff892a2f","modified":1751351172563},{"_id":"themes/anzhiyu/scripts/helpers/catalog_list.js","hash":"f2ba64e35ee507ecbcaa4a3516ea95f1f7abefac","modified":1751351172567},{"_id":"themes/anzhiyu/scripts/helpers/aside_archives.js","hash":"12be80b9828008e9dd6aa7f57e875acda88e7046","modified":1751351172566},{"_id":"themes/anzhiyu/scripts/helpers/aside_categories.js","hash":"6e97bc9b99fac73561793bc746e9199636f1cf78","modified":1751351172566},{"_id":"themes/anzhiyu/scripts/helpers/get_version.js","hash":"799ae97c1368c395649444b9e5a71f9074852522","modified":1751351172568},{"_id":"themes/anzhiyu/scripts/helpers/inject_head_js.js","hash":"52f710f99904521c37fc1f19a33929799ceeafe2","modified":1751351172569},{"_id":"themes/anzhiyu/scripts/helpers/related_post.js","hash":"b6960063129984f1c6760e21c8215a4739fdbac5","modified":1751351172571},{"_id":"themes/anzhiyu/scripts/helpers/page.js","hash":"b0a3c347ae90ac998fa17e9e67b7cd290d4d7ab7","modified":1751351172570},{"_id":"themes/anzhiyu/scripts/helpers/random.js","hash":"feeabd29864fe8a2e50edc4d6c7523897f38aaca","modified":1751351172570},{"_id":"themes/anzhiyu/scripts/helpers/sort_attr_post.js","hash":"1cf55b611e4342f5a0c0e26bf69cf2a401cdcfff","modified":1751351172571},{"_id":"themes/anzhiyu/scripts/helpers/tags_page_list.js","hash":"59b5ae1970f4575d8e32309d7b4040fe55acee38","modified":1751351172572},{"_id":"themes/anzhiyu/scripts/helpers/year.js","hash":"94f15ddba7d29cdcc4dd52ed6c35c9c29cc19d37","modified":1751351172572},{"_id":"themes/anzhiyu/scripts/filters/random_cover.js","hash":"17497ecec828b68005762d627c54dde42de0806f","modified":1751351172565},{"_id":"themes/anzhiyu/scripts/filters/post_lazyload.js","hash":"19f85dc094e3d2b72244cc0ef59e60f88373b779","modified":1751351172564},{"_id":"themes/anzhiyu/scripts/tag/Introduction-card.js","hash":"15d1a82549af21ef55dd40758c16ddf26a17fe22","modified":1751351172573},{"_id":"themes/anzhiyu/scripts/tag/bilibili.js","hash":"cc3f9f29f777dea0e4714ce08be4edb301c0b768","modified":1751351172573},{"_id":"themes/anzhiyu/scripts/tag/btns.js","hash":"84992525efbccb9e87bbc72dfef2968212cabf2e","modified":1751351172573},{"_id":"themes/anzhiyu/scripts/tag/button.js","hash":"8f6d382ea394bef44da90cdf197dd2e207d5c7db","modified":1751351172575},{"_id":"themes/anzhiyu/scripts/tag/checkbox.js","hash":"636cef0f4500a14b123c6b21187fb67989472cbd","modified":1751351172575},{"_id":"themes/anzhiyu/scripts/tag/dogeplayer.js","hash":"facf3251b8eb2fd26f2d78906934d463d0adbd0f","modified":1751351172576},{"_id":"themes/anzhiyu/scripts/tag/flink.js","hash":"f987ce74edeee13a83fe526c234626eeae0588f0","modified":1751351172576},{"_id":"themes/anzhiyu/scripts/tag/folding.js","hash":"93f56903a307b4ce54963b40050fbb9aeb5baf47","modified":1751351172577},{"_id":"themes/anzhiyu/scripts/tag/gallery.js","hash":"3fb27bd4b176b15f2e3a54d452ae4ef922c763d3","modified":1751351172578},{"_id":"themes/anzhiyu/scripts/tag/iconfont.js","hash":"ea983f7c8dd060ed411044df1c10aa6b72dec34f","modified":1751351172579},{"_id":"themes/anzhiyu/scripts/tag/image.js","hash":"382cae620f3917cc99762942ad40b3ff146216ba","modified":1751351172579},{"_id":"themes/anzhiyu/scripts/tag/inline-labels.js","hash":"eaaedc3d65384e0beb4306534ef4ed202b46da18","modified":1751351172579},{"_id":"themes/anzhiyu/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1751351172580},{"_id":"themes/anzhiyu/scripts/tag/label.js","hash":"160cce6b5d58187dea0cb907116cda2bbfe6ee1c","modified":1751351172580},{"_id":"themes/anzhiyu/scripts/tag/link.js","hash":"9b7f81107a7c9d887060f6d3309f444090d7ccc3","modified":1751351172581},{"_id":"themes/anzhiyu/scripts/tag/hide.js","hash":"8c9275fd1a357670a84577306b5e9568ab875a7b","modified":1751351172578},{"_id":"themes/anzhiyu/scripts/tag/mermaid.js","hash":"e1a5e8e412cbbb3fc361136e9a5408170b7d93f8","modified":1751351172581},{"_id":"themes/anzhiyu/scripts/tag/media.js","hash":"ebe4a6ebe34e8d77c0652c63bd5f763439743eb2","modified":1751351172581},{"_id":"themes/anzhiyu/scripts/tag/site.js","hash":"b085ab9682b8465b1399c60889283d809a91e980","modified":1751351172583},{"_id":"themes/anzhiyu/scripts/tag/span.js","hash":"89aaa0678188aa85ec18116af4b036f80ca7c073","modified":1751351172583},{"_id":"themes/anzhiyu/scripts/tag/tabs.js","hash":"5dac02bb83aab3ff2afb3317ef7a2a626440671f","modified":1751351172583},{"_id":"themes/anzhiyu/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1751351172582},{"_id":"themes/anzhiyu/source/css/index.styl","hash":"10e57f33d5326128dd736135d15c8d46162d27de","modified":1751351172647},{"_id":"themes/anzhiyu/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1751351172584},{"_id":"themes/anzhiyu/source/css/var.styl","hash":"94afa286f44875f20b7bc1b983069bee0b97058c","modified":1751351172648},{"_id":"themes/anzhiyu/source/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1751351172650},{"_id":"themes/anzhiyu/scripts/tag/tip.js","hash":"0c2833f461168fa04c23bfd87f1274976d611fc1","modified":1751351172584},{"_id":"themes/anzhiyu/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1751351172650},{"_id":"themes/anzhiyu/source/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1751351172651},{"_id":"themes/anzhiyu/source/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1751351172651},{"_id":"themes/anzhiyu/source/img/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1751351172651},{"_id":"themes/anzhiyu/source/js/main.js","hash":"426ef036cb913ebb2aabe24bac1681757464b47c","modified":1751351172669},{"_id":"themes/anzhiyu/source/js/utils.js","hash":"8072d375ba873eb6d7d649f39689b4b03c33cb1d","modified":1751351172671},{"_id":"themes/anzhiyu/source/js/tw_cn.js","hash":"b3dfb877a3f2e66086b9e4f714f906df6f104700","modified":1751351172671},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/clock.pug","hash":"475ef93ee833f283e02a0a0e4e5a0ab8743e7e19","modified":1751351172494},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/ai-info.pug","hash":"73ca24d63adbab59ef206771107a90f3afb61d56","modified":1751351172493},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/log-js.pug","hash":"b298ec00407d7e30b744a56ee8df8cec39989e52","modified":1751351172495},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/rightmenu.pug","hash":"60a6829fed3cfebf7bdab3475a4c0291a82a678c","modified":1751351172495},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/console.pug","hash":"e05a5f1debeb6a48e918e04097f0a4551c93a405","modified":1751351172494},{"_id":"themes/anzhiyu/layout/includes/anzhiyu/tags-group-all.pug","hash":"b3fd7a18a9b87500348eb36be62ca29e91b58dd8","modified":1751351172496},{"_id":"themes/anzhiyu/layout/includes/bili-banner/index.pug","hash":"e3954ae43a708a560894fb28a21ac369a5b2d422","modified":1751351172497},{"_id":"themes/anzhiyu/layout/includes/head/Open_Graph.pug","hash":"2f0a172bd29333a2c6301ba4b86a74173f5502d3","modified":1751351172500},{"_id":"themes/anzhiyu/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1751351172500},{"_id":"themes/anzhiyu/layout/includes/head/config.pug","hash":"41f77ddd5c3259d7f74f831b40dfa6ab202a990a","modified":1751351172501},{"_id":"themes/anzhiyu/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1751351172502},{"_id":"themes/anzhiyu/layout/includes/head/config_site.pug","hash":"c50d21cd3ee0d45d8fe65ed679c4d131ef4ed7e6","modified":1751351172501},{"_id":"themes/anzhiyu/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1751351172502},{"_id":"themes/anzhiyu/layout/includes/head/preconnect.pug","hash":"01cf3be31783c0432ee2c79a8dc4c1422832cbe0","modified":1751351172503},{"_id":"themes/anzhiyu/layout/includes/head/pwa.pug","hash":"0fc38262a891a66f98972fe0389ad9a5e1abdb7d","modified":1751351172503},{"_id":"themes/anzhiyu/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1751351172504},{"_id":"themes/anzhiyu/layout/includes/header/menu_item.pug","hash":"c3f390d17d92da630892f275dc935f04a7a18dbf","modified":1751351172505},{"_id":"themes/anzhiyu/layout/includes/header/nav.pug","hash":"846131493ff841e15ff7dd145033331851b5af18","modified":1751351172506},{"_id":"themes/anzhiyu/layout/includes/header/index.pug","hash":"b4a9f655175fca7cfe9ef3ba3866d763271fa081","modified":1751351172505},{"_id":"themes/anzhiyu/layout/includes/header/post-info.pug","hash":"0c43738c963d97cc3e28c95004d0d689fb395217","modified":1751351172506},{"_id":"themes/anzhiyu/layout/includes/header/social.pug","hash":"7e9ee70012fdef99e80aa92fb301e27900a8ec6b","modified":1751351172507},{"_id":"themes/anzhiyu/layout/includes/loading/fullpage-loading.pug","hash":"1ffb745ce3a56f5ab180cdf08907d3e3ea20d387","modified":1751351172510},{"_id":"themes/anzhiyu/layout/includes/loading/pace.pug","hash":"8f25b42cb6c2c07ea609ad69c243bb11463d8b60","modified":1751351172510},{"_id":"themes/anzhiyu/layout/includes/loading/index.pug","hash":"81362a8c82029119d02b33f0f7bed249950040f0","modified":1751351172510},{"_id":"themes/anzhiyu/layout/includes/mixins/article-sort.pug","hash":"7527afa245ae66e8913d72627e9bea7bdc38ad50","modified":1751351172511},{"_id":"themes/anzhiyu/layout/includes/mixins/post-ui.pug","hash":"4b9b6377d14e3bdf977ed130324c8d043945f057","modified":1751351172511},{"_id":"themes/anzhiyu/layout/includes/page/about.pug","hash":"ac7e135290f744b005e6c1f38a89d7e1159c61e2","modified":1751351172513},{"_id":"themes/anzhiyu/layout/includes/page/album.pug","hash":"6473c0f664bc1d7b02ecbb1321a895d506dc5094","modified":1751351172514},{"_id":"themes/anzhiyu/layout/includes/page/album_detail.pug","hash":"b056b5cc18876665316e235b60247cdc589c8f99","modified":1751351172514},{"_id":"themes/anzhiyu/layout/includes/page/categories.pug","hash":"2a9ad7e38cda70a54e7a65a513f0748fdee3ca9e","modified":1751351172515},{"_id":"themes/anzhiyu/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1751351172515},{"_id":"themes/anzhiyu/layout/includes/page/essay.pug","hash":"0e317d13c40e8393962cf5fa39fee6cf82601007","modified":1751351172517},{"_id":"themes/anzhiyu/layout/includes/page/equipment.pug","hash":"7bd7f12123eb8d6b5ea65397642fec92cdbcdb1e","modified":1751351172516},{"_id":"themes/anzhiyu/layout/includes/page/fcircle.pug","hash":"42998c6f90aa1e5ec87ba628e42b2a16889970e1","modified":1751351172517},{"_id":"themes/anzhiyu/layout/includes/page/music.pug","hash":"2cee254ce63d5890e6cabb358b29e0c01275abc3","modified":1751351172518},{"_id":"themes/anzhiyu/layout/includes/page/flink.pug","hash":"7cf8f32581202e60fdc960f2f73ef9bcec5ff27f","modified":1751351172518},{"_id":"themes/anzhiyu/layout/includes/page/room.pug","hash":"c509876ab0488cdc3a21f0dcbea01abdcae58a31","modified":1751351172519},{"_id":"themes/anzhiyu/layout/includes/page/tags.pug","hash":"affa27b6fa972c2868dc7a445342becea43476b9","modified":1751351172519},{"_id":"themes/anzhiyu/layout/includes/popup/index.pug","hash":"d7144d918882727b60af84269761e6e4ce1987ad","modified":1751351172520},{"_id":"themes/anzhiyu/layout/includes/post/post-copyright.pug","hash":"c0849c39a27d1e2952dc59df1f0200856e21068a","modified":1751351172520},{"_id":"themes/anzhiyu/layout/includes/post/ptool.pug","hash":"90ad5d7c0ab8da38d71b514c6d4e14488f5c66c8","modified":1751351172521},{"_id":"themes/anzhiyu/layout/includes/post/reward.pug","hash":"22af38003ab111e6449c029310a32021bb2a00a3","modified":1751351172521},{"_id":"themes/anzhiyu/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1751351172533},{"_id":"themes/anzhiyu/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1751351172523},{"_id":"themes/anzhiyu/layout/includes/third-party/footerBarSubtitle.pug","hash":"62cefd8319c3819e2d0606a047cb90583c28cb78","modified":1751351172533},{"_id":"themes/anzhiyu/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1751351172539},{"_id":"themes/anzhiyu/layout/includes/third-party/pjax.pug","hash":"e0f26227c21544960b9abeb9ef7e9e5a02fffc64","modified":1751351172540},{"_id":"themes/anzhiyu/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1751351172540},{"_id":"themes/anzhiyu/layout/includes/third-party/subtitle.pug","hash":"d561d36229692e2c8a9ee45a7c24c0c2b3599170","modified":1751351172545},{"_id":"themes/anzhiyu/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1751351172547},{"_id":"themes/anzhiyu/layout/includes/top/top.pug","hash":"2b68f90a9f14f29828602289da867226b2e3c144","modified":1751351172546},{"_id":"themes/anzhiyu/layout/includes/widget/card_announcement.pug","hash":"ac60c45ae916120aab1e5c5039444029042eb3a4","modified":1751351172548},{"_id":"themes/anzhiyu/layout/includes/widget/card_archives.pug","hash":"aea77a8644328f08b79f18d3b43702b0d8eb853c","modified":1751351172548},{"_id":"themes/anzhiyu/layout/includes/widget/card_author.pug","hash":"fd12d544418d11495878dedd6dc0155078cc48bb","modified":1751351172549},{"_id":"themes/anzhiyu/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1751351172549},{"_id":"themes/anzhiyu/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1751351172550},{"_id":"themes/anzhiyu/layout/includes/widget/card_console_archives.pug","hash":"cd4626a66fe724241d8a219e78308136b4919c6f","modified":1751351172550},{"_id":"themes/anzhiyu/layout/includes/widget/card_console_tags.pug","hash":"2d9385004542fe1ce615a9b4f33e45e98eb7befc","modified":1751351172551},{"_id":"themes/anzhiyu/layout/includes/widget/card_post_toc.pug","hash":"9c849ba0451a314a1d97016be7b12f04c3ce6444","modified":1751351172551},{"_id":"themes/anzhiyu/layout/includes/widget/card_newest_comment.pug","hash":"f136d6265e7a4e77772853c248a26804d35697dd","modified":1751351172551},{"_id":"themes/anzhiyu/layout/includes/widget/card_recent_post.pug","hash":"1740e6ef4e483c108dd6af5808ed7e99c644a4d0","modified":1751351172552},{"_id":"themes/anzhiyu/layout/includes/widget/card_tags.pug","hash":"b8315b369164ee12c79cd0d1ebc11753e3c26f4d","modified":1751351172552},{"_id":"themes/anzhiyu/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1751351172553},{"_id":"themes/anzhiyu/layout/includes/widget/card_webinfo.pug","hash":"7d3cae5dac3e0b2993798839df3d3cfac1fd97e9","modified":1751351172553},{"_id":"themes/anzhiyu/layout/includes/widget/card_weixin.pug","hash":"7725687c5db4329d989350f2d3e1de72b6e69156","modified":1751351172554},{"_id":"themes/anzhiyu/layout/includes/widget/index.pug","hash":"4b20439472a1cefd958afc6c882617c6fad6a0cd","modified":1751351172554},{"_id":"themes/anzhiyu/source/css/_global/function.styl","hash":"67ae8fa268d4dfe7ac691adbb1b0fdf7d2afab8f","modified":1751351172613},{"_id":"themes/anzhiyu/source/css/_global/loading.styl","hash":"0dea01a2d462685b952fa41f51de784149b45e4f","modified":1751351172615},{"_id":"themes/anzhiyu/source/css/_global/index.styl","hash":"2c2a0bb1ec71246eaccc80e944ea75ed61c4d1b6","modified":1751351172614},{"_id":"themes/anzhiyu/source/css/_highlight/theme.styl","hash":"fd8115debce97b92c31927abb877de1bdf55fa83","modified":1751351172618},{"_id":"themes/anzhiyu/source/css/_highlight/highlight.styl","hash":"67c3f00d450ee4f992c2561cd4fd9e6b3bba2099","modified":1751351172615},{"_id":"themes/anzhiyu/source/css/_global/icon.styl","hash":"0a8e0470910209033479ef515013bb968db9e4b5","modified":1751351172614},{"_id":"themes/anzhiyu/source/css/_layout/404.styl","hash":"6c984a3a6ac4599ea11f56f218ab575242a6217e","modified":1751351172619},{"_id":"themes/anzhiyu/source/css/_layout/aside.styl","hash":"fadd9e7e75b4b2c269310928859d5ec734aaf056","modified":1751351172619},{"_id":"themes/anzhiyu/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1751351172621},{"_id":"themes/anzhiyu/source/css/_layout/footer.styl","hash":"fe3004296f8eff61155b7095f78bfa7bc2331d08","modified":1751351172622},{"_id":"themes/anzhiyu/source/css/_layout/banner.styl","hash":"31df78e8a76590d735d27c82196b9ce0ba6e722f","modified":1751351172620},{"_id":"themes/anzhiyu/source/css/_layout/comments.styl","hash":"74a11d371c2e3a7f02ab314f769483960399b2b0","modified":1751351172621},{"_id":"themes/anzhiyu/source/css/_layout/nav.styl","hash":"978915633e99e1d49bd06b94bea2eb405c8fcba0","modified":1751351172624},{"_id":"themes/anzhiyu/source/css/_layout/head.styl","hash":"f093d83d13d778cd0e0053e1b4dde63d66d4bce2","modified":1751351172623},{"_id":"themes/anzhiyu/source/css/_layout/oneGraphFlow.styl","hash":"3a2a8549df55fb053871576be20e7e85fe4cda37","modified":1751351172625},{"_id":"themes/anzhiyu/source/css/_layout/pagination.styl","hash":"e12ff8f89458b17659e58dc65fdd2b9e7d7b4c68","modified":1751351172625},{"_id":"themes/anzhiyu/source/css/_layout/home_top.styl","hash":"1df055ba6519f6920029cc4400fc39d89602440f","modified":1751351172623},{"_id":"themes/anzhiyu/source/css/_layout/relatedposts.styl","hash":"96825d6fec11a7caca5d7be6ce67b985a5be8bb2","modified":1751351172627},{"_id":"themes/anzhiyu/source/css/_layout/ptool.styl","hash":"d9ca5e1a7b584c96246fb626aa74f85766c481aa","modified":1751351172626},{"_id":"themes/anzhiyu/source/css/_layout/reward.styl","hash":"a1db997b40d35bcbb270937d76bf54021bccdda2","modified":1751351172627},{"_id":"themes/anzhiyu/source/css/_layout/post.styl","hash":"ec6a5d69475f528dfd08a7cc0877d904a4b4bcbf","modified":1751351172626},{"_id":"themes/anzhiyu/source/css/_layout/rightmenu.styl","hash":"67ed9f69ce7e88af1d96667e112f5592d1435730","modified":1751351172628},{"_id":"themes/anzhiyu/source/css/_layout/rightside.styl","hash":"5d92b9bb99515d391323ddcaa91bfcdc5be41f44","modified":1751351172628},{"_id":"themes/anzhiyu/source/css/_layout/sidebar.styl","hash":"1414615f345f00cc85bfc81d33268a95a2cb1090","modified":1751351172629},{"_id":"themes/anzhiyu/source/css/_layout/shortcutKey.styl","hash":"9f45ebfba4fd0c6bde7877b06d7e1b3b1e7da405","modified":1751351172628},{"_id":"themes/anzhiyu/source/css/_layout/third-party.styl","hash":"b5f366f4c5286ca4321c832852feddda1f18c960","modified":1751351172629},{"_id":"themes/anzhiyu/source/css/_mode/darkmode.styl","hash":"c0e081e0fac44041942c1dcb2f799095c4116e20","modified":1751351172630},{"_id":"themes/anzhiyu/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1751351172631},{"_id":"themes/anzhiyu/source/css/_mode/readmode.styl","hash":"618694850dfa8fac81e21ea369fb8f5589ac0d0f","modified":1751351172630},{"_id":"themes/anzhiyu/source/css/_page/about.styl","hash":"08e81e2fa5b5e761211115c733e657f56fbdc507","modified":1751351172631},{"_id":"themes/anzhiyu/source/css/_page/archives.styl","hash":"f70bfb4e5b5b59c5713695927c2140957dc7aa1f","modified":1751351172632},{"_id":"themes/anzhiyu/source/css/_page/common.styl","hash":"2ad261e7a747e2e43757f4c11324c9ed459fdbc5","modified":1751351172633},{"_id":"themes/anzhiyu/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1751351172632},{"_id":"themes/anzhiyu/source/css/_page/flink.styl","hash":"342b32142741c6a51f5219c93b9e3fad95430145","modified":1751351172634},{"_id":"themes/anzhiyu/source/css/_page/homepage.styl","hash":"8310390419d1eb5b23ae48aced4a87b0318e85be","modified":1751351172635},{"_id":"themes/anzhiyu/source/css/_page/equipment.styl","hash":"5a4cbddb41aee76cb2a9c5433b7b5a487f118da7","modified":1751351172633},{"_id":"themes/anzhiyu/source/css/_page/music.styl","hash":"cfeba567ccb6bc421261d71a2e50242a955ba099","modified":1751351172635},{"_id":"themes/anzhiyu/source/css/_page/reward.styl","hash":"bbe91f4f0525a01901be2794f698ed99f5cb58bd","modified":1751351172636},{"_id":"themes/anzhiyu/source/css/_page/tag_page.styl","hash":"7a93cd4509a16b845ce2a9044320f43214dbcdc5","modified":1751351172636},{"_id":"themes/anzhiyu/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1751351172636},{"_id":"themes/anzhiyu/source/css/_search/algolia.styl","hash":"e1dda3de7bbfce226bb8300db15a930176289a27","modified":1751351172636},{"_id":"themes/anzhiyu/source/css/_search/index.styl","hash":"c315988ee28ad853aaa2060055d10aa88225a131","modified":1751351172636},{"_id":"themes/anzhiyu/source/css/_search/local-search.styl","hash":"45792c13c7c439d412b7dc597d74d24f3b598406","modified":1751351172637},{"_id":"themes/anzhiyu/source/css/_tags/bilbili.styl","hash":"e909f60fbbdcbd072fcb1a4c2eeafa237a13b6b0","modified":1751351172638},{"_id":"themes/anzhiyu/source/css/_tags/btns.styl","hash":"0e22fdd43f698d2b27999301ca2a8bb392ac04cf","modified":1751351172638},{"_id":"themes/anzhiyu/source/css/_tags/Introduction-card.styl","hash":"12a3b3ad1e97d0a4fa63521c4eaf2b1025a95719","modified":1751351172638},{"_id":"themes/anzhiyu/source/css/_tags/button.styl","hash":"ea2018ba7cbc2e11d413231556d5b001cdbd5117","modified":1751351172639},{"_id":"themes/anzhiyu/source/css/_tags/checkbox.styl","hash":"3f1fcb0973ccea197afef26e0d515b3800dae348","modified":1751351172639},{"_id":"themes/anzhiyu/source/css/_tags/folding.styl","hash":"f4c117ccd9ffec997a36347358050021e60df498","modified":1751351172639},{"_id":"themes/anzhiyu/source/css/_tags/gallery.styl","hash":"99f2edcee8318b8cf5911fe344b89f58df7f313c","modified":1751351172640},{"_id":"themes/anzhiyu/source/css/_tags/hide.styl","hash":"4de1984c5fdf774ef2f8e856ea188729d06743b6","modified":1751351172641},{"_id":"themes/anzhiyu/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1751351172641},{"_id":"themes/anzhiyu/source/css/_tags/image.styl","hash":"f0043e6d5542e63a919162a545fa228acc8e1ef9","modified":1751351172642},{"_id":"themes/anzhiyu/source/css/_tags/inline-labels.styl","hash":"25a32624cab8b623634bb797cde7f2c6baff5a15","modified":1751351172642},{"_id":"themes/anzhiyu/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1751351172642},{"_id":"themes/anzhiyu/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1751351172643},{"_id":"themes/anzhiyu/source/css/_tags/note.styl","hash":"c991d29f0b970d4b738656501847cc70161dc594","modified":1751351172643},{"_id":"themes/anzhiyu/source/css/_tags/media.styl","hash":"da94e08918d1468871e69e265969d501310d3553","modified":1751351172643},{"_id":"themes/anzhiyu/source/css/_tags/site-card.styl","hash":"d497a9c654b927e1579a8a8513573bafacc7150a","modified":1751351172644},{"_id":"themes/anzhiyu/source/css/_tags/span.styl","hash":"252220ebb7f8e3bbff620b4d254a4703dfea7f3e","modified":1751351172644},{"_id":"themes/anzhiyu/source/css/_tags/tabs.styl","hash":"ead8a25eb164a361990c8a4cef3afb45d9dc33d9","modified":1751351172645},{"_id":"themes/anzhiyu/source/css/_tags/timeline.styl","hash":"f538fe0525c6491ac24b23ae2f9c1d2c396494fd","modified":1751351172645},{"_id":"themes/anzhiyu/source/css/_tags/tip.styl","hash":"4682fa963d6e667e24fe35a18b5d351c640a2769","modified":1751351172646},{"_id":"themes/anzhiyu/source/css/_third-party/snackbar.styl","hash":"86a40c9b534498dadbf5076c1d6f84c030da5184","modified":1751351172646},{"_id":"themes/anzhiyu/source/css/_third-party/normalize.min.css","hash":"a1d57065668c1695a10032cea26dc4b5cd143690","modified":1751351172646},{"_id":"themes/anzhiyu/source/css/_third-party/twikoo.styl","hash":"1040ba99c7b14ca3d71e0e517310307376892af6","modified":1751351172647},{"_id":"themes/anzhiyu/source/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1751351172662},{"_id":"themes/anzhiyu/source/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1751351172663},{"_id":"themes/anzhiyu/source/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1751351172664},{"_id":"themes/anzhiyu/source/js/anzhiyu/ai_abstract.js","hash":"c857f20164ed3efddc284bbf7ef56eee8cc37bcd","modified":1751351172666},{"_id":"themes/anzhiyu/source/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1751351172664},{"_id":"themes/anzhiyu/source/js/anzhiyu/comment_barrage.js","hash":"1fb6922cb6d9345fc73d7f516c48a3799d7cdebd","modified":1751351172667},{"_id":"themes/anzhiyu/source/js/anzhiyu/random_friends_post.js","hash":"03b34e7fc4c0b5748f036a45e822be75b282b86c","modified":1751351172667},{"_id":"themes/anzhiyu/source/js/anzhiyu/people.js","hash":"c76d30b73f575cd9e0659600b05cf3819f20b17c","modified":1751351172667},{"_id":"themes/anzhiyu/source/js/anzhiyu/right_click_menu.js","hash":"0de57a2c37a799fec0979ea3195f4dd3827e9514","modified":1751351172668},{"_id":"themes/anzhiyu/source/js/search/algolia.js","hash":"51bcf73660635454d66dd2b7a906caf69afa9518","modified":1751351172670},{"_id":"themes/anzhiyu/source/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1751351172664},{"_id":"themes/anzhiyu/source/js/search/local-search.js","hash":"23e1b201d825afc1063b51031c5c172dfdeb49d4","modified":1751351172670},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1751351172528},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1751351172527},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1751351172528},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/index.pug","hash":"085b6ec501eef02bb82157712cde35bf5cdf639e","modified":1751351172529},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/artalk.pug","hash":"32b1ec70a6e350c7839b50110a0949d39b827db8","modified":1751351172524},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/index.pug","hash":"5a6072e73874997e27dce1bf47f3d37922430336","modified":1751351172525},{"_id":"themes/anzhiyu/layout/includes/third-party/chat/tidio.pug","hash":"26bbedadf03ca8e1d8a8f1d39444cbe3413f8872","modified":1751351172529},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1751351172526},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1751351172525},{"_id":"themes/anzhiyu/layout/includes/third-party/card-post-count/waline.pug","hash":"6dd328b615f7ecf604fb0a1fbb1479e89674ea4b","modified":1751351172526},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/artalk.pug","hash":"d3fc4c539bb4e70539ba0f90debd06791be28466","modified":1751351172530},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/js.pug","hash":"6bdb7e04d7e6c2a1608ad5a43866ced2fca9955e","modified":1751351172531},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/giscus.pug","hash":"52db09844df436f026f6f0896190bdbf6f15a473","modified":1751351172530},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/index.pug","hash":"dffbe34a6030c9c4022928b3bdb7df71c93a0aa3","modified":1751351172531},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/twikoo.pug","hash":"a60562048ff32bde1ceb8b5975158c85db2e16f2","modified":1751351172531},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/valine.pug","hash":"cfcbc39104ff3bb44bdb41d9b6dab8388005b750","modified":1751351172531},{"_id":"themes/anzhiyu/layout/includes/third-party/comments/waline.pug","hash":"2fed41601733bf3b1a437aa40b9101987b9a95a2","modified":1751351172532},{"_id":"themes/anzhiyu/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1751351172534},{"_id":"themes/anzhiyu/layout/includes/third-party/math/katex.pug","hash":"65a432d2c54b9269ddaa68715dbcd8724ed32efb","modified":1751351172535},{"_id":"themes/anzhiyu/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1751351172536},{"_id":"themes/anzhiyu/layout/includes/third-party/math/mermaid.pug","hash":"0b0123024cf64a23de92f9668d71f61558cf8f60","modified":1751351172536},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/artalk.pug","hash":"c46c9af5f626063aaafe5b0c027f4f6be06d4fcf","modified":1751351172537},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/index.pug","hash":"cb4021a8bbb4045c2ecca1a161921ea45fb1506f","modified":1751351172537},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"25b1e1cc5eca5a45f738071c3c66ca7a156b3740","modified":1751351172538},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/valine.pug","hash":"836d25b645aba02c7148547aed4a1be4f6146e07","modified":1751351172538},{"_id":"themes/anzhiyu/layout/includes/third-party/newest-comments/waline.pug","hash":"5aaffe9f673e5148493e14c84ceab50652e8a0e6","modified":1751351172539},{"_id":"themes/anzhiyu/layout/includes/third-party/runtime/runtime-js.pug","hash":"f76b4d84993a26e919bbc7cd531c5da5c5edd0c0","modified":1751351172541},{"_id":"themes/anzhiyu/layout/includes/third-party/search/algolia.pug","hash":"7d48985c136472a9a3170d4c57758bb275f6ec7b","modified":1751351172542},{"_id":"themes/anzhiyu/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1751351172543},{"_id":"themes/anzhiyu/layout/includes/third-party/search/docsearch.pug","hash":"4e0b2a779654022dff37f74aaad24e1f04280657","modified":1751351172542},{"_id":"themes/anzhiyu/layout/includes/third-party/share/share-js.pug","hash":"b45fc15c3ae7db3a0fbce0d6da74a72a95ca8a2b","modified":1751351172545},{"_id":"themes/anzhiyu/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1751351172544},{"_id":"themes/anzhiyu/layout/includes/third-party/search/local-search.pug","hash":"928accb5fb5978b851b1d19abcd464258dd10e06","modified":1751351172543},{"_id":"themes/anzhiyu/layout/includes/third-party/share/index.pug","hash":"a47fe41f39f0073d98baa72adbde87b2d1499049","modified":1751351172544},{"_id":"themes/anzhiyu/source/css/_extra/album/album.css","hash":"d79cc995aca04bb0072b206668a8530ff4bdacb6","modified":1751351172586},{"_id":"themes/anzhiyu/source/css/_extra/album/album_detail.css","hash":"868db4e9e51e2bbe2d6555c957ecf56d50032c3c","modified":1751351172586},{"_id":"themes/anzhiyu/source/css/_extra/anzhiyu/custom.css","hash":"262291db00a343991c5472131804a4fd00deed4f","modified":1751351172586},{"_id":"themes/anzhiyu/source/css/_extra/aside_weixin/aside_weixin.css","hash":"a96b0559ca915f2aa1f2a80412bb75cfce6fea38","modified":1751351172587},{"_id":"themes/anzhiyu/source/css/_extra/catalog_list/catalog_list.css","hash":"027a9fb2d501c82d4bb6d69e2e76a7fa8be27f11","modified":1751351172587},{"_id":"themes/anzhiyu/source/css/_extra/clock/clock.css","hash":"581be0a5214a5534e4cf81ceb3184737e5f2d987","modified":1751351172589},{"_id":"themes/anzhiyu/source/css/_extra/categoryBar/categoryBar.css","hash":"07ef90cb816c5fef8114031bfbe7f7741b6b9b98","modified":1751351172587},{"_id":"themes/anzhiyu/source/css/_extra/code/code.css","hash":"bb9e145a87748f2db0441ab2ea79ef4a7e03356e","modified":1751351172591},{"_id":"themes/anzhiyu/source/css/_extra/commentBarrage/commentBarrage.css","hash":"335861ca0fc4aa4be700b769c871038743ea95dd","modified":1751351172591},{"_id":"themes/anzhiyu/source/css/_extra/code/details_summary.css","hash":"71d98974fca9d899bcb5c429b3ab3e9e1cb88bba","modified":1751351172591},{"_id":"themes/anzhiyu/source/css/_extra/console/console.css","hash":"0c22c5c2a004b09bb913ce52caf7ff115c8d7ef5","modified":1751351172592},{"_id":"themes/anzhiyu/source/css/_extra/essay_page/essay_page.css","hash":"99d7a0fece8d6e69da5ba570acb77016e92113fd","modified":1751351172594},{"_id":"themes/anzhiyu/source/css/_extra/essay_page/home_essay_bar.css","hash":"69c4c9acd4a42c6fad4bb507e45cf01b5f0aa37b","modified":1751351172594},{"_id":"themes/anzhiyu/source/css/_extra/fix/aplayer.css","hash":"d8beefb88560e30178b8baab596791e51b4d5451","modified":1751351172595},{"_id":"themes/anzhiyu/source/css/_extra/fix/bilibili-bangumi.css","hash":"0cb28adec6878ebd7a9372f289e21280b2bc7259","modified":1751351172595},{"_id":"themes/anzhiyu/source/css/_extra/fix/categories.css","hash":"b6f7f3e384f0497926ffda4a6db1ccfc90307651","modified":1751351172596},{"_id":"themes/anzhiyu/source/css/_extra/fix/clock.css","hash":"adb0616fdb157a880d1ab01bfb51e522df8c3523","modified":1751351172596},{"_id":"themes/anzhiyu/source/css/_extra/fix/comments.css","hash":"7c2a30ceeb7519c96eda1c2ef67b6873ba3f24d2","modified":1751351172597},{"_id":"themes/anzhiyu/source/css/_extra/fix/dark.css","hash":"dfc609b95f31544177babc76dade1720fe7cda42","modified":1751351172597},{"_id":"themes/anzhiyu/source/css/_extra/fix/bilibili-ratio.css","hash":"628352103e72c98e6d2b25f1cdb39070bd0f021c","modified":1751351172595},{"_id":"themes/anzhiyu/source/css/_extra/fix/fcircle_page.css","hash":"16833b57f9dbb1d72cdf4a3cd80751a315a0bb27","modified":1751351172598},{"_id":"themes/anzhiyu/source/css/_extra/fix/gitcalendar.css","hash":"b3081e90ff9994e0ed0206065bbb07daa90d6e29","modified":1751351172599},{"_id":"themes/anzhiyu/source/css/_extra/fix/hexo-tag-dplayer.css","hash":"7ded42d62e0ba475b9789977ed7236a6c1b32007","modified":1751351172599},{"_id":"themes/anzhiyu/source/css/_extra/fix/link_page.css","hash":"ced162602659f3cb0e423ef15c532cc7c99d6123","modified":1751351172600},{"_id":"themes/anzhiyu/source/css/_extra/fix/hide-block.css","hash":"cb6319200511548acd5642f4c6d9a3115a778b35","modified":1751351172600},{"_id":"themes/anzhiyu/source/css/_extra/fix/overflow.css","hash":"b2dafcb1bc1fa4c06f648245f11acdaf7a878d05","modified":1751351172601},{"_id":"themes/anzhiyu/source/css/_extra/fix/site-card.css","hash":"f56eff8b96c773ae6a8e97ef0e1c822feabe5854","modified":1751351172601},{"_id":"themes/anzhiyu/source/css/_extra/fix/radius.css","hash":"a55321b326f241d0788359d5366172d7aeb734e1","modified":1751351172601},{"_id":"themes/anzhiyu/source/css/_extra/footer/footer.css","hash":"497980fa313ff7045c0756a32dc08101dcc3013d","modified":1751351172602},{"_id":"themes/anzhiyu/source/css/_extra/friends/friends.css","hash":"171868650c64cb995cfab069b3c128b5d07e3d38","modified":1751351172603},{"_id":"themes/anzhiyu/source/css/_extra/greeting_box/greeting_box.css","hash":"9c54f33a8f22064e803b2a8324f93549021f5aa4","modified":1751351172603},{"_id":"themes/anzhiyu/source/css/_extra/local_search/local_search.css","hash":"9fc79ed81a5f0476172fe688ecba08e7b8e3be03","modified":1751351172608},{"_id":"themes/anzhiyu/source/css/_extra/home_top/categorygroup.css","hash":"b38d1dd55da2ff3e18e32628a5484e46e880d6b9","modified":1751351172604},{"_id":"themes/anzhiyu/source/css/_extra/home_top/home_top.css","hash":"954a9eca322a5eb3fd04ad5a71f61927b0c35400","modified":1751351172604},{"_id":"themes/anzhiyu/source/css/_extra/home_top/swiperstyle.css","hash":"33f5a0731ac439871dd54aad7528431df091b551","modified":1751351172606},{"_id":"themes/anzhiyu/source/css/_extra/home_top/home_top_post_group.css","hash":"4f60d12d4f174453223be2070ed608de4ad5d14d","modified":1751351172605},{"_id":"themes/anzhiyu/source/css/_extra/home_top/top_group_banner.css","hash":"4b3090b0f5f01dbd4b1706e4104962b15c05f8d0","modified":1751351172607},{"_id":"themes/anzhiyu/source/css/_extra/reset/reset.css","hash":"4651067de360b4e00dd361795a74a7ed2a5a62ff","modified":1751351172608},{"_id":"themes/anzhiyu/source/css/_extra/reward/about-reward.css","hash":"2201faa78b7a9ded910f59abe28df2b897fd23b0","modified":1751351172609},{"_id":"themes/anzhiyu/source/css/_extra/runtime/runtime.css","hash":"6e8dbcf6e505cd96192c8b75970ff65f98acf51c","modified":1751351172611},{"_id":"themes/anzhiyu/source/css/_extra/room/room.css","hash":"5a730fdec4fd9e1d8b38e407ba1d139abd6a17d2","modified":1751351172610},{"_id":"themes/anzhiyu/source/css/_extra/single_card/single_card.css","hash":"f7690f0dde69437f2222a9889ea957a185a7fbb6","modified":1751351172611},{"_id":"themes/anzhiyu/source/css/_extra/skills/skills.css","hash":"12901c0c77345fbd92edf591ee98266919eed259","modified":1751351172612},{"_id":"themes/anzhiyu/source/css/_extra/tag/link.css","hash":"da429802cbe2cf45b66115d03c682e9463c34dc1","modified":1751351172612},{"_id":"themes/anzhiyu/source/css/_extra/tag/site.css","hash":"8735ce339b410a72fc314af37f5d7ffd783fad05","modified":1751351172613},{"_id":"themes/anzhiyu/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1751351172616},{"_id":"themes/anzhiyu/source/css/_highlight/highlight/index.styl","hash":"58680cd4ff5767afeabe4d4cfb621c0c2d7a68e4","modified":1751351172617},{"_id":"themes/anzhiyu/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1751351172617},{"_id":"themes/anzhiyu/source/css/_highlight/prismjs/index.styl","hash":"78398d5c407a30a561c1c98baccaabd9633edd27","modified":1751351172618},{"_id":"themes/anzhiyu/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1751351172618},{"_id":"themes/anzhiyu/source/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1751351172649},{"_id":"themes/anzhiyu/source/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1751351172656},{"_id":"themes/anzhiyu/source/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1751351172662},{"_id":"public/search.xml","hash":"e7e834b13b2b2e1358cf708a02b8890376419c05","modified":1751423427538},{"_id":"public/anzhiyu/random.js","hash":"7469603b0b0a8d20fa454fcfb5d488e8b9d9cc96","modified":1751423427538},{"_id":"public/404.html","hash":"9af41e9afcdfd4de01568306e97014bbe66e68f6","modified":1751423427538},{"_id":"public/about/index.html","hash":"3168eb4d5f206554580dda646f843eb4d78e5da0","modified":1751423427538},{"_id":"public/categories/index.html","hash":"95ef4f9404bf6e83489fe5cb74fdc2d70e19f2bd","modified":1751423427538},{"_id":"public/link/index.html","hash":"8922d07badd977cfb4fbcbc247914f41a1b581f5","modified":1751423427538},{"_id":"public/archives/index.html","hash":"612efd6a5de05ec33be7a9a35f82a84ef6c81a19","modified":1751423427538},{"_id":"public/tags/index.html","hash":"378baa255a2629f4d04407beab5fd8045579d2e0","modified":1751423427538},{"_id":"public/post/asynchronous-operation-after-spring-transaction-operation-z1rhawf.html","hash":"deb36e46f1a139a4e21018f6abee6899b9a2f6ed","modified":1751423427538},{"_id":"public/post/springboot-introduces-local-jar-packages-1lmxzy.html","hash":"4b661b0a2ddfa592831393bb69bfc51584c1364d","modified":1751423427538},{"_id":"public/post/use-in-grammar-in-mybatisplus-1bihse.html","hash":"1b2bafbf0a5e2d847ebbd83b7878f77539238c9a","modified":1751423427538},{"_id":"public/post/java-list-itzf4.html","hash":"cffea05624ade07dfce74475d96a3e1417140c12","modified":1751423427538},{"_id":"public/post/nginx-configuration-rtsp-service-1p9fjr.html","hash":"1eb4be5dd6c9dc1a0a2337da1aa64a19e29c012b","modified":1751423427538},{"_id":"public/post/nginx-turn-on-the-webdav-service-zadzub.html","hash":"ba85847a98453db6c812c224e12937baba21e3f9","modified":1751423427538},{"_id":"public/post/use-redis-as-a-message-queue-in-java-zniajv.html","hash":"efcd634a3c1d001b6061608901d11e345369c7c7","modified":1751423427538},{"_id":"public/post/press-a-copy-component-z2ezflv.html","hash":"a4e22b130c917a09098c280263ec1e60eb56180d","modified":1751423427538},{"_id":"public/post/the-difference-between-isa-havea-and-likea-1u8avc.html","hash":"c85ff303bb7988a884792de9995356889c4c6211","modified":1751423427538},{"_id":"public/post/siyuan-notedockercompose-oneclick-deployment-1wlgle.html","hash":"a7faff97e90b1534b0db785270038c4fa099391a","modified":1751423427538},{"_id":"public/post/nacos-configuration-center-and-support-multi-configuration-files-zi2mmf.html","hash":"080e91429686f1f7dbeec5958327f659bd05c08e","modified":1751423427538},{"_id":"public/post/computer-status-2pq0or.html","hash":"e791db59fda405761ed2489bca5fa32456d99f97","modified":1751423427538},{"_id":"public/post/port-occupation-treatment-2ogd9p.html","hash":"ce212384c36ae786698d3797d42e448b9a1a46f7","modified":1751423427538},{"_id":"public/post/nginx-configuration-tcp-agency-guide-kqsal.html","hash":"d4424cae7424540b26e380fc8afd0a4483e14705","modified":1751423427538},{"_id":"public/post/nginx-installation-deployment-z1jtjzq.html","hash":"17f083a643956fd1c2de6bd767c5b0f7fa3b7c9e","modified":1751423427538},{"_id":"public/post/test-the-linux-system-disk-read-and-write-performance-linux-disk-read-and-write-test-z1eep63.html","hash":"4861e0bb48441bc1828ff5d23c719288e86df1fc","modified":1751423427538},{"_id":"public/post/yum-source-replacement-1jg9tx.html","hash":"7437bec0ec566746d34a78fd56717f198ef05454","modified":1751423427538},{"_id":"public/post/java-implementing-agent-mode-zxwpxc.html","hash":"0652d15f2af8305adee7f9a2328337f2cd5684ba","modified":1751423427538},{"_id":"public/archives/page/2/index.html","hash":"d070458562be7d82fc9963df6d93aeaafb59480e","modified":1751423427538},{"_id":"public/archives/2024/index.html","hash":"de2add6edadd501b2c5a44e71943774caa692122","modified":1751423427538},{"_id":"public/archives/2024/page/2/index.html","hash":"64b49ce21b36f08d65bbcc39a92795dc2ac3099e","modified":1751423427538},{"_id":"public/archives/2024/12/index.html","hash":"7430611483f49e9ccaaeb1b3b7370c964fc4e237","modified":1751423427538},{"_id":"public/archives/2024/12/page/2/index.html","hash":"eb5000c2021868608d636557150e49815ca5bf32","modified":1751423427538},{"_id":"public/archives/2025/index.html","hash":"a2790e7d376ea444714a8b9c990b7f69f4039cfa","modified":1751423427538},{"_id":"public/archives/2025/02/index.html","hash":"219abb0592a80090e271d9a8bffff19a2de5a693","modified":1751423427538},{"_id":"public/categories/事务管理/index.html","hash":"7c59ff188cf4e8cbf80d0852dbb6db308c1138d9","modified":1751423427538},{"_id":"public/categories/系统休眠/index.html","hash":"ce8b076596bffea27788dc4a186d80abad144cf2","modified":1751423427538},{"_id":"public/categories/java/index.html","hash":"4ae6b0500bd4d49a17fee179356d5ec17ca8985f","modified":1751423427538},{"_id":"public/categories/事务管理/异步操作/index.html","hash":"16507ea11d6cd8014c765b59d92de71960a4a995","modified":1751423427538},{"_id":"public/categories/配置指南/index.html","hash":"8b2200a98db054fa32e526c50b5ce84b3dc4ecc5","modified":1751423427538},{"_id":"public/categories/网络配置/index.html","hash":"c0fd676caa44640d349fffe4a92b628ad34bb800","modified":1751423427538},{"_id":"public/categories/部署指南/index.html","hash":"ad3add1ada9e8763c090961c37092eb1e1aaac77","modified":1751423427538},{"_id":"public/categories/java/工具类/index.html","hash":"ffaebded859c0a615bfa2fcad9a7367a993aa355","modified":1751423427538},{"_id":"public/categories/服务器/index.html","hash":"cf721a2945f7c1e27ffa7a08aa84f50b3fc294ca","modified":1751423427538},{"_id":"public/categories/前端开发/index.html","hash":"66cc087f0eeea940fe5d61abe6dbb43a47c0231f","modified":1751423427538},{"_id":"public/categories/事务管理/异步操作/Spring框架/index.html","hash":"52793214175e17222a86dddeffbbb726afd751fa","modified":1751423427538},{"_id":"public/categories/Docker/index.html","hash":"2190915a55e59cfb322d0092d0864a03367c965e","modified":1751423427538},{"_id":"public/categories/Spring/index.html","hash":"0f4e9f44d7f3a7b9d3166df021fe76056165b4ff","modified":1751423427538},{"_id":"public/categories/配置指南/RTSP服务/index.html","hash":"8c5ffd12add2e9f394b535f03966b7a2988ee6ee","modified":1751423427538},{"_id":"public/categories/Linux系统/index.html","hash":"25b04d1f75bf870a86d8c675d461def6b7b903f7","modified":1751423427538},{"_id":"public/categories/mybatis/index.html","hash":"79a91fdbfa08fafee54248c46aa7f5f90e401f90","modified":1751423427538},{"_id":"public/categories/网络配置/性能监控/index.html","hash":"bf9be88d953f197a7fceaa1cfaf9777f109ef8b2","modified":1751423427538},{"_id":"public/categories/Java/index.html","hash":"a9a4ca8cf213b5ec978c4988e7f8e1850e0d49cd","modified":1751423427538},{"_id":"public/categories/部署指南/安装教程/index.html","hash":"798dcdacca7b7d32c0ea3d18e7a69cbff9b4d35a","modified":1751423427538},{"_id":"public/categories/linux/index.html","hash":"ee852acdd3189d1f0d89a814fcf54bbabf074514","modified":1751423427538},{"_id":"public/categories/服务器/网络配置/index.html","hash":"69944cc14f2331a3350bd003221c45a98a6e0785","modified":1751423427538},{"_id":"public/categories/前端开发/组件设计/index.html","hash":"bc3aecfc3c3576cff1495c74c9325915b99f8729","modified":1751423427538},{"_id":"public/categories/Docker/笔记软件/index.html","hash":"97ac3f4d1f67db49177f09657e8b833ab2f49133","modified":1751423427538},{"_id":"public/categories/Spring/Java/index.html","hash":"2cabe408a3a2106f65112ade05fa0ae248d6095e","modified":1751423427538},{"_id":"public/categories/配置指南/RTSP服务/Nginx安装/index.html","hash":"ee499765b6e18c90911c51c69b767342dc16bb9d","modified":1751423427538},{"_id":"public/categories/Linux系统/磁盘测试/index.html","hash":"e2bd9398bbbcfc384fc54c0ca22e88649d95d993","modified":1751423427538},{"_id":"public/categories/网络配置/性能监控/负载均衡/index.html","hash":"0c2b6f10717ec4f8fd17fcf584c9a67f5297da62","modified":1751423427538},{"_id":"public/categories/Java/Redis/index.html","hash":"27e39cfdabe45b368ce46ac07b561d81b2dfb33f","modified":1751423427538},{"_id":"public/categories/部署指南/安装教程/配置管理/index.html","hash":"d9ad7db7752f9625a135f608d0f8ed5bd4371fb7","modified":1751423427538},{"_id":"public/categories/服务器/网络配置/WebDAV/index.html","hash":"958a87ad329708238e12c54b01fe52defa16a7f6","modified":1751423427538},{"_id":"public/categories/前端开发/组件设计/代码示例/index.html","hash":"6e958ea45779f99550b7bd7e0fd23dadea81163d","modified":1751423427538},{"_id":"public/categories/Docker/笔记软件/开源/index.html","hash":"85ee709fa2befdc8b64f631e72aebfc8de11c428","modified":1751423427538},{"_id":"public/index.html","hash":"1149f8e0d04b6fc782484722f2fb948519d5ec9f","modified":1751423427538},{"_id":"public/categories/Spring/Java/Maven/index.html","hash":"492af09a7dad58a1d13cf2dac29d26758cf363f9","modified":1751423427538},{"_id":"public/categories/Java/Redis/消息队列/index.html","hash":"7e2e112fbfd8adbdf6863356923aaaec34d3a1cb","modified":1751423427538},{"_id":"public/page/2/index.html","hash":"c5a589bc5b99460a207275e4149e343e71d926bd","modified":1751423427538},{"_id":"public/tags/spring事务/index.html","hash":"94f4b0cf653829c432c2fec519b1f224e6a31450","modified":1751423427538},{"_id":"public/tags/异步操作/index.html","hash":"dfce62b08045b41cec55823a9004b18c87d7d523","modified":1751423427538},{"_id":"public/tags/事务提交/index.html","hash":"9788ca438ad90802c0a1c32e5a2990a716e992a8","modified":1751423427538},{"_id":"public/tags/编程技巧/index.html","hash":"ef542ccb6d2156463414c27d20746da9ba7e4c05","modified":1751423427538},{"_id":"public/tags/java开发/index.html","hash":"308a9163ee39b862dcf93cdf9118ecdd2f28211b","modified":1751423427538},{"_id":"public/tags/计算机状态/index.html","hash":"d2127d77a886aacd65ceb823ddf230d84086bd93","modified":1751423427538},{"_id":"public/tags/电源管理/index.html","hash":"c4fc43d428621f4dce0f6c179086f4dac600ede4","modified":1751423427538},{"_id":"public/tags/S3睡眠/index.html","hash":"71eba4c2e41f7b622ba933d2e8e4f0f005f7f43f","modified":1751423427538},{"_id":"public/tags/S4休眠/index.html","hash":"e3b0305fc5d3862a9b455a0a52c8e198179befbf","modified":1751423427538},{"_id":"public/tags/Java/index.html","hash":"7a5195bff3b5e55c53479b740c48fecf2c809d9b","modified":1751423427538},{"_id":"public/tags/List/index.html","hash":"fde835784cc43ef4ead6a7bff244b6bd1814dadc","modified":1751423427538},{"_id":"public/tags/分片/index.html","hash":"ba38a60f8f72a15a5903cd40cb6528db6bc57191","modified":1751423427538},{"_id":"public/tags/分组/index.html","hash":"575c83daa4beb5e7e9f83f5208243f4a05760d07","modified":1751423427538},{"_id":"public/tags/工具类/index.html","hash":"cd4820e4eab426422f0505a9da29d07b5baddcc2","modified":1751423427538},{"_id":"public/tags/nginx/index.html","hash":"1c4b73770dc3730b7e79a162658ed70a6cb280dd","modified":1751423427538},{"_id":"public/tags/rtsp/index.html","hash":"1d9e73579f6b313f91a2c76000579de0e4612efb","modified":1751423427538},{"_id":"public/tags/配置/index.html","hash":"9e97cda5fe833ab2f6ce5449852d035d573b9f81","modified":1751423427538},{"_id":"public/tags/流媒体/index.html","hash":"4a481ca103c705e1c709c65b4f1d0d25a13ef5fd","modified":1751423427538},{"_id":"public/tags/认证/index.html","hash":"174a397c082ac77d348ace91dd88a50487ab5846","modified":1751423427538},{"_id":"public/tags/tcp代理/index.html","hash":"271e2a4627abd7cbc0cf94bc782307f92f6d82a2","modified":1751423427538},{"_id":"public/tags/配置指南/index.html","hash":"ca26487c4111b63b260d4f0d583fd543dcd0fcdc","modified":1751423427538},{"_id":"public/tags/负载均衡/index.html","hash":"5cffb39a4ed3959d6056c1ae1fdfe29c92c91652","modified":1751423427538},{"_id":"public/tags/性能监控/index.html","hash":"b8519c3fe08cac2c510fa7a46aca5380977eaf2b","modified":1751423427538},{"_id":"public/tags/docker/index.html","hash":"c741878d9aa3cb323eee74835edd34edc5e92b54","modified":1751423427538},{"_id":"public/tags/源码部署/index.html","hash":"b2c61853a3de1c101bacb4e2265f1c2829023a81","modified":1751423427538},{"_id":"public/tags/包管理/index.html","hash":"80d9e5b616d9fe0c1e05413f7e383832dfa83e7e","modified":1751423427538},{"_id":"public/tags/开机自启/index.html","hash":"ad2d2e3ae68bc2549b34b7b6d4bd3d72310a871d","modified":1751423427538},{"_id":"public/tags/Nginx/index.html","hash":"10dee6912b2d6c8210162442421cd7dc4d8b8e23","modified":1751423427538},{"_id":"public/tags/WebDAV/index.html","hash":"f3dbe20289a1a82881091061f2e3cef1731ee70b","modified":1751423427538},{"_id":"public/tags/安全/index.html","hash":"11dc24f7ac838732f1214f5203369dc347f71bdf","modified":1751423427538},{"_id":"public/tags/服务/index.html","hash":"b7c085c90329d0059082ea4c81fefd135f1cee95","modified":1751423427538},{"_id":"public/tags/端口占用/index.html","hash":"2ae82ac0c91f5182296c9ed78eca25507a964bfa","modified":1751423427538},{"_id":"public/tags/错误处理/index.html","hash":"e562df2ee4017dd91d9a01e6302624d7cec255cc","modified":1751423427538},{"_id":"public/tags/Windows/index.html","hash":"a231537dd7f15a65f005bf1358716b6f3999b22e","modified":1751423427538},{"_id":"public/tags/Linux/index.html","hash":"651641909e3dc72299347e13abdfba9ed8d3b782","modified":1751423427538},{"_id":"public/tags/进程管理/index.html","hash":"b49745e733dc8238d5628b47ba7c0ce84b0f610b","modified":1751423427538},{"_id":"public/tags/复制组件/index.html","hash":"8e7a0699bf2bae970cf65168e11a15586d890e56","modified":1751423427538},{"_id":"public/tags/vue/index.html","hash":"1b919e8b8ae7c56af9a1b4ec639bb26e0a76d3ba","modified":1751423427538},{"_id":"public/tags/element-plus/index.html","hash":"ace4ef518183f0cba2745015a1bc5bce4529339d","modified":1751423427538},{"_id":"public/tags/剪贴板/index.html","hash":"170a6d66939ca71b48eeb0c1638e923dce96b962","modified":1751423427538},{"_id":"public/tags/国际化/index.html","hash":"88d787b0508def5d51ee596dcf60b8ce0542cb86","modified":1751423427538},{"_id":"public/tags/思源笔记/index.html","hash":"932c66982eb1cc05bfa55f2cbbe6f0a8e02a0d7f","modified":1751423427538},{"_id":"public/tags/一键部署/index.html","hash":"0f0b0b1c8680e5eefb68a17168205f098f934db4","modified":1751423427538},{"_id":"public/tags/云备份/index.html","hash":"ebe6cdc0b64f7110c23b8f36d18a05eb61d74cdf","modified":1751423427538},{"_id":"public/tags/解锁版/index.html","hash":"a7ce67d7c47415ba314d4f0117824c7e0d67408d","modified":1751423427538},{"_id":"public/tags/springboot/index.html","hash":"7f478668eb83a752cd1a0fc9bfee77b062c6e4e6","modified":1751423427538},{"_id":"public/tags/本地jar/index.html","hash":"eed0739e31577dc2fb4ebb77be01fc4e82ec27eb","modified":1751423427538},{"_id":"public/tags/maven/index.html","hash":"7bd095aa3f934efa31697a17fc262290b046b2d7","modified":1751423427538},{"_id":"public/tags/依赖管理/index.html","hash":"5a50611ef8fe4417013edf42148d713a21239cb3","modified":1751423427538},{"_id":"public/tags/项目配置/index.html","hash":"0c6b56c061e14dbf2ecf8273fe0cb7dd4b026194","modified":1751423427538},{"_id":"public/tags/磁盘测试/index.html","hash":"5ed308d553b628dce159adad8344ffde6891663d","modified":1751423427538},{"_id":"public/tags/iozone/index.html","hash":"af4df7d20bcd5c3a60a2d6bc9f97faf981156da4","modified":1751423427538},{"_id":"public/tags/dd命令/index.html","hash":"1e5c8f4d86f85bf4e77b89371e1d35b1a304a694","modified":1751423427538},{"_id":"public/tags/文件系统/index.html","hash":"235750d4040a405fa4c1f26a7d5a96c795e0cadc","modified":1751423427538},{"_id":"public/tags/性能优化/index.html","hash":"d72d35edde7cf05565655cf2728524b2d4f3558b","modified":1751423427538},{"_id":"public/tags/mybatis-plus/index.html","hash":"630200857e430ac703c47c4819dff31fbd700a20","modified":1751423427538},{"_id":"public/tags/in语法/index.html","hash":"cb254184d1cc82b456e36886bc17c7ac823d2b89","modified":1751423427538},{"_id":"public/tags/查询/index.html","hash":"503791fd86462dcb13830ccf77b456a968a66158","modified":1751423427538},{"_id":"public/tags/空列表处理/index.html","hash":"40057b733dad9df3b40baa3f1dc65901610a052e","modified":1751423427538},{"_id":"public/tags/lambda/index.html","hash":"7b8924920f189340c5bf78ee6f581ce2d2049b38","modified":1751423427538},{"_id":"public/tags/redis/index.html","hash":"db668b37a177920e4dcbe35a33404bad3925ce0f","modified":1751423427538},{"_id":"public/tags/消息队列/index.html","hash":"a6cd77112dbf1ec8762293890e4f4fbe48104059","modified":1751423427538},{"_id":"public/tags/java/index.html","hash":"2d1205b8f403594af91210269af29e6c3a4d17fc","modified":1751423427538},{"_id":"public/tags/阻塞消费/index.html","hash":"91c7ab0500cf60547076650c129e2ebab7b1f9fd","modified":1751423427538},{"_id":"public/tags/发布订阅/index.html","hash":"c0eb2ac41c092c86d54f238603a7552fcb299630","modified":1751423427538},{"_id":"public/tags/yum源更换/index.html","hash":"fc20b29f81082b8cbc2a06c0018fb2742bf6c1d0","modified":1751423427538},{"_id":"public/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1751423427538},{"_id":"public/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1751423427538},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1751423427538},{"_id":"public/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1751423427538},{"_id":"public/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1751423427538},{"_id":"public/img/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1751423427538},{"_id":"public/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1751423427538},{"_id":"public/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1751423427538},{"_id":"public/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1751423427538},{"_id":"public/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1751423427538},{"_id":"public/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1751423427538},{"_id":"public/css/index.css","hash":"7328b3b243d10702db2459870ef526ed83eb8062","modified":1751423427538},{"_id":"public/js/main.js","hash":"888563ad7324e565e6f5060ca126d69c7309bef1","modified":1751423427538},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1751423427538},{"_id":"public/js/utils.js","hash":"68e7f87c38365ef1271b69943395aa5fdb5417ea","modified":1751423427538},{"_id":"public/js/anzhiyu/ai_abstract.js","hash":"be52eb13a416b18337d3b1142277920072e698c3","modified":1751423427538},{"_id":"public/js/tw_cn.js","hash":"6cbec565e98cbd49aa75e6161d8fa996ae3be91a","modified":1751423427538},{"_id":"public/js/anzhiyu/comment_barrage.js","hash":"1b30f922238f626c6a90ce2705789ba2362a2a9e","modified":1751423427538},{"_id":"public/js/anzhiyu/people.js","hash":"f3d2a3d0c730124d9f64dbf59486145c05a42ac6","modified":1751423427538},{"_id":"public/js/anzhiyu/random_friends_post.js","hash":"1548fdc0a8cb4291bc8793dc8d321c59c097c08e","modified":1751423427538},{"_id":"public/js/anzhiyu/right_click_menu.js","hash":"d605ee0cab24604f97ccef5747bfacaa108645ba","modified":1751423427538},{"_id":"public/js/search/algolia.js","hash":"5c2a0d0489c51c6d9e54f5a3b0c6e66a5f649450","modified":1751423427538},{"_id":"public/js/search/local-search.js","hash":"3ad66c75b4a0fc28a14a5478ee8a19fde72f837f","modified":1751423427538},{"_id":"public/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1751423427538},{"_id":"public/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1751423427538},{"_id":"public/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1751423427538},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/home_top/random-banner.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1751424096203},{"_id":"node_modules/hexo-theme-anzhiyu/LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1751424096104},{"_id":"node_modules/hexo-theme-anzhiyu/package.json","hash":"b1bd6fd513cd4d1a98a904b37c6cd28296af7ee7","modified":1751424097030},{"_id":"node_modules/hexo-theme-anzhiyu/README_EN.md","hash":"3b27231432adf2bd180857fc6d3de646dfd444bf","modified":1751424097032},{"_id":"node_modules/hexo-theme-anzhiyu/README.md","hash":"46c4c8c308bd18c813da6b37356c7953f0d2e4af","modified":1751424097034},{"_id":"node_modules/hexo-theme-anzhiyu/sw-rules.js","hash":"0dc0fbe4d5e9acad4fffe69355830dcd41f89da6","modified":1751424097008},{"_id":"node_modules/hexo-theme-anzhiyu/_config.yml","hash":"a9dc87847239343e2c0079e155222eaf78029604","modified":1751424097457},{"_id":"node_modules/hexo-theme-anzhiyu/plugins.yml","hash":"23296290f36523e41926e22888f3d87b236dfbf0","modified":1751424097483},{"_id":"node_modules/hexo-theme-anzhiyu/languages/zh-CN.yml","hash":"dbd5b387322693ed53df84eab709bf04ffeb8b81","modified":1751424097486},{"_id":"node_modules/hexo-theme-anzhiyu/languages/default.yml","hash":"be22c8d1730408a2ac3ec9a57406e297fc1f7ce6","modified":1751424097465},{"_id":"node_modules/hexo-theme-anzhiyu/languages/en.yml","hash":"4c46ef35360b8322269417bcae68e609ca8f85be","modified":1751424097466},{"_id":"node_modules/hexo-theme-anzhiyu/layout/category.pug","hash":"1d55b22a50675d1ecfb95d031ea011245c7c6511","modified":1751424097118},{"_id":"node_modules/hexo-theme-anzhiyu/layout/archive.pug","hash":"b8778e55f1aab2431daa4a64cba991ef40e33224","modified":1751424097085},{"_id":"node_modules/hexo-theme-anzhiyu/layout/index.pug","hash":"cf1b756e06864a47352bb9890519eafcf5d0340d","modified":1751424097185},{"_id":"node_modules/hexo-theme-anzhiyu/source/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1751424096892},{"_id":"node_modules/hexo-theme-anzhiyu/languages/zh-TW.yml","hash":"0e0b432912390e3de9d99bc54add99e4d265d3d1","modified":1751424097489},{"_id":"node_modules/hexo-theme-anzhiyu/layout/page.pug","hash":"98e81d10e6caab2ff79b4a2788d2312acded36ef","modified":1751424097220},{"_id":"node_modules/hexo-theme-anzhiyu/layout/tag.pug","hash":"354b85519feab71c0233eb240655d0e0ec67021c","modified":1751424097266},{"_id":"node_modules/hexo-theme-anzhiyu/layout/post.pug","hash":"0d8d8cfd31e97053c908dac3ee19072825a6a2dc","modified":1751424097235},{"_id":"node_modules/hexo-theme-anzhiyu/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"3978be1ecdd21be564aa590b17eda6f03cd77e19","modified":1751424097459},{"_id":"node_modules/hexo-theme-anzhiyu/.github/ISSUE_TEMPLATE/config.yml","hash":"a23b745378bc745b15f2dfefcc6a203d5d1d5fcd","modified":1751424097462},{"_id":"node_modules/hexo-theme-anzhiyu/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"53260c55a97ed93e6a1f9acc23b9d21193cae6ef","modified":1751424097467},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/issue_close_stale.yml","hash":"6151bdec23ded908adf01ba5ecdf3c0da573449d","modified":1751424097470},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/issue_invalid.yml","hash":"8cdde230c8f9330cc7cd5c149ea5fc258ffb0b8b","modified":1751424097473},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/issue_duplicate.yml","hash":"42a8e022434604081fe443d416bd443efd887015","modified":1751424097472},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/issue_question.yml","hash":"72ce6e36847f20952d8f8742e4fd1969cd086320","modified":1751424097476},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/issue_close_question.yml","hash":"a7f1bf4578faa6092898a9a44bfd467cbb1788dd","modified":1751424097469},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/issue_wontfix.yml","hash":"3b498c22281bb454f8ee1135a4becee0adc5b9ae","modified":1751424097479},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1751424097485},{"_id":"node_modules/hexo-theme-anzhiyu/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1751424097483},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/404.pug","hash":"aa158d5a661aa2fab4737b9460ce34f6784fdee5","modified":1751424097062},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/categoryGroup.pug","hash":"243f63820db5f3241e682ae8f3baffd6501df3de","modified":1751424097119},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/bbTimeList.pug","hash":"0a0c4cdf69314c3a9ecb078f4213c76129a9ac06","modified":1751424097095},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/footer.pug","hash":"50131aa8ad85fd6c08d8e1cb2d3dcfceb5964abe","modified":1751424097158},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/additional-js.pug","hash":"d7e42261a79651ce13ff2213947ecb3e4c41ee81","modified":1751424097066},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head.pug","hash":"8db5b7382011745f53b99b5b5577ae28140068e2","modified":1751424097167},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/music.pug","hash":"163f5bbeadbe481a809652e6ce453022db26694a","modified":1751424097199},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/layout.pug","hash":"3bc51657414be0c94bd27752616cc7f7d54f20cd","modified":1751424097188},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/mourn.pug","hash":"d114b9493fbe6551b0c4ad1c1d8886b7f98a0d60","modified":1751424097198},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/shortcutKey.pug","hash":"dcf8fb7bbddd4a64626f4fcf2523ace2dfce879f","modified":1751424097256},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/pagination.pug","hash":"1e0be343f9bdc6cefc5ff0dd3c2936ed91d5be86","modified":1751424097222},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/404.js","hash":"170e72e851257365468024557c767360c3deafbf","modified":1751424096910},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/cdn.js","hash":"39aaf1d4fed1382c85776581225747285b7b388c","modified":1751424096933},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/comment.js","hash":"a3d1f417965ca20253c36f9e93429f3df6268856","modified":1751424096940},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/merge_config.js","hash":"4bc10659ac9b483032a13bd3d7bce9094fd7c58b","modified":1751424096981},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/rightside.pug","hash":"d865835bc5432d8ec15fd0cb168643f3e9b77a18","modified":1751424097249},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/stylus.js","hash":"675eee74f9efcbc846b89eb9ba41f130a95310ee","modified":1751424097007},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/init.js","hash":"006401bd6f4bb3fc8756e752d6ab93bf770bb77f","modified":1751424096955},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/events/welcome.js","hash":"3177e070519a10fff904595e152a329115d22c61","modified":1751424097024},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/filters/post_lazyload.js","hash":"61f06b25c09434340e81c8c3dbbd1a0d58406652","modified":1751424096989},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/filters/random_cover.js","hash":"98275d777b3c388345de3ee8caf5d16900388925","modified":1751424096990},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/aside_archives.js","hash":"ca03ba2a0a7f2132ac5d3f66cb1bbd9e078aed3f","modified":1751424096919},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/catalog_list.js","hash":"aa38fd791d58df3fd518adf144578f160073d06e","modified":1751424096931},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/findArchiveLength.js","hash":"d8aa1a4824ba6b0df911af563ae5fb361257a88a","modified":1751424096944},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/get_version.js","hash":"f2b7364706fc4d039da4a486e133baf7accf6836","modified":1751424096951},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/inject_head_js.js","hash":"847bc24452bc23dfc860b219588cfb2bff84cfbf","modified":1751424096960},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/page.js","hash":"dff1124a8825479606e45e69e329a3ad1903ec87","modified":1751424096985},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/random.js","hash":"d659d1d05c919d1abba2dc55439749e6e5b6e707","modified":1751424096996},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/related_post.js","hash":"c5f70efdbfd733f4dfec0ca8fe4aded0eec394cf","modified":1751424096999},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/sort_attr_post.js","hash":"6b6e9fb0d0dc38e8d7136dc7720c70f0c29619ab","modified":1751424097005},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/tags_page_list.js","hash":"35d71c025a3289be188371cc56320c563213c4af","modified":1751424097012},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/year.js","hash":"94f15ddba7d29cdcc4dd52ed6c35c9c29cc19d37","modified":1751424097026},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/Introduction-card.js","hash":"61a55f9b1f5f576e6900d2900cb42754575a4cb7","modified":1751424096965},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/helpers/aside_categories.js","hash":"19244d6a9e42c34b9df2250be2467c352fa5fd41","modified":1751424096921},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/bilibili.js","hash":"085e033cb359e8f109968748cedbd0079515e7c6","modified":1751424096927},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/button.js","hash":"430c31584930bc5407811c3dbc01be92473cfcbf","modified":1751424096930},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/btns.js","hash":"200e1ce72f335caa71dc8423f5c5e2aba1195b61","modified":1751424096929},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/dogeplayer.js","hash":"e9b0d88e38d3caf88b66ea39ca704d45c643ba51","modified":1751424096941},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/checkbox.js","hash":"fa93b169fe74bced502b0d16fe3d6bd17434b8f3","modified":1751424096935},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/folding.js","hash":"dc4e409eabebf5769b50c12c9e8c66b749d0ae85","modified":1751424096948},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/gallery.js","hash":"0364b021f2519a937464e585a7e2cbdde57ca412","modified":1751424096949},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/hide.js","hash":"37b81ff46d104554b9a5934bfd434dbfd6a84958","modified":1751424096952},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/flink.js","hash":"5b0086d1b726d1068b3d8ee0563ae31485896c4b","modified":1751424096946},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/image.js","hash":"0b7051574af6cf28c378db65f6c6dab722a8e118","modified":1751424096955},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/inline-labels.js","hash":"08fbdc0ea622270e1236a28778f875c8ad2e5516","modified":1751424096962},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1751424096963},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/link.js","hash":"a5d49f1d0e4602b0fce158efd0b1ec02c0bfd3e3","modified":1751424096966},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/media.js","hash":"76efb072e0716e55deedb044fed1ad585871335b","modified":1751424096977},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/iconfont.js","hash":"ea983f7c8dd060ed411044df1c10aa6b72dec34f","modified":1751424096953},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/mermaid.js","hash":"d3d6c8a23ddfecac35f7022eecd4ffc6171a37fa","modified":1751424096982},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1751424096984},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/span.js","hash":"0a2188be1e3ee6ed183c0f16d24795ef31116e10","modified":1751424097006},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/label.js","hash":"87acd7d5615dd8034c51ba28d4964992d2ffed37","modified":1751424096966},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/tabs.js","hash":"dea5cd52bb9fd658bc03074b2388d91ea528fc2b","modified":1751424097010},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/site.js","hash":"bc34bfab53f520bec33d273ee599de5905ca19a9","modified":1751424097003},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1751424097013},{"_id":"node_modules/hexo-theme-anzhiyu/scripts/tag/tip.js","hash":"e45a0955439dfbe6c0b4d27f8403896a0fb1d33b","modified":1751424097015},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/tw_cn.js","hash":"6cbec565e98cbd49aa75e6161d8fa996ae3be91a","modified":1751424097018},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/main.js","hash":"888563ad7324e565e6f5060ca126d69c7309bef1","modified":1751424096974},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/sidebar.pug","hash":"fd6d7873df74994ed6a36bd07a438c427db97e18","modified":1751424097257},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/utils.js","hash":"68e7f87c38365ef1271b69943395aa5fdb5417ea","modified":1751424097023},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1751424097040},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1751424097452},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/favicon.ico","hash":"14310db268ea8d3b2096f434c6e293fc207f5f09","modified":1751424096894},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1751424097043},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/index.styl","hash":"ddded5cd1da248fdc30556a33877579ff8379a48","modified":1751424097374},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/var.styl","hash":"7bdedada1176e55d5fb72e3cc9f46e01d03b704a","modified":1751424097451},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/anzhiyu/ai-info.pug","hash":"0c2e9e58069880c0617208840cf2f0712339ddf0","modified":1751424097070},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1751424096908},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/anzhiyu/clock.pug","hash":"c13b21cdcbc5280deb26537c58af5443cb66c62f","modified":1751424097132},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/anzhiyu/console.pug","hash":"d46c93a7a22129795cc856045967b0e07c5e53c2","modified":1751424097137},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/anzhiyu/log-js.pug","hash":"a44b4f89f39d1e32889849c3dd1403dffa2786a4","modified":1751424097191},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/anzhiyu/rightmenu.pug","hash":"2747252c6337d8fb7ba773cdb466611607f9a23b","modified":1751424097246},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/anzhiyu/tags-group-all.pug","hash":"bc16fa91883895544273161cc8672bfe5c010e5e","modified":1751424097268},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/Open_Graph.pug","hash":"dff5b967a641f385c4661fe66ad62d53cabf857a","modified":1751424097217},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/bili-banner/index.pug","hash":"8cb1c404adc6fe188bdceca3c09d3f215048e9bd","modified":1751424097169},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/config.pug","hash":"068b2fe70e7f26cdd1f0ee6c75d79266ceed89dd","modified":1751424097136},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/config_site.pug","hash":"3038adec24b17f019bdd7d6aa15ebe091b11397d","modified":1751424097134},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1751424097166},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1751424097215},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1751424097082},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1751424097259},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/preconnect.pug","hash":"56ef61e74598cf60551d363a15fc53842b8dc41b","modified":1751424097237},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/head/pwa.pug","hash":"a4cc65381275e09f3f54f6e958d359c89c7b2c4e","modified":1751424097243},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/header/index.pug","hash":"c865d51436cfd5413df6c691a7ab1f0eb600e79c","modified":1751424097171},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/header/nav.pug","hash":"e567624b78d723346193a9b0d28032031997b865","modified":1751424097214},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/header/social.pug","hash":"2185b69eb54656ed9e401bc47ca3cd9905b022f3","modified":1751424097262},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/header/post-info.pug","hash":"0f1503c88d05ada69919e0bdbbf7b2ea1603d20b","modified":1751424097232},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/loading/fullpage-loading.pug","hash":"39977280dd32f1435a97f285a75f2a02902472d6","modified":1751424097163},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/loading/pace.pug","hash":"7f04cabd68f75d7f953503283316e1594bbec45f","modified":1751424097218},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/header/menu_item.pug","hash":"4537154b8830310ce5dff3c9cfd558f0ec1311a5","modified":1751424097195},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/loading/index.pug","hash":"f86b0c45874ae1335ab575c29d4f9c8ea09ab92a","modified":1751424097172},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/mixins/article-sort.pug","hash":"7a06f5f24f8e32b3025cf43474db9519d48517e5","modified":1751424097093},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/mixins/post-ui.pug","hash":"80858e19caf57c275cb7d6acf3bfff7d0c90c774","modified":1751424097233},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/album_detail.pug","hash":"c735533f7671905d06bae5645306cd08abb0b43c","modified":1751424097075},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/about.pug","hash":"fa529ca6b5ab9001822668697f410cc3020980ad","modified":1751424097065},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/categories.pug","hash":"f23d074ef6875311e74169da7592ecf667539775","modified":1751424097117},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1751424097142},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/equipment.pug","hash":"87ca40c49ddfe9c266cd96b4eb3594d7c64c1d55","modified":1751424097148},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/fcircle.pug","hash":"a4bfc9855bcfc859f0c04e869e0ec8cb8d2a1357","modified":1751424097152},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/essay.pug","hash":"b0a25ded52c72c84bd29593bd7a57046c4b36195","modified":1751424097150},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/music.pug","hash":"3cbec3b3dc0f0e812f29c222ebb2d2a3d8c2719f","modified":1751424097200},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/flink.pug","hash":"3756dfd0ad97968c02a9be662dc5e9253cbc33b9","modified":1751424097156},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/album.pug","hash":"0ca70f1ec4757d6127048d71762752dabf1af2ea","modified":1751424097076},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/tags.pug","hash":"62882d8a699254486add2f7b0f089521732e4869","modified":1751424097269},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/popup/index.pug","hash":"3ac8714556f94a614100aeddeb7f7e0cdff2fb9c","modified":1751424097175},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/page/room.pug","hash":"c35a2fb076e0196ba28389b5309dde33a2add576","modified":1751424097251},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1751424097084},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/post/reward.pug","hash":"cdf5ff34ba8efe526cfe77ddf3277d997d172d41","modified":1751424097245},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/post/post-copyright.pug","hash":"10638ede3b9ea1ef4e336f5c4d690239ef353843","modified":1751424097228},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/post/ptool.pug","hash":"173d1a63099109bd909de919281db9f2b2a023f0","modified":1751424097240},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1751424097146},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/footerBarSubtitle.pug","hash":"bb2df2fbbdc9fe0f4b9d66928247faa49f70e2e5","modified":1751424097159},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1751424097223},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1751424097239},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/pjax.pug","hash":"4ee026b34e6ecc2c03cf04933973b496472309c2","modified":1751424097224},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/top/top.pug","hash":"9f849b05e220efa72d56f524a27ab2877e27e9e3","modified":1751424097274},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_announcement.pug","hash":"ed8796dd3c5710d745fdcc0021b02a3cda07fd1b","modified":1751424097098},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/subtitle.pug","hash":"142621f70bedcb5033ee99a988f7bb6c5eea3493","modified":1751424097264},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1751424097097},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_archives.pug","hash":"9ca97d85cc7b214e1107d0b4feac4d8ad2fd0ac8","modified":1751424097099},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1751424097103},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_author.pug","hash":"b7e11bcd199f343a844315e5d16735205dded9d2","modified":1751424097101},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1751424097101},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_console_archives.pug","hash":"8c095ae91183d6a2aeed64f378e60baaa29d4065","modified":1751424097103},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_console_tags.pug","hash":"d723516d48cd94a68819df5c61087c9e7339e2af","modified":1751424097105},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_newest_comment.pug","hash":"419eed9a771299c9ffb85fdf38073bbd5bd7775c","modified":1751424097106},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_post_toc.pug","hash":"638417324111b66c834314b96cbf02e959be58f4","modified":1751424097107},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1751424097113},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_tags.pug","hash":"3475134643b70cbf0e806806bd2e0d2a7371f8a5","modified":1751424097111},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_recent_post.pug","hash":"544272cb0977b8a941de22f1f58f76d370b2cbbd","modified":1751424097109},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_webinfo.pug","hash":"5ddf285ca0ecbb57cbbbc36a4e9eaaca40406257","modified":1751424097115},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_global/function.styl","hash":"e91b257ce982b670eb911c7120f379960083c959","modified":1751424097346},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/card_weixin.pug","hash":"28f11437bcba4df1e53fc1e32df213392b9ca4b6","modified":1751424097116},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/widget/index.pug","hash":"e33c360217b11a7980e780a5bc20e9d31f5dacf5","modified":1751424097184},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_global/loading.styl","hash":"734c69c16135543267794e12b43e776d501fb6ca","modified":1751424097386},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_global/icon.styl","hash":"da488461e8c5e504961c0a8f44b1e3605f72f956","modified":1751424097363},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/highlight.styl","hash":"4a1f547d921d1b44f1221e60a42666a63a19e5a1","modified":1751424097356},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/theme.styl","hash":"c074efc93f4f118c3fc3b3d3c9f9abc42e4858b4","modified":1751424097439},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_global/index.styl","hash":"55850e21e138a0ad8250f4b2ff38412fdb343d1d","modified":1751424097367},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/404.styl","hash":"02a8df2e9734848cc4670a4b9f6e9a776e995644","modified":1751424097293},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/banner.styl","hash":"62f4202467cc9f313361911ed2a2005e66b3b2ca","modified":1751424097308},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1751424097316},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/footer.styl","hash":"ce21052dd27e752c3734083ec1401b96c542bfda","modified":1751424097344},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/aside.styl","hash":"b62fbde63342f779b4dd27492e6da878c25f7dfb","modified":1751424097306},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/comments.styl","hash":"3dbb4c0e1ef79eab1f327d303c3aed61ddc3f58c","modified":1751424097319},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/home_top.styl","hash":"c975f539ae6bed3b24c9dc3914b412f179ee2543","modified":1751424097358},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/head.styl","hash":"960ca89ac2456f165e0b71214ef0b1519e1690ad","modified":1751424097350},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/nav.styl","hash":"200ddfe40c4a820af25fcfa71aa450b22741f6df","modified":1751424097397},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/oneGraphFlow.styl","hash":"1e5843caf8674429a5782712879c4a532074514d","modified":1751424097399},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/relatedposts.styl","hash":"c67558ba609b59375f8ee6ad479fcb16ddda9cb6","modified":1751424097412},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/post.styl","hash":"2a4a8af05bc24edbd14c4160b17489242164727f","modified":1751424097404},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/ptool.styl","hash":"2ffeca0499c6ad1c4ea2ef783d7493b713b24569","modified":1751424097407},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/pagination.styl","hash":"88f2fbb0ccb061410b07e1ed6303583230e96d4e","modified":1751424097402},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/rightmenu.styl","hash":"cc622c70ff61ef70dfa6445b5b4b09eb92cf9994","modified":1751424097418},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/rightside.styl","hash":"bebc753a414d3fb807b5bf8dfeb87fe602e92e73","modified":1751424097420},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/reward.styl","hash":"152b802a38f029dece2b8f8812404cec25975212","modified":1751424097415},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/third-party.styl","hash":"a6b708dfeda4ad837bbfc76bd74810805ca521a0","modified":1751424097441},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_mode/darkmode.styl","hash":"43391bb6a4d1908c87515851c41b8d97b847b49b","modified":1751424097324},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/shortcutKey.styl","hash":"ca7674768558396a8e2f9eaa452575bff099e4e8","modified":1751424097421},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_layout/sidebar.styl","hash":"57d6857a1209dacb6f3fd0eb3c3f539fef3a2daf","modified":1751424097426},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1751424097297},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_mode/readmode.styl","hash":"a5a27dea73ed993ce81ca691eff9eb71c2b311a7","modified":1751424097409},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/archives.styl","hash":"8652be12d88083f71a1efb88a2482a0aeda2c65f","modified":1751424097303},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1751424097316},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/common.styl","hash":"99ca9cb011349c045ed779bd5db9763c2073bbfe","modified":1751424097322},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/about.styl","hash":"72a3345b9791fcf51bb74ff6eebfda4674e8f60d","modified":1751424097298},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/flink.styl","hash":"990a1b5d937980ec1f6f764f4b5ce371279cc451","modified":1751424097339},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/equipment.styl","hash":"8ed450c37e8b5b5d6ce04245b54fc0877b0ad0d9","modified":1751424097335},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/homepage.styl","hash":"7b2b2b4a7f3139f7db2d535b2ed7167db8bfd0ed","modified":1751424097362},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/reward.styl","hash":"3a6e95f58b1692c6ee67a669fc965d9dea026186","modified":1751424097416},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1751424097437},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/music.styl","hash":"290dd82c05bc21a0f22a7b666f2af233e9e8bbb2","modified":1751424097393},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_page/tag_page.styl","hash":"704a74185d0e872ca3358567a2ecede5c2d35910","modified":1751424097436},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_search/algolia.styl","hash":"f7cb2effef6b4e587fad385d7c11b4b23c110589","modified":1751424097301},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_search/index.styl","hash":"fd2833ec664a9de9a7b3dd1cade7d65e3ad80ddd","modified":1751424097372},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/bilbili.styl","hash":"081833e071be562201c56ec4db000b7ac144a39a","modified":1751424097311},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/Introduction-card.styl","hash":"ec70e67c2a8bc1a0ebe536091d97bc326faf9973","modified":1751424097381},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_search/local-search.styl","hash":"25e58a7a8bda4b73d0a0e551643ca01b09ccd7e5","modified":1751424097388},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/checkbox.styl","hash":"2a31f4c0cd31f67342564ef22254eb317d82f331","modified":1751424097317},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/btns.styl","hash":"903b571a6e352e5014e35e9a675b7d2d6e5b82bd","modified":1751424097313},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/button.styl","hash":"af1840996356aeae6ffbee49ab86aa7834ab18a0","modified":1751424097315},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/folding.styl","hash":"537320d4762bef842beabfbde9b27f0e2ece2ba6","modified":1751424097341},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1751424097351},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/hide.styl","hash":"810c54530d3799fe492d9c3d4842ab5ca4243092","modified":1751424097354},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/gallery.styl","hash":"697408d915056ae6e6814e0f24ca013f68227f74","modified":1751424097348},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/image.styl","hash":"4cf305b1d57d0c9bfe948f916fe9b124ee62fc0a","modified":1751424097364},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1751424097380},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1751424097382},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/inline-labels.styl","hash":"d9bdac4ca48b19cc028efc1a084ebf99c38bb8ec","modified":1751424097378},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/note.styl","hash":"3b357c94cb8e80039cc1689161637d5b9690ff18","modified":1751424097398},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/media.styl","hash":"05a249c807cd7760492a9ef5914b3e363d7d1028","modified":1751424097390},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/site-card.styl","hash":"5ff77bfa663aca406e3a0bd822da0d6e3c3c2c8b","modified":1751424097428},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/span.styl","hash":"f75112e431fcbef352a7ee7f0aa85e8b2f0b4a26","modified":1751424097432},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_third-party/normalize.min.css","hash":"007ada04a97d0fcaf55ee840a03f2f10b9abcbff","modified":1751424096199},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/tabs.styl","hash":"b0dc66d3daafe8c3a022f7235de3d8224cb56ec9","modified":1751424097434},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/tip.styl","hash":"0f712be285681bac71e96c48d0836b8fea52bf6f","modified":1751424097447},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/anzhiyu/ai_abstract.js","hash":"be52eb13a416b18337d3b1142277920072e698c3","modified":1751424096914},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/anzhiyu/comment_barrage.js","hash":"1b30f922238f626c6a90ce2705789ba2362a2a9e","modified":1751424096938},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/anzhiyu/people.js","hash":"f3d2a3d0c730124d9f64dbf59486145c05a42ac6","modified":1751424096987},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/anzhiyu/random_friends_post.js","hash":"1548fdc0a8cb4291bc8793dc8d321c59c097c08e","modified":1751424096994},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/anzhiyu/right_click_menu.js","hash":"d605ee0cab24604f97ccef5747bfacaa108645ba","modified":1751424097001},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/search/algolia.js","hash":"5c2a0d0489c51c6d9e54f5a3b0c6e66a5f649450","modified":1751424096916},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1751424097035},{"_id":"node_modules/hexo-theme-anzhiyu/source/js/search/local-search.js","hash":"3ad66c75b4a0fc28a14a5478ee8a19fde72f837f","modified":1751424096970},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1751424097046},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1751424097047},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1751424097040},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_third-party/snackbar.styl","hash":"47a90d6a87744c6e4ced18b95220debef8f278d0","modified":1751424097430},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_third-party/twikoo.styl","hash":"51475a99ec3281fb98ca8707e28064f91dd9c68a","modified":1751424097450},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_tags/timeline.styl","hash":"3076b68fece8ef394cbd44570037e5e479fdd277","modified":1751424097443},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/card-post-count/index.pug","hash":"a20dd36c318c7a37870fbc9dcecbc03f94ade817","modified":1751424097176},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/card-post-count/artalk.pug","hash":"6b8e29a8ad921ae50f8c43b8b7459ddc152b05ed","modified":1751424097087},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1751424097282},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1751424097130},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1751424097277},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1751424097038},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/card-post-count/waline.pug","hash":"b40b0cbd0389f03fed5ddf624fa598613135046a","modified":1751424097285},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/chat/index.pug","hash":"9eff7757c825d776edde1c1dd09623a91d891e6b","modified":1751424097177},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1751424097138},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1751424097140},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/chat/tidio.pug","hash":"76b08a6da3eed8f90304fa6546783e5c04a792fb","modified":1751424097269},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/giscus.pug","hash":"1359563b73f3ce1629be49dc7780b4670f370995","modified":1751424097165},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/index.pug","hash":"d5bb2cd8d96523a6693fa1bfa68c307f6c63f325","modified":1751424097179},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/artalk.pug","hash":"a486578b5b9cd130dbe22e7b4ad5cbe724dc4678","modified":1751424097088},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/js.pug","hash":"29539a0f6c5622efba25805c8ff3252a70e1a2b7","modified":1751424097186},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/twikoo.pug","hash":"1582986ede8a9c727004d1dc114bd7ee92880641","modified":1751424097281},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1751424097180},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/waline.pug","hash":"612ab49a4a2e676c7c1110b5f618726b2dc7ddf7","modified":1751424097287},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/math/katex.pug","hash":"235fb3c8b4da8ec6b010d4d30d3594d3dbfd0bbe","modified":1751424097187},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/comments/valine.pug","hash":"e54a60b1795721153faaa887b46a68b68bcd3abc","modified":1751424097283},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1751424097194},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/math/mermaid.pug","hash":"10f3949da0889c1ec3e3617da290927d834d1f6d","modified":1751424097197},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/newest-comments/artalk.pug","hash":"bbaaa94d99c345f7412803a98bf3d83722743dfb","modified":1751424097090},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/newest-comments/index.pug","hash":"6dafa98f6082e909c00396a4793ed3e7c866f824","modified":1751424097181},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"3b20540a0e687cb05fd71a716e78f16a175a7d58","modified":1751424097276},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/newest-comments/valine.pug","hash":"3de61f1b229f2928ae120ecfa6166862c1735d18","modified":1751424097284},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/newest-comments/waline.pug","hash":"3fbf5700aedaa63ea09e8f68c063961db785fa44","modified":1751424097289},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/search/algolia.pug","hash":"fbdeb32013088e8f7f4c8a6a1f20622e58dc09c2","modified":1751424097079},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/runtime/runtime-js.pug","hash":"63391ff01fd55d8c48b3a9e46d83d4af75908ffb","modified":1751424097253},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1751424097182},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/search/docsearch.pug","hash":"cb42537ea530d6679a46a1db092da0e91756b2c3","modified":1751424097143},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/album/album.css","hash":"d3938a8e6edcf2be0dff02728f605406feba800d","modified":1751424096116},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/search/local-search.pug","hash":"d3f133564dda5e2c51661a914ae5aab8fb9dbaf6","modified":1751424097190},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1751424097068},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/anzhiyu/custom.css","hash":"262291db00a343991c5472131804a4fd00deed4f","modified":1751424096158},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/catalog_list/catalog_list.css","hash":"77526a3317c058a965ca44e446412f1d74b97c96","modified":1751424096128},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/album/album_detail.css","hash":"b75189ece986fa6b645751791a72d2783fbae05f","modified":1751424096114},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/aside_weixin/aside_weixin.css","hash":"17015ed4c296ea890e807716c6abe0a11ddcb906","modified":1751424096122},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/categoryBar/categoryBar.css","hash":"b9ab5612f4d24092388defcb8db7399445a10710","modified":1751424096132},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/clock/clock.css","hash":"b91f3216c6e859f89d9348bd9517c764e607402d","modified":1751424096140},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/code/code.css","hash":"976b68722d6698d7687f362532d7a0e6b6050d3e","modified":1751424096144},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/console/console.css","hash":"f61b9504a5f7b33d7508c9c5201c0c21ae9f8d53","modified":1751424096154},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/code/details_summary.css","hash":"30b01d74157aaccea84c4c0d7e0ebb65f5a7f9c9","modified":1751424096162},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/commentBarrage/commentBarrage.css","hash":"a1355fe5e03c5e5dbd17761cc7a80fa9758c5891","modified":1751424096147},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/essay_page/essay_page.css","hash":"0d62e0d6b6f57fce49d347c8ce969071933dcd45","modified":1751424096166},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/bilibili-bangumi.css","hash":"81567514e32d5c2cc647aff121f405c7a7b50897","modified":1751424096124},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/essay_page/home_essay_bar.css","hash":"bfb259092223dcdfcb1a652330dc8ea1236fe76c","modified":1751424096182},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/bilibili-ratio.css","hash":"ad6edf2b75dd717e9dff9fe4ca4db79c1599a6f9","modified":1751424096126},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/categories.css","hash":"563bd4583007329c6e34c28883ee26a39af6c8f3","modified":1751424096130},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/aplayer.css","hash":"00aee0451ccb5b2f402ecb7f358acf78c53cee60","modified":1751424096120},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/clock.css","hash":"90e0bce1341d9e01aa0efaf9c70256ef5fe6139b","modified":1751424096141},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/dark.css","hash":"febe18af9e0cc45c6a35f0e0ef085c182985afa6","modified":1751424096160},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/comments.css","hash":"667a4182d046cb6bf0561bdb7fe8c788ae79438f","modified":1751424096148},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/fcircle_page.css","hash":"02ce333e7f9ed6b9756a6706475192e2fd3fbd4b","modified":1751424096168},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/gitcalendar.css","hash":"f99c63423cbedb8f12ccea673d8e79e10a4cfb6c","modified":1751424096175},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/hexo-tag-dplayer.css","hash":"90e6ba180e0b9267aa0bf27eb9f0a1d2e9cb3ecc","modified":1751424096180},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/hide-block.css","hash":"15e0c13f8451bfe36fa5e464b86767bd98cab70b","modified":1751424096181},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/link_page.css","hash":"69e5ed458c0dc10d93ebb7e4943196be1167ed5a","modified":1751424096188},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/site-card.css","hash":"0a662f62c69d36ac583528c02346d848aa1d026a","modified":1751424096224},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/radius.css","hash":"6ef242f7a79427da9651a26c8a07e4e56ac56a42","modified":1751424096202},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/footer/footer.css","hash":"d94ed305398eb831b9e7160ce54510b0d25fcf67","modified":1751424096171},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/fix/overflow.css","hash":"71e3bd9905684e6e2ba6e18282e982d96dc4d61d","modified":1751424096201},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/friends/friends.css","hash":"a2e50f529aa1fd60732d9a892166bb1d3ae725d7","modified":1751424096174},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/greeting_box/greeting_box.css","hash":"208ba729979dffdaa2f82639027a09b8c64fc5c2","modified":1751424096179},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/home_top/home_top_post_group.css","hash":"04d9a3bd9cb247f4c391af0cd7cb47206974ceaf","modified":1751424096186},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/home_top/home_top.css","hash":"4bf724bd2f1a0447532456c60701e79b906c8dd0","modified":1751424096186},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/home_top/swiperstyle.css","hash":"ea249de8cebc68cda7e62705df2acd7c78d13f37","modified":1751424096234},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/home_top/top_group_banner.css","hash":"909b63f4b66c1c324ea302e93b3cb7c038306d0b","modified":1751424096236},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/home_top/categorygroup.css","hash":"bc5b8a6cddca8c36a96ea5ecd1e56a5860bbb09a","modified":1751424096137},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/local_search/local_search.css","hash":"d3bc30e147897fb3026284d4244c4cf195d4588a","modified":1751424096194},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/reset/reset.css","hash":"0617cd338ebe4be2820d03d88376b30e0f378c1c","modified":1751424096207},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/room/room.css","hash":"82eb83dc296c045b0388cd9417ff1bc822e46f41","modified":1751424096216},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/runtime/runtime.css","hash":"7fd033212b0dcdb06ca7f7a83343ea1b6044d59c","modified":1751424096219},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/single_card/single_card.css","hash":"1559219f059389933e435dd081af5e6e17ef4b75","modified":1751424096224},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/skills/skills.css","hash":"6dcf742c38dcdf988e3d6f545fbfa0227d3155ea","modified":1751424096231},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/tag/link.css","hash":"dbc87df28d7dfa366ab3c91ac61967ac48d7877c","modified":1751424096191},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/tag/site.css","hash":"631a068d827a84a46fa03282b4ca38936c4bc4f3","modified":1751424096226},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_extra/reward/about-reward.css","hash":"f95871737b0e883ab70b30948b2cd4339bf36756","modified":1751424096107},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1751424097255},{"_id":"node_modules/hexo-theme-anzhiyu/layout/includes/third-party/share/index.pug","hash":"b0e932171cbdfeb8a98bc1e8b78172f672f5fdfd","modified":1751424097183},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1751424097384},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/prismjs/index.styl","hash":"7751de787861a9b45cf3879fb18601abc8935bde","modified":1751424097371},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1751424097329},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1751424097333},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1751424096904},{"_id":"node_modules/hexo-theme-anzhiyu/source/css/_highlight/highlight/index.styl","hash":"75b01603cacde3b58cc2719dce1f72458ecf3842","modified":1751424097370},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1751424096671},{"_id":"node_modules/hexo-theme-anzhiyu/source/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1751424096890},{"_id":"source/equipment/index.md","hash":"c35f21920d22e48321b18c648a2487a90f34f46e","modified":1754357526065},{"_id":"source/music/index.md","hash":"133ef41ce49770289c5bc2e9b1948fc323f8ab9e","modified":1754357526070},{"_id":"source/fcircle/index.md","hash":"0801fa37d30ad3fcdeed6ba18daf4e627a9954d6","modified":1754357526066},{"_id":"source/album/index.md","hash":"703f8de991f30a519d2b8825af7ba3a096ac6c97","modified":1754357526062},{"_id":"source/essay/index.md","hash":"d0e286de40f300396d2abc07ef9df62273148616","modified":1754357526066},{"_id":"source/_data/about.yml","hash":"098482496806c0b4ef5d78c8a553604269378149","modified":1751427529529},{"_id":"source/_data/album.yml","hash":"6802a1d8fbc1df5b33d5761dff22310445100cc2","modified":1751427671298},{"_id":"source/_data/essay.yml","hash":"6f5727d77fa76a286b7f3946d811d2169cbb32a5","modified":1751427744453},{"_id":"source/json/music.json","hash":"c1d46df151b6c4a006b31f9f73e83d80b651e97e","modified":1751427400025},{"_id":"source/_posts/mysql-suffix-matching-problem-vwtyk.md","hash":"00d0bedc7945b7655fc7f47c5edc12262583bd42","modified":1754358745511},{"_id":"source/_posts/custom-firmware-development-guide-for-fulldevice-simulation-z17aist.md","hash":"b6bd51c76ac0413bbe16715c381e721640bf5741","modified":1754358745515},{"_id":"node_modules/hexo-theme-matery/CHANGELOG.md","hash":"084ec8b110a20170d08a0aa5fd8accf601051835","modified":1754358577078},{"_id":"node_modules/hexo-theme-matery/README_CN.md","hash":"497c6645c55dce9f190ec7625de76083262e1707","modified":1754358577080},{"_id":"node_modules/hexo-theme-matery/_config.yml","hash":"204d1fc39c410562457f61ed5e561ae154baa239","modified":1754358577157},{"_id":"node_modules/hexo-theme-matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1754358576432},{"_id":"node_modules/hexo-theme-matery/package.json","hash":"5caee9883f52662309c63f1513c17e9ab4a8d036","modified":1754358577076},{"_id":"node_modules/hexo-theme-matery/README.md","hash":"9d98fe84a60bd6b222740f238d83f0999eaa77a3","modified":1754358577082},{"_id":"node_modules/hexo-theme-matery/layout/404.ejs","hash":"36f8d3e530e8144bf80d0772284edd9b0da362fe","modified":1754358576541},{"_id":"node_modules/hexo-theme-matery/languages/jp.yml","hash":"a811cec0b6d91f405e8c7386a57039cd8c3448bb","modified":1754358577161},{"_id":"node_modules/hexo-theme-matery/languages/zh-HK.yml","hash":"51c06005927e8bde5b3e23353d2bf2c32ed855f3","modified":1754358577164},{"_id":"node_modules/hexo-theme-matery/languages/default.yml","hash":"2ed57824573d7bed71e56023ed92500734a8886d","modified":1754358577160},{"_id":"node_modules/hexo-theme-matery/languages/zh-CN.yml","hash":"a2695fdb7579a77daec7773a9bb8e71b9edbf16b","modified":1754358577163},{"_id":"node_modules/hexo-theme-matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1754358576559},{"_id":"node_modules/hexo-theme-matery/layout/about.ejs","hash":"99a74316aed478efb0db823c4460ee2e660f101c","modified":1754358576543},{"_id":"node_modules/hexo-theme-matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1754358576563},{"_id":"node_modules/hexo-theme-matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1754358576545},{"_id":"node_modules/hexo-theme-matery/layout/bb.ejs","hash":"21959d702f17a3d98b716daf44c8b5eecd59c7c5","modified":1754358576553},{"_id":"node_modules/hexo-theme-matery/layout/galleries.ejs","hash":"85b8b9e583ffa7a4ee6d0c2be4779cb2f7d91777","modified":1754358576582},{"_id":"node_modules/hexo-theme-matery/layout/contact.ejs","hash":"71ef2540fa586cd0c3b1f216f59fa9ec85fc6a38","modified":1754358576570},{"_id":"node_modules/hexo-theme-matery/layout/friends.ejs","hash":"534511d9f38f281b531e24c19d9c1526cc7e5e27","modified":1754358576581},{"_id":"node_modules/hexo-theme-matery/layout/index.ejs","hash":"1656c2db90e24a360282d15c71144b4f14edb43d","modified":1754358576596},{"_id":"node_modules/hexo-theme-matery/layout/movies.ejs","hash":"abce85ffdd99e787e3652fbd466447e032b626bd","modified":1754358576603},{"_id":"node_modules/hexo-theme-matery/layout/gallery.ejs","hash":"fcc7364b03329148ba4920cddb0d34d5b7410788","modified":1754358576584},{"_id":"node_modules/hexo-theme-matery/layout/layout.ejs","hash":"94c2fee85418370ca8f7d54050c852267e924eb7","modified":1754358576598},{"_id":"node_modules/hexo-theme-matery/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1754358577094},{"_id":"node_modules/hexo-theme-matery/layout/post.ejs","hash":"3d4f40121dbb75bcb71837c35ec5ee17cdffae31","modified":1754358576627},{"_id":"node_modules/hexo-theme-matery/layout/musics.ejs","hash":"9ac6053e09ed2c8a844d7e93c3fdce4ded95248a","modified":1754358576607},{"_id":"node_modules/hexo-theme-matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1754358576658},{"_id":"node_modules/hexo-theme-matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1754358576656},{"_id":"node_modules/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1754358576549},{"_id":"node_modules/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1754358576552},{"_id":"node_modules/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1754358576551},{"_id":"node_modules/hexo-theme-matery/layout/_partial/background.ejs","hash":"12350c0d366141b5c27792bb414d4adc303b0a9f","modified":1754358576550},{"_id":"node_modules/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"9e6b10d5cf4b5faf0d851f4777f75a7297ce68b9","modified":1754358576555},{"_id":"node_modules/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1754358576556},{"_id":"node_modules/hexo-theme-matery/layout/_partial/bg-video.ejs","hash":"963422029eb5158eb5f5bc97ce19b66e5399db97","modified":1754358576557},{"_id":"node_modules/hexo-theme-matery/layout/_partial/cover-style.ejs","hash":"4288b9d91b2d71404e7a509a81a5d7f7a4b8b5e8","modified":1754358576572},{"_id":"node_modules/hexo-theme-matery/layout/_partial/codeblock.ejs","hash":"086a06863a0f88888707409936aa06a09ff50e3a","modified":1754358576568},{"_id":"node_modules/hexo-theme-matery/layout/_partial/footer.ejs","hash":"e8958bc066b3c2fcd4152604cc12f30020106848","modified":1754358576579},{"_id":"node_modules/hexo-theme-matery/layout/_partial/changyan.ejs","hash":"cd919d31564e118c2ee8d5cbfb7d51ee6da15d82","modified":1754358576566},{"_id":"node_modules/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1754358576576},{"_id":"node_modules/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1754358576586},{"_id":"node_modules/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1754358576589},{"_id":"node_modules/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1754358576585},{"_id":"node_modules/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1754358576587},{"_id":"node_modules/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"e8b44268b59add61af44b7338527523d10d9d742","modified":1754358576595},{"_id":"node_modules/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"52de0cf3ce13a3477b0a1659d2b8aa41db1f622d","modified":1754358576602},{"_id":"node_modules/hexo-theme-matery/layout/_partial/head.ejs","hash":"f5c00f21af281a09dc7de89e82a3b442903451a7","modified":1754358576591},{"_id":"node_modules/hexo-theme-matery/layout/_partial/main-style.ejs","hash":"8819b334509682355a5e53fa0f307f90166d175c","modified":1754358576601},{"_id":"node_modules/hexo-theme-matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1754358576593},{"_id":"node_modules/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1754358576619},{"_id":"node_modules/hexo-theme-matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1754358576614},{"_id":"node_modules/hexo-theme-matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1754358576599},{"_id":"node_modules/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"0953217f4e19a51dfc5a0ffc7d066406df18060b","modified":1754358576613},{"_id":"node_modules/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"6261f8191c3c1159f63ec7f9293bb93f7d2a3dbb","modified":1754358576623},{"_id":"node_modules/hexo-theme-matery/layout/_partial/post-style.ejs","hash":"243c3ba783553f25955d524fd47a5bb59a5e732b","modified":1754358576626},{"_id":"node_modules/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"70fccaea75ce48364222c4e5de0496e556b01cb1","modified":1754358576620},{"_id":"node_modules/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1754358576624},{"_id":"node_modules/hexo-theme-matery/layout/_partial/reward-style.ejs","hash":"8256ed940c0185ccf01890d59fb4262f196e2323","modified":1754358576633},{"_id":"node_modules/hexo-theme-matery/layout/_partial/reward.ejs","hash":"236668e72b01db91f5bf29eec4c79e34e2746d98","modified":1754358576635},{"_id":"node_modules/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1754358576628},{"_id":"node_modules/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1754358576632},{"_id":"node_modules/hexo-theme-matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1754358576637},{"_id":"node_modules/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1754358576560},{"_id":"node_modules/hexo-theme-matery/layout/_partial/search.ejs","hash":"150529c9fb9aa8ddb42ec3e02645d301faa2503b","modified":1754358576636},{"_id":"node_modules/hexo-theme-matery/layout/_partial/twikoo.ejs","hash":"f9cb8c82b9d2a7cdb644e10718f1cdeb9400414c","modified":1754358576660},{"_id":"node_modules/hexo-theme-matery/layout/_partial/valine.ejs","hash":"2ac48566bb806336f1e5bc5c66fc816a580d63c3","modified":1754358576662},{"_id":"node_modules/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1754358576650},{"_id":"node_modules/hexo-theme-matery/layout/_partial/waline.ejs","hash":"2658cb73ef984a30b248351d7858ee15596a6e7a","modified":1754358576665},{"_id":"node_modules/hexo-theme-matery/layout/_widget/artitalk.ejs","hash":"b14e486f12b9ac42a273b80e4d785fcb94cf04b2","modified":1754358576547},{"_id":"node_modules/hexo-theme-matery/layout/_widget/day-night.ejs","hash":"ff21dd5e49e1fc9a9ab8c7d164fd4b32a8265ea2","modified":1754358576573},{"_id":"node_modules/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1754358576562},{"_id":"node_modules/hexo-theme-matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1754358576578},{"_id":"node_modules/hexo-theme-matery/layout/_widget/musics.ejs","hash":"bfebdf0731fee0cd4fd51efa0da1d0184565ae25","modified":1754358576606},{"_id":"node_modules/hexo-theme-matery/layout/_widget/music.ejs","hash":"bb25a6fa51eb5ebfba687b2cbadff6c7a4b4bfef","modified":1754358576604},{"_id":"node_modules/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1754358576608},{"_id":"node_modules/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1754358576612},{"_id":"node_modules/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1754358576610},{"_id":"node_modules/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1754358576618},{"_id":"node_modules/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1754358576616},{"_id":"node_modules/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1754358576631},{"_id":"node_modules/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1754358576654},{"_id":"node_modules/hexo-theme-matery/layout/_widget/video.ejs","hash":"5e5ec78f8ab229d54786ef2e0ea2864af2dc459f","modified":1754358576663},{"_id":"node_modules/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1754358576652},{"_id":"node_modules/hexo-theme-matery/scripts/tags/index.js","hash":"223a31ea3aa4a689d45a033c7d680cb4fff8d8af","modified":1754358576927},{"_id":"node_modules/hexo-theme-matery/scripts/tags/button.js","hash":"ab02fb2da648f4f7afa0c2381aaca334bdeb54e6","modified":1754358576879},{"_id":"node_modules/hexo-theme-matery/scripts/tags/note.js","hash":"84b0122b92342834540f69b19600cb54c50ab69e","modified":1754358576996},{"_id":"node_modules/hexo-theme-matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1754358576499},{"_id":"node_modules/hexo-theme-matery/source/css/gallery.css","hash":"015097ca1271dd44e6d663332587dbe58ae2ade8","modified":1754358576487},{"_id":"node_modules/hexo-theme-matery/source/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1754358576478},{"_id":"node_modules/hexo-theme-matery/source/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1754358576525},{"_id":"node_modules/hexo-theme-matery/source/css/barrager.css","hash":"862879d9313ed8d4c721fa32ef8f94ac2f0a28ae","modified":1754358576476},{"_id":"node_modules/hexo-theme-matery/source/css/matery.css","hash":"413ad9731332810823b57dd0f4c0284e3af2af63","modified":1754358576521},{"_id":"node_modules/hexo-theme-matery/source/css/dark.css","hash":"be4ef08494f3c965d513d9413685c0e723f671cd","modified":1754358576481},{"_id":"node_modules/hexo-theme-matery/source/css/indexcover.css","hash":"00f4f498ae8514022004f2281cab8ff304cd0f37","modified":1754358576501},{"_id":"node_modules/hexo-theme-matery/source/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1754358576526},{"_id":"node_modules/hexo-theme-matery/source/css/post.css","hash":"1ebbf9ddee7db4b3039d8d4e25f2605072ab6e24","modified":1754358576528},{"_id":"node_modules/hexo-theme-matery/source/css/reward.css","hash":"56f8d21c3bb1dc57c762a63d13b08161d8260738","modified":1754358576534},{"_id":"node_modules/hexo-theme-matery/source/js/gallery-encrypt.js","hash":"f611a391d62da17b71f75577a72ad246ef6c5a71","modified":1754358576917},{"_id":"node_modules/hexo-theme-matery/source/js/jquery.barrager.js","hash":"19c8b2498ca1083e537f7f443172970912107f83","modified":1754358576938},{"_id":"node_modules/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1754358577092},{"_id":"node_modules/hexo-theme-matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1754358576854},{"_id":"node_modules/hexo-theme-matery/source/js/tw_cn.js","hash":"29157cdfa87aec28e56d3d5717d486bf4de07db6","modified":1754358577045},{"_id":"node_modules/hexo-theme-matery/source/js/matery.js","hash":"aa957ea8cf6787f0ed6095fedc6cb9d7d1bf3522","modified":1754358576958},{"_id":"node_modules/hexo-theme-matery/source/js/search.js","hash":"5caa2d6e3d34c334ac68dfaafc81a583d6123382","modified":1754358577034},{"_id":"node_modules/hexo-theme-matery/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1754358577097},{"_id":"node_modules/hexo-theme-matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1754358577096},{"_id":"node_modules/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1754358576467},{"_id":"node_modules/hexo-theme-matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1754358576470},{"_id":"node_modules/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1754358576885},{"_id":"node_modules/hexo-theme-matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1754358576860},{"_id":"node_modules/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1754358576888},{"_id":"node_modules/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1754358576473},{"_id":"node_modules/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1754358576887},{"_id":"node_modules/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1754358576864},{"_id":"node_modules/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1754358576889},{"_id":"node_modules/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1754358577003},{"_id":"node_modules/hexo-theme-matery/source/libs/aplayer/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1754358576991},{"_id":"node_modules/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1754358576882},{"_id":"node_modules/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1754358576486},{"_id":"node_modules/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1754358577005},{"_id":"node_modules/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1754358577006},{"_id":"node_modules/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1754358576900},{"_id":"node_modules/hexo-theme-matery/source/libs/fancybox/jquery.fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1754358576506},{"_id":"node_modules/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1754358576930},{"_id":"node_modules/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1754358576496},{"_id":"node_modules/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1754358576492},{"_id":"node_modules/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1754358576932},{"_id":"node_modules/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1754358576503},{"_id":"node_modules/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.css","hash":"b9323091d50785ad6c617d7cae76a41a89eb44b3","modified":1754358576508},{"_id":"node_modules/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"d20252cf76c3be8af37a8415d13ad368c762b4d8","modified":1754358576951},{"_id":"node_modules/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.js","hash":"6f5433cc9f19ce2403e903e5d01a4c7b38f0969b","modified":1754358576943},{"_id":"node_modules/hexo-theme-matery/source/libs/mermaid/mermaid.min.css","hash":"1dbcd9312e57f2a0b569451d0028d88316614481","modified":1754358576523},{"_id":"node_modules/hexo-theme-matery/source/libs/others/TencentCaptcha.js","hash":"fb4d34c48567b7b992aac1c75f0d24c3eb2cc3fa","modified":1754358577042},{"_id":"node_modules/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1754358576877},{"_id":"node_modules/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1754358576883},{"_id":"node_modules/hexo-theme-matery/source/libs/others/sakura-half.js","hash":"a41b64af88fdd0e2d3502752d059661c1bc743dc","modified":1754358577009},{"_id":"node_modules/hexo-theme-matery/source/libs/minivaline/MiniValine.js","hash":"f7f6cdc1b22297e02334e304444e9a8351acb455","modified":1754358576994},{"_id":"node_modules/hexo-theme-matery/source/libs/prism/prism.min.css","hash":"ed3896649670cf142e514685da2b060cca5fd43a","modified":1754358576532},{"_id":"node_modules/hexo-theme-matery/source/libs/others/sakura-reduce.js","hash":"f7527e9fb4e6fe2cc7c8880692d77bcda95900c7","modified":1754358577012},{"_id":"node_modules/hexo-theme-matery/source/libs/others/sakura.js","hash":"b6ebe8f040c84f067300996a5f377846f01605fa","modified":1754358577027},{"_id":"node_modules/hexo-theme-matery/source/libs/others/snow.js","hash":"02b1eeaca737c47be637b304feb3d36d792ee0c4","modified":1754358577036},{"_id":"node_modules/hexo-theme-matery/source/libs/others/sakura-small.js","hash":"3284a9ab71454e574d80663f3a05735cd12a6a05","modified":1754358577015},{"_id":"node_modules/hexo-theme-matery/source/libs/others/star.js","hash":"cf32f8ce2a1a51ba65d3b6063fe2ee1482550190","modified":1754358577040},{"_id":"node_modules/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1754358577032},{"_id":"node_modules/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"39055053a477e7d54b46cfb46591f84cc3818eeb","modified":1754358577043},{"_id":"node_modules/hexo-theme-matery/source/libs/typed/typed.js","hash":"eaf2798298790ec3fad17f6c68b5d3b02dfd069c","modified":1754358577063},{"_id":"node_modules/hexo-theme-matery/source/libs/twikoo/twikoo.all.min.js.LICENSE.txt","hash":"1e286a31ef472fb864fe2b9502e87df9242df56b","modified":1754358577136},{"_id":"node_modules/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1754358576539},{"_id":"node_modules/hexo-theme-matery/source/medias/barrager/0.png","hash":"b30416fd3b3aec5af3fa90823a7e2e9c0af4cda8","modified":1754358577084},{"_id":"node_modules/hexo-theme-matery/source/medias/barrager/1.png","hash":"b8c211690dba3addedfe7b928e3936cd487df0d6","modified":1754358577087},{"_id":"node_modules/hexo-theme-matery/source/medias/barrager/close.png","hash":"045346df61ee01abe5018c5d9ba805d2831ce7b1","modified":1754358577090},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1754358576731},{"_id":"node_modules/hexo-theme-matery/source/medias/barrager/2.png","hash":"52b2b13373fe611ad2327b9b40426d6dc05b69cd","modified":1754358577088},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1754358576745},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1754358576753},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1754358576757},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1754358576794},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1754358576781},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1754358576799},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1754358576807},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1754358576790},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1754358576828},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1754358576841},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1754358576845},{"_id":"node_modules/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1754358576852},{"_id":"node_modules/hexo-theme-matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1754358577103},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f7a09bcbd996fd634045d4e79b6504c945730686","modified":1754358577147},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"9b26d745a1e69b23d71b7ea36d5de1209c997901","modified":1754358577119},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-v4compatibility.woff2","hash":"37ab2a6a0810d5a6c10a355fe1d7af0042bd6a2a","modified":1754358577155},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-v4compatibility.ttf","hash":"3fc15c8154f8bd2d7bd1dfe55ae5ab1c33e5e40f","modified":1754358577132},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"509c56c80732a1cd80df8f2b4b0ac1128c31999f","modified":1754358577110},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"7873d80020ae04955bb57521bd249a6974d1180f","modified":1754358576512},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"49693fa946534a56d7e5d4274e1ce55b05d782c3","modified":1754358577134},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"04f09ad797ced119d6608909d06e500f16a03bbb","modified":1754358577139},{"_id":"node_modules/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1754358576537},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1754358576671},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"aab2633f69581c2e26e22a23712f1501d7fcec18","modified":1754358576948},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1754358577099},{"_id":"node_modules/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1754358576669},{"_id":"node_modules/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1754358576941},{"_id":"node_modules/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1754358577106},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1754358577101},{"_id":"node_modules/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1754358577105},{"_id":"node_modules/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1754358577038},{"_id":"node_modules/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1754358577137},{"_id":"node_modules/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1754358577133},{"_id":"node_modules/hexo-theme-matery/source/libs/fancybox/fancybox.js","hash":"eef46b6fb2e460838cd7328a6e13ecda0cb1e194","modified":1754358576915},{"_id":"node_modules/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1754358576926},{"_id":"node_modules/hexo-theme-matery/source/libs/jquery/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1754358576936},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1754358576679},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1754358576804},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1754358576778},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1754358576728},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1754358576686},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1754358576736},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1754358576750},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1754358576741},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1754358576766},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1754358576770},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1754358576762},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1754358576786},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1754358576837},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1754358576819},{"_id":"node_modules/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1754358576848},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/css/all.min.css","hash":"0ae47fa834fb55de7b50c79021aeabecfae50c9c","modified":1754358576462},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"e219af1e3bbc2219359d3d0916e263b279c4abfd","modified":1754358577144},{"_id":"node_modules/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1754358576859},{"_id":"node_modules/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"490148a22ab2b03a880495cc733ecd1840c02ed6","modified":1754358576904},{"_id":"node_modules/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"d1328a7872827bc63e7cc4d33745397681accda8","modified":1754358576518},{"_id":"node_modules/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"8eee32acbfac59744b4053a7290f503ef623d3ab","modified":1754358576956},{"_id":"node_modules/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1754358577069},{"_id":"node_modules/hexo-theme-matery/source/libs/waline/Waline.min.js","hash":"94f70e622e2a1ab05adb205033a9ddf371c61534","modified":1754358577075},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1754358576722},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1754358576825},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1754358576833},{"_id":"node_modules/hexo-theme-matery/source/medias/images/02.jpg","hash":"a5b656606811f4d7e10307f48c0e3c373e0b886d","modified":1754358576703},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"8d63fa8b0f60a50b07ac0f7e751f6f5e02ecdc44","modified":1754358576443},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"fa5745d421c0fc90928626be98e9f8cf7580b327","modified":1754358577117},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"1979128e8ba1517d85f5e4ee505abf486c51557c","modified":1754358577152},{"_id":"node_modules/hexo-theme-matery/source/js/crypto-js.js","hash":"ddacd177f23f65ff97b93b0417048f51928ee17e","modified":1754358576895},{"_id":"node_modules/hexo-theme-matery/source/libs/valine/av-min.js","hash":"db56ef6acb789da00d39bd6b97c1b09c2d429195","modified":1754358576874},{"_id":"node_modules/hexo-theme-matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1754358576815},{"_id":"node_modules/hexo-theme-matery/source/medias/images/03.jpg","hash":"2bd3815508a9f5b0ae79aa780bc02ac80b2a354e","modified":1754358576714},{"_id":"node_modules/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"e3339400ef6214cfa077d003daed2bfa659e2956","modified":1754358577130},{"_id":"node_modules/hexo-theme-matery/source/libs/twikoo/twikoo.all.min.js","hash":"c3f5f0a69b7864e7ef5bbf99fc774bec37947d7c","modified":1754358577060},{"_id":"node_modules/hexo-theme-matery/source/libs/prism/prism.min.js","hash":"6fc9b7be93e51b4017a61483c13187af0149f194","modified":1754358577001},{"_id":"node_modules/hexo-theme-matery/source/medias/images/01.jpg","hash":"6a81f437fb876666bafaa98b2a09bd8bd7f21832","modified":1754358576694},{"_id":"node_modules/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1754358576912},{"_id":"node_modules/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1754358576922},{"_id":"node_modules/hexo-theme-matery/source/libs/mermaid/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1754358576989},{"_id":"node_modules/hexo-theme-matery/source/libs/mermaid/mermaid.js","hash":"a7933bef8aba190825ba7716497209187ac1de5d","modified":1754358576980},{"_id":"themes/matery/CHANGELOG.md","hash":"084ec8b110a20170d08a0aa5fd8accf601051835","modified":1606456707000},{"_id":"themes/matery/README.md","hash":"0366f3d50b18d095b0581e7b5974e3283d693884","modified":1606456707000},{"_id":"themes/matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1606456707000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1606456707000},{"_id":"themes/matery/_config.yml","hash":"056cf5f020e9a240522808b6872897f6dcee79fa","modified":1606456707000},{"_id":"themes/matery/README_CN.md","hash":"089de96e2165ea2a8a3adf38ebda85b65e7f716e","modified":1606456707000},{"_id":"themes/matery/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1606456707000},{"_id":"themes/matery/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1606456707000},{"_id":"themes/matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1606456707000},{"_id":"themes/matery/layout/404.ejs","hash":"9c8ca67377211e5d60fdde272a975faa9a91a22a","modified":1606456707000},{"_id":"themes/matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1606456707000},{"_id":"themes/matery/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1606456707000},{"_id":"themes/matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1606456707000},{"_id":"themes/matery/layout/bb.ejs","hash":"21959d702f17a3d98b716daf44c8b5eecd59c7c5","modified":1606456707000},{"_id":"themes/matery/layout/index.ejs","hash":"4dc6f08e7709cc04e886be72dbf0d06469f0effc","modified":1606456707000},{"_id":"themes/matery/layout/contact.ejs","hash":"19d62e521c4253496db559478db5164ddfd2480e","modified":1606456707000},{"_id":"themes/matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1606456707000},{"_id":"themes/matery/layout/about.ejs","hash":"41849f9300b8dc47048333fcf4a897dd8a2a13ca","modified":1606456707000},{"_id":"themes/matery/layout/friends.ejs","hash":"92892bab5578ccf758ce57e19fca08be80d0d5b9","modified":1606456707000},{"_id":"themes/matery/layout/layout.ejs","hash":"974b44eb3e343cd3ee57ebad34bbb0eff4184400","modified":1606456707000},{"_id":"themes/matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1606456707000},{"_id":"themes/matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1606456707000},{"_id":"themes/matery/source/js/search.js","hash":"e1482406c58ea2a0eb178d7e4efb2c879cdddc80","modified":1606456707000},{"_id":"themes/matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1606456707000},{"_id":"themes/matery/layout/post.ejs","hash":"90b5a4c1f70e4756db569c15a7c6cad0c77c4500","modified":1606456707000},{"_id":"themes/matery/source/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1606456707000},{"_id":"themes/matery/source/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1606456707000},{"_id":"themes/matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1606456707000},{"_id":"themes/matery/source/css/matery.css","hash":"a630f6e8643904073dce9eada57b5c16c4dba5e2","modified":1606456707000},{"_id":"themes/matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1606456707000},{"_id":"themes/matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1606456707000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1606456707000},{"_id":"themes/matery/source/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1606456707000},{"_id":"themes/matery/source/medias/contact.png","hash":"443ea472dd49b74d9d70295837eb381c8c64f02c","modified":1606456707000},{"_id":"themes/matery/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1606456707000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1606456707000},{"_id":"themes/matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1606456707000},{"_id":"themes/matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1606456707000},{"_id":"themes/matery/layout/_partial/background.ejs","hash":"aef6edeeb11209831a11d8c7f5d59992e2573335","modified":1606456707000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1606456707000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1606456707000},{"_id":"themes/matery/layout/_partial/changyan.ejs","hash":"cd919d31564e118c2ee8d5cbfb7d51ee6da15d82","modified":1606456707000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"28617bf2a35a4269eba6df466acd174e416d2d1e","modified":1606456707000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"3be24e4c370671eda53bdfd99fb748f4a22948ba","modified":1606456707000},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1606456707000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1606456707000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1606456707000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"76b4a37e0364380b143fdf94bf1a5e6941564414","modified":1606456707000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1606456707000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1606456707000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"f8438ac80df005934a330b029de292d26f0b6ecb","modified":1606456707000},{"_id":"themes/matery/layout/_partial/minivaline.ejs","hash":"5f09386aece8f9cf31f6059bbde79cd6c5171493","modified":1606456707000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"78b70ff24b3039c871331ebec114b936c1756cc8","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1606456707000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1606456707000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1606456707000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"3ff94aff01936242a9f4e1f31adb9b43bfab8d53","modified":1606456707000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"cb0cb452be1cd1857ba600f04025b506f3b6fc79","modified":1606456707000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"880ebaf78a947631a38ad0b3d65201315845a264","modified":1606456707000},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"ffc55bc7e73bc698bfc58d8e3780c336b83282cf","modified":1606456707000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"150529c9fb9aa8ddb42ec3e02645d301faa2503b","modified":1606456707000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1606456707000},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1606456707000},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1606456707000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"0e4c0a6154aa34007849928ca88f05b6185b256e","modified":1606456707000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1606456707000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1606456707000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1606456707000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1606456707000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1606456707000},{"_id":"themes/matery/layout/_widget/artitalk.ejs","hash":"b14e486f12b9ac42a273b80e4d785fcb94cf04b2","modified":1606456707000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1606456707000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1606456707000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1606456707000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1606456707000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"e9e3e327d5de9d7aeadbde32e1d558652d9e9195","modified":1606456707000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1606456707000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1606456707000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"a0e002377af2a7f7e4da6d9a644de97adb035925","modified":1606456707000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1606456707000},{"_id":"themes/matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1606456707000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1606456707000},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1606456707000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1606456707000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1606456707000},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1606456707000},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1606456707000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1606456707000},{"_id":"themes/matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1606456707000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1606456707000},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1606456707000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1606456707000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1606456707000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1606456707000},{"_id":"themes/matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1606456707000},{"_id":"themes/matery/source/libs/minivaline/MiniValine.js","hash":"fbb58c37e2c74f127ae0c566afa9b48889aab79f","modified":1606456707000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1606456707000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1606456707000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1606456707000},{"_id":"themes/matery/source/libs/prism/prism.css","hash":"62e5474893dece076534352f564ceabd6e088a5a","modified":1606456707000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1606456707000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1606456707000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1606456707000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1606456707000},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1606456707000},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"9c6632aeec67d3e84a1434884aa801514ff8103b","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1606456707000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1606456707000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1606456707000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1606456707000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1606456707000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1606456707000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1606456707000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1606456707000},{"_id":"themes/matery/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1606456707000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1606456707000},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1606456707000},{"_id":"themes/matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1606456707000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1606456707000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1606456707000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1606456707000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1606456707000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1606456707000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1606456707000},{"_id":"themes/matery/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1606456707000}],"Category":[{"name":"事务管理","_id":"cmclcaf3l0004p8vwe8fc96bf"},{"name":"系统休眠","_id":"cmclcaf3t000cp8vw4m753liv"},{"name":"java","_id":"cmclcaf3x000gp8vw9hhb9w60"},{"name":"异步操作","parent":"cmclcaf3l0004p8vwe8fc96bf","_id":"cmclcaf42000lp8vw82x80qgg"},{"name":" 配置指南","_id":"cmclcaf47000pp8vw45ua4oq9"},{"name":"网络配置","_id":"cmclcaf4b000up8vw3evcbhe2"},{"name":"部署指南","_id":"cmclcaf4f0010p8vwgds8goru"},{"name":"工具类","parent":"cmclcaf3x000gp8vw9hhb9w60","_id":"cmclcaf4j0016p8vwhlzq97vh"},{"name":"服务器","_id":"cmclcaf4k0019p8vw1mjq0r4n"},{"name":"前端开发","_id":"cmclcaf4l001cp8vw0oi9dtez"},{"name":"Spring框架","parent":"cmclcaf42000lp8vw82x80qgg","_id":"cmclcaf4m001hp8vw4zmn06oz"},{"name":"Docker","_id":"cmclcaf4n001lp8vwczvtavvq"},{"name":"Spring","_id":"cmclcaf4o001op8vw6kz3ceiu"},{"name":"RTSP服务","parent":"cmclcaf47000pp8vw45ua4oq9","_id":"cmclcaf4p001sp8vw5wj27mja"},{"name":"Linux系统","_id":"cmclcaf4r001up8vwetb45loh"},{"name":"性能监控","parent":"cmclcaf4b000up8vw3evcbhe2","_id":"cmclcaf4r001yp8vw3sw54rfz"},{"name":"mybatis","_id":"cmclcaf4t0022p8vw1r9y8zxt"},{"name":"Java","_id":"cmclcaf4t0025p8vwdsu2hj2q"},{"name":"安装教程","parent":"cmclcaf4f0010p8vwgds8goru","_id":"cmclcaf4u0028p8vw4m845q3e"},{"name":"linux","_id":"cmclcaf4u002ap8vw1maqdkb8"},{"name":"网络配置","parent":"cmclcaf4k0019p8vw1mjq0r4n","_id":"cmclcaf4y002fp8vw2lxua9u6"},{"name":"组件设计","parent":"cmclcaf4l001cp8vw0oi9dtez","_id":"cmclcaf4z002kp8vw81pbcl2o"},{"name":"笔记软件","parent":"cmclcaf4n001lp8vwczvtavvq","_id":"cmclcaf4z002np8vwhiag7ml3"},{"name":"Java","parent":"cmclcaf4o001op8vw6kz3ceiu","_id":"cmclcaf50002pp8vw5kck6w5v"},{"name":"Nginx安装","parent":"cmclcaf4p001sp8vw5wj27mja","_id":"cmclcaf50002rp8vw1ioz0m7x"},{"name":"磁盘测试","parent":"cmclcaf4r001up8vwetb45loh","_id":"cmclcaf53002vp8vwds5680rc"},{"name":"负载均衡","parent":"cmclcaf4r001yp8vw3sw54rfz","_id":"cmclcaf540030p8vwdrlaftqd"},{"name":"Redis","parent":"cmclcaf4t0025p8vwdsu2hj2q","_id":"cmclcaf550035p8vwhv2ogb04"},{"name":"配置管理","parent":"cmclcaf4u0028p8vw4m845q3e","_id":"cmclcaf550039p8vw1ew53cbf"},{"name":"WebDAV","parent":"cmclcaf4y002fp8vw2lxua9u6","_id":"cmclcaf56003dp8vw84b1bu2m"},{"name":"代码示例","parent":"cmclcaf4z002kp8vw81pbcl2o","_id":"cmclcaf58003jp8vw0hbod8ah"},{"name":"开源","parent":"cmclcaf4z002np8vwhiag7ml3","_id":"cmclcaf59003qp8vwg0ywbl5x"},{"name":"Maven","parent":"cmclcaf50002pp8vw5kck6w5v","_id":"cmclcaf5a003up8vwh13qgpjd"},{"name":"消息队列","parent":"cmclcaf550035p8vwhv2ogb04","_id":"cmclcaf5b003yp8vw6ip5aqvi"},{"name":"数据库","_id":"cmdxvwf0y00010wsd7s5c6js6"},{"name":"性能优化","parent":"cmdxvwf0y00010wsd7s5c6js6","_id":"cmdxvwf1400050wsdeci2fiuj"},{"name":"硬件开发","_id":"cmdxvwf1700070wsd8zml77ed"},{"name":"MySQL","parent":"cmdxvwf1400050wsdeci2fiuj","_id":"cmdxvwf1900090wsdgies1mvd"},{"name":"FPGA","parent":"cmdxvwf1700070wsd8zml77ed","_id":"cmdxvwf1b000b0wsd5xuz6b71"},{"name":"固件","parent":"cmdxvwf1b000b0wsd5xuz6b71","_id":"cmdxvwf1e000h0wsd4xtra0ac"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"网站","class_desc":"值得推荐的网站","link_list":[{"name":"IT Tools","link":"https://ittools.top/","avatar":"https://ittools.top/android-chrome-192x192.png","descr":"开发人员工具网站"},{"name":"Linux命令","link":"https://linux.forz.fun/","avatar":"https://linux.forz.fun/img/favicon.ico","descr":"Linux命令手册"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]},{"_id":"about","data":[{"class_name":"关于页","subtitle":"生活明朗，万物可爱✨","avatarImg":"https://npm.elemecdn.com/anzhiyu-blog-static@1.0.0/img/avatar.webp","avatarSkills":{"left":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙"],"right":["专修交互与设计 🤝","脚踏实地行动派 🏃","团队小组发动机 🧱","壮汉人狠话不多 💢"]},"name":"陈志伟","description":"是一名 前端工程师、学生、独立开发者、博主","aboutsiteTips":{"tips":"追求","title1":"源于","title2":"热爱而去 感受","word":["学习","生活","程序","体验"]},"helloAbout":"Hello there!","skillsTips":{"tips":"技能","title":"开启创造力"},"careers":{"tips":"生涯","title":"无限进步","list":[{"desc":"EDU,软件工程专业","color":"#357ef5"},{"desc":"EDU,软件工程专业","color":"#357ef5"},{"desc":"EDU,软件工程专业","color":"#357ef5"}],"img":"https://bu.dusays.com/2023/04/21/644287166329b.png"},"statistic":{"link":"/archives","text":"文章隧道","cover":"https://bu.dusays.com/2023/05/01/644f4b037b930.jpg"},"map":{"title":"我现在住在","StrengthenTitle":"中国，长沙市","background":"https://bu.dusays.com/2023/07/05/64a4c61cb20ef.jpg","backgroundDark":"https://bu.dusays.com/2023/07/05/64a4c63495ac5.jpg"},"selfInfo":{"selfInfoTips1":"生于","selfInfoContentYear":2002,"selfInfoTips2":"湖南信息学院","selfInfoContent2":"软件工程","selfInfoTips3":"现在职业","selfInfoContent3":"大三学生👨‍🎓"},"personalities":{"author_name":"执政官","personality_type":"ESFJ-A","photo_url":"https://bu.dusays.com/2023/07/05/64a4c63495ac5.jpg","personality_img":"https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/ESFJ-A.svg","name_url":"https://www.16personalities.com/ch/esfj-%E4%BA%BA%E6%A0%BC"},"maxim":{"maxim_tips":"座右铭","maxim_top":"生活明朗，","maxim_bottom":"万物可爱。"},"buff":{"buff_tips":"特长","buff_top":"脑回路新奇的 酸菜鱼","buff_bottom":"二次元指数 MAX"},"game":{"game_tips":"爱好游戏","game_title":"原神","game_uid":"UID: 125766904","game_bg":"https://bu.dusays.com/2023/04/22/64433bf26e25d.webp"},"comic":{"comic_tips":"爱好番剧","comic_title":"追番","comic_list":[{"name":"约定的梦幻岛","href":"https://www.bilibili.com/bangumi/media/md5267750/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/27/647166c44b414.webp"},{"name":"咒术回战","href":"https://www.bilibili.com/bangumi/media/md28229899/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/24/646db4398832e.webp"},{"name":"紫罗兰永恒花园","href":"https://www.bilibili.com/bangumi/media/md8892/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/24/646db43983d99.webp"},{"name":"鬼灭之刃","href":"https://www.bilibili.com/bangumi/media/md22718131/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/24/646db439856a0.webp"},{"name":"JOJO的奇妙冒险 黄金之风","href":"https://www.bilibili.com/bangumi/media/md135652/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1","cover":"https://bu.dusays.com/2023/05/30/64760e38d651a.webp"}]},"like":{"like_tips":"关注偏好","like_title":"数码科技","like_bg":"https://bu.dusays.com/2022/12/06/638f5f05ce1f7.jpg","like_bottom":"手机、电脑软硬件"},"music":{"music_tips":"音乐偏好","music_title":"许嵩、民谣、华语流行","music_bg":"https://p2.music.126.net/Mrg1i7DwcwjWBvQPIMt_Mg==/79164837213438.jpg","music_link":"/music"},"reward_list":[{"name":"海阔蓝","amount":8.8,"datatime":"2023-03-28T00:00:00.000Z"},{"name":"LK66","amount":66.6,"datatime":"2023-03-24T00:00:00.000Z"},{"name":"张时貳","amount":6.6,"datatime":"2023-01-22T00:00:00.000Z"},{"name":"ZeroAf","amount":9.9,"datatime":"2022-12-14T00:00:00.000Z"},{"name":"LuckyWangXi","amount":6.6,"datatime":"2022-12-14T00:00:00.000Z"},{"name":"刀中日月长","amount":10,"datatime":"2022-11-16T00:00:00.000Z"},{"name":"鹿啵包","amount":10,"datatime":"2022-11-08T00:00:00.000Z"},{"name":"疾速k","amount":50,"datatime":"2022-09-20T00:00:00.000Z"},{"name":"伴舟先生大霖子","amount":4.03,"datatime":"2022-10-27T00:00:00.000Z","suffix":"贝壳"},{"name":"Magica_0x0","amount":3.36,"datatime":"2022-10-07T00:00:00.000Z","suffix":"贝壳"},{"name":"名字就是要短像这样","amount":3.36,"datatime":"2022-08-25T00:00:00.000Z","suffix":"贝壳"},{"name":"Leviathan520","amount":1.34,"datatime":"2022-08-23T00:00:00.000Z","suffix":"贝壳"},{"name":"托马斯","amount":10,"datatime":"2022-08-19T00:00:00.000Z"},{"name":"哇是猫猫欸","amount":1.34,"datatime":"2022-08-19T00:00:00.000Z","suffix":"贝壳"}]}]},{"_id":"album","data":[{"class_name":"世界各地夕阳与风景","path_name":"/wordScenery","type":2,"description":"因为到不了世界各地，所以请网友们发来了各地的夕阳与风景🌇。","cover":"https://upload-bbs.miyoushe.com/upload/2025/06/13/125766904/2cf2b6aea07bba089d0d17c4fea72d1b_5366629137934368264.png","top_background":"https://bu.dusays.com/2023/06/30/649e546ada7dd.webp","rowHeight":220,"limit":10,"lazyload":true,"btnLazyload":false,"url":false,"top_link":"/album","top_btn_text":"返回","album_list":[{"date":"2022/10/26 01:00:00","content":"湘潭的一角。","address":"湖南湘潭","from":"再吃一口就减肥","image":["https://bu.dusays.com/2023/04/09/64329399db122.webp"]},{"date":"2022-10-25T00:00:00.000Z","content":"洛阳暴雨后的天空。","address":"河南洛阳","from":"紫菜卷","image":["https://bu.dusays.com/2023/04/09/64329399db122.webp","https://bu.dusays.com/2023/04/09/64329399db2e1.webp"]}]},{"class_name":"我的日常","path_name":"/dailyPhoto","type":1,"description":"这里存放的是有关我自己的一些沙雕生活与有趣的事情。","top_link":"/album","top_btn_text":"返回","top_background":"https://bu.dusays.com/2023/04/09/64329399cea5a.webp","cover":"https://bu.dusays.com/2023/04/09/64329399cea5a.webp","album_list":[{"date":"2022-10-24T00:00:00.000Z","content":"老妹的画","image":["https://bu.dusays.com/2023/04/09/643293997b92b.jpeg"]}]}]},{"_id":"essay","data":[{"title":"即刻短文","subTitle":"咸鱼的日常生活。","tips":"随时随地，分享生活","buttonText":"关于我","buttonLink":"/about/","limit":30,"home_essay":true,"top_background":"https://img02.anheyu.com/adminuploads/1/2022/08/21/630249e2df20f.jpg","essay_list":[{"content":"安知鱼主题指南","date":"2023/09/09","video":["https://player.bilibili.com/player.html?aid=226886152&bvid=BV1Ch41137tR&cid=1081639816&p=1&autoplay=0"]},{"content":"支持了Accesskey快捷键，可以直接按下shift + ?组合键以查看快捷键选项。","date":"2023/07/01","video":["https://cdn.jsdelivr.net/npm/anzhiyu-blog-static@1.0.0/video/%E9%A3%8E%E8%BD%A6%E6%A0%B7%E5%BC%8F%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88.mp4"],"image":["https://img02.anheyu.com/adminuploads/1/2023/07/01/64a033cb2c21e.webp!blogimg"],"address":"长沙","from":"安知鱼","link":"/posts/e140.html"},{"content":"音乐支持了参数设置自定义歌单","date":"2023/01/02","link":"https://blog.anheyu.com/music/?id=7269231710&server=tencent"},{"content":"关于页的打赏仿了b站的充电功能，使用svg绘图➕一些动画参数移动，应该不会被b站警告吧😜，另外文章也支持了顶部随机b站同款春秋冬banner。","date":"2022/12/18"},{"content":"React中不能直接修改state的一个重要原因是在性能优化时的prueComponment会进行浅层比较会认为是用一个对象且不能进入队列中批量更新","date":"2022/12/10"},{"content":"好耶，马上就可以放假回家了！好想家里的好吃的😋！才不是想捏妹妹的脸了","date":"2022/12/06"},{"content":"全局音乐的动画也处理好了, nice!","date":"2022/11/13"},{"content":"把页脚, 首页顶部全都魔改到本地了, 方便后续魔改, 音乐也改成胶囊的样式了, 其实还是想让胶囊可拖拽, 不可点击改变歌词位置的, 但是弄了半天都没弄好就放弃了","date":"2022/11/13"},{"content":"朋友圈船新版本终于写完了, 耶✌️","date":"2022/11/05","link":"https://blog.anheyu.com/album/"},{"content":"终于把相册集搞定了, 耶✌️, 瀑布流在滑动滚动条一个视口范围上下100的情况执行一次, 到底部停止监听让性能高了好多，再也不会布局混乱🤪了","date":"2022/10/25","link":"https://blog.anheyu.com/album/"},{"content":"搜索🔍支持缩略图显示啦（默认获取文章内容的第一张图片）","date":"2022/10/23 08:00:00","from":"安知鱼"},{"content":"遇见彩虹🌈吃定彩虹","date":"2022/10/23 10:00:00","image":["https://bu.dusays.com/2023/04/09/64329399e285d.webp","https://bu.dusays.com/2023/04/09/64329399aa3bc.webp","https://bu.dusays.com/2023/04/09/6432939996dd7.webp"]},{"content":"ThreeJs API真多丫","date":"2022/10/19"},{"content":"妹妹强制要求我买走了她的两幅画 -¥30","date":"2022/10/02","image":["https://bu.dusays.com/2023/04/09/643293997b92b.jpeg"]},{"content":"歌曲推荐","date":"2022/09/25","aplayer":{"server":"tencent","id":"001FGQba3i10mw"}},{"content":"做了一个噩梦, 梦到从楼顶坠下去了。😷","date":"2022/09/24"},{"content":"JOJO是真的好看！","date":"2022/09/21","link":"https://www.bilibili.com/bangumi/play/ss39431?spm_id_from=333.337.0.0"}]}]}],"Page":[{"title":"关于","date":"2021-03-30T07:57:51.000Z","aside":false,"top_img":false,"background":"#f8f9fe","comments":0,"type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-03-30 15:57:51\naside: false\ntop_img: false\nbackground: \"#f8f9fe\"\ncomments: false\ntype: \"about\"\n---","updated":"2025-07-02T03:38:17.635Z","path":"about/index.html","_id":"cmclcaf380000p8vw1v9cazbk","layout":"page","content":"","cover":false,"excerpt":"","more":""},{"title":"分类","date":"2024-09-15T16:21:37.000Z","aside":false,"top_img":false,"type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2024-09-16 00:21:37\naside: false\ntop_img: false\ntype: \"categories\"\n---\n","updated":"2025-07-01T06:36:34.278Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cmclcaf3i0002p8vw9vbi0p5v","content":"","cover":false,"excerpt":"","more":""},{"title":"友情链接","date":"2024-09-15T16:22:14.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2024-09-16 00:22:14\ntype: \"link\"\n---\n","updated":"2025-07-01T06:19:35.705Z","path":"link/index.html","comments":1,"layout":"page","_id":"cmclcaf3o0006p8vw9vf36udo","content":"","cover":false,"excerpt":"","more":""},{"title":"archives","date":"2024-09-15T16:41:00.000Z","type":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2024-09-16 00:41:00\ntype: archives\n---\n","updated":"2025-07-01T06:19:35.704Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cmclcaf3q0008p8vwftlqf7qf","content":"","cover":false,"excerpt":"","more":""},{"title":"标签","date":"2024-09-15T16:21:00.000Z","type":"tags","comments":0,"top_img":false,"orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-09-16 00:21:00\ntype: \"tags\"\ncomments: false\ntop_img: false\norderby: random\norder: 1\n---\n","updated":"2025-07-01T06:36:54.888Z","path":"tags/index.html","layout":"page","_id":"cmclcaf3s000ap8vwhf7ug253","content":"","cover":false,"excerpt":"","more":""},{"title":"equipment","date":"2025-07-02T03:33:09.000Z","_content":"","source":"equipment/index.md","raw":"---\ntitle: equipment\ndate: 2025-07-02 11:33:09\n---\n","updated":"2025-08-05T01:32:06.065Z","path":"equipment/index.html","_id":"cmclej09e000058vwaai7g6hm","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"音乐馆","date":"2021-04-24T13:41:30.000Z","type":"music","aplayer":true,"top_img":false,"comments":0,"aside":false,"_content":"","source":"music/index.md","raw":"---\ntitle: 音乐馆\ndate: 2021-04-24 21:41:30\ntype: music\naplayer: true\ntop_img: false\ncomments: false\naside: false\n---","updated":"2025-08-05T01:32:06.070Z","path":"music/index.html","_id":"cmclemnvf000158vwc0tz862s","layout":"page","content":"","excerpt":"","more":""},{"_content":"[\n  {\n    \"name\": \"青花瓷\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n  },\n  {\n    \"name\": \"稻香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n  },\n  {\n    \"name\": \"晴天\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n  },\n  {\n    \"name\": \"七里香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n  },\n  {\n    \"name\": \"花海\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n  },\n  {\n    \"name\": \"反方向的钟\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n  },\n  {\n    \"name\": \"兰亭序\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n  },\n  {\n    \"name\": \"说好的辛福呢\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n  },\n  {\n    \"name\": \"等你下课 (with 杨瑞代)\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n  },\n  {\n    \"name\": \"我落泪情绪零碎\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n  },\n  {\n    \"name\": \"听妈妈的话\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n  },\n  {\n    \"name\": \"明明就\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n  },\n  {\n    \"name\": \"我是如此相信\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n  },\n  {\n    \"name\": \"发如雪\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n  },\n  {\n    \"name\": \"以父之名\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n  },\n  {\n    \"name\": \"园游会\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n  },\n  {\n    \"name\": \"本草纲目\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n  },\n  {\n    \"name\": \"龙卷风\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n  }\n]","source":"json/music.json","raw":"[\n  {\n    \"name\": \"青花瓷\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n  },\n  {\n    \"name\": \"稻香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n  },\n  {\n    \"name\": \"晴天\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n  },\n  {\n    \"name\": \"七里香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n  },\n  {\n    \"name\": \"花海\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n  },\n  {\n    \"name\": \"反方向的钟\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n  },\n  {\n    \"name\": \"兰亭序\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n  },\n  {\n    \"name\": \"说好的辛福呢\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n  },\n  {\n    \"name\": \"等你下课 (with 杨瑞代)\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n  },\n  {\n    \"name\": \"我落泪情绪零碎\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n  },\n  {\n    \"name\": \"听妈妈的话\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n  },\n  {\n    \"name\": \"明明就\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n  },\n  {\n    \"name\": \"我是如此相信\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n  },\n  {\n    \"name\": \"发如雪\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n  },\n  {\n    \"name\": \"以父之名\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n  },\n  {\n    \"name\": \"园游会\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n  },\n  {\n    \"name\": \"本草纲目\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n  },\n  {\n    \"name\": \"龙卷风\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n  }\n]","date":"2025-07-02T03:36:40.025Z","updated":"2025-07-02T03:36:40.025Z","path":"json/music.json","layout":"false","_id":"cmclenh6y000258vw6zssdhji","title":"","comments":1,"content":"[{\"name\":\"青花瓷\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"},{\"name\":\"稻香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"},{\"name\":\"晴天\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"},{\"name\":\"七里香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"},{\"name\":\"花海\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"},{\"name\":\"反方向的钟\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"},{\"name\":\"兰亭序\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"},{\"name\":\"说好的辛福呢\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"},{\"name\":\"等你下课 (with 杨瑞代)\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"},{\"name\":\"我落泪情绪零碎\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"},{\"name\":\"听妈妈的话\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"},{\"name\":\"明明就\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"},{\"name\":\"我是如此相信\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"},{\"name\":\"发如雪\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"},{\"name\":\"以父之名\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"},{\"name\":\"园游会\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"},{\"name\":\"本草纲目\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"},{\"name\":\"龙卷风\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"}]"},{"title":"fcircle","date":"2025-07-02T03:39:14.000Z","_content":"","source":"fcircle/index.md","raw":"---\ntitle: fcircle\ndate: 2025-07-02 11:39:14\n---\n","updated":"2025-08-05T01:32:06.066Z","path":"fcircle/index.html","_id":"cmcleqtu8000358vw2althggn","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"相册集","date":"2022-10-23T07:57:51.000Z","aside":false,"top_img":false,"type":"album","_content":"","source":"album/index.md","raw":"---\ntitle: 相册集\ndate: 2022-10-23 15:57:51\naside: false\ntop_img: false\ntype: \"album\"\n---","updated":"2025-08-05T01:32:06.062Z","path":"album/index.html","_id":"cmclesjxj000458vw29s76vpe","comments":1,"layout":"page","content":"","excerpt":"","more":""},{"title":"即刻短文","date":"2020-07-22T14:06:17.000Z","comments":1,"aside":false,"top_img":false,"type":"essay","_content":"","source":"essay/index.md","raw":"---\ntitle: 即刻短文\ndate: 2020-07-22 22:06:17\ncomments: true\naside: false\ntop_img: false\ntype: essay\n---","updated":"2025-08-05T01:32:06.066Z","path":"essay/index.html","_id":"cmcletund000558vwen776ujg","layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"spring事务操作后进行异步操作","date":"2025-02-28T06:40:25.000Z","updated":"2025-02-28T06:45:28.000Z","excerpt":"本文讨论了在Spring开发中，如何解决事务操作后进行异步操作时可能出现的数据同步问题。当事务操作未完成时，异步操作可能无法获取到最新的数据库记录。文章提出了两种解决方案：  \n1. **方案一**：将异步操作放在事务操作方法之外调用，例如在控制器中分别调用事务方法和异步方法。但这种方法逻辑上不够清晰，可能给后续维护带来困难。  \n2. **方案二**：使用Spring的`TransactionSynchronizationManager`，通过注册事务同步回调，在事务提交成功后执行异步操作。此方案通过在`afterCommit`中调用异步方法，确保异步操作在事务提交后执行，避免了数据未同步的问题。需要注意的是，如果事务回滚，则不会执行`afterCommit`中的逻辑。","comments":1,"toc":true,"abbrlink":52682,"_content":"\n# spring事务操作后进行异步操作\n\n\t开发中有很多需要事务 A 操作后进行异步 B 操作, 如发送 mq, 或者开线程做其他事情. 有一部分的异步操作需要查询当前事务方法的保存 / 修改数据. 所以, 如果直接在事务方法中调用异步方法的话, 如果异步方法的逻辑查询对应的数据库记录时, 还没有刷到数据库, 那就会获取不到最新值\n\n解决方法\n\n方案一: 调用异步的方法不要写在 A 操作的方法中, 如下伪代码\n\n```JAVA\n@RequestMapping(\"doWork\")\n@ResponseBody\npublic String doWork(){\n    doWorkA();//事务操作\n    doWorkB(); //异步操作 \n}\n```\n\n但是这样并不友好, 因为逻辑上这两个操作应该是一起的, 以后维护的程序猿可能不知道这个.\n\n方案二: 使用spring的 TransactionSynchronizationManager 来保证在当前事务提交成功后执行异步操作\n\n```JAVA\n@Transactional\npublic String doWorkA(){\n    saveOrUpdate();//业务逻辑\n    TransactionSynchronizationManager.registerSynchronization(new      TransactionSynchronizationAdapter() {\n                @Override\n                public void afterCommit() {\n                    doWorkB();//异步操作\n                }\n            });\n}\n```\n\n另外注意的是, 如果前面的业务逻辑发送错误导致回滚, 不会执行 afterCommit 内的方法。\n\n‍\n","source":"_posts/asynchronous-operation-after-spring-transaction-operation-z1rhawf.md","raw":"---\ntitle: spring事务操作后进行异步操作\ndate: '2025-02-28 14:40:25'\nupdated: '2025-02-28 14:45:28'\nexcerpt: >-\n  本文讨论了在Spring开发中，如何解决事务操作后进行异步操作时可能出现的数据同步问题。当事务操作未完成时，异步操作可能无法获取到最新的数据库记录。文章提出了两种解决方案：  \n\n  1. **方案一**：将异步操作放在事务操作方法之外调用，例如在控制器中分别调用事务方法和异步方法。但这种方法逻辑上不够清晰，可能给后续维护带来困难。  \n\n  2.\n  **方案二**：使用Spring的`TransactionSynchronizationManager`，通过注册事务同步回调，在事务提交成功后执行异步操作。此方案通过在`afterCommit`中调用异步方法，确保异步操作在事务提交后执行，避免了数据未同步的问题。需要注意的是，如果事务回滚，则不会执行`afterCommit`中的逻辑。\ntags:\n  - spring事务\n  - 异步操作\n  - 事务提交\n  - 编程技巧\n  - java开发\ncategories:\n  - 事务管理\n  - 异步操作\n  - Spring框架\npermalink: /post/asynchronous-operation-after-spring-transaction-operation-z1rhawf.html\ncomments: true\ntoc: true\nabbrlink: 52682\n---\n\n# spring事务操作后进行异步操作\n\n\t开发中有很多需要事务 A 操作后进行异步 B 操作, 如发送 mq, 或者开线程做其他事情. 有一部分的异步操作需要查询当前事务方法的保存 / 修改数据. 所以, 如果直接在事务方法中调用异步方法的话, 如果异步方法的逻辑查询对应的数据库记录时, 还没有刷到数据库, 那就会获取不到最新值\n\n解决方法\n\n方案一: 调用异步的方法不要写在 A 操作的方法中, 如下伪代码\n\n```JAVA\n@RequestMapping(\"doWork\")\n@ResponseBody\npublic String doWork(){\n    doWorkA();//事务操作\n    doWorkB(); //异步操作 \n}\n```\n\n但是这样并不友好, 因为逻辑上这两个操作应该是一起的, 以后维护的程序猿可能不知道这个.\n\n方案二: 使用spring的 TransactionSynchronizationManager 来保证在当前事务提交成功后执行异步操作\n\n```JAVA\n@Transactional\npublic String doWorkA(){\n    saveOrUpdate();//业务逻辑\n    TransactionSynchronizationManager.registerSynchronization(new      TransactionSynchronizationAdapter() {\n                @Override\n                public void afterCommit() {\n                    doWorkB();//异步操作\n                }\n            });\n}\n```\n\n另外注意的是, 如果前面的业务逻辑发送错误导致回滚, 不会执行 afterCommit 内的方法。\n\n‍\n","slug":"asynchronous-operation-after-spring-transaction-operation-z1rhawf","published":1,"__permalink":"/post/asynchronous-operation-after-spring-transaction-operation-z1rhawf.html","_id":"cmclcaf3e0001p8vw5cy92vgv","layout":"post","photos":[],"content":"<h1 id=\"spring事务操作后进行异步操作\"><a href=\"#spring事务操作后进行异步操作\" class=\"headerlink\" title=\"spring事务操作后进行异步操作\"></a>spring事务操作后进行异步操作</h1><pre><code>开发中有很多需要事务 A 操作后进行异步 B 操作, 如发送 mq, 或者开线程做其他事情. 有一部分的异步操作需要查询当前事务方法的保存 / 修改数据. 所以, 如果直接在事务方法中调用异步方法的话, 如果异步方法的逻辑查询对应的数据库记录时, 还没有刷到数据库, 那就会获取不到最新值\n</code></pre>\n<p>解决方法</p>\n<p>方案一: 调用异步的方法不要写在 A 操作的方法中, 如下伪代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;doWork&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doWork</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    doWorkA();<span class=\"comment\">//事务操作</span></span><br><span class=\"line\">    doWorkB(); <span class=\"comment\">//异步操作 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样并不友好, 因为逻辑上这两个操作应该是一起的, 以后维护的程序猿可能不知道这个.</p>\n<p>方案二: 使用spring的 TransactionSynchronizationManager 来保证在当前事务提交成功后执行异步操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doWorkA</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    saveOrUpdate();<span class=\"comment\">//业务逻辑</span></span><br><span class=\"line\">    TransactionSynchronizationManager.registerSynchronization(<span class=\"keyword\">new</span>      <span class=\"title class_\">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterCommit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    doWorkB();<span class=\"comment\">//异步操作</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外注意的是, 如果前面的业务逻辑发送错误导致回滚, 不会执行 afterCommit 内的方法。</p>\n<p>‍</p>\n","more":"<h1 id=\"spring事务操作后进行异步操作\"><a href=\"#spring事务操作后进行异步操作\" class=\"headerlink\" title=\"spring事务操作后进行异步操作\"></a>spring事务操作后进行异步操作</h1><pre><code>开发中有很多需要事务 A 操作后进行异步 B 操作, 如发送 mq, 或者开线程做其他事情. 有一部分的异步操作需要查询当前事务方法的保存 / 修改数据. 所以, 如果直接在事务方法中调用异步方法的话, 如果异步方法的逻辑查询对应的数据库记录时, 还没有刷到数据库, 那就会获取不到最新值\n</code></pre>\n<p>解决方法</p>\n<p>方案一: 调用异步的方法不要写在 A 操作的方法中, 如下伪代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;doWork&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doWork</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    doWorkA();<span class=\"comment\">//事务操作</span></span><br><span class=\"line\">    doWorkB(); <span class=\"comment\">//异步操作 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样并不友好, 因为逻辑上这两个操作应该是一起的, 以后维护的程序猿可能不知道这个.</p>\n<p>方案二: 使用spring的 TransactionSynchronizationManager 来保证在当前事务提交成功后执行异步操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">doWorkA</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    saveOrUpdate();<span class=\"comment\">//业务逻辑</span></span><br><span class=\"line\">    TransactionSynchronizationManager.registerSynchronization(<span class=\"keyword\">new</span>      <span class=\"title class_\">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterCommit</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    doWorkB();<span class=\"comment\">//异步操作</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外注意的是, 如果前面的业务逻辑发送错误导致回滚, 不会执行 afterCommit 内的方法。</p>\n<p>‍</p>\n"},{"title":"详解计算机状态：从待机到休眠的五种模式","date":"2024-12-19T01:57:31.000Z","updated":"2024-12-23T01:55:33.000Z","excerpt":"这篇文章详细介绍了计算机的五种状态：S1待机、S2电源待机、S3挂起到内存、S4挂起到硬盘和S5关机。S1和S2状态类似，都是低电源供应状态，但S2更为彻底。S3状态将内存数据保持不变，其他设备停止供电，恢复时快速回到原状态。S4状态将内存数据保存到硬盘，适合长时间离线，恢复时数据不会丢失。S5状态则是完全关机，功耗为0。这些状态有助于节能和管理计算机运行。","comments":1,"toc":true,"abbrlink":61463,"_content":"\n# 详解计算机状态：从待机到休眠的五种模式\n\n# 计算机状态\n\n* **S1**\n\n　Standby。即指说系统处于低电源供应状态，在 windows or BIOS 中可设定屏幕信号输出关闭、硬盘停止运转进入待机状态、电源灯处于闪烁状态。此时动一动鼠标、按键盘任一键均可叫醒电脑。\n\n* **S2**\n\n　　Power Standby。和 S1 几乎是一样的。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。\n\n* **S3**\n\n　　Suspend to RAM。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。在BIOS中叫做\"挂到内存 \" (Suspend to RAM/STR)，在Windows XP 以后的Windows 版本和一些Linux 发行版中叫做\"待机 (Standby)\"，在Windows Vista 和Mac OS X 则叫做\"睡眠(Sleep)\"，虽然ACPI规范仅仅提到术语\"S3\"和\"睡眠(Sleep)\"。在这个状态下，主存储器(RAM )仍然有电源供给，尽管它也是几乎唯一的有电源供给的原件。因为操作系统 、所有应用程序和被打开的文档等等的状态都是保存在主存储器中，用户可以把工作恢复到正好上次他们保持的状态-计算机从S3状态回来时主存储器的内容和它进入S3状态时候的内容是相同象的。(规范中提到了S3和S2是相当类似的，只有更多的组件在S3状态下会被关掉电源。) 相比较S4来说S3有两个好处；计算机恢复的过程比重启要快，第二，如果任何正在运行的应用程序(被打开的文档等等)有私有信息在里面，这些信息是不会被写到硬盘上的。然而，在系统不能被唤醒比如遇到了电源故障的时候， 高速缓冲存储器 可能会被flushed来防止数据毁坏。\n\n* **S4**\n\n　　Suspend to Disk。即是把 windows 内存中的资料完整的保存在硬盘中，等开机时就直接从保存这些资料的地方直接完整的读到内存中，不需要跑一堆应用程序。使用这种模式，硬盘一定要腾出一个完整的连续空间。WinME/2000/XP 在电源管理中休眠的作用就是这个 。在启动后，C:下会看到一个和你电脑现有内存大小一样的文件。在Windows 中叫休眠 ，在Mac OS X 中叫作安全睡眠 ，也称为挂到硬盘 ，虽然ACPI规范中只提到了一个术语S4 （main article:Hibernate(OS feature) )。在这个状态下，所有主存储器 的内容被储存在非挥发性存储器，例如硬盘 ，保护操作系统当前的状态，包括所有应用程序,打开的文档等.这意味着从S4恢复后，用户可以恢复到原本的工作状态，采用的方法和S3是一样的。S4和S3之间的差异是，除了把主存储器中的内容移进移出所消耗的时间以外,在S3状态下的时候如果一旦停电了,所有主存储器上的数据就会丢失,包括所有的没有保存的文档,而在S4状态下则没有影响.S4和其他的S 状态有很大不同,事实上更类似G2Soft Off 状态和G3 Mechanical Off 状态,而不是S1-S3.在S4状态下的系统同样可进入G3(Mechanical Off )状态,并且保留S4时候的状态信息.所以它可以恢复到以前的运行状态在关掉电源之后.\n\n* **S5**\n\n　　Shutdown。功耗为0。S\n","source":"_posts/computer-status-2pq0or.md","raw":"---\ntitle: 详解计算机状态：从待机到休眠的五种模式\ndate: '2024-12-19 09:57:31'\nupdated: '2024-12-23 09:55:33'\nexcerpt: >-\n  这篇文章详细介绍了计算机的五种状态：S1待机、S2电源待机、S3挂起到内存、S4挂起到硬盘和S5关机。S1和S2状态类似，都是低电源供应状态，但S2更为彻底。S3状态将内存数据保持不变，其他设备停止供电，恢复时快速回到原状态。S4状态将内存数据保存到硬盘，适合长时间离线，恢复时数据不会丢失。S5状态则是完全关机，功耗为0。这些状态有助于节能和管理计算机运行。\ntags:\n  - 计算机状态\n  - 电源管理\n  - S3睡眠\n  - S4休眠\ncategories:\n  - 系统休眠\npermalink: /post/computer-status-2pq0or.html\ncomments: true\ntoc: true\nabbrlink: 61463\n---\n\n# 详解计算机状态：从待机到休眠的五种模式\n\n# 计算机状态\n\n* **S1**\n\n　Standby。即指说系统处于低电源供应状态，在 windows or BIOS 中可设定屏幕信号输出关闭、硬盘停止运转进入待机状态、电源灯处于闪烁状态。此时动一动鼠标、按键盘任一键均可叫醒电脑。\n\n* **S2**\n\n　　Power Standby。和 S1 几乎是一样的。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。\n\n* **S3**\n\n　　Suspend to RAM。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。在BIOS中叫做\"挂到内存 \" (Suspend to RAM/STR)，在Windows XP 以后的Windows 版本和一些Linux 发行版中叫做\"待机 (Standby)\"，在Windows Vista 和Mac OS X 则叫做\"睡眠(Sleep)\"，虽然ACPI规范仅仅提到术语\"S3\"和\"睡眠(Sleep)\"。在这个状态下，主存储器(RAM )仍然有电源供给，尽管它也是几乎唯一的有电源供给的原件。因为操作系统 、所有应用程序和被打开的文档等等的状态都是保存在主存储器中，用户可以把工作恢复到正好上次他们保持的状态-计算机从S3状态回来时主存储器的内容和它进入S3状态时候的内容是相同象的。(规范中提到了S3和S2是相当类似的，只有更多的组件在S3状态下会被关掉电源。) 相比较S4来说S3有两个好处；计算机恢复的过程比重启要快，第二，如果任何正在运行的应用程序(被打开的文档等等)有私有信息在里面，这些信息是不会被写到硬盘上的。然而，在系统不能被唤醒比如遇到了电源故障的时候， 高速缓冲存储器 可能会被flushed来防止数据毁坏。\n\n* **S4**\n\n　　Suspend to Disk。即是把 windows 内存中的资料完整的保存在硬盘中，等开机时就直接从保存这些资料的地方直接完整的读到内存中，不需要跑一堆应用程序。使用这种模式，硬盘一定要腾出一个完整的连续空间。WinME/2000/XP 在电源管理中休眠的作用就是这个 。在启动后，C:下会看到一个和你电脑现有内存大小一样的文件。在Windows 中叫休眠 ，在Mac OS X 中叫作安全睡眠 ，也称为挂到硬盘 ，虽然ACPI规范中只提到了一个术语S4 （main article:Hibernate(OS feature) )。在这个状态下，所有主存储器 的内容被储存在非挥发性存储器，例如硬盘 ，保护操作系统当前的状态，包括所有应用程序,打开的文档等.这意味着从S4恢复后，用户可以恢复到原本的工作状态，采用的方法和S3是一样的。S4和S3之间的差异是，除了把主存储器中的内容移进移出所消耗的时间以外,在S3状态下的时候如果一旦停电了,所有主存储器上的数据就会丢失,包括所有的没有保存的文档,而在S4状态下则没有影响.S4和其他的S 状态有很大不同,事实上更类似G2Soft Off 状态和G3 Mechanical Off 状态,而不是S1-S3.在S4状态下的系统同样可进入G3(Mechanical Off )状态,并且保留S4时候的状态信息.所以它可以恢复到以前的运行状态在关掉电源之后.\n\n* **S5**\n\n　　Shutdown。功耗为0。S\n","slug":"computer-status-2pq0or","published":1,"__permalink":"/post/computer-status-2pq0or.html","_id":"cmclcaf3j0003p8vwg7k2efso","layout":"post","photos":[],"content":"<h1 id=\"详解计算机状态：从待机到休眠的五种模式\"><a href=\"#详解计算机状态：从待机到休眠的五种模式\" class=\"headerlink\" title=\"详解计算机状态：从待机到休眠的五种模式\"></a>详解计算机状态：从待机到休眠的五种模式</h1><h1 id=\"计算机状态\"><a href=\"#计算机状态\" class=\"headerlink\" title=\"计算机状态\"></a>计算机状态</h1><ul>\n<li><strong>S1</strong></li>\n</ul>\n<p>　Standby。即指说系统处于低电源供应状态，在 windows or BIOS 中可设定屏幕信号输出关闭、硬盘停止运转进入待机状态、电源灯处于闪烁状态。此时动一动鼠标、按键盘任一键均可叫醒电脑。</p>\n<ul>\n<li><strong>S2</strong></li>\n</ul>\n<p>　　Power Standby。和 S1 几乎是一样的。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。</p>\n<ul>\n<li><strong>S3</strong></li>\n</ul>\n<p>　　Suspend to RAM。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。在BIOS中叫做”挂到内存 “ (Suspend to RAM&#x2F;STR)，在Windows XP 以后的Windows 版本和一些Linux 发行版中叫做”待机 (Standby)”，在Windows Vista 和Mac OS X 则叫做”睡眠(Sleep)”，虽然ACPI规范仅仅提到术语”S3”和”睡眠(Sleep)”。在这个状态下，主存储器(RAM )仍然有电源供给，尽管它也是几乎唯一的有电源供给的原件。因为操作系统 、所有应用程序和被打开的文档等等的状态都是保存在主存储器中，用户可以把工作恢复到正好上次他们保持的状态-计算机从S3状态回来时主存储器的内容和它进入S3状态时候的内容是相同象的。(规范中提到了S3和S2是相当类似的，只有更多的组件在S3状态下会被关掉电源。) 相比较S4来说S3有两个好处；计算机恢复的过程比重启要快，第二，如果任何正在运行的应用程序(被打开的文档等等)有私有信息在里面，这些信息是不会被写到硬盘上的。然而，在系统不能被唤醒比如遇到了电源故障的时候， 高速缓冲存储器 可能会被flushed来防止数据毁坏。</p>\n<ul>\n<li><strong>S4</strong></li>\n</ul>\n<p>　　Suspend to Disk。即是把 windows 内存中的资料完整的保存在硬盘中，等开机时就直接从保存这些资料的地方直接完整的读到内存中，不需要跑一堆应用程序。使用这种模式，硬盘一定要腾出一个完整的连续空间。WinME&#x2F;2000&#x2F;XP 在电源管理中休眠的作用就是这个 。在启动后，C:下会看到一个和你电脑现有内存大小一样的文件。在Windows 中叫休眠 ，在Mac OS X 中叫作安全睡眠 ，也称为挂到硬盘 ，虽然ACPI规范中只提到了一个术语S4 （main article:Hibernate(OS feature) )。在这个状态下，所有主存储器 的内容被储存在非挥发性存储器，例如硬盘 ，保护操作系统当前的状态，包括所有应用程序,打开的文档等.这意味着从S4恢复后，用户可以恢复到原本的工作状态，采用的方法和S3是一样的。S4和S3之间的差异是，除了把主存储器中的内容移进移出所消耗的时间以外,在S3状态下的时候如果一旦停电了,所有主存储器上的数据就会丢失,包括所有的没有保存的文档,而在S4状态下则没有影响.S4和其他的S 状态有很大不同,事实上更类似G2Soft Off 状态和G3 Mechanical Off 状态,而不是S1-S3.在S4状态下的系统同样可进入G3(Mechanical Off )状态,并且保留S4时候的状态信息.所以它可以恢复到以前的运行状态在关掉电源之后.</p>\n<ul>\n<li><strong>S5</strong></li>\n</ul>\n<p>　　Shutdown。功耗为0。S</p>\n","more":"<h1 id=\"详解计算机状态：从待机到休眠的五种模式\"><a href=\"#详解计算机状态：从待机到休眠的五种模式\" class=\"headerlink\" title=\"详解计算机状态：从待机到休眠的五种模式\"></a>详解计算机状态：从待机到休眠的五种模式</h1><h1 id=\"计算机状态\"><a href=\"#计算机状态\" class=\"headerlink\" title=\"计算机状态\"></a>计算机状态</h1><ul>\n<li><strong>S1</strong></li>\n</ul>\n<p>　Standby。即指说系统处于低电源供应状态，在 windows or BIOS 中可设定屏幕信号输出关闭、硬盘停止运转进入待机状态、电源灯处于闪烁状态。此时动一动鼠标、按键盘任一键均可叫醒电脑。</p>\n<ul>\n<li><strong>S2</strong></li>\n</ul>\n<p>　　Power Standby。和 S1 几乎是一样的。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。</p>\n<ul>\n<li><strong>S3</strong></li>\n</ul>\n<p>　　Suspend to RAM。即是把 windows 当前存在内存中的所有资料保存不动，然后进入“假关机”。此时除了内存需要电源来保持资料以外，其它的设备，装置全部停止供电。也就是说，理论上可以把CPU，PCI卡，AGP Device拿掉又插回去，电脑也可能正常完成开机及运作，只要不动到内存和电源的部份。这时只剩下电源灯一闪一闪的，其它和关机没什么两样。（电源供应器的风扇也停止运转）重新开机后，电脑只是把内存的资料完整性确认后，即立刻会回到你进S3前的画面。记得有人试过，在刻录中启动S3，CDRW还会自动启动Just-Link，等你回复后它又自动继续刻录（没实际试过）。在BIOS中叫做”挂到内存 “ (Suspend to RAM&#x2F;STR)，在Windows XP 以后的Windows 版本和一些Linux 发行版中叫做”待机 (Standby)”，在Windows Vista 和Mac OS X 则叫做”睡眠(Sleep)”，虽然ACPI规范仅仅提到术语”S3”和”睡眠(Sleep)”。在这个状态下，主存储器(RAM )仍然有电源供给，尽管它也是几乎唯一的有电源供给的原件。因为操作系统 、所有应用程序和被打开的文档等等的状态都是保存在主存储器中，用户可以把工作恢复到正好上次他们保持的状态-计算机从S3状态回来时主存储器的内容和它进入S3状态时候的内容是相同象的。(规范中提到了S3和S2是相当类似的，只有更多的组件在S3状态下会被关掉电源。) 相比较S4来说S3有两个好处；计算机恢复的过程比重启要快，第二，如果任何正在运行的应用程序(被打开的文档等等)有私有信息在里面，这些信息是不会被写到硬盘上的。然而，在系统不能被唤醒比如遇到了电源故障的时候， 高速缓冲存储器 可能会被flushed来防止数据毁坏。</p>\n<ul>\n<li><strong>S4</strong></li>\n</ul>\n<p>　　Suspend to Disk。即是把 windows 内存中的资料完整的保存在硬盘中，等开机时就直接从保存这些资料的地方直接完整的读到内存中，不需要跑一堆应用程序。使用这种模式，硬盘一定要腾出一个完整的连续空间。WinME&#x2F;2000&#x2F;XP 在电源管理中休眠的作用就是这个 。在启动后，C:下会看到一个和你电脑现有内存大小一样的文件。在Windows 中叫休眠 ，在Mac OS X 中叫作安全睡眠 ，也称为挂到硬盘 ，虽然ACPI规范中只提到了一个术语S4 （main article:Hibernate(OS feature) )。在这个状态下，所有主存储器 的内容被储存在非挥发性存储器，例如硬盘 ，保护操作系统当前的状态，包括所有应用程序,打开的文档等.这意味着从S4恢复后，用户可以恢复到原本的工作状态，采用的方法和S3是一样的。S4和S3之间的差异是，除了把主存储器中的内容移进移出所消耗的时间以外,在S3状态下的时候如果一旦停电了,所有主存储器上的数据就会丢失,包括所有的没有保存的文档,而在S4状态下则没有影响.S4和其他的S 状态有很大不同,事实上更类似G2Soft Off 状态和G3 Mechanical Off 状态,而不是S1-S3.在S4状态下的系统同样可进入G3(Mechanical Off )状态,并且保留S4时候的状态信息.所以它可以恢复到以前的运行状态在关掉电源之后.</p>\n<ul>\n<li><strong>S5</strong></li>\n</ul>\n<p>　　Shutdown。功耗为0。S</p>\n"},{"title":"Java实现代理模式","date":"2024-12-19T01:55:21.000Z","updated":"2024-12-19T16:10:15.000Z","comments":1,"toc":true,"abbrlink":43440,"_content":"\n# Java实现代理模式\n\nJava实现代理模式\n\n1、代理模式\n\n---\n\n代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。\n\n代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。\n\n代理模式有**静态代理**和**动态代理**两种实现方式。\n\n2、静态代理\n\n---\n\n静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。\n\n上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。\n\n下面通过代码展示！ **1**​ **.**​ ** 定义发送短信的接口**\n\n```java\npublic interface SmsService {\n    String send(String message);\n}\n```\n\n##### **2**​ **.**​ ** 实现发送短信的接口**\n\n```java\npublic class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println(\"真实的 send message : \" + message);\n        return message;\n    }\n}\n```\n\n##### **3**​ **.**​ ** 创建代理类并同样实现发送短信的接口**\n\n```java\npublic class SmsProxy implements SmsService {\n \n    private final SmsService smsService;\n \n    public SmsProxy(SmsService smsService) {\n        this.smsService = smsService;\n    }\n \n    @Override\n    public String send(String message) {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"静态代理 before method send()\");\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"静态代理 after method send()\");\n        return message;\n    }\n}\n```\n\n##### **4**​ **.**​ ** 实际使用**\n\n```java\npublic class 静态代理和动态代理 {\n    public static void main(String[] args) {\n        // 静态代理\n        SmsService smsService = new SmsServiceImpl();\n        SmsProxy smsProxy = new SmsProxy(smsService);\n        smsProxy.send(\"java\");\n    }\n}\n```\n\n##### 5.执行结果：\n\n```java\n静态代理 before method send()\n真实的 send message : java\n静态代理 after method send()\n```\n\n3、动态代理\n\n---\n\n相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类(CGLIB动态代理机制)。\n\n从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。\n\n说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。\n\n动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。\n\n就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。\n\nguide-rpc-framework使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。\n\n另外，虽然 guide-rpc-framework 没有用到 CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和JDK 动态代理的对比。\n\n### 3.1 JDK 动态代理机制\n\n#### 3.1.1 介绍\n\n在 Java 动态代理机制中 `*InvocationHandler*` 接口和 Proxy 类是核心。\n\nProxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。\n\n```java\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        .......\n    }\n```\n\n这个方法一共有 3 个参数：\n\n1. \\*\\*loader：\\*\\*类加载器，用于加载代理对象。\n2. \\*\\*interfaces：\\*\\*被代理类实现的一些接口；\n3. \\*\\*h：\\*\\*实现了 `InvocationHandler` 接口的对象；\n\n要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。\n\n```java\npublic interface InvocationHandler {\n    // 当你使用代理对象调用方法的时候实际会调用到这个方法\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n```\n\n`invoke()` 方法有下面三个参数：\n\n1. \\*\\*proxy：\\*\\*动态生成的代理类\n2. \\*\\*methoh：\\*\\*与代理类对象调用的方法相对应\n3. \\*\\*args：\\*\\*当前 method 方法的参数\n\n也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。\n\n##### 3.1.2 JDK 动态代理类使用步骤\n\n定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>\\[\\] interfaces,InvocationHandler h) 方法创建代理对象；\n\n##### 3.1.2 代码示例\n\n1. 定义发送短信的接口\n\n```java\npublic interface SmsService {\n    String send(String message);\n}\n```\n\n1. 实现发送短信的接口\n\n```java\npublic class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println(\"真实的 send message : \" + message);\n        return message;\n    }\n}\n```\n\n1. 定义一个JDK动态代理类\n\n```java\npublic class DebugInvocationHandler implements InvocationHandler {\n    // 代理类中的真实对象\n    private final Object target;\n \n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n \n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"JDK动态代理 before method \" + method.getName());\n        Object result = method.invoke(target, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"JDK动态代理 after method \" + method.getName());\n        return result;\n    }\n}\n```\n\n1. 获取代理对象的工厂类\n\n```java\npublic class JdkProxyFactory {\n    public static Object getProxy(Object target) {\n        return Proxy.newProxyInstance(\n            target.getClass().getClassLoader(), // 目标类的类加载\n            target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个\n            new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler\n        );\n    }\n}\n```\n\n1. 实际使用\n\n```java\npublic class 静态代理和动态代理 {\n    public static void main(String[] args) {\n        SmsService smsService1 = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());\n        smsService1.send(\"Java!\");\n    }\n}\n```\n\n1. 执行结果：\n\n```java\nJDK动态代理 before method send\n真实的 send message : Java!\nJDK动态代理 after method send\n```\n\n### 3.2. CGLIB 动态代理机制\n\n#### 3.2.1. 介绍\n\nJDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。\n\nCGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。\n\n在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。\n\n你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。\n\n```java\npublic interface MethodInterceptor\nextends Callback{\n    // 拦截被代理类中的方法\n    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,\n                               MethodProxy proxy) throws Throwable;\n}\n```\n\n1. \\*\\*obj：\\*\\*被代理的对象（需要增强的对象）\n2. \\*\\*method：\\*\\*被拦截的方法（需要增强的方法）\n3. \\*\\*args：\\*\\*方法入参\n4. \\*\\*proxy：\\*\\*用于调用原始方法\n\n你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。\n\n#### 3.2.2. CGLIB 动态代理类使用步骤\n\n1. 定义一个类；\n2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；\n3. 通过 `Enhancer` 类的 `create()`创建代理类；\n\n#### 3.2.3. 代码示例\n\n不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。\n\n```xml\n<dependency>\n  <groupId>cglib</groupId>\n  <artifactId>cglib</artifactId>\n  <version>3.3.0</version>\n</dependency>\n```\n\n1. 实现一个使用阿里云发送短信的类\n\n```java\npublic class AliSmsService {\n    public String send(String message) {\n        System.out.println(\"send message:\" + message);\n        return message;\n    }\n}\n```\n\n1. 自定义 MethodInterceptor（方法拦截器）\n\n```java\npublic class DebugMethodInterceptor implements MethodInterceptor {\n    /**\n     * @param o           代理对象（增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param args        方法入参\n     * @param methodProxy 用于调用原始方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method \" + method.getName());\n        Object object = methodProxy.invokeSuper(o, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method \" + method.getName());\n        return object;\n    }\n}\n```\n\n1. 获取代理类\n\n```java\npublic class CglibProxyFactory {\n    public static Object getProxy(Class<?> clazz) {\n        // 创建动态代理增强类\n        Enhancer enhancer = new Enhancer();\n        // 设置类加载器\n        enhancer.setClassLoader(clazz.getClassLoader());\n        // 设置被代理类\n        enhancer.setSuperclass(clazz);\n        // 设置方法拦截器\n        enhancer.setCallback(new DebugMethodInterceptor());\n        // 创建代理类\n        return enhancer.create();\n    }\n}\n```\n\n1. 实际使用\n\n   ```java\n   public class 静态代理和动态代理 {\n       public static void main(String[] args) {\n           AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);\n           aliSmsService.send(\"java\");\n       }\n   }\n   ```\n2. 执行结果：\n\n```java\nbefore method send\nsend message:java\nafter method send\n```\n\n#### 3.3. JDK动态代理和CGLIB动态代理对比\n\n1. JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。\n2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。\n\n4、静态代理和动态代理的对比\n\n---\n\n1. 灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！\n2. JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。\n","source":"_posts/java-implementing-agent-mode-zxwpxc.md","raw":"---\ntitle: Java实现代理模式\ndate: '2024-12-19 09:55:21'\nupdated: '2024-12-20 00:10:15'\npermalink: /post/java-implementing-agent-mode-zxwpxc.html\ncomments: true\ntoc: true\nabbrlink: 43440\n---\n\n# Java实现代理模式\n\nJava实现代理模式\n\n1、代理模式\n\n---\n\n代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。\n\n代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。\n\n代理模式有**静态代理**和**动态代理**两种实现方式。\n\n2、静态代理\n\n---\n\n静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。\n\n上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。\n\n下面通过代码展示！ **1**​ **.**​ ** 定义发送短信的接口**\n\n```java\npublic interface SmsService {\n    String send(String message);\n}\n```\n\n##### **2**​ **.**​ ** 实现发送短信的接口**\n\n```java\npublic class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println(\"真实的 send message : \" + message);\n        return message;\n    }\n}\n```\n\n##### **3**​ **.**​ ** 创建代理类并同样实现发送短信的接口**\n\n```java\npublic class SmsProxy implements SmsService {\n \n    private final SmsService smsService;\n \n    public SmsProxy(SmsService smsService) {\n        this.smsService = smsService;\n    }\n \n    @Override\n    public String send(String message) {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"静态代理 before method send()\");\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"静态代理 after method send()\");\n        return message;\n    }\n}\n```\n\n##### **4**​ **.**​ ** 实际使用**\n\n```java\npublic class 静态代理和动态代理 {\n    public static void main(String[] args) {\n        // 静态代理\n        SmsService smsService = new SmsServiceImpl();\n        SmsProxy smsProxy = new SmsProxy(smsService);\n        smsProxy.send(\"java\");\n    }\n}\n```\n\n##### 5.执行结果：\n\n```java\n静态代理 before method send()\n真实的 send message : java\n静态代理 after method send()\n```\n\n3、动态代理\n\n---\n\n相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类(CGLIB动态代理机制)。\n\n从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。\n\n说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。\n\n动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。\n\n就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。\n\nguide-rpc-framework使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。\n\n另外，虽然 guide-rpc-framework 没有用到 CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和JDK 动态代理的对比。\n\n### 3.1 JDK 动态代理机制\n\n#### 3.1.1 介绍\n\n在 Java 动态代理机制中 `*InvocationHandler*` 接口和 Proxy 类是核心。\n\nProxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。\n\n```java\n    public static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n        .......\n    }\n```\n\n这个方法一共有 3 个参数：\n\n1. \\*\\*loader：\\*\\*类加载器，用于加载代理对象。\n2. \\*\\*interfaces：\\*\\*被代理类实现的一些接口；\n3. \\*\\*h：\\*\\*实现了 `InvocationHandler` 接口的对象；\n\n要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。\n\n```java\npublic interface InvocationHandler {\n    // 当你使用代理对象调用方法的时候实际会调用到这个方法\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n```\n\n`invoke()` 方法有下面三个参数：\n\n1. \\*\\*proxy：\\*\\*动态生成的代理类\n2. \\*\\*methoh：\\*\\*与代理类对象调用的方法相对应\n3. \\*\\*args：\\*\\*当前 method 方法的参数\n\n也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。\n\n##### 3.1.2 JDK 动态代理类使用步骤\n\n定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>\\[\\] interfaces,InvocationHandler h) 方法创建代理对象；\n\n##### 3.1.2 代码示例\n\n1. 定义发送短信的接口\n\n```java\npublic interface SmsService {\n    String send(String message);\n}\n```\n\n1. 实现发送短信的接口\n\n```java\npublic class SmsServiceImpl implements SmsService {\n    public String send(String message) {\n        System.out.println(\"真实的 send message : \" + message);\n        return message;\n    }\n}\n```\n\n1. 定义一个JDK动态代理类\n\n```java\npublic class DebugInvocationHandler implements InvocationHandler {\n    // 代理类中的真实对象\n    private final Object target;\n \n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n \n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"JDK动态代理 before method \" + method.getName());\n        Object result = method.invoke(target, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"JDK动态代理 after method \" + method.getName());\n        return result;\n    }\n}\n```\n\n1. 获取代理对象的工厂类\n\n```java\npublic class JdkProxyFactory {\n    public static Object getProxy(Object target) {\n        return Proxy.newProxyInstance(\n            target.getClass().getClassLoader(), // 目标类的类加载\n            target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个\n            new DebugInvocationHandler(target)   // 代理对象对应的自定义 InvocationHandler\n        );\n    }\n}\n```\n\n1. 实际使用\n\n```java\npublic class 静态代理和动态代理 {\n    public static void main(String[] args) {\n        SmsService smsService1 = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());\n        smsService1.send(\"Java!\");\n    }\n}\n```\n\n1. 执行结果：\n\n```java\nJDK动态代理 before method send\n真实的 send message : Java!\nJDK动态代理 after method send\n```\n\n### 3.2. CGLIB 动态代理机制\n\n#### 3.2.1. 介绍\n\nJDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。\n\nCGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。\n\n在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。\n\n你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。\n\n```java\npublic interface MethodInterceptor\nextends Callback{\n    // 拦截被代理类中的方法\n    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,\n                               MethodProxy proxy) throws Throwable;\n}\n```\n\n1. \\*\\*obj：\\*\\*被代理的对象（需要增强的对象）\n2. \\*\\*method：\\*\\*被拦截的方法（需要增强的方法）\n3. \\*\\*args：\\*\\*方法入参\n4. \\*\\*proxy：\\*\\*用于调用原始方法\n\n你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。\n\n#### 3.2.2. CGLIB 动态代理类使用步骤\n\n1. 定义一个类；\n2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；\n3. 通过 `Enhancer` 类的 `create()`创建代理类；\n\n#### 3.2.3. 代码示例\n\n不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。\n\n```xml\n<dependency>\n  <groupId>cglib</groupId>\n  <artifactId>cglib</artifactId>\n  <version>3.3.0</version>\n</dependency>\n```\n\n1. 实现一个使用阿里云发送短信的类\n\n```java\npublic class AliSmsService {\n    public String send(String message) {\n        System.out.println(\"send message:\" + message);\n        return message;\n    }\n}\n```\n\n1. 自定义 MethodInterceptor（方法拦截器）\n\n```java\npublic class DebugMethodInterceptor implements MethodInterceptor {\n    /**\n     * @param o           代理对象（增强的对象）\n     * @param method      被拦截的方法（需要增强的方法）\n     * @param args        方法入参\n     * @param methodProxy 用于调用原始方法\n     */\n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method \" + method.getName());\n        Object object = methodProxy.invokeSuper(o, args);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method \" + method.getName());\n        return object;\n    }\n}\n```\n\n1. 获取代理类\n\n```java\npublic class CglibProxyFactory {\n    public static Object getProxy(Class<?> clazz) {\n        // 创建动态代理增强类\n        Enhancer enhancer = new Enhancer();\n        // 设置类加载器\n        enhancer.setClassLoader(clazz.getClassLoader());\n        // 设置被代理类\n        enhancer.setSuperclass(clazz);\n        // 设置方法拦截器\n        enhancer.setCallback(new DebugMethodInterceptor());\n        // 创建代理类\n        return enhancer.create();\n    }\n}\n```\n\n1. 实际使用\n\n   ```java\n   public class 静态代理和动态代理 {\n       public static void main(String[] args) {\n           AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);\n           aliSmsService.send(\"java\");\n       }\n   }\n   ```\n2. 执行结果：\n\n```java\nbefore method send\nsend message:java\nafter method send\n```\n\n#### 3.3. JDK动态代理和CGLIB动态代理对比\n\n1. JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。\n2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。\n\n4、静态代理和动态代理的对比\n\n---\n\n1. 灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！\n2. JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。\n","slug":"java-implementing-agent-mode-zxwpxc","published":1,"__permalink":"/post/java-implementing-agent-mode-zxwpxc.html","_id":"cmclcaf3p0007p8vwgb4r1q2o","layout":"post","photos":[],"content":"<h1 id=\"Java实现代理模式\"><a href=\"#Java实现代理模式\" class=\"headerlink\" title=\"Java实现代理模式\"></a>Java实现代理模式</h1><p>Java实现代理模式</p>\n<p>1、代理模式</p>\n<hr>\n<p>代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>\n<p>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</p>\n<p>代理模式有<strong>静态代理</strong>和<strong>动态代理</strong>两种实现方式。</p>\n<p>2、静态代理</p>\n<hr>\n<p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>\n<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>\n<p>下面通过代码展示！ <strong>1</strong>​ **.<strong>​ ** 定义发送短信的接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2​-​-实现发送短信的接口\"><a href=\"#2​-​-实现发送短信的接口\" class=\"headerlink\" title=\"2​ **.​ ** 实现发送短信的接口\"></a><strong>2</strong>​ **.<strong>​ ** 实现发送短信的接口</strong></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;真实的 send message : &quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3​-​-创建代理类并同样实现发送短信的接口\"><a href=\"#3​-​-创建代理类并同样实现发送短信的接口\" class=\"headerlink\" title=\"3​ **.​ ** 创建代理类并同样实现发送短信的接口\"></a><strong>3</strong>​ **.<strong>​ ** 创建代理类并同样实现发送短信的接口</strong></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SmsService smsService;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SmsProxy</span><span class=\"params\">(SmsService smsService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.smsService = smsService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;静态代理 before method send()&quot;</span>);</span><br><span class=\"line\">        smsService.send(message);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;静态代理 after method send()&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4​-​-实际使用\"><a href=\"#4​-​-实际使用\" class=\"headerlink\" title=\"4​ **.​ ** 实际使用\"></a><strong>4</strong>​ **.<strong>​ ** 实际使用</strong></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 静态代理和动态代理 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 静态代理</span></span><br><span class=\"line\">        <span class=\"type\">SmsService</span> <span class=\"variable\">smsService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">SmsProxy</span> <span class=\"variable\">smsProxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsProxy</span>(smsService);</span><br><span class=\"line\">        smsProxy.send(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5-执行结果：\"><a href=\"#5-执行结果：\" class=\"headerlink\" title=\"5.执行结果：\"></a>5.执行结果：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">静态代理 before method <span class=\"title function_\">send</span><span class=\"params\">()</span></span><br><span class=\"line\">真实的 send message : java</span><br><span class=\"line\">静态代理 after method <span class=\"title function_\">send</span><span class=\"params\">()</span></span><br></pre></td></tr></table></figure>\n\n<p>3、动态代理</p>\n<hr>\n<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类(CGLIB动态代理机制)。</p>\n<p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>\n<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>\n<p>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</p>\n<p>就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。</p>\n<p>guide-rpc-framework使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>\n<p>另外，虽然 guide-rpc-framework 没有用到 CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和JDK 动态代理的对比。</p>\n<h3 id=\"3-1-JDK-动态代理机制\"><a href=\"#3-1-JDK-动态代理机制\" class=\"headerlink\" title=\"3.1 JDK 动态代理机制\"></a>3.1 JDK 动态代理机制</h3><h4 id=\"3-1-1-介绍\"><a href=\"#3-1-1-介绍\" class=\"headerlink\" title=\"3.1.1 介绍\"></a>3.1.1 介绍</h4><p>在 Java 动态代理机制中 <code>*InvocationHandler*</code> 接口和 Proxy 类是核心。</p>\n<p>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class=\"line\"><span class=\"params\">                                      InvocationHandler h)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IllegalArgumentException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法一共有 3 个参数：</p>\n<ol>\n<li>**loader：**类加载器，用于加载代理对象。</li>\n<li>**interfaces：**被代理类实现的一些接口；</li>\n<li>**h：**实现了 <code>InvocationHandler</code> 接口的对象；</li>\n</ol>\n<p>要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>invoke()</code> 方法有下面三个参数：</p>\n<ol>\n<li>**proxy：**动态生成的代理类</li>\n<li>**methoh：**与代理类对象调用的方法相对应</li>\n<li>**args：**当前 method 方法的参数</li>\n</ol>\n<p>也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>\n<h5 id=\"3-1-2-JDK-动态代理类使用步骤\"><a href=\"#3-1-2-JDK-动态代理类使用步骤\" class=\"headerlink\" title=\"3.1.2 JDK 动态代理类使用步骤\"></a>3.1.2 JDK 动态代理类使用步骤</h5><p>定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</p>\n<h5 id=\"3-1-2-代码示例\"><a href=\"#3-1-2-代码示例\" class=\"headerlink\" title=\"3.1.2 代码示例\"></a>3.1.2 代码示例</h5><ol>\n<li>定义发送短信的接口</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实现发送短信的接口</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;真实的 send message : &quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>定义一个JDK动态代理类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DebugInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 代理类中的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DebugInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;JDK动态代理 before method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;JDK动态代理 after method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>获取代理对象的工厂类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JdkProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(</span><br><span class=\"line\">            target.getClass().getClassLoader(), <span class=\"comment\">// 目标类的类加载</span></span><br><span class=\"line\">            target.getClass().getInterfaces(),  <span class=\"comment\">// 代理需要实现的接口，可指定多个</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">DebugInvocationHandler</span>(target)   <span class=\"comment\">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实际使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 静态代理和动态代理 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SmsService</span> <span class=\"variable\">smsService1</span> <span class=\"operator\">=</span> (SmsService) JdkProxyFactory.getProxy(<span class=\"keyword\">new</span> <span class=\"title class_\">SmsServiceImpl</span>());</span><br><span class=\"line\">        smsService1.send(<span class=\"string\">&quot;Java!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行结果：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK动态代理 before method send</span><br><span class=\"line\">真实的 send message : Java!</span><br><span class=\"line\">JDK动态代理 after method send</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-CGLIB-动态代理机制\"><a href=\"#3-2-CGLIB-动态代理机制\" class=\"headerlink\" title=\"3.2. CGLIB 动态代理机制\"></a>3.2. CGLIB 动态代理机制</h3><h4 id=\"3-2-1-介绍\"><a href=\"#3-2-1-介绍\" class=\"headerlink\" title=\"3.2.1. 介绍\"></a>3.2.1. 介绍</h4><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>\n<p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>\n<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>\n<p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MethodInterceptor</span></span><br><span class=\"line\"><span class=\"keyword\">extends</span> <span class=\"title class_\">Callback</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拦截被代理类中的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class=\"line\"><span class=\"params\">                               MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>**obj：**被代理的对象（需要增强的对象）</li>\n<li>**method：**被拦截的方法（需要增强的方法）</li>\n<li>**args：**方法入参</li>\n<li>**proxy：**用于调用原始方法</li>\n</ol>\n<p>你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</p>\n<h4 id=\"3-2-2-CGLIB-动态代理类使用步骤\"><a href=\"#3-2-2-CGLIB-动态代理类使用步骤\" class=\"headerlink\" title=\"3.2.2. CGLIB 动态代理类使用步骤\"></a>3.2.2. CGLIB 动态代理类使用步骤</h4><ol>\n<li>定义一个类；</li>\n<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>\n<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>\n</ol>\n<h4 id=\"3-2-3-代码示例\"><a href=\"#3-2-3-代码示例\" class=\"headerlink\" title=\"3.2.3. 代码示例\"></a>3.2.3. 代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>cglib<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>cglib<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实现一个使用阿里云发送短信的类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliSmsService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;send message:&quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>自定义 MethodInterceptor（方法拦截器）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DebugMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> o           代理对象（增强的对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args        方法入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodProxy 用于调用原始方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> methodProxy.invokeSuper(o, args);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>获取代理类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CglibProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建动态代理增强类</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 设置类加载器</span></span><br><span class=\"line\">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class=\"line\">        <span class=\"comment\">// 设置被代理类</span></span><br><span class=\"line\">        enhancer.setSuperclass(clazz);</span><br><span class=\"line\">        <span class=\"comment\">// 设置方法拦截器</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">DebugMethodInterceptor</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>实际使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 静态代理和动态代理 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">AliSmsService</span> <span class=\"variable\">aliSmsService</span> <span class=\"operator\">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class=\"line\">        aliSmsService.send(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>执行结果：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before method send</span><br><span class=\"line\">send message:java</span><br><span class=\"line\">after method send</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-JDK动态代理和CGLIB动态代理对比\"><a href=\"#3-3-JDK动态代理和CGLIB动态代理对比\" class=\"headerlink\" title=\"3.3. JDK动态代理和CGLIB动态代理对比\"></a>3.3. JDK动态代理和CGLIB动态代理对比</h4><ol>\n<li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>\n<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>\n</ol>\n<p>4、静态代理和动态代理的对比</p>\n<hr>\n<ol>\n<li>灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>\n<li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Java实现代理模式\"><a href=\"#Java实现代理模式\" class=\"headerlink\" title=\"Java实现代理模式\"></a>Java实现代理模式</h1><p>Java实现代理模式</p>\n<p>1、代理模式</p>\n<hr>\n<p>代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>\n<p>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</p>\n<p>代理模式有<strong>静态代理</strong>和<strong>动态代理</strong>两种实现方式。</p>\n<p>2、静态代理</p>\n<hr>\n<p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>\n<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>\n<p>下面通过代码展示！ <strong>1</strong>​ **.<strong>​ ** 定义发送短信的接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2​-​-实现发送短信的接口\"><a href=\"#2​-​-实现发送短信的接口\" class=\"headerlink\" title=\"2​ **.​ ** 实现发送短信的接口\"></a><strong>2</strong>​ **.<strong>​ ** 实现发送短信的接口</strong></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;真实的 send message : &quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3​-​-创建代理类并同样实现发送短信的接口\"><a href=\"#3​-​-创建代理类并同样实现发送短信的接口\" class=\"headerlink\" title=\"3​ **.​ ** 创建代理类并同样实现发送短信的接口\"></a><strong>3</strong>​ **.<strong>​ ** 创建代理类并同样实现发送短信的接口</strong></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SmsService smsService;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SmsProxy</span><span class=\"params\">(SmsService smsService)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.smsService = smsService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;静态代理 before method send()&quot;</span>);</span><br><span class=\"line\">        smsService.send(message);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;静态代理 after method send()&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4​-​-实际使用\"><a href=\"#4​-​-实际使用\" class=\"headerlink\" title=\"4​ **.​ ** 实际使用\"></a><strong>4</strong>​ **.<strong>​ ** 实际使用</strong></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 静态代理和动态代理 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 静态代理</span></span><br><span class=\"line\">        <span class=\"type\">SmsService</span> <span class=\"variable\">smsService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">SmsProxy</span> <span class=\"variable\">smsProxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SmsProxy</span>(smsService);</span><br><span class=\"line\">        smsProxy.send(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5-执行结果：\"><a href=\"#5-执行结果：\" class=\"headerlink\" title=\"5.执行结果：\"></a>5.执行结果：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">静态代理 before method <span class=\"title function_\">send</span><span class=\"params\">()</span></span><br><span class=\"line\">真实的 send message : java</span><br><span class=\"line\">静态代理 after method <span class=\"title function_\">send</span><span class=\"params\">()</span></span><br></pre></td></tr></table></figure>\n\n<p>3、动态代理</p>\n<hr>\n<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类(CGLIB动态代理机制)。</p>\n<p>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>\n<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p>\n<p>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</p>\n<p>就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。</p>\n<p>guide-rpc-framework使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p>\n<p>另外，虽然 guide-rpc-framework 没有用到 CGLIB 动态代理 ，我们这里还是简单介绍一下其使用以及和JDK 动态代理的对比。</p>\n<h3 id=\"3-1-JDK-动态代理机制\"><a href=\"#3-1-JDK-动态代理机制\" class=\"headerlink\" title=\"3.1 JDK 动态代理机制\"></a>3.1 JDK 动态代理机制</h3><h4 id=\"3-1-1-介绍\"><a href=\"#3-1-1-介绍\" class=\"headerlink\" title=\"3.1.1 介绍\"></a>3.1.1 介绍</h4><p>在 Java 动态代理机制中 <code>*InvocationHandler*</code> 接口和 Proxy 类是核心。</p>\n<p>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"params\">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class=\"line\"><span class=\"params\">                                      InvocationHandler h)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> IllegalArgumentException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法一共有 3 个参数：</p>\n<ol>\n<li>**loader：**类加载器，用于加载代理对象。</li>\n<li>**interfaces：**被代理类实现的一些接口；</li>\n<li>**h：**实现了 <code>InvocationHandler</code> 接口的对象；</li>\n</ol>\n<p>要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>invoke()</code> 方法有下面三个参数：</p>\n<ol>\n<li>**proxy：**动态生成的代理类</li>\n<li>**methoh：**与代理类对象调用的方法相对应</li>\n<li>**args：**当前 method 方法的参数</li>\n</ol>\n<p>也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>\n<h5 id=\"3-1-2-JDK-动态代理类使用步骤\"><a href=\"#3-1-2-JDK-动态代理类使用步骤\" class=\"headerlink\" title=\"3.1.2 JDK 动态代理类使用步骤\"></a>3.1.2 JDK 动态代理类使用步骤</h5><p>定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象；</p>\n<h5 id=\"3-1-2-代码示例\"><a href=\"#3-1-2-代码示例\" class=\"headerlink\" title=\"3.1.2 代码示例\"></a>3.1.2 代码示例</h5><ol>\n<li>定义发送短信的接口</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实现发送短信的接口</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SmsServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmsService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;真实的 send message : &quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>定义一个JDK动态代理类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DebugInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 代理类中的真实对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DebugInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;JDK动态代理 before method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;JDK动态代理 after method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>获取代理对象的工厂类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JdkProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(</span><br><span class=\"line\">            target.getClass().getClassLoader(), <span class=\"comment\">// 目标类的类加载</span></span><br><span class=\"line\">            target.getClass().getInterfaces(),  <span class=\"comment\">// 代理需要实现的接口，可指定多个</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">DebugInvocationHandler</span>(target)   <span class=\"comment\">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实际使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 静态代理和动态代理 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SmsService</span> <span class=\"variable\">smsService1</span> <span class=\"operator\">=</span> (SmsService) JdkProxyFactory.getProxy(<span class=\"keyword\">new</span> <span class=\"title class_\">SmsServiceImpl</span>());</span><br><span class=\"line\">        smsService1.send(<span class=\"string\">&quot;Java!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>执行结果：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JDK动态代理 before method send</span><br><span class=\"line\">真实的 send message : Java!</span><br><span class=\"line\">JDK动态代理 after method send</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-CGLIB-动态代理机制\"><a href=\"#3-2-CGLIB-动态代理机制\" class=\"headerlink\" title=\"3.2. CGLIB 动态代理机制\"></a>3.2. CGLIB 动态代理机制</h3><h4 id=\"3-2-1-介绍\"><a href=\"#3-2-1-介绍\" class=\"headerlink\" title=\"3.2.1. 介绍\"></a>3.2.1. 介绍</h4><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>\n<p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>\n<p>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</p>\n<p>你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MethodInterceptor</span></span><br><span class=\"line\"><span class=\"keyword\">extends</span> <span class=\"title class_\">Callback</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 拦截被代理类中的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class=\"line\"><span class=\"params\">                               MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>**obj：**被代理的对象（需要增强的对象）</li>\n<li>**method：**被拦截的方法（需要增强的方法）</li>\n<li>**args：**方法入参</li>\n<li>**proxy：**用于调用原始方法</li>\n</ol>\n<p>你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。</p>\n<h4 id=\"3-2-2-CGLIB-动态代理类使用步骤\"><a href=\"#3-2-2-CGLIB-动态代理类使用步骤\" class=\"headerlink\" title=\"3.2.2. CGLIB 动态代理类使用步骤\"></a>3.2.2. CGLIB 动态代理类使用步骤</h4><ol>\n<li>定义一个类；</li>\n<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>\n<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>\n</ol>\n<h4 id=\"3-2-3-代码示例\"><a href=\"#3-2-3-代码示例\" class=\"headerlink\" title=\"3.2.3. 代码示例\"></a>3.2.3. 代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>cglib<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>cglib<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实现一个使用阿里云发送短信的类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AliSmsService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;send message:&quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>自定义 MethodInterceptor（方法拦截器）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DebugMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> o           代理对象（增强的对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args        方法入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodProxy 用于调用原始方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> methodProxy.invokeSuper(o, args);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>获取代理类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CglibProxyFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getProxy</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建动态代理增强类</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 设置类加载器</span></span><br><span class=\"line\">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class=\"line\">        <span class=\"comment\">// 设置被代理类</span></span><br><span class=\"line\">        enhancer.setSuperclass(clazz);</span><br><span class=\"line\">        <span class=\"comment\">// 设置方法拦截器</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">DebugMethodInterceptor</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>实际使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class 静态代理和动态代理 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">AliSmsService</span> <span class=\"variable\">aliSmsService</span> <span class=\"operator\">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class=\"line\">        aliSmsService.send(<span class=\"string\">&quot;java&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>执行结果：</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before method send</span><br><span class=\"line\">send message:java</span><br><span class=\"line\">after method send</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-JDK动态代理和CGLIB动态代理对比\"><a href=\"#3-3-JDK动态代理和CGLIB动态代理对比\" class=\"headerlink\" title=\"3.3. JDK动态代理和CGLIB动态代理对比\"></a>3.3. JDK动态代理和CGLIB动态代理对比</h4><ol>\n<li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>\n<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>\n</ol>\n<p>4、静态代理和动态代理的对比</p>\n<hr>\n<ol>\n<li>灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>\n<li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>\n</ol>\n"},{"title":"Java List 分片工具类","date":"2024-12-30T02:58:24.000Z","updated":"2024-12-30T03:01:28.000Z","excerpt":"本文介绍了如何使用Java将一个大List分片为多个小List，每个小List的大小为50。通过`subList`方法实现分片，具体步骤包括：确定原List大小、使用循环分组、获取子列表并复制到新ArrayList、处理边界情况等。代码示例展示了如何实现分组功能，并解释了关键点，如检查分组大小、处理边界情况等。注意事项包括`subList`返回的是动态视图、处理原List大小不能被整除的情况，以及多线程环境下的使用建议。该方法适用于需要将大List分组的场景。","comments":1,"toc":true,"abbrlink":14367,"_content":"\n# Java List 分片工具类\n\n为了将一个大的List分组为多个小的List，每个小List的大小为50，我们可以使用Java中的`subList`​方法来实现。以下是详细的实现步骤和代码示例：\n\n### 实现步骤\n\n1. **确定原List的大小**：获取原List的大小，以便确定需要分成多少个小组。\n2. **使用循环分组**：使用一个循环，每次取50个元素，直到处理完整个原List。\n3. **获取子列表并复制**：使用`subList`​方法获取子列表，并将其复制到一个新的ArrayList中，以避免与原List的关联。\n4. **将新的ArrayList加入到结果List中**：将包含50个元素的新ArrayList加入到结果List中。\n5. **处理边界情况**：确保循环的索引不会越界，避免`IndexOutOfBoundsException`​。\n\n### 代码示例\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListGrouping {\n\n    public static <T> List<List<T>> groupList(List<T> originalList, int groupSize) {\n        if (groupSize <= 0) {\n            throw new IllegalArgumentException(\"Group size must be positive.\");\n        }\n        List<List<T>> result = new ArrayList<>();\n        int size = originalList.size();\n        for (int i = 0; i < size; i += groupSize) {\n            int endIndex = i + groupSize;\n            if (endIndex > size) {\n                endIndex = size;\n            }\n            List<T> sub = new ArrayList<>(originalList.subList(i, endIndex));\n            result.add(sub);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> original = new ArrayList<>();\n        for (int i = 1; i <= 10; i++) {\n            original.add(i);\n        }\n        List<List<Integer>> groups = groupList(original, 4);\n        System.out.println(groups); // 输出: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]\n    }\n}\n```\n\n### 代码解释\n\n* **groupList方法**：\n\n  * 检查分组大小`groupSize`​是否为正数，如果是非正数则抛出异常。\n  * 初始化结果List来存储分组后的子List。\n  * 使用循环遍历原List，每次取`groupSize`​个元素，创建新的ArrayList并加入结果List中。\n  * 处理边界情况，确保`endIndex`​不超过原List的大小。\n* **main方法**：\n\n  * 创建一个包含10个元素的原List。\n  * 调用`groupList`​方法将原List分组，每组4个元素。\n  * 打印分组结果。\n\n### 注意事项\n\n* **动态视图**：`subList`​返回的是原List的视图，直接使用可能影响原List的修改，因此需要复制到新的ArrayList中。\n* **边界情况**：处理原List大小不能被`groupSize`​整除的情况，确保最后一组包含剩余的所有元素。\n* **多线程环境**：如果在多线程环境下使用，确保原List在分组过程中不被修改，或者使用不可变的List。\n\n通过以上方法，可以有效地将一个大的List分组为多个小的List，每个小List的大小为指定的值，例如50。\n","source":"_posts/java-list-itzf4.md","raw":"---\ntitle: Java List 分片工具类\ndate: '2024-12-30 10:58:24'\nupdated: '2024-12-30 11:01:28'\nexcerpt: >-\n  本文介绍了如何使用Java将一个大List分片为多个小List，每个小List的大小为50。通过`subList`方法实现分片，具体步骤包括：确定原List大小、使用循环分组、获取子列表并复制到新ArrayList、处理边界情况等。代码示例展示了如何实现分组功能，并解释了关键点，如检查分组大小、处理边界情况等。注意事项包括`subList`返回的是动态视图、处理原List大小不能被整除的情况，以及多线程环境下的使用建议。该方法适用于需要将大List分组的场景。\ntags:\n  - Java\n  - List\n  - 分片\n  - 分组\n  - 工具类\ncategories:\n  - java\n  - 工具类\npermalink: /post/java-list-itzf4.html\ncomments: true\ntoc: true\nabbrlink: 14367\n---\n\n# Java List 分片工具类\n\n为了将一个大的List分组为多个小的List，每个小List的大小为50，我们可以使用Java中的`subList`​方法来实现。以下是详细的实现步骤和代码示例：\n\n### 实现步骤\n\n1. **确定原List的大小**：获取原List的大小，以便确定需要分成多少个小组。\n2. **使用循环分组**：使用一个循环，每次取50个元素，直到处理完整个原List。\n3. **获取子列表并复制**：使用`subList`​方法获取子列表，并将其复制到一个新的ArrayList中，以避免与原List的关联。\n4. **将新的ArrayList加入到结果List中**：将包含50个元素的新ArrayList加入到结果List中。\n5. **处理边界情况**：确保循环的索引不会越界，避免`IndexOutOfBoundsException`​。\n\n### 代码示例\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ListGrouping {\n\n    public static <T> List<List<T>> groupList(List<T> originalList, int groupSize) {\n        if (groupSize <= 0) {\n            throw new IllegalArgumentException(\"Group size must be positive.\");\n        }\n        List<List<T>> result = new ArrayList<>();\n        int size = originalList.size();\n        for (int i = 0; i < size; i += groupSize) {\n            int endIndex = i + groupSize;\n            if (endIndex > size) {\n                endIndex = size;\n            }\n            List<T> sub = new ArrayList<>(originalList.subList(i, endIndex));\n            result.add(sub);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> original = new ArrayList<>();\n        for (int i = 1; i <= 10; i++) {\n            original.add(i);\n        }\n        List<List<Integer>> groups = groupList(original, 4);\n        System.out.println(groups); // 输出: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]\n    }\n}\n```\n\n### 代码解释\n\n* **groupList方法**：\n\n  * 检查分组大小`groupSize`​是否为正数，如果是非正数则抛出异常。\n  * 初始化结果List来存储分组后的子List。\n  * 使用循环遍历原List，每次取`groupSize`​个元素，创建新的ArrayList并加入结果List中。\n  * 处理边界情况，确保`endIndex`​不超过原List的大小。\n* **main方法**：\n\n  * 创建一个包含10个元素的原List。\n  * 调用`groupList`​方法将原List分组，每组4个元素。\n  * 打印分组结果。\n\n### 注意事项\n\n* **动态视图**：`subList`​返回的是原List的视图，直接使用可能影响原List的修改，因此需要复制到新的ArrayList中。\n* **边界情况**：处理原List大小不能被`groupSize`​整除的情况，确保最后一组包含剩余的所有元素。\n* **多线程环境**：如果在多线程环境下使用，确保原List在分组过程中不被修改，或者使用不可变的List。\n\n通过以上方法，可以有效地将一个大的List分组为多个小的List，每个小List的大小为指定的值，例如50。\n","slug":"java-list-itzf4","published":1,"__permalink":"/post/java-list-itzf4.html","_id":"cmclcaf3q0009p8vw9oj28ohx","layout":"post","photos":[],"content":"<h1 id=\"Java-List-分片工具类\"><a href=\"#Java-List-分片工具类\" class=\"headerlink\" title=\"Java List 分片工具类\"></a>Java List 分片工具类</h1><p>为了将一个大的List分组为多个小的List，每个小List的大小为50，我们可以使用Java中的<code>subList</code>​方法来实现。以下是详细的实现步骤和代码示例：</p>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><ol>\n<li><strong>确定原List的大小</strong>：获取原List的大小，以便确定需要分成多少个小组。</li>\n<li><strong>使用循环分组</strong>：使用一个循环，每次取50个元素，直到处理完整个原List。</li>\n<li><strong>获取子列表并复制</strong>：使用<code>subList</code>​方法获取子列表，并将其复制到一个新的ArrayList中，以避免与原List的关联。</li>\n<li><strong>将新的ArrayList加入到结果List中</strong>：将包含50个元素的新ArrayList加入到结果List中。</li>\n<li><strong>处理边界情况</strong>：确保循环的索引不会越界，避免<code>IndexOutOfBoundsException</code>​。</li>\n</ol>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListGrouping</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; List&lt;List&lt;T&gt;&gt; <span class=\"title function_\">groupList</span><span class=\"params\">(List&lt;T&gt; originalList, <span class=\"type\">int</span> groupSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (groupSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Group size must be positive.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;T&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> originalList.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i += groupSize) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">endIndex</span> <span class=\"operator\">=</span> i + groupSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (endIndex &gt; size) &#123;</span><br><span class=\"line\">                endIndex = size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            List&lt;T&gt; sub = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(originalList.subList(i, endIndex));</span><br><span class=\"line\">            result.add(sub);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; original = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            original.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; groups = groupList(original, <span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(groups); <span class=\"comment\">// 输出: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><ul>\n<li><p><strong>groupList方法</strong>：</p>\n<ul>\n<li>检查分组大小<code>groupSize</code>​是否为正数，如果是非正数则抛出异常。</li>\n<li>初始化结果List来存储分组后的子List。</li>\n<li>使用循环遍历原List，每次取<code>groupSize</code>​个元素，创建新的ArrayList并加入结果List中。</li>\n<li>处理边界情况，确保<code>endIndex</code>​不超过原List的大小。</li>\n</ul>\n</li>\n<li><p><strong>main方法</strong>：</p>\n<ul>\n<li>创建一个包含10个元素的原List。</li>\n<li>调用<code>groupList</code>​方法将原List分组，每组4个元素。</li>\n<li>打印分组结果。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li><strong>动态视图</strong>：<code>subList</code>​返回的是原List的视图，直接使用可能影响原List的修改，因此需要复制到新的ArrayList中。</li>\n<li><strong>边界情况</strong>：处理原List大小不能被<code>groupSize</code>​整除的情况，确保最后一组包含剩余的所有元素。</li>\n<li><strong>多线程环境</strong>：如果在多线程环境下使用，确保原List在分组过程中不被修改，或者使用不可变的List。</li>\n</ul>\n<p>通过以上方法，可以有效地将一个大的List分组为多个小的List，每个小List的大小为指定的值，例如50。</p>\n","more":"<h1 id=\"Java-List-分片工具类\"><a href=\"#Java-List-分片工具类\" class=\"headerlink\" title=\"Java List 分片工具类\"></a>Java List 分片工具类</h1><p>为了将一个大的List分组为多个小的List，每个小List的大小为50，我们可以使用Java中的<code>subList</code>​方法来实现。以下是详细的实现步骤和代码示例：</p>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><ol>\n<li><strong>确定原List的大小</strong>：获取原List的大小，以便确定需要分成多少个小组。</li>\n<li><strong>使用循环分组</strong>：使用一个循环，每次取50个元素，直到处理完整个原List。</li>\n<li><strong>获取子列表并复制</strong>：使用<code>subList</code>​方法获取子列表，并将其复制到一个新的ArrayList中，以避免与原List的关联。</li>\n<li><strong>将新的ArrayList加入到结果List中</strong>：将包含50个元素的新ArrayList加入到结果List中。</li>\n<li><strong>处理边界情况</strong>：确保循环的索引不会越界，避免<code>IndexOutOfBoundsException</code>​。</li>\n</ol>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListGrouping</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; List&lt;List&lt;T&gt;&gt; <span class=\"title function_\">groupList</span><span class=\"params\">(List&lt;T&gt; originalList, <span class=\"type\">int</span> groupSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (groupSize &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Group size must be positive.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;T&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> originalList.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i += groupSize) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">endIndex</span> <span class=\"operator\">=</span> i + groupSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (endIndex &gt; size) &#123;</span><br><span class=\"line\">                endIndex = size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            List&lt;T&gt; sub = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(originalList.subList(i, endIndex));</span><br><span class=\"line\">            result.add(sub);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; original = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            original.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; groups = groupList(original, <span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(groups); <span class=\"comment\">// 输出: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码解释\"><a href=\"#代码解释\" class=\"headerlink\" title=\"代码解释\"></a>代码解释</h3><ul>\n<li><p><strong>groupList方法</strong>：</p>\n<ul>\n<li>检查分组大小<code>groupSize</code>​是否为正数，如果是非正数则抛出异常。</li>\n<li>初始化结果List来存储分组后的子List。</li>\n<li>使用循环遍历原List，每次取<code>groupSize</code>​个元素，创建新的ArrayList并加入结果List中。</li>\n<li>处理边界情况，确保<code>endIndex</code>​不超过原List的大小。</li>\n</ul>\n</li>\n<li><p><strong>main方法</strong>：</p>\n<ul>\n<li>创建一个包含10个元素的原List。</li>\n<li>调用<code>groupList</code>​方法将原List分组，每组4个元素。</li>\n<li>打印分组结果。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li><strong>动态视图</strong>：<code>subList</code>​返回的是原List的视图，直接使用可能影响原List的修改，因此需要复制到新的ArrayList中。</li>\n<li><strong>边界情况</strong>：处理原List大小不能被<code>groupSize</code>​整除的情况，确保最后一组包含剩余的所有元素。</li>\n<li><strong>多线程环境</strong>：如果在多线程环境下使用，确保原List在分组过程中不被修改，或者使用不可变的List。</li>\n</ul>\n<p>通过以上方法，可以有效地将一个大的List分组为多个小的List，每个小List的大小为指定的值，例如50。</p>\n"},{"title":"Nacos配置中心并支持多配置文件","date":"2024-12-19T01:59:49.000Z","updated":"2024-12-19T16:12:14.000Z","comments":1,"toc":true,"abbrlink":42899,"_content":"\n# Nacos配置中心并支持多配置文件\n\n### 一、引入依赖包\n\n---\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n> discovery和config分别为注册中心客户端和配置中心客户端\n>\n> 注意：\n>\n> 1. config，引入这个配置中心的依赖后，需要使用bootstrap.yml作为中转配置文件，读取的优先级为bootstrap.yml>application.yml\n> 2. 配置中心地址结尾不能带斜杠 否者会报异常\n\n### 二、单文件配置\n\n---\n\n```yml\nspring:\n  application:\n    name: onedata\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://172.20.23.140:80\n      config:\n         server-addr: http://172.20.23.140:80\n         group: DEFAULT_GROUP\n         file-extension: yml\n```\n\n三、多文件配置\n\n---\n\n1、创建bootstrap.yml,配置激活环境标识\n\n```yml\nspring:\n  profiles:\n    active: dev\n```\n\n2、创建bootstrap-dev.yml文件，配置连接nacos服务中心，加载多个配置文件\n\n**写法一：**\n\n```yml\nspring:\n  application:\n    name: mybatis-plus-join-practice\n  #配置nacos注册中心和配置中心\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://xxx:8848\n        username: nacos\n        password: nacos\n        namespace: dev\n        group: MYBATIS-PLUS-JOIN-PRACTICE\n      config:\n        server-addr: ${spring.cloud.nacos.discovery.server-addr}\n        username: ${spring.cloud.nacos.discovery.username}\n        password: ${spring.cloud.nacos.discovery.password}\n        namespace: ${spring.cloud.nacos.discovery.namespace}\n        file-extension: yml  # yaml格式\n        extension-configs:\n          - data-id: application.yml\n            group: ${spring.cloud.nacos.discovery.group}\n            refresh: true\n \n          - data-id: datasource.yml\n            group: ${spring.cloud.nacos.discovery.group}\n            refresh: true\n```\n\n**写法二：**\n\n```yaml\nspring:\n  application:\n    name: mybatis-plus-join-practice\n  #配置nacos注册中心和配置中心\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://xxx:8848\n        username: nacos\n        password: nacos\n        namespace: dev\n        group: MYBATIS-PLUS-JOIN-PRACTICE\n      config:\n        server-addr: ${spring.cloud.nacos.discovery.server-addr}\n        username: ${spring.cloud.nacos.discovery.username}\n        password: ${spring.cloud.nacos.discovery.password}\n        namespace: ${spring.cloud.nacos.discovery.namespace}\n        extension-configs[0]:\n          data-id: application.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n \n        extension-configs[1]:\n          data-id: datasource.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n```\n\n**写法三：**\n\n```yaml\nspring:\n  application:\n    name: mybatis-plus-join-practice\n  #配置nacos注册中心和配置中心\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://xxx:8848\n        username: nacos\n        password: nacos\n        namespace: dev\n        group: MYBATIS-PLUS-JOIN-PRACTICE\n      config:\n        server-addr: ${spring.cloud.nacos.discovery.server-addr}\n        username: ${spring.cloud.nacos.discovery.username}\n        password: ${spring.cloud.nacos.discovery.password}\n        namespace: ${spring.cloud.nacos.discovery.namespace}\n        shared-configs[0]:\n          data-id: application.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n \n        shared-configs[1]:\n          data-id: datasource.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n```\n\n说明： 1、以上三种写法都支持加载多个配置文件 1、内容中 extension-configs\\[0\\]、shared-configs\\[0\\] 加载的是 application.yml 配置文件 2、内容中 extension-configs\\[1\\]、shared-configs\\[1\\] 加载的是 datasource.yml 配置文件 3、配置文件在激活标识的 dev 环境的 MYBATIS-PLUS-PRACTICE 分组下\n\n> 1、在实际应用中，可以使用多文件配置，把spring配置和数据源配置分开\n>\n> 2、可以使用命名空间区分不同的环境，例如：dev,sit,uat等环境\n>\n> 3、权限控制开启方式，在conf/applicaiton.properties文件中修改属性值即可，如下\n>\n> `nacos.core.auth.enabled=true`\n>\n> 4、如果服务端开启了权限控制，注册中心和配置中心需要明确指定访问用户名和密码，命名空间才可以正常访问\n","source":"_posts/nacos-configuration-center-and-support-multi-configuration-files-zi2mmf.md","raw":"---\ntitle: Nacos配置中心并支持多配置文件\ndate: '2024-12-19 09:59:49'\nupdated: '2024-12-20 00:12:14'\npermalink: >-\n  /post/nacos-configuration-center-and-support-multi-configuration-files-zi2mmf.html\ncomments: true\ntoc: true\nabbrlink: 42899\n---\n\n# Nacos配置中心并支持多配置文件\n\n### 一、引入依赖包\n\n---\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n> discovery和config分别为注册中心客户端和配置中心客户端\n>\n> 注意：\n>\n> 1. config，引入这个配置中心的依赖后，需要使用bootstrap.yml作为中转配置文件，读取的优先级为bootstrap.yml>application.yml\n> 2. 配置中心地址结尾不能带斜杠 否者会报异常\n\n### 二、单文件配置\n\n---\n\n```yml\nspring:\n  application:\n    name: onedata\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://172.20.23.140:80\n      config:\n         server-addr: http://172.20.23.140:80\n         group: DEFAULT_GROUP\n         file-extension: yml\n```\n\n三、多文件配置\n\n---\n\n1、创建bootstrap.yml,配置激活环境标识\n\n```yml\nspring:\n  profiles:\n    active: dev\n```\n\n2、创建bootstrap-dev.yml文件，配置连接nacos服务中心，加载多个配置文件\n\n**写法一：**\n\n```yml\nspring:\n  application:\n    name: mybatis-plus-join-practice\n  #配置nacos注册中心和配置中心\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://xxx:8848\n        username: nacos\n        password: nacos\n        namespace: dev\n        group: MYBATIS-PLUS-JOIN-PRACTICE\n      config:\n        server-addr: ${spring.cloud.nacos.discovery.server-addr}\n        username: ${spring.cloud.nacos.discovery.username}\n        password: ${spring.cloud.nacos.discovery.password}\n        namespace: ${spring.cloud.nacos.discovery.namespace}\n        file-extension: yml  # yaml格式\n        extension-configs:\n          - data-id: application.yml\n            group: ${spring.cloud.nacos.discovery.group}\n            refresh: true\n \n          - data-id: datasource.yml\n            group: ${spring.cloud.nacos.discovery.group}\n            refresh: true\n```\n\n**写法二：**\n\n```yaml\nspring:\n  application:\n    name: mybatis-plus-join-practice\n  #配置nacos注册中心和配置中心\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://xxx:8848\n        username: nacos\n        password: nacos\n        namespace: dev\n        group: MYBATIS-PLUS-JOIN-PRACTICE\n      config:\n        server-addr: ${spring.cloud.nacos.discovery.server-addr}\n        username: ${spring.cloud.nacos.discovery.username}\n        password: ${spring.cloud.nacos.discovery.password}\n        namespace: ${spring.cloud.nacos.discovery.namespace}\n        extension-configs[0]:\n          data-id: application.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n \n        extension-configs[1]:\n          data-id: datasource.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n```\n\n**写法三：**\n\n```yaml\nspring:\n  application:\n    name: mybatis-plus-join-practice\n  #配置nacos注册中心和配置中心\n  cloud:\n    nacos:\n      discovery:\n        server-addr: http://xxx:8848\n        username: nacos\n        password: nacos\n        namespace: dev\n        group: MYBATIS-PLUS-JOIN-PRACTICE\n      config:\n        server-addr: ${spring.cloud.nacos.discovery.server-addr}\n        username: ${spring.cloud.nacos.discovery.username}\n        password: ${spring.cloud.nacos.discovery.password}\n        namespace: ${spring.cloud.nacos.discovery.namespace}\n        shared-configs[0]:\n          data-id: application.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n \n        shared-configs[1]:\n          data-id: datasource.yml\n          group: ${spring.cloud.nacos.discovery.group}\n          refresh: true\n          file-extension: yml\n```\n\n说明： 1、以上三种写法都支持加载多个配置文件 1、内容中 extension-configs\\[0\\]、shared-configs\\[0\\] 加载的是 application.yml 配置文件 2、内容中 extension-configs\\[1\\]、shared-configs\\[1\\] 加载的是 datasource.yml 配置文件 3、配置文件在激活标识的 dev 环境的 MYBATIS-PLUS-PRACTICE 分组下\n\n> 1、在实际应用中，可以使用多文件配置，把spring配置和数据源配置分开\n>\n> 2、可以使用命名空间区分不同的环境，例如：dev,sit,uat等环境\n>\n> 3、权限控制开启方式，在conf/applicaiton.properties文件中修改属性值即可，如下\n>\n> `nacos.core.auth.enabled=true`\n>\n> 4、如果服务端开启了权限控制，注册中心和配置中心需要明确指定访问用户名和密码，命名空间才可以正常访问\n","slug":"nacos-configuration-center-and-support-multi-configuration-files-zi2mmf","published":1,"__permalink":"/post/nacos-configuration-center-and-support-multi-configuration-files-zi2mmf.html","_id":"cmclcaf3t000bp8vwfq0nfthe","layout":"post","photos":[],"content":"<h1 id=\"Nacos配置中心并支持多配置文件\"><a href=\"#Nacos配置中心并支持多配置文件\" class=\"headerlink\" title=\"Nacos配置中心并支持多配置文件\"></a>Nacos配置中心并支持多配置文件</h1><h3 id=\"一、引入依赖包\"><a href=\"#一、引入依赖包\" class=\"headerlink\" title=\"一、引入依赖包\"></a>一、引入依赖包</h3><hr>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>discovery和config分别为注册中心客户端和配置中心客户端</p>\n<p>注意：</p>\n<ol>\n<li>config，引入这个配置中心的依赖后，需要使用bootstrap.yml作为中转配置文件，读取的优先级为bootstrap.yml&gt;application.yml</li>\n<li>配置中心地址结尾不能带斜杠 否者会报异常</li>\n</ol>\n</blockquote>\n<h3 id=\"二、单文件配置\"><a href=\"#二、单文件配置\" class=\"headerlink\" title=\"二、单文件配置\"></a>二、单文件配置</h3><hr>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">onedata</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://172.20.23.140:80</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">         <span class=\"attr\">server-addr:</span> <span class=\"string\">http://172.20.23.140:80</span></span><br><span class=\"line\">         <span class=\"attr\">group:</span> <span class=\"string\">DEFAULT_GROUP</span></span><br><span class=\"line\">         <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br></pre></td></tr></table></figure>\n\n<p>三、多文件配置</p>\n<hr>\n<p>1、创建bootstrap.yml,配置激活环境标识</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profiles:</span></span><br><span class=\"line\">    <span class=\"attr\">active:</span> <span class=\"string\">dev</span></span><br></pre></td></tr></table></figure>\n\n<p>2、创建bootstrap-dev.yml文件，配置连接nacos服务中心，加载多个配置文件</p>\n<p><strong>写法一：</strong></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">mybatis-plus-join-practice</span></span><br><span class=\"line\">  <span class=\"comment\">#配置nacos注册中心和配置中心</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://xxx:8848</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">        <span class=\"attr\">group:</span> <span class=\"string\">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span>  <span class=\"comment\"># yaml格式</span></span><br><span class=\"line\">        <span class=\"attr\">extension-configs:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">application.yml</span></span><br><span class=\"line\">            <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">datasource.yml</span></span><br><span class=\"line\">            <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>写法二：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">mybatis-plus-join-practice</span></span><br><span class=\"line\">  <span class=\"comment\">#配置nacos注册中心和配置中心</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://xxx:8848</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">        <span class=\"attr\">group:</span> <span class=\"string\">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class=\"line\">        <span class=\"string\">extension-configs[0]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">application.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"string\">extension-configs[1]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">datasource.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>写法三：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">mybatis-plus-join-practice</span></span><br><span class=\"line\">  <span class=\"comment\">#配置nacos注册中心和配置中心</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://xxx:8848</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">        <span class=\"attr\">group:</span> <span class=\"string\">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class=\"line\">        <span class=\"string\">shared-configs[0]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">application.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"string\">shared-configs[1]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">datasource.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br></pre></td></tr></table></figure>\n\n<p>说明： 1、以上三种写法都支持加载多个配置文件 1、内容中 extension-configs[0]、shared-configs[0] 加载的是 application.yml 配置文件 2、内容中 extension-configs[1]、shared-configs[1] 加载的是 datasource.yml 配置文件 3、配置文件在激活标识的 dev 环境的 MYBATIS-PLUS-PRACTICE 分组下</p>\n<blockquote>\n<p>1、在实际应用中，可以使用多文件配置，把spring配置和数据源配置分开</p>\n<p>2、可以使用命名空间区分不同的环境，例如：dev,sit,uat等环境</p>\n<p>3、权限控制开启方式，在conf&#x2F;applicaiton.properties文件中修改属性值即可，如下</p>\n<p><code>nacos.core.auth.enabled=true</code></p>\n<p>4、如果服务端开启了权限控制，注册中心和配置中心需要明确指定访问用户名和密码，命名空间才可以正常访问</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"Nacos配置中心并支持多配置文件\"><a href=\"#Nacos配置中心并支持多配置文件\" class=\"headerlink\" title=\"Nacos配置中心并支持多配置文件\"></a>Nacos配置中心并支持多配置文件</h1><h3 id=\"一、引入依赖包\"><a href=\"#一、引入依赖包\" class=\"headerlink\" title=\"一、引入依赖包\"></a>一、引入依赖包</h3><hr>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>discovery和config分别为注册中心客户端和配置中心客户端</p>\n<p>注意：</p>\n<ol>\n<li>config，引入这个配置中心的依赖后，需要使用bootstrap.yml作为中转配置文件，读取的优先级为bootstrap.yml&gt;application.yml</li>\n<li>配置中心地址结尾不能带斜杠 否者会报异常</li>\n</ol>\n</blockquote>\n<h3 id=\"二、单文件配置\"><a href=\"#二、单文件配置\" class=\"headerlink\" title=\"二、单文件配置\"></a>二、单文件配置</h3><hr>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">onedata</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://172.20.23.140:80</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">         <span class=\"attr\">server-addr:</span> <span class=\"string\">http://172.20.23.140:80</span></span><br><span class=\"line\">         <span class=\"attr\">group:</span> <span class=\"string\">DEFAULT_GROUP</span></span><br><span class=\"line\">         <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br></pre></td></tr></table></figure>\n\n<p>三、多文件配置</p>\n<hr>\n<p>1、创建bootstrap.yml,配置激活环境标识</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profiles:</span></span><br><span class=\"line\">    <span class=\"attr\">active:</span> <span class=\"string\">dev</span></span><br></pre></td></tr></table></figure>\n\n<p>2、创建bootstrap-dev.yml文件，配置连接nacos服务中心，加载多个配置文件</p>\n<p><strong>写法一：</strong></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">mybatis-plus-join-practice</span></span><br><span class=\"line\">  <span class=\"comment\">#配置nacos注册中心和配置中心</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://xxx:8848</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">        <span class=\"attr\">group:</span> <span class=\"string\">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span>  <span class=\"comment\"># yaml格式</span></span><br><span class=\"line\">        <span class=\"attr\">extension-configs:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">application.yml</span></span><br><span class=\"line\">            <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">datasource.yml</span></span><br><span class=\"line\">            <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>写法二：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">mybatis-plus-join-practice</span></span><br><span class=\"line\">  <span class=\"comment\">#配置nacos注册中心和配置中心</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://xxx:8848</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">        <span class=\"attr\">group:</span> <span class=\"string\">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class=\"line\">        <span class=\"string\">extension-configs[0]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">application.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"string\">extension-configs[1]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">datasource.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>写法三：</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">mybatis-plus-join-practice</span></span><br><span class=\"line\">  <span class=\"comment\">#配置nacos注册中心和配置中心</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">http://xxx:8848</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">nacos</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">        <span class=\"attr\">group:</span> <span class=\"string\">MYBATIS-PLUS-JOIN-PRACTICE</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.username&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.password&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.namespace&#125;</span></span><br><span class=\"line\">        <span class=\"string\">shared-configs[0]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">application.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"string\">shared-configs[1]:</span></span><br><span class=\"line\">          <span class=\"attr\">data-id:</span> <span class=\"string\">datasource.yml</span></span><br><span class=\"line\">          <span class=\"attr\">group:</span> <span class=\"string\">$&#123;spring.cloud.nacos.discovery.group&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">file-extension:</span> <span class=\"string\">yml</span></span><br></pre></td></tr></table></figure>\n\n<p>说明： 1、以上三种写法都支持加载多个配置文件 1、内容中 extension-configs[0]、shared-configs[0] 加载的是 application.yml 配置文件 2、内容中 extension-configs[1]、shared-configs[1] 加载的是 datasource.yml 配置文件 3、配置文件在激活标识的 dev 环境的 MYBATIS-PLUS-PRACTICE 分组下</p>\n<blockquote>\n<p>1、在实际应用中，可以使用多文件配置，把spring配置和数据源配置分开</p>\n<p>2、可以使用命名空间区分不同的环境，例如：dev,sit,uat等环境</p>\n<p>3、权限控制开启方式，在conf&#x2F;applicaiton.properties文件中修改属性值即可，如下</p>\n<p><code>nacos.core.auth.enabled=true</code></p>\n<p>4、如果服务端开启了权限控制，注册中心和配置中心需要明确指定访问用户名和密码，命名空间才可以正常访问</p>\n</blockquote>\n"},{"title":"nginx 配置rtsp服务","date":"2024-12-27T01:25:55.000Z","updated":"2024-12-27T01:27:53.000Z","excerpt":"本文详细介绍了在Ubuntu系统上配置Nginx以提供RTSP服务的步骤。首先，安装编译工具和依赖包；其次，下载并编译Nginx及其rtsp模块；然后，在Nginx配置文件中添加RTSP服务器配置，并设置基本认证；接着，配置防火墙开放端口；最后，测试配置并使用VLC播放器测试RTSP服务。文章还提供了结合RTMP的高级配置示例，以供进一步扩展服务功能。","comments":1,"toc":true,"abbrlink":19461,"_content":"\n# nginx 配置rtsp服务\n\n配置 Nginx 提供 RTSP 服务涉及安装和编译第三方模块 nginx-rtsp-module，并进行相应的配置。以下是详细的步骤和配置示例：\n\n### 步骤 1: 安装依赖和工具\n\n在 Ubuntu 上，安装必要的编译工具和依赖包：\n\n```\nsudo apt-get update\nsudo apt-get install build-essential libpcre3-dev\n```\n\n### 步骤 2: 下载并编译 Nginx 及模块\n\n1. 克隆 nginx-rtsp-module 仓库：\n\n    ```\n    git clone https://github.com/arut/nginx-rtsp-module.git\n    ```\n2. 下载 Nginx 源码（使用稳定版本）：\n\n    ```\n    wget http://nginx.org/download/nginx-1.21.3.tar.gz\n    tar -zxvf nginx-1.21.3.tar.gz\n    cd nginx-1.21.3\n    ```\n3. 配置编译选项并加入 nginx-rtsp-module：\n\n    ```\n    ./configure --add-module=../nginx-rtsp-module\n    ```\n4. 编译并安装：\n\n    ```\n    make\n    sudo make install\n    ```\n\n### 步骤 3: 配置 Nginx\n\n在 Nginx 配置文件中添加 RTSP 服务器配置：\n\n```\nrtsp {\n    listen 8554;\n    server_name localhost;\n\n    auth_basic \"Restricted\";\n    auth_basic_user_file /etc/nginx/.htpasswd;\n\n    access_log /var/log/nginx/rtsp_access.log;\n    error_log /var/log/nginx/rtsp_error.log;\n\n    location / {\n        rtsp_server all;\n        rtsp_publish all;\n    }\n}\n```\n\n### 步骤 4: 设置基本认证\n\n生成密码文件：\n\n```\nsudo htpasswd -c /etc/nginx/.htpasswd username\n```\n\n### 步骤 5: 配置防火墙\n\n开放 8554 端口：\n\n```\nsudo ufw allow 8554/tcp\n```\n\n或\n\n```\nsudo firewall-cmd --add-port=8554/tcp --permanent\nsudo firewall-cmd --reload\n```\n\n### 步骤 6: 测试配置\n\n检查 Nginx 配置并重启服务：\n\n```\nsudo nginx -t\nsudo systemctl restart nginx\n```\n\n### 步骤 7: 测试 RTSP 服务\n\n使用 VLC 播放器测试连接：\n\n1. 打开 VLC，选择“媒体” -\\> “打开网络串流”。\n2. 输入 `rtsp://localhost:8554/test`​ 并播放。\n\n### 高级配置（可选）\n\n若需结合 RTMP 使用，可在配置中添加 RTMP 服务器：\n\n```\nrtsp {\n    listen 8554;\n    server_name localhost;\n\n    location /rtsp {\n        rtsp_server all;\n        rtsp_publish all;\n\n        rtmp {\n            server 127.0.0.1:1935;\n        }\n    }\n}\n\nhttp {\n    ...\n    rtmp {\n        server {\n            listen 1935;\n            chunk_size 4096;\n\n            application live {\n                live on;\n            }\n        }\n    }\n    ...\n}\n```\n\n### 总结\n\n通过以上步骤，你已成功配置 Nginx 以支持 RTSP 服务。根据具体需求，可以进一步配置认证、日志记录和流转发等功能。如遇问题，可通过查看日志文件进行调试和修正。\n","source":"_posts/nginx-configuration-rtsp-service-1p9fjr.md","raw":"---\ntitle: nginx 配置rtsp服务\ndate: '2024-12-27 09:25:55'\nupdated: '2024-12-27 09:27:53'\nexcerpt: >-\n  本文详细介绍了在Ubuntu系统上配置Nginx以提供RTSP服务的步骤。首先，安装编译工具和依赖包；其次，下载并编译Nginx及其rtsp模块；然后，在Nginx配置文件中添加RTSP服务器配置，并设置基本认证；接着，配置防火墙开放端口；最后，测试配置并使用VLC播放器测试RTSP服务。文章还提供了结合RTMP的高级配置示例，以供进一步扩展服务功能。\ntags:\n  - nginx\n  - rtsp\n  - 配置\n  - 流媒体\n  - 认证\ncategories:\n  - ' 配置指南'\n  - RTSP服务\n  - Nginx安装\npermalink: /post/nginx-configuration-rtsp-service-1p9fjr.html\ncomments: true\ntoc: true\nabbrlink: 19461\n---\n\n# nginx 配置rtsp服务\n\n配置 Nginx 提供 RTSP 服务涉及安装和编译第三方模块 nginx-rtsp-module，并进行相应的配置。以下是详细的步骤和配置示例：\n\n### 步骤 1: 安装依赖和工具\n\n在 Ubuntu 上，安装必要的编译工具和依赖包：\n\n```\nsudo apt-get update\nsudo apt-get install build-essential libpcre3-dev\n```\n\n### 步骤 2: 下载并编译 Nginx 及模块\n\n1. 克隆 nginx-rtsp-module 仓库：\n\n    ```\n    git clone https://github.com/arut/nginx-rtsp-module.git\n    ```\n2. 下载 Nginx 源码（使用稳定版本）：\n\n    ```\n    wget http://nginx.org/download/nginx-1.21.3.tar.gz\n    tar -zxvf nginx-1.21.3.tar.gz\n    cd nginx-1.21.3\n    ```\n3. 配置编译选项并加入 nginx-rtsp-module：\n\n    ```\n    ./configure --add-module=../nginx-rtsp-module\n    ```\n4. 编译并安装：\n\n    ```\n    make\n    sudo make install\n    ```\n\n### 步骤 3: 配置 Nginx\n\n在 Nginx 配置文件中添加 RTSP 服务器配置：\n\n```\nrtsp {\n    listen 8554;\n    server_name localhost;\n\n    auth_basic \"Restricted\";\n    auth_basic_user_file /etc/nginx/.htpasswd;\n\n    access_log /var/log/nginx/rtsp_access.log;\n    error_log /var/log/nginx/rtsp_error.log;\n\n    location / {\n        rtsp_server all;\n        rtsp_publish all;\n    }\n}\n```\n\n### 步骤 4: 设置基本认证\n\n生成密码文件：\n\n```\nsudo htpasswd -c /etc/nginx/.htpasswd username\n```\n\n### 步骤 5: 配置防火墙\n\n开放 8554 端口：\n\n```\nsudo ufw allow 8554/tcp\n```\n\n或\n\n```\nsudo firewall-cmd --add-port=8554/tcp --permanent\nsudo firewall-cmd --reload\n```\n\n### 步骤 6: 测试配置\n\n检查 Nginx 配置并重启服务：\n\n```\nsudo nginx -t\nsudo systemctl restart nginx\n```\n\n### 步骤 7: 测试 RTSP 服务\n\n使用 VLC 播放器测试连接：\n\n1. 打开 VLC，选择“媒体” -\\> “打开网络串流”。\n2. 输入 `rtsp://localhost:8554/test`​ 并播放。\n\n### 高级配置（可选）\n\n若需结合 RTMP 使用，可在配置中添加 RTMP 服务器：\n\n```\nrtsp {\n    listen 8554;\n    server_name localhost;\n\n    location /rtsp {\n        rtsp_server all;\n        rtsp_publish all;\n\n        rtmp {\n            server 127.0.0.1:1935;\n        }\n    }\n}\n\nhttp {\n    ...\n    rtmp {\n        server {\n            listen 1935;\n            chunk_size 4096;\n\n            application live {\n                live on;\n            }\n        }\n    }\n    ...\n}\n```\n\n### 总结\n\n通过以上步骤，你已成功配置 Nginx 以支持 RTSP 服务。根据具体需求，可以进一步配置认证、日志记录和流转发等功能。如遇问题，可通过查看日志文件进行调试和修正。\n","slug":"nginx-configuration-rtsp-service-1p9fjr","published":1,"__permalink":"/post/nginx-configuration-rtsp-service-1p9fjr.html","_id":"cmclcaf3v000ep8vw24bg498u","layout":"post","photos":[],"content":"<h1 id=\"nginx-配置rtsp服务\"><a href=\"#nginx-配置rtsp服务\" class=\"headerlink\" title=\"nginx 配置rtsp服务\"></a>nginx 配置rtsp服务</h1><p>配置 Nginx 提供 RTSP 服务涉及安装和编译第三方模块 nginx-rtsp-module，并进行相应的配置。以下是详细的步骤和配置示例：</p>\n<h3 id=\"步骤-1-安装依赖和工具\"><a href=\"#步骤-1-安装依赖和工具\" class=\"headerlink\" title=\"步骤 1: 安装依赖和工具\"></a>步骤 1: 安装依赖和工具</h3><p>在 Ubuntu 上，安装必要的编译工具和依赖包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install build-essential libpcre3-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-2-下载并编译-Nginx-及模块\"><a href=\"#步骤-2-下载并编译-Nginx-及模块\" class=\"headerlink\" title=\"步骤 2: 下载并编译 Nginx 及模块\"></a>步骤 2: 下载并编译 Nginx 及模块</h3><ol>\n<li><p>克隆 nginx-rtsp-module 仓库：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/arut/nginx-rtsp-module.git</span><br></pre></td></tr></table></figure></li>\n<li><p>下载 Nginx 源码（使用稳定版本）：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nginx.org/download/nginx-1.21.3.tar.gz</span><br><span class=\"line\">tar -zxvf nginx-1.21.3.tar.gz</span><br><span class=\"line\">cd nginx-1.21.3</span><br></pre></td></tr></table></figure></li>\n<li><p>配置编译选项并加入 nginx-rtsp-module：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --add-module=../nginx-rtsp-module</span><br></pre></td></tr></table></figure></li>\n<li><p>编译并安装：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"步骤-3-配置-Nginx\"><a href=\"#步骤-3-配置-Nginx\" class=\"headerlink\" title=\"步骤 3: 配置 Nginx\"></a>步骤 3: 配置 Nginx</h3><p>在 Nginx 配置文件中添加 RTSP 服务器配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtsp &#123;</span><br><span class=\"line\">    listen 8554;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    auth_basic &quot;Restricted&quot;;</span><br><span class=\"line\">    auth_basic_user_file /etc/nginx/.htpasswd;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log /var/log/nginx/rtsp_access.log;</span><br><span class=\"line\">    error_log /var/log/nginx/rtsp_error.log;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        rtsp_server all;</span><br><span class=\"line\">        rtsp_publish all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-4-设置基本认证\"><a href=\"#步骤-4-设置基本认证\" class=\"headerlink\" title=\"步骤 4: 设置基本认证\"></a>步骤 4: 设置基本认证</h3><p>生成密码文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo htpasswd -c /etc/nginx/.htpasswd username</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-5-配置防火墙\"><a href=\"#步骤-5-配置防火墙\" class=\"headerlink\" title=\"步骤 5: 配置防火墙\"></a>步骤 5: 配置防火墙</h3><p>开放 8554 端口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ufw allow 8554/tcp</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --add-port=8554/tcp --permanent</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-6-测试配置\"><a href=\"#步骤-6-测试配置\" class=\"headerlink\" title=\"步骤 6: 测试配置\"></a>步骤 6: 测试配置</h3><p>检查 Nginx 配置并重启服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br><span class=\"line\">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-7-测试-RTSP-服务\"><a href=\"#步骤-7-测试-RTSP-服务\" class=\"headerlink\" title=\"步骤 7: 测试 RTSP 服务\"></a>步骤 7: 测试 RTSP 服务</h3><p>使用 VLC 播放器测试连接：</p>\n<ol>\n<li>打开 VLC，选择“媒体” -&gt; “打开网络串流”。</li>\n<li>输入 <code>rtsp://localhost:8554/test</code>​ 并播放。</li>\n</ol>\n<h3 id=\"高级配置（可选）\"><a href=\"#高级配置（可选）\" class=\"headerlink\" title=\"高级配置（可选）\"></a>高级配置（可选）</h3><p>若需结合 RTMP 使用，可在配置中添加 RTMP 服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtsp &#123;</span><br><span class=\"line\">    listen 8554;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    location /rtsp &#123;</span><br><span class=\"line\">        rtsp_server all;</span><br><span class=\"line\">        rtsp_publish all;</span><br><span class=\"line\"></span><br><span class=\"line\">        rtmp &#123;</span><br><span class=\"line\">            server 127.0.0.1:1935;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    rtmp &#123;</span><br><span class=\"line\">        server &#123;</span><br><span class=\"line\">            listen 1935;</span><br><span class=\"line\">            chunk_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">            application live &#123;</span><br><span class=\"line\">                live on;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上步骤，你已成功配置 Nginx 以支持 RTSP 服务。根据具体需求，可以进一步配置认证、日志记录和流转发等功能。如遇问题，可通过查看日志文件进行调试和修正。</p>\n","more":"<h1 id=\"nginx-配置rtsp服务\"><a href=\"#nginx-配置rtsp服务\" class=\"headerlink\" title=\"nginx 配置rtsp服务\"></a>nginx 配置rtsp服务</h1><p>配置 Nginx 提供 RTSP 服务涉及安装和编译第三方模块 nginx-rtsp-module，并进行相应的配置。以下是详细的步骤和配置示例：</p>\n<h3 id=\"步骤-1-安装依赖和工具\"><a href=\"#步骤-1-安装依赖和工具\" class=\"headerlink\" title=\"步骤 1: 安装依赖和工具\"></a>步骤 1: 安装依赖和工具</h3><p>在 Ubuntu 上，安装必要的编译工具和依赖包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install build-essential libpcre3-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-2-下载并编译-Nginx-及模块\"><a href=\"#步骤-2-下载并编译-Nginx-及模块\" class=\"headerlink\" title=\"步骤 2: 下载并编译 Nginx 及模块\"></a>步骤 2: 下载并编译 Nginx 及模块</h3><ol>\n<li><p>克隆 nginx-rtsp-module 仓库：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/arut/nginx-rtsp-module.git</span><br></pre></td></tr></table></figure></li>\n<li><p>下载 Nginx 源码（使用稳定版本）：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nginx.org/download/nginx-1.21.3.tar.gz</span><br><span class=\"line\">tar -zxvf nginx-1.21.3.tar.gz</span><br><span class=\"line\">cd nginx-1.21.3</span><br></pre></td></tr></table></figure></li>\n<li><p>配置编译选项并加入 nginx-rtsp-module：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure --add-module=../nginx-rtsp-module</span><br></pre></td></tr></table></figure></li>\n<li><p>编译并安装：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"步骤-3-配置-Nginx\"><a href=\"#步骤-3-配置-Nginx\" class=\"headerlink\" title=\"步骤 3: 配置 Nginx\"></a>步骤 3: 配置 Nginx</h3><p>在 Nginx 配置文件中添加 RTSP 服务器配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtsp &#123;</span><br><span class=\"line\">    listen 8554;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    auth_basic &quot;Restricted&quot;;</span><br><span class=\"line\">    auth_basic_user_file /etc/nginx/.htpasswd;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log /var/log/nginx/rtsp_access.log;</span><br><span class=\"line\">    error_log /var/log/nginx/rtsp_error.log;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        rtsp_server all;</span><br><span class=\"line\">        rtsp_publish all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-4-设置基本认证\"><a href=\"#步骤-4-设置基本认证\" class=\"headerlink\" title=\"步骤 4: 设置基本认证\"></a>步骤 4: 设置基本认证</h3><p>生成密码文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo htpasswd -c /etc/nginx/.htpasswd username</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-5-配置防火墙\"><a href=\"#步骤-5-配置防火墙\" class=\"headerlink\" title=\"步骤 5: 配置防火墙\"></a>步骤 5: 配置防火墙</h3><p>开放 8554 端口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ufw allow 8554/tcp</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --add-port=8554/tcp --permanent</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-6-测试配置\"><a href=\"#步骤-6-测试配置\" class=\"headerlink\" title=\"步骤 6: 测试配置\"></a>步骤 6: 测试配置</h3><p>检查 Nginx 配置并重启服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br><span class=\"line\">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"步骤-7-测试-RTSP-服务\"><a href=\"#步骤-7-测试-RTSP-服务\" class=\"headerlink\" title=\"步骤 7: 测试 RTSP 服务\"></a>步骤 7: 测试 RTSP 服务</h3><p>使用 VLC 播放器测试连接：</p>\n<ol>\n<li>打开 VLC，选择“媒体” -&gt; “打开网络串流”。</li>\n<li>输入 <code>rtsp://localhost:8554/test</code>​ 并播放。</li>\n</ol>\n<h3 id=\"高级配置（可选）\"><a href=\"#高级配置（可选）\" class=\"headerlink\" title=\"高级配置（可选）\"></a>高级配置（可选）</h3><p>若需结合 RTMP 使用，可在配置中添加 RTMP 服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtsp &#123;</span><br><span class=\"line\">    listen 8554;</span><br><span class=\"line\">    server_name localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    location /rtsp &#123;</span><br><span class=\"line\">        rtsp_server all;</span><br><span class=\"line\">        rtsp_publish all;</span><br><span class=\"line\"></span><br><span class=\"line\">        rtmp &#123;</span><br><span class=\"line\">            server 127.0.0.1:1935;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    rtmp &#123;</span><br><span class=\"line\">        server &#123;</span><br><span class=\"line\">            listen 1935;</span><br><span class=\"line\">            chunk_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">            application live &#123;</span><br><span class=\"line\">                live on;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过以上步骤，你已成功配置 Nginx 以支持 RTSP 服务。根据具体需求，可以进一步配置认证、日志记录和流转发等功能。如遇问题，可通过查看日志文件进行调试和修正。</p>\n"},{"title":"Nginx配置TCP代理指南","date":"2024-12-19T01:56:33.000Z","updated":"2024-12-20T06:29:51.000Z","excerpt":"本指南介绍了如何使用Nginx配置TCP代理，以实现高性能的负载均衡和反向代理。主要步骤包括：\n\n1. **安装Nginx**：确保系统已安装Nginx，可通过官方网站或包管理器获取。\n2. **编辑Nginx配置文件**：在`/etc/nginx/nginx.conf`中添加`stream`块，配置`upstream`和`server`，将请求转发到后端服务器。\n3. **重新加载配置**：使用`sudo nginx -s reload`命令使配置生效。\n4. **验证代理设置**：通过`telnet`等工具测试代理是否正常工作。\n5. **监控和调整配置**：定期监控Nginx性能，根据负载情况进行调整。\n\n通过这些步骤，您可以在环境中配置Nginx，实现高效的TCP代理服务。","comments":1,"toc":true,"abbrlink":13896,"_content":"\n# Nginx配置TCP代理指南\n\n# Nginx配置TCP代理指南\n\n使用Nginx作为TCP代理是一种有效的方式，可以实现高性能的负载均衡和反向代理。本篇指南将介绍如何配置Nginx以用作TCP代理。\n\n## 步骤1：安装Nginx\n\n---\n\n首先，确保您的系统已经安装了Nginx。您可以从Nginx官方网站或适用于您的操作系统的软件包管理器中获取Nginx。\n\n## 步骤2：编辑Nginx配置文件\n\n---\n\n默认情况下，Nginx的主配置文件位于/etc/nginx/nginx.conf。在继续之前，请备份此文件，并确保具有root权限。\n\n使用文本编辑器打开nginx.conf文件，并进行以下配置更改：\n\n* 在http块之后，添加一个新的stream块：\n\n```\nstream {\n    # 配置项添加在这里\n}\n```\n\n* 在stream块内，添加upstream和server配置。例如，以下配置将将请求转发到两个后端服务器，端口分别为192.168.1.10:8080和192.168.1.11:8080：\n\n```\nstream {\n    upstream my_backend_servers {\n        server 192.168.1.10:8080;\n        server 192.168.1.11:8080;\n    }\n\n    server {\n        listen 80;\n        proxy_pass my_backend_servers;\n    }\n}\n```\n\n* 根据您的需求，可以根据需要添加更多的upstream和server块。\n\n## 步骤3：重新加载配置\n\n---\n\n保存并关闭配置文件后，使用以下命令重新加载Nginx配置：\n\n```\nsudo nginx -s reload\n```\n\n## 步骤4：验证代理设置\n\n---\n\n现在，您的Nginx已配置为TCP代理。您可以使用telnet工具或其他任何适合您需求的工具来验证代理是否正常工作。\n\n例如，您可以使用以下命令将请求发送到Nginx代理服务器：\n\n```\ntelnet localhost 80\n```\n\n根据您的实际配置，您可能需要更改\"localhost\"为相应的IP地址和端口号。\n\n## 步骤5：监控和调整配置\n\n---\n\n建议您定期监控Nginx的性能，并根据负载情况进行必要的调整。您可以使用Nginx的日志文件、监控工具和系统性能工具来跟踪Nginx的表现并作出相应的改进。\n\n这就是使用Nginx作为TCP代理的简单指南。通过按照上述步骤，在您的环境中配置Nginx，您可以实现高效的TCP代理服务。\n","source":"_posts/nginx-configuration-tcp-agency-guide-kqsal.md","raw":"---\ntitle: Nginx配置TCP代理指南\ndate: '2024-12-19 09:56:33'\nupdated: '2024-12-20 14:29:51'\nexcerpt: >-\n  本指南介绍了如何使用Nginx配置TCP代理，以实现高性能的负载均衡和反向代理。主要步骤包括：\n\n\n  1. **安装Nginx**：确保系统已安装Nginx，可通过官方网站或包管理器获取。\n\n  2.\n  **编辑Nginx配置文件**：在`/etc/nginx/nginx.conf`中添加`stream`块，配置`upstream`和`server`，将请求转发到后端服务器。\n\n  3. **重新加载配置**：使用`sudo nginx -s reload`命令使配置生效。\n\n  4. **验证代理设置**：通过`telnet`等工具测试代理是否正常工作。\n\n  5. **监控和调整配置**：定期监控Nginx性能，根据负载情况进行调整。\n\n\n  通过这些步骤，您可以在环境中配置Nginx，实现高效的TCP代理服务。\ntags:\n  - nginx\n  - tcp代理\n  - 配置指南\n  - 负载均衡\n  - 性能监控\ncategories:\n  - 网络配置\n  - 性能监控\n  - 负载均衡\npermalink: /post/nginx-configuration-tcp-agency-guide-kqsal.html\ncomments: true\ntoc: true\nabbrlink: 13896\n---\n\n# Nginx配置TCP代理指南\n\n# Nginx配置TCP代理指南\n\n使用Nginx作为TCP代理是一种有效的方式，可以实现高性能的负载均衡和反向代理。本篇指南将介绍如何配置Nginx以用作TCP代理。\n\n## 步骤1：安装Nginx\n\n---\n\n首先，确保您的系统已经安装了Nginx。您可以从Nginx官方网站或适用于您的操作系统的软件包管理器中获取Nginx。\n\n## 步骤2：编辑Nginx配置文件\n\n---\n\n默认情况下，Nginx的主配置文件位于/etc/nginx/nginx.conf。在继续之前，请备份此文件，并确保具有root权限。\n\n使用文本编辑器打开nginx.conf文件，并进行以下配置更改：\n\n* 在http块之后，添加一个新的stream块：\n\n```\nstream {\n    # 配置项添加在这里\n}\n```\n\n* 在stream块内，添加upstream和server配置。例如，以下配置将将请求转发到两个后端服务器，端口分别为192.168.1.10:8080和192.168.1.11:8080：\n\n```\nstream {\n    upstream my_backend_servers {\n        server 192.168.1.10:8080;\n        server 192.168.1.11:8080;\n    }\n\n    server {\n        listen 80;\n        proxy_pass my_backend_servers;\n    }\n}\n```\n\n* 根据您的需求，可以根据需要添加更多的upstream和server块。\n\n## 步骤3：重新加载配置\n\n---\n\n保存并关闭配置文件后，使用以下命令重新加载Nginx配置：\n\n```\nsudo nginx -s reload\n```\n\n## 步骤4：验证代理设置\n\n---\n\n现在，您的Nginx已配置为TCP代理。您可以使用telnet工具或其他任何适合您需求的工具来验证代理是否正常工作。\n\n例如，您可以使用以下命令将请求发送到Nginx代理服务器：\n\n```\ntelnet localhost 80\n```\n\n根据您的实际配置，您可能需要更改\"localhost\"为相应的IP地址和端口号。\n\n## 步骤5：监控和调整配置\n\n---\n\n建议您定期监控Nginx的性能，并根据负载情况进行必要的调整。您可以使用Nginx的日志文件、监控工具和系统性能工具来跟踪Nginx的表现并作出相应的改进。\n\n这就是使用Nginx作为TCP代理的简单指南。通过按照上述步骤，在您的环境中配置Nginx，您可以实现高效的TCP代理服务。\n","slug":"nginx-configuration-tcp-agency-guide-kqsal","published":1,"__permalink":"/post/nginx-configuration-tcp-agency-guide-kqsal.html","_id":"cmclcaf3w000fp8vwafhyflhh","layout":"post","photos":[],"content":"<h1 id=\"Nginx配置TCP代理指南\"><a href=\"#Nginx配置TCP代理指南\" class=\"headerlink\" title=\"Nginx配置TCP代理指南\"></a>Nginx配置TCP代理指南</h1><h1 id=\"Nginx配置TCP代理指南-1\"><a href=\"#Nginx配置TCP代理指南-1\" class=\"headerlink\" title=\"Nginx配置TCP代理指南\"></a>Nginx配置TCP代理指南</h1><p>使用Nginx作为TCP代理是一种有效的方式，可以实现高性能的负载均衡和反向代理。本篇指南将介绍如何配置Nginx以用作TCP代理。</p>\n<h2 id=\"步骤1：安装Nginx\"><a href=\"#步骤1：安装Nginx\" class=\"headerlink\" title=\"步骤1：安装Nginx\"></a>步骤1：安装Nginx</h2><hr>\n<p>首先，确保您的系统已经安装了Nginx。您可以从Nginx官方网站或适用于您的操作系统的软件包管理器中获取Nginx。</p>\n<h2 id=\"步骤2：编辑Nginx配置文件\"><a href=\"#步骤2：编辑Nginx配置文件\" class=\"headerlink\" title=\"步骤2：编辑Nginx配置文件\"></a>步骤2：编辑Nginx配置文件</h2><hr>\n<p>默认情况下，Nginx的主配置文件位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。在继续之前，请备份此文件，并确保具有root权限。</p>\n<p>使用文本编辑器打开nginx.conf文件，并进行以下配置更改：</p>\n<ul>\n<li>在http块之后，添加一个新的stream块：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream &#123;</span><br><span class=\"line\">    # 配置项添加在这里</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在stream块内，添加upstream和server配置。例如，以下配置将将请求转发到两个后端服务器，端口分别为192.168.1.10:8080和192.168.1.11:8080：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream &#123;</span><br><span class=\"line\">    upstream my_backend_servers &#123;</span><br><span class=\"line\">        server 192.168.1.10:8080;</span><br><span class=\"line\">        server 192.168.1.11:8080;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        proxy_pass my_backend_servers;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>根据您的需求，可以根据需要添加更多的upstream和server块。</li>\n</ul>\n<h2 id=\"步骤3：重新加载配置\"><a href=\"#步骤3：重新加载配置\" class=\"headerlink\" title=\"步骤3：重新加载配置\"></a>步骤3：重新加载配置</h2><hr>\n<p>保存并关闭配置文件后，使用以下命令重新加载Nginx配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -s reload</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤4：验证代理设置\"><a href=\"#步骤4：验证代理设置\" class=\"headerlink\" title=\"步骤4：验证代理设置\"></a>步骤4：验证代理设置</h2><hr>\n<p>现在，您的Nginx已配置为TCP代理。您可以使用telnet工具或其他任何适合您需求的工具来验证代理是否正常工作。</p>\n<p>例如，您可以使用以下命令将请求发送到Nginx代理服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet localhost 80</span><br></pre></td></tr></table></figure>\n\n<p>根据您的实际配置，您可能需要更改”localhost”为相应的IP地址和端口号。</p>\n<h2 id=\"步骤5：监控和调整配置\"><a href=\"#步骤5：监控和调整配置\" class=\"headerlink\" title=\"步骤5：监控和调整配置\"></a>步骤5：监控和调整配置</h2><hr>\n<p>建议您定期监控Nginx的性能，并根据负载情况进行必要的调整。您可以使用Nginx的日志文件、监控工具和系统性能工具来跟踪Nginx的表现并作出相应的改进。</p>\n<p>这就是使用Nginx作为TCP代理的简单指南。通过按照上述步骤，在您的环境中配置Nginx，您可以实现高效的TCP代理服务。</p>\n","more":"<h1 id=\"Nginx配置TCP代理指南\"><a href=\"#Nginx配置TCP代理指南\" class=\"headerlink\" title=\"Nginx配置TCP代理指南\"></a>Nginx配置TCP代理指南</h1><h1 id=\"Nginx配置TCP代理指南-1\"><a href=\"#Nginx配置TCP代理指南-1\" class=\"headerlink\" title=\"Nginx配置TCP代理指南\"></a>Nginx配置TCP代理指南</h1><p>使用Nginx作为TCP代理是一种有效的方式，可以实现高性能的负载均衡和反向代理。本篇指南将介绍如何配置Nginx以用作TCP代理。</p>\n<h2 id=\"步骤1：安装Nginx\"><a href=\"#步骤1：安装Nginx\" class=\"headerlink\" title=\"步骤1：安装Nginx\"></a>步骤1：安装Nginx</h2><hr>\n<p>首先，确保您的系统已经安装了Nginx。您可以从Nginx官方网站或适用于您的操作系统的软件包管理器中获取Nginx。</p>\n<h2 id=\"步骤2：编辑Nginx配置文件\"><a href=\"#步骤2：编辑Nginx配置文件\" class=\"headerlink\" title=\"步骤2：编辑Nginx配置文件\"></a>步骤2：编辑Nginx配置文件</h2><hr>\n<p>默认情况下，Nginx的主配置文件位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。在继续之前，请备份此文件，并确保具有root权限。</p>\n<p>使用文本编辑器打开nginx.conf文件，并进行以下配置更改：</p>\n<ul>\n<li>在http块之后，添加一个新的stream块：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream &#123;</span><br><span class=\"line\">    # 配置项添加在这里</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在stream块内，添加upstream和server配置。例如，以下配置将将请求转发到两个后端服务器，端口分别为192.168.1.10:8080和192.168.1.11:8080：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream &#123;</span><br><span class=\"line\">    upstream my_backend_servers &#123;</span><br><span class=\"line\">        server 192.168.1.10:8080;</span><br><span class=\"line\">        server 192.168.1.11:8080;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        proxy_pass my_backend_servers;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>根据您的需求，可以根据需要添加更多的upstream和server块。</li>\n</ul>\n<h2 id=\"步骤3：重新加载配置\"><a href=\"#步骤3：重新加载配置\" class=\"headerlink\" title=\"步骤3：重新加载配置\"></a>步骤3：重新加载配置</h2><hr>\n<p>保存并关闭配置文件后，使用以下命令重新加载Nginx配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -s reload</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"步骤4：验证代理设置\"><a href=\"#步骤4：验证代理设置\" class=\"headerlink\" title=\"步骤4：验证代理设置\"></a>步骤4：验证代理设置</h2><hr>\n<p>现在，您的Nginx已配置为TCP代理。您可以使用telnet工具或其他任何适合您需求的工具来验证代理是否正常工作。</p>\n<p>例如，您可以使用以下命令将请求发送到Nginx代理服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet localhost 80</span><br></pre></td></tr></table></figure>\n\n<p>根据您的实际配置，您可能需要更改”localhost”为相应的IP地址和端口号。</p>\n<h2 id=\"步骤5：监控和调整配置\"><a href=\"#步骤5：监控和调整配置\" class=\"headerlink\" title=\"步骤5：监控和调整配置\"></a>步骤5：监控和调整配置</h2><hr>\n<p>建议您定期监控Nginx的性能，并根据负载情况进行必要的调整。您可以使用Nginx的日志文件、监控工具和系统性能工具来跟踪Nginx的表现并作出相应的改进。</p>\n<p>这就是使用Nginx作为TCP代理的简单指南。通过按照上述步骤，在您的环境中配置Nginx，您可以实现高效的TCP代理服务。</p>\n"},{"title":"nginx安装部署","date":"2024-12-19T01:56:33.000Z","updated":"2024-12-20T01:30:32.000Z","excerpt":"本文介绍了Nginx的安装部署方法，包括Docker部署、源码部署和包管理工具安装三种方式。Docker部署部分提供了docker-compose.yml配置文件，用于设置Nginx容器的端口映射、环境变量、卷挂载等。源码部署部分详细说明了依赖安装、创建用户和组、编译安装Nginx的步骤，并提供了查看模块和操作命令的方法。包管理工具安装部分则分别介绍了在Ubuntu/Debian和CentOS/RHEL系统上使用apt和yum/dnf安装Nginx的步骤，包括添加仓库、安装、启动服务和设置开机自启动等。","comments":1,"toc":true,"abbrlink":46125,"_content":"\n# nginx安装部署\n\n# nginx安装部署\n\n## docker部署\n\n---\n\n**docker-compose.yml**\n\n```yaml\nversion: '3'\nservices:\n  nginx:\n    image: nginx:1.23.1\n    ports:\n    - 443:443\n    - 80:80\n    environment:\n      TZ: Asia/Shanghai\n    volumes:\n     - ./conf.d:/etc/nginx/conf.d:Z\n     - ./nginx.conf:/etc/nginx/nginx.conf:ro\n     - ./ssl:/etc/nginx/ssl_key:Z\n     - ./logs:/var/log/nginx:Z\n     - ./html:/etc/nginx/html:Z\n    command: [nginx-debug,'-g','daemon off;']\n```\n\n文件夹规划 nginx\n\n|-conf.d #文件夹，用于存放server的配置#​\n\n|-ssl.conf ## https配置文件\n\n|-docker-compose.yaml ## 主的docker-compose配置文件\n\n|-html ## 作为前端服务器用于存放前端文件\n\n|-logs ## 日志文件信息\n\n|-nginx.conf ## nginx主的配置文件，通用的http配置都放在这里\n\n|-ssl ## crt key的存放地址\n\n## 源码部署\n\n---\n\n### 依赖安装\n\n```shell\nyum -y install openssl openssl-devel make zlib zlib-devel gcc gcc-c++ libtool    pcre pcre-devel\n```\n\n### 创建没有登录的用户和用户组\n\n```shell\ngroupadd -r nginx\n\nuseradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx\n```\n\n* \\-r: 添加系统用户( 这里指将要被创建的系统用户`nginx`)\n* \\-g: 指定要创建的用户所属组( 这里指添加新系统用户`nginx`到`nginx`系统用户组 )\n* \\-s: 新帐户的登录`shell`( `/sbin/nologin` 这里设置为将要被创建系统用户`nginx`不能用来登录系统 )\n* \\-d: 新帐户的主目录( 这里指定将要被创建的系统用户`nginx`的家目录为 `/usr/local/nginx` )\n* \\-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户`nginx`不会在 `/home` 目录下创建 `nginx` 家目录 )\n\n### 源码安装nginx\n\n```shell\nwget http://nginx.org/download/nginx-1.23.1.tar.gz\ntar -zvxf nginx-1.23.1.tar.gz -C ./nginx\ncd nginx/nginx-1.23.1\n./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module \nmake && make install\n```\n\n### 查看内置模块\n\n```shell\ncat ./auto/options |grep YES\n```\n\n### 查看自定义模块\n\n```shell\nnginx -V\n```\n\n### 操作命令\n\n```bash\ncd /usr/local/nginx/sbin\nnginx -c nginx.conf  # 启动\nnginx -s stop  # 关闭\nnginx -s reload # 重新加载配置\nnginx -s quit # 重启，先停止在启动\n```\n\n### 开机自启动\n\n在`rc.local`增加启动代码即可\n\n```bash\nvi /etc/rc.local\n /usr/local/nignx/sbin/nginx  -c /usr/local/nginx/conf/nginx.conf\n```\n\n设置rc.local的文件执行权限\n\n```bash\nchmod 755 rc.local\n```\n\n## 包管理工具安装\n\n安装 Nginx 可以使用多种包管理工具，具体取决于你的操作系统。以下是常见操作系统的安装方法:\n\n---\n\n### **1. 在 Ubuntu/Debian 上安装 Nginx**\n\n#### 使用 `apt`​ 包管理工具：\n\n1. **更新包列表**：\n\n    ```bash\n    sudo apt update\n    ```\n2. **安装 Nginx**：\n\n    ```bash\n    sudo apt install nginx\n    ```\n3. **启动 Nginx 服务**：\n\n    ```bash\n    sudo systemctl start nginx\n    ```\n4. **设置 Nginx 开机自启动**：\n\n    ```\n    sudo systemctl enable nginx\n    ```\n5. **验证安装**：  \n    打开浏览器，访问 `http://localhost`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### **2. 在 CentOS/RHEL 上安装 Nginx**\n\n#### 使用 `yum`​ 或 `dnf`​ 包管理工具：\n\n1. **添加 Nginx 官方仓库**：  \n    创建一个文件 `/etc/yum.repos.d/nginx.repo`​，并添加以下内容：\n\n    ```ini\n    [nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1\n    ```\n2. **安装 Nginx**：\n\n    ```bash\n    sudo yum install nginx\n    ```\n\n    或者使用 `dnf`​（适用于 CentOS 8+）：\n\n    ```bash\n    sudo dnf install nginx\n    ```\n3. **启动 Nginx 服务**：\n\n    ```bash\n    sudo systemctl start nginx\n    ```\n4. **设置 Nginx 开机自启动**：\n\n    ```\n    sudo systemctl enable nginx\n    ```\n5. **验证安装**：  \n    打开浏览器，访问 `http://<服务器IP>`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### **3. 在 macOS 上安装 Nginx**\n\n#### 使用 `Homebrew`​ 包管理工具：\n\n1. **安装 Homebrew**（如果尚未安装）：\n\n    ```\n    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n    ```\n2. **安装 Nginx**：\n\n    ```\n    brew install nginx\n    ```\n3. **启动 Nginx 服务**：\n\n    ```\n    brew services start nginx\n    ```\n4. **验证安装**：  \n    打开浏览器，访问 `http://localhost:8080`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### **4. 在 Windows 上安装 Nginx**\n\nWindows 上没有直接的包管理工具安装 Nginx，但可以通过以下方式安装：\n\n1. **下载 Nginx**：  \n    访问 [Nginx 官方网站](http://nginx.org/en/download.html)，下载适合 Windows 的版本。\n2. **解压并运行**：\n\n    * 将下载的压缩包解压到一个目录（例如 `C:\\nginx`​）。\n    * 打开命令提示符，进入解压后的目录：\n\n      ```cmd\n      cd C:\\nginx\n      ```\n    * 启动 Nginx：\n\n      ```cmd\n      start nginx\n      ```\n3. **验证安装**：  \n    打开浏览器，访问 `http://localhost`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### 总结\n\n|操作系统|包管理工具|安装命令|\n| ---------------| ------------| -------------------------|\n|Ubuntu/Debian|​`apt`​|​`sudo apt install nginx`​|\n|CentOS/RHEL|​`yum/dnf`​|​`sudo yum install nginx`​|\n|macOS|​`Homebrew`​|​`brew install nginx`​|\n|Windows|手动安装|下载并解压 Nginx 压缩包|\n\n根据你的操作系统选择合适的安装方法即可。\n","source":"_posts/nginx-installation-deployment-z1jtjzq.md","raw":"---\ntitle: nginx安装部署\ndate: '2024-12-19 09:56:33'\nupdated: '2024-12-20 09:30:32'\nexcerpt: >-\n  本文介绍了Nginx的安装部署方法，包括Docker部署、源码部署和包管理工具安装三种方式。Docker部署部分提供了docker-compose.yml配置文件，用于设置Nginx容器的端口映射、环境变量、卷挂载等。源码部署部分详细说明了依赖安装、创建用户和组、编译安装Nginx的步骤，并提供了查看模块和操作命令的方法。包管理工具安装部分则分别介绍了在Ubuntu/Debian和CentOS/RHEL系统上使用apt和yum/dnf安装Nginx的步骤，包括添加仓库、安装、启动服务和设置开机自启动等。\ntags:\n  - nginx\n  - docker\n  - 源码部署\n  - 包管理\n  - 开机自启\ncategories:\n  - 部署指南\n  - 安装教程\n  - 配置管理\npermalink: /post/nginx-installation-deployment-z1jtjzq.html\ncomments: true\ntoc: true\nabbrlink: 46125\n---\n\n# nginx安装部署\n\n# nginx安装部署\n\n## docker部署\n\n---\n\n**docker-compose.yml**\n\n```yaml\nversion: '3'\nservices:\n  nginx:\n    image: nginx:1.23.1\n    ports:\n    - 443:443\n    - 80:80\n    environment:\n      TZ: Asia/Shanghai\n    volumes:\n     - ./conf.d:/etc/nginx/conf.d:Z\n     - ./nginx.conf:/etc/nginx/nginx.conf:ro\n     - ./ssl:/etc/nginx/ssl_key:Z\n     - ./logs:/var/log/nginx:Z\n     - ./html:/etc/nginx/html:Z\n    command: [nginx-debug,'-g','daemon off;']\n```\n\n文件夹规划 nginx\n\n|-conf.d #文件夹，用于存放server的配置#​\n\n|-ssl.conf ## https配置文件\n\n|-docker-compose.yaml ## 主的docker-compose配置文件\n\n|-html ## 作为前端服务器用于存放前端文件\n\n|-logs ## 日志文件信息\n\n|-nginx.conf ## nginx主的配置文件，通用的http配置都放在这里\n\n|-ssl ## crt key的存放地址\n\n## 源码部署\n\n---\n\n### 依赖安装\n\n```shell\nyum -y install openssl openssl-devel make zlib zlib-devel gcc gcc-c++ libtool    pcre pcre-devel\n```\n\n### 创建没有登录的用户和用户组\n\n```shell\ngroupadd -r nginx\n\nuseradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx\n```\n\n* \\-r: 添加系统用户( 这里指将要被创建的系统用户`nginx`)\n* \\-g: 指定要创建的用户所属组( 这里指添加新系统用户`nginx`到`nginx`系统用户组 )\n* \\-s: 新帐户的登录`shell`( `/sbin/nologin` 这里设置为将要被创建系统用户`nginx`不能用来登录系统 )\n* \\-d: 新帐户的主目录( 这里指定将要被创建的系统用户`nginx`的家目录为 `/usr/local/nginx` )\n* \\-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户`nginx`不会在 `/home` 目录下创建 `nginx` 家目录 )\n\n### 源码安装nginx\n\n```shell\nwget http://nginx.org/download/nginx-1.23.1.tar.gz\ntar -zvxf nginx-1.23.1.tar.gz -C ./nginx\ncd nginx/nginx-1.23.1\n./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module \nmake && make install\n```\n\n### 查看内置模块\n\n```shell\ncat ./auto/options |grep YES\n```\n\n### 查看自定义模块\n\n```shell\nnginx -V\n```\n\n### 操作命令\n\n```bash\ncd /usr/local/nginx/sbin\nnginx -c nginx.conf  # 启动\nnginx -s stop  # 关闭\nnginx -s reload # 重新加载配置\nnginx -s quit # 重启，先停止在启动\n```\n\n### 开机自启动\n\n在`rc.local`增加启动代码即可\n\n```bash\nvi /etc/rc.local\n /usr/local/nignx/sbin/nginx  -c /usr/local/nginx/conf/nginx.conf\n```\n\n设置rc.local的文件执行权限\n\n```bash\nchmod 755 rc.local\n```\n\n## 包管理工具安装\n\n安装 Nginx 可以使用多种包管理工具，具体取决于你的操作系统。以下是常见操作系统的安装方法:\n\n---\n\n### **1. 在 Ubuntu/Debian 上安装 Nginx**\n\n#### 使用 `apt`​ 包管理工具：\n\n1. **更新包列表**：\n\n    ```bash\n    sudo apt update\n    ```\n2. **安装 Nginx**：\n\n    ```bash\n    sudo apt install nginx\n    ```\n3. **启动 Nginx 服务**：\n\n    ```bash\n    sudo systemctl start nginx\n    ```\n4. **设置 Nginx 开机自启动**：\n\n    ```\n    sudo systemctl enable nginx\n    ```\n5. **验证安装**：  \n    打开浏览器，访问 `http://localhost`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### **2. 在 CentOS/RHEL 上安装 Nginx**\n\n#### 使用 `yum`​ 或 `dnf`​ 包管理工具：\n\n1. **添加 Nginx 官方仓库**：  \n    创建一个文件 `/etc/yum.repos.d/nginx.repo`​，并添加以下内容：\n\n    ```ini\n    [nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1\n    ```\n2. **安装 Nginx**：\n\n    ```bash\n    sudo yum install nginx\n    ```\n\n    或者使用 `dnf`​（适用于 CentOS 8+）：\n\n    ```bash\n    sudo dnf install nginx\n    ```\n3. **启动 Nginx 服务**：\n\n    ```bash\n    sudo systemctl start nginx\n    ```\n4. **设置 Nginx 开机自启动**：\n\n    ```\n    sudo systemctl enable nginx\n    ```\n5. **验证安装**：  \n    打开浏览器，访问 `http://<服务器IP>`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### **3. 在 macOS 上安装 Nginx**\n\n#### 使用 `Homebrew`​ 包管理工具：\n\n1. **安装 Homebrew**（如果尚未安装）：\n\n    ```\n    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n    ```\n2. **安装 Nginx**：\n\n    ```\n    brew install nginx\n    ```\n3. **启动 Nginx 服务**：\n\n    ```\n    brew services start nginx\n    ```\n4. **验证安装**：  \n    打开浏览器，访问 `http://localhost:8080`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### **4. 在 Windows 上安装 Nginx**\n\nWindows 上没有直接的包管理工具安装 Nginx，但可以通过以下方式安装：\n\n1. **下载 Nginx**：  \n    访问 [Nginx 官方网站](http://nginx.org/en/download.html)，下载适合 Windows 的版本。\n2. **解压并运行**：\n\n    * 将下载的压缩包解压到一个目录（例如 `C:\\nginx`​）。\n    * 打开命令提示符，进入解压后的目录：\n\n      ```cmd\n      cd C:\\nginx\n      ```\n    * 启动 Nginx：\n\n      ```cmd\n      start nginx\n      ```\n3. **验证安装**：  \n    打开浏览器，访问 `http://localhost`​，如果看到 Nginx 的欢迎页面，说明安装成功。\n\n---\n\n### 总结\n\n|操作系统|包管理工具|安装命令|\n| ---------------| ------------| -------------------------|\n|Ubuntu/Debian|​`apt`​|​`sudo apt install nginx`​|\n|CentOS/RHEL|​`yum/dnf`​|​`sudo yum install nginx`​|\n|macOS|​`Homebrew`​|​`brew install nginx`​|\n|Windows|手动安装|下载并解压 Nginx 压缩包|\n\n根据你的操作系统选择合适的安装方法即可。\n","slug":"nginx-installation-deployment-z1jtjzq","published":1,"__permalink":"/post/nginx-installation-deployment-z1jtjzq.html","_id":"cmclcaf3z000ip8vwhmu58oq5","layout":"post","photos":[],"content":"<h1 id=\"nginx安装部署\"><a href=\"#nginx安装部署\" class=\"headerlink\" title=\"nginx安装部署\"></a>nginx安装部署</h1><h1 id=\"nginx安装部署-1\"><a href=\"#nginx安装部署-1\" class=\"headerlink\" title=\"nginx安装部署\"></a>nginx安装部署</h1><h2 id=\"docker部署\"><a href=\"#docker部署\" class=\"headerlink\" title=\"docker部署\"></a>docker部署</h2><hr>\n<p><strong>docker-compose.yml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">nginx:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.23.1</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"number\">443</span><span class=\"string\">:443</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"number\">80</span><span class=\"string\">:80</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">TZ:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./conf.d:/etc/nginx/conf.d:Z</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./ssl:/etc/nginx/ssl_key:Z</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./logs:/var/log/nginx:Z</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./html:/etc/nginx/html:Z</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">nginx-debug</span>,<span class=\"string\">&#x27;-g&#x27;</span>,<span class=\"string\">&#x27;daemon off;&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>文件夹规划 nginx</p>\n<p>|-conf.d #文件夹，用于存放server的配置#​</p>\n<p>|-ssl.conf ## https配置文件</p>\n<p>|-docker-compose.yaml ## 主的docker-compose配置文件</p>\n<p>|-html ## 作为前端服务器用于存放前端文件</p>\n<p>|-logs ## 日志文件信息</p>\n<p>|-nginx.conf ## nginx主的配置文件，通用的http配置都放在这里</p>\n<p>|-ssl ## crt key的存放地址</p>\n<h2 id=\"源码部署\"><a href=\"#源码部署\" class=\"headerlink\" title=\"源码部署\"></a>源码部署</h2><hr>\n<h3 id=\"依赖安装\"><a href=\"#依赖安装\" class=\"headerlink\" title=\"依赖安装\"></a>依赖安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install openssl openssl-devel make zlib zlib-devel gcc gcc-c++ libtool    pcre pcre-devel</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建没有登录的用户和用户组\"><a href=\"#创建没有登录的用户和用户组\" class=\"headerlink\" title=\"创建没有登录的用户和用户组\"></a>创建没有登录的用户和用户组</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd -r nginx</span><br><span class=\"line\"></span><br><span class=\"line\">useradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-r: 添加系统用户( 这里指将要被创建的系统用户<code>nginx</code>)</li>\n<li>-g: 指定要创建的用户所属组( 这里指添加新系统用户<code>nginx</code>到<code>nginx</code>系统用户组 )</li>\n<li>-s: 新帐户的登录<code>shell</code>( <code>/sbin/nologin</code> 这里设置为将要被创建系统用户<code>nginx</code>不能用来登录系统 )</li>\n<li>-d: 新帐户的主目录( 这里指定将要被创建的系统用户<code>nginx</code>的家目录为 <code>/usr/local/nginx</code> )</li>\n<li>-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户<code>nginx</code>不会在 <code>/home</code> 目录下创建 <code>nginx</code> 家目录 )</li>\n</ul>\n<h3 id=\"源码安装nginx\"><a href=\"#源码安装nginx\" class=\"headerlink\" title=\"源码安装nginx\"></a>源码安装nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nginx.org/download/nginx-1.23.1.tar.gz</span><br><span class=\"line\">tar -zvxf nginx-1.23.1.tar.gz -C ./nginx</span><br><span class=\"line\">cd nginx/nginx-1.23.1</span><br><span class=\"line\">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module </span><br><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看内置模块\"><a href=\"#查看内置模块\" class=\"headerlink\" title=\"查看内置模块\"></a>查看内置模块</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ./auto/options |grep YES</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看自定义模块\"><a href=\"#查看自定义模块\" class=\"headerlink\" title=\"查看自定义模块\"></a>查看自定义模块</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"操作命令\"><a href=\"#操作命令\" class=\"headerlink\" title=\"操作命令\"></a>操作命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/nginx/sbin</span><br><span class=\"line\">nginx -c nginx.conf  <span class=\"comment\"># 启动</span></span><br><span class=\"line\">nginx -s stop  <span class=\"comment\"># 关闭</span></span><br><span class=\"line\">nginx -s reload <span class=\"comment\"># 重新加载配置</span></span><br><span class=\"line\">nginx -s quit <span class=\"comment\"># 重启，先停止在启动</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"开机自启动\"><a href=\"#开机自启动\" class=\"headerlink\" title=\"开机自启动\"></a>开机自启动</h3><p>在<code>rc.local</code>增加启动代码即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/rc.local</span><br><span class=\"line\"> /usr/local/nignx/sbin/nginx  -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n\n<p>设置rc.local的文件执行权限</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 755 rc.local</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"包管理工具安装\"><a href=\"#包管理工具安装\" class=\"headerlink\" title=\"包管理工具安装\"></a>包管理工具安装</h2><p>安装 Nginx 可以使用多种包管理工具，具体取决于你的操作系统。以下是常见操作系统的安装方法:</p>\n<hr>\n<h3 id=\"1-在-Ubuntu-Debian-上安装-Nginx\"><a href=\"#1-在-Ubuntu-Debian-上安装-Nginx\" class=\"headerlink\" title=\"1. 在 Ubuntu&#x2F;Debian 上安装 Nginx\"></a><strong>1. 在 Ubuntu&#x2F;Debian 上安装 Nginx</strong></h3><h4 id=\"使用-apt​-包管理工具：\"><a href=\"#使用-apt​-包管理工具：\" class=\"headerlink\" title=\"使用 apt​ 包管理工具：\"></a>使用 <code>apt</code>​ 包管理工具：</h4><ol>\n<li><p><strong>更新包列表</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装 Nginx</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动 Nginx 服务</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置 Nginx 开机自启动</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-在-CentOS-RHEL-上安装-Nginx\"><a href=\"#2-在-CentOS-RHEL-上安装-Nginx\" class=\"headerlink\" title=\"2. 在 CentOS&#x2F;RHEL 上安装 Nginx\"></a><strong>2. 在 CentOS&#x2F;RHEL 上安装 Nginx</strong></h3><h4 id=\"使用-yum​-或-dnf​-包管理工具：\"><a href=\"#使用-yum​-或-dnf​-包管理工具：\" class=\"headerlink\" title=\"使用 yum​ 或 dnf​ 包管理工具：\"></a>使用 <code>yum</code>​ 或 <code>dnf</code>​ 包管理工具：</h4><ol>\n<li><p><strong>添加 Nginx 官方仓库</strong>：<br> 创建一个文件 <code>/etc/yum.repos.d/nginx.repo</code>​，并添加以下内容：</p>\n <figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[nginx]</span><span class=\"attr\">name</span>=nginx repobaseurl=http://nginx.org/packages/centos/<span class=\"variable\">$releasever</span>/<span class=\"variable\">$basearch</span>/gpgcheck=<span class=\"number\">0</span>enabled=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装 Nginx</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> yum install nginx</span><br></pre></td></tr></table></figure>\n\n<p> 或者使用 <code>dnf</code>​（适用于 CentOS 8+）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动 Nginx 服务</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置 Nginx 开机自启动</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://&lt;服务器IP&gt;</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"3-在-macOS-上安装-Nginx\"><a href=\"#3-在-macOS-上安装-Nginx\" class=\"headerlink\" title=\"3. 在 macOS 上安装 Nginx\"></a><strong>3. 在 macOS 上安装 Nginx</strong></h3><h4 id=\"使用-Homebrew​-包管理工具：\"><a href=\"#使用-Homebrew​-包管理工具：\" class=\"headerlink\" title=\"使用 Homebrew​ 包管理工具：\"></a>使用 <code>Homebrew</code>​ 包管理工具：</h4><ol>\n<li><p><strong>安装 Homebrew</strong>（如果尚未安装）：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装 Nginx</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动 Nginx 服务</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew services start nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost:8080</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"4-在-Windows-上安装-Nginx\"><a href=\"#4-在-Windows-上安装-Nginx\" class=\"headerlink\" title=\"4. 在 Windows 上安装 Nginx\"></a><strong>4. 在 Windows 上安装 Nginx</strong></h3><p>Windows 上没有直接的包管理工具安装 Nginx，但可以通过以下方式安装：</p>\n<ol>\n<li><p><strong>下载 Nginx</strong>：<br> 访问 <a href=\"http://nginx.org/en/download.html\">Nginx 官方网站</a>，下载适合 Windows 的版本。</p>\n</li>\n<li><p><strong>解压并运行</strong>：</p>\n<ul>\n<li><p>将下载的压缩包解压到一个目录（例如 <code>C:\\nginx</code>​）。</p>\n</li>\n<li><p>打开命令提示符，进入解压后的目录：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> C:\\nginx</span><br></pre></td></tr></table></figure></li>\n<li><p>启动 Nginx：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">start</span> nginx</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>操作系统</th>\n<th>包管理工具</th>\n<th>安装命令</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Ubuntu&#x2F;Debian</td>\n<td>​<code>apt</code>​</td>\n<td>​<code>sudo apt install nginx</code>​</td>\n</tr>\n<tr>\n<td>CentOS&#x2F;RHEL</td>\n<td>​<code>yum/dnf</code>​</td>\n<td>​<code>sudo yum install nginx</code>​</td>\n</tr>\n<tr>\n<td>macOS</td>\n<td>​<code>Homebrew</code>​</td>\n<td>​<code>brew install nginx</code>​</td>\n</tr>\n<tr>\n<td>Windows</td>\n<td>手动安装</td>\n<td>下载并解压 Nginx 压缩包</td>\n</tr>\n</tbody></table>\n<p>根据你的操作系统选择合适的安装方法即可。</p>\n","more":"<h1 id=\"nginx安装部署\"><a href=\"#nginx安装部署\" class=\"headerlink\" title=\"nginx安装部署\"></a>nginx安装部署</h1><h1 id=\"nginx安装部署-1\"><a href=\"#nginx安装部署-1\" class=\"headerlink\" title=\"nginx安装部署\"></a>nginx安装部署</h1><h2 id=\"docker部署\"><a href=\"#docker部署\" class=\"headerlink\" title=\"docker部署\"></a>docker部署</h2><hr>\n<p><strong>docker-compose.yml</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">nginx:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:1.23.1</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"number\">443</span><span class=\"string\">:443</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"number\">80</span><span class=\"string\">:80</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">TZ:</span> <span class=\"string\">Asia/Shanghai</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./conf.d:/etc/nginx/conf.d:Z</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./ssl:/etc/nginx/ssl_key:Z</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./logs:/var/log/nginx:Z</span></span><br><span class=\"line\">     <span class=\"bullet\">-</span> <span class=\"string\">./html:/etc/nginx/html:Z</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">nginx-debug</span>,<span class=\"string\">&#x27;-g&#x27;</span>,<span class=\"string\">&#x27;daemon off;&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>文件夹规划 nginx</p>\n<p>|-conf.d #文件夹，用于存放server的配置#​</p>\n<p>|-ssl.conf ## https配置文件</p>\n<p>|-docker-compose.yaml ## 主的docker-compose配置文件</p>\n<p>|-html ## 作为前端服务器用于存放前端文件</p>\n<p>|-logs ## 日志文件信息</p>\n<p>|-nginx.conf ## nginx主的配置文件，通用的http配置都放在这里</p>\n<p>|-ssl ## crt key的存放地址</p>\n<h2 id=\"源码部署\"><a href=\"#源码部署\" class=\"headerlink\" title=\"源码部署\"></a>源码部署</h2><hr>\n<h3 id=\"依赖安装\"><a href=\"#依赖安装\" class=\"headerlink\" title=\"依赖安装\"></a>依赖安装</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install openssl openssl-devel make zlib zlib-devel gcc gcc-c++ libtool    pcre pcre-devel</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建没有登录的用户和用户组\"><a href=\"#创建没有登录的用户和用户组\" class=\"headerlink\" title=\"创建没有登录的用户和用户组\"></a>创建没有登录的用户和用户组</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd -r nginx</span><br><span class=\"line\"></span><br><span class=\"line\">useradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-r: 添加系统用户( 这里指将要被创建的系统用户<code>nginx</code>)</li>\n<li>-g: 指定要创建的用户所属组( 这里指添加新系统用户<code>nginx</code>到<code>nginx</code>系统用户组 )</li>\n<li>-s: 新帐户的登录<code>shell</code>( <code>/sbin/nologin</code> 这里设置为将要被创建系统用户<code>nginx</code>不能用来登录系统 )</li>\n<li>-d: 新帐户的主目录( 这里指定将要被创建的系统用户<code>nginx</code>的家目录为 <code>/usr/local/nginx</code> )</li>\n<li>-M: 不要创建用户的主目录( 也就是说将要被创建的系统用户<code>nginx</code>不会在 <code>/home</code> 目录下创建 <code>nginx</code> 家目录 )</li>\n</ul>\n<h3 id=\"源码安装nginx\"><a href=\"#源码安装nginx\" class=\"headerlink\" title=\"源码安装nginx\"></a>源码安装nginx</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nginx.org/download/nginx-1.23.1.tar.gz</span><br><span class=\"line\">tar -zvxf nginx-1.23.1.tar.gz -C ./nginx</span><br><span class=\"line\">cd nginx/nginx-1.23.1</span><br><span class=\"line\">./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_stub_status_module </span><br><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看内置模块\"><a href=\"#查看内置模块\" class=\"headerlink\" title=\"查看内置模块\"></a>查看内置模块</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ./auto/options |grep YES</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看自定义模块\"><a href=\"#查看自定义模块\" class=\"headerlink\" title=\"查看自定义模块\"></a>查看自定义模块</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"操作命令\"><a href=\"#操作命令\" class=\"headerlink\" title=\"操作命令\"></a>操作命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/local/nginx/sbin</span><br><span class=\"line\">nginx -c nginx.conf  <span class=\"comment\"># 启动</span></span><br><span class=\"line\">nginx -s stop  <span class=\"comment\"># 关闭</span></span><br><span class=\"line\">nginx -s reload <span class=\"comment\"># 重新加载配置</span></span><br><span class=\"line\">nginx -s quit <span class=\"comment\"># 重启，先停止在启动</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"开机自启动\"><a href=\"#开机自启动\" class=\"headerlink\" title=\"开机自启动\"></a>开机自启动</h3><p>在<code>rc.local</code>增加启动代码即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/rc.local</span><br><span class=\"line\"> /usr/local/nignx/sbin/nginx  -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n\n<p>设置rc.local的文件执行权限</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 755 rc.local</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"包管理工具安装\"><a href=\"#包管理工具安装\" class=\"headerlink\" title=\"包管理工具安装\"></a>包管理工具安装</h2><p>安装 Nginx 可以使用多种包管理工具，具体取决于你的操作系统。以下是常见操作系统的安装方法:</p>\n<hr>\n<h3 id=\"1-在-Ubuntu-Debian-上安装-Nginx\"><a href=\"#1-在-Ubuntu-Debian-上安装-Nginx\" class=\"headerlink\" title=\"1. 在 Ubuntu&#x2F;Debian 上安装 Nginx\"></a><strong>1. 在 Ubuntu&#x2F;Debian 上安装 Nginx</strong></h3><h4 id=\"使用-apt​-包管理工具：\"><a href=\"#使用-apt​-包管理工具：\" class=\"headerlink\" title=\"使用 apt​ 包管理工具：\"></a>使用 <code>apt</code>​ 包管理工具：</h4><ol>\n<li><p><strong>更新包列表</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装 Nginx</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动 Nginx 服务</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置 Nginx 开机自启动</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"2-在-CentOS-RHEL-上安装-Nginx\"><a href=\"#2-在-CentOS-RHEL-上安装-Nginx\" class=\"headerlink\" title=\"2. 在 CentOS&#x2F;RHEL 上安装 Nginx\"></a><strong>2. 在 CentOS&#x2F;RHEL 上安装 Nginx</strong></h3><h4 id=\"使用-yum​-或-dnf​-包管理工具：\"><a href=\"#使用-yum​-或-dnf​-包管理工具：\" class=\"headerlink\" title=\"使用 yum​ 或 dnf​ 包管理工具：\"></a>使用 <code>yum</code>​ 或 <code>dnf</code>​ 包管理工具：</h4><ol>\n<li><p><strong>添加 Nginx 官方仓库</strong>：<br> 创建一个文件 <code>/etc/yum.repos.d/nginx.repo</code>​，并添加以下内容：</p>\n <figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[nginx]</span><span class=\"attr\">name</span>=nginx repobaseurl=http://nginx.org/packages/centos/<span class=\"variable\">$releasever</span>/<span class=\"variable\">$basearch</span>/gpgcheck=<span class=\"number\">0</span>enabled=<span class=\"number\">1</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装 Nginx</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> yum install nginx</span><br></pre></td></tr></table></figure>\n\n<p> 或者使用 <code>dnf</code>​（适用于 CentOS 8+）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> dnf install nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动 Nginx 服务</strong>：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>设置 Nginx 开机自启动</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://&lt;服务器IP&gt;</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"3-在-macOS-上安装-Nginx\"><a href=\"#3-在-macOS-上安装-Nginx\" class=\"headerlink\" title=\"3. 在 macOS 上安装 Nginx\"></a><strong>3. 在 macOS 上安装 Nginx</strong></h3><h4 id=\"使用-Homebrew​-包管理工具：\"><a href=\"#使用-Homebrew​-包管理工具：\" class=\"headerlink\" title=\"使用 Homebrew​ 包管理工具：\"></a>使用 <code>Homebrew</code>​ 包管理工具：</h4><ol>\n<li><p><strong>安装 Homebrew</strong>（如果尚未安装）：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装 Nginx</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动 Nginx 服务</strong>：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew services start nginx</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost:8080</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"4-在-Windows-上安装-Nginx\"><a href=\"#4-在-Windows-上安装-Nginx\" class=\"headerlink\" title=\"4. 在 Windows 上安装 Nginx\"></a><strong>4. 在 Windows 上安装 Nginx</strong></h3><p>Windows 上没有直接的包管理工具安装 Nginx，但可以通过以下方式安装：</p>\n<ol>\n<li><p><strong>下载 Nginx</strong>：<br> 访问 <a href=\"http://nginx.org/en/download.html\">Nginx 官方网站</a>，下载适合 Windows 的版本。</p>\n</li>\n<li><p><strong>解压并运行</strong>：</p>\n<ul>\n<li><p>将下载的压缩包解压到一个目录（例如 <code>C:\\nginx</code>​）。</p>\n</li>\n<li><p>打开命令提示符，进入解压后的目录：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> C:\\nginx</span><br></pre></td></tr></table></figure></li>\n<li><p>启动 Nginx：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">start</span> nginx</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>验证安装</strong>：<br> 打开浏览器，访问 <code>http://localhost</code>​，如果看到 Nginx 的欢迎页面，说明安装成功。</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>操作系统</th>\n<th>包管理工具</th>\n<th>安装命令</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Ubuntu&#x2F;Debian</td>\n<td>​<code>apt</code>​</td>\n<td>​<code>sudo apt install nginx</code>​</td>\n</tr>\n<tr>\n<td>CentOS&#x2F;RHEL</td>\n<td>​<code>yum/dnf</code>​</td>\n<td>​<code>sudo yum install nginx</code>​</td>\n</tr>\n<tr>\n<td>macOS</td>\n<td>​<code>Homebrew</code>​</td>\n<td>​<code>brew install nginx</code>​</td>\n</tr>\n<tr>\n<td>Windows</td>\n<td>手动安装</td>\n<td>下载并解压 Nginx 压缩包</td>\n</tr>\n</tbody></table>\n<p>根据你的操作系统选择合适的安装方法即可。</p>\n"},{"title":"在Nginx上配置并开启WebDAV服务的完整指南","date":"2024-12-26T09:24:17.000Z","updated":"2024-12-26T09:26:38.000Z","excerpt":"要在Nginx上开启WebDAV服务，需要进行以下步骤：\n\n1. 确认Nginx已安装WebDAV模块，可通过`nginx -V`命令检查。\n2. 编辑Nginx配置文件，添加WebDAV相关配置，包括指定存储目录、启用WebDAV方法、设置访问权限等。\n3. 创建WebDAV存储目录，并设置权限。\n4. 如需认证，生成密码文件并配置基本认证。\n5. 测试Nginx配置并重启服务。\n6. 使用`cadaver`工具测试WebDAV服务。\n7. 确保防火墙允许HTTP或HTTPS流量。\n8. 完成以上步骤后，即可通过WebDAV客户端进行文件管理。","comments":1,"toc":true,"abbrlink":47927,"_content":"\n# nginx 开启webdav服务\n\n## 如何在 Nginx 上开启 WebDAV 服务\n\n要在 Nginx 上开启 WebDAV 服务，你需要配置 Nginx 以支持 WebDAV 请求。以下是详细的步骤：\n\n### 1. 确保 Nginx 安装了 WebDAV 模块\n\nNginx 的 WebDAV 功能由 `http_dav_module`​ 模块提供。默认情况下，这个模块是包含在标准 Nginx 编译中的，但某些情况下可能需要重新编译 Nginx 以包含此模块。\n\n检查 Nginx 是否包含 `http_dav_module`​ 模块：\n\n```\nnginx -V 2>&1 | grep -o with-http_dav_module\n```\n\n如果输出包含 `with-http_dav_module`​，则模块已启用。否则，你需要重新编译 Nginx 并添加此模块。\n\n### 2. 配置 Nginx 以支持 WebDAV\n\n编辑你的 Nginx 配置文件（通常位于 `/etc/nginx/nginx.conf`​ 或 `/etc/nginx/sites-available/default`​），添加或修改以下配置：\n\n```\nserver {\n    listen 80;\n    server_name your_domain.com;\n\n    location /webdav {\n        root /path/to/webdav/storage;\n        autoindex on;\n        dav_methods PUT DELETE MKCOL COPY MOVE;\n        dav_ext_methods PROPFIND PROPPATCH MKACTIVITY CHECKOUT;\n        dav_access user:rw group:rw all:r;\n        create_full_path on;\n\n        # 认证配置（可选）\n        auth_basic \"WebDAV Authentication\";\n        auth_basic_user_file /etc/nginx/.htpasswd;\n    }\n}\n```\n\n**配置说明：**\n\n* ​`root /path/to/webdav/storage;`​：指定 WebDAV 存储目录。\n* ​`dav_methods`​ 和 `dav_ext_methods`​：启用 WebDAV 方法。\n* ​`dav_access`​：设置访问权限。\n* ​`create_full_path`​：允许创建完整路径。\n* ​`auth_basic`​ 和 `auth_basic_user_file`​：启用基本认证（可选）。\n\n### 3. 创建存储目录并设置权限\n\n创建 WebDAV 存储目录并设置适当的权限：\n\n```\nsudo mkdir -p /path/to/webdav/storage\nsudo chown -R www-data:www-data /path/to/webdav/storage\nsudo chmod -R 755 /path/to/webdav/storage\n```\n\n### 4. 配置基本认证（可选）\n\n如果启用了认证，生成密码文件：\n\n```\nsudo htpasswd -c /etc/nginx/.htpasswd username\n```\n\n**注意：**  将 `username`​ 替换为实际的用户名，并根据提示设置密码。\n\n### 5. 测试 Nginx 配置并重启服务\n\n测试 Nginx 配置是否正确：\n\n```\nsudo nginx -t\n```\n\n如果配置正确，重启 Nginx 以应用更改：\n\n```\nsudo systemctl restart nginx\n```\n\n或者\n\n```\nsudo service nginx restart\n```\n\n### 6. 测试 WebDAV 服务\n\n你可以使用 `cadaver`​ 工具来测试 WebDAV 服务：\n\n```\nsudo apt-get install cadaver\ncadaver http://your_domain.com/webdav\n```\n\n输入认证信息后，你应该能够进行文件上传、下载等操作。\n\n### 7. 防火墙设置\n\n确保防火墙允许 HTTP（端口 80）或 HTTPS（端口 443）流量。\n\n```\nsudo ufw allow 80/tcp\n```\n\n或者\n\n```\nsudo firewall-cmd --permanent --add-service=http\nsudo firewall-cmd --reload\n```\n\n### 8. 完成\n\n现在，你已经成功在 Nginx 上开启了 WebDAV 服务。你可以通过 WebDAV 客户端访问该服务并进行文件管理。\n","source":"_posts/nginx-turn-on-the-webdav-service-zadzub.md","raw":"---\ntitle: 在Nginx上配置并开启WebDAV服务的完整指南\ndate: '2024-12-26 17:24:17'\nupdated: '2024-12-26 17:26:38'\nexcerpt: |-\n  要在Nginx上开启WebDAV服务，需要进行以下步骤：\n\n  1. 确认Nginx已安装WebDAV模块，可通过`nginx -V`命令检查。\n  2. 编辑Nginx配置文件，添加WebDAV相关配置，包括指定存储目录、启用WebDAV方法、设置访问权限等。\n  3. 创建WebDAV存储目录，并设置权限。\n  4. 如需认证，生成密码文件并配置基本认证。\n  5. 测试Nginx配置并重启服务。\n  6. 使用`cadaver`工具测试WebDAV服务。\n  7. 确保防火墙允许HTTP或HTTPS流量。\n  8. 完成以上步骤后，即可通过WebDAV客户端进行文件管理。\ntags:\n  - Nginx\n  - WebDAV\n  - 配置\n  - 安全\n  - 服务\ncategories:\n  - 服务器\n  - 网络配置\n  - WebDAV\npermalink: /post/nginx-turn-on-the-webdav-service-zadzub.html\ncomments: true\ntoc: true\nabbrlink: 47927\n---\n\n# nginx 开启webdav服务\n\n## 如何在 Nginx 上开启 WebDAV 服务\n\n要在 Nginx 上开启 WebDAV 服务，你需要配置 Nginx 以支持 WebDAV 请求。以下是详细的步骤：\n\n### 1. 确保 Nginx 安装了 WebDAV 模块\n\nNginx 的 WebDAV 功能由 `http_dav_module`​ 模块提供。默认情况下，这个模块是包含在标准 Nginx 编译中的，但某些情况下可能需要重新编译 Nginx 以包含此模块。\n\n检查 Nginx 是否包含 `http_dav_module`​ 模块：\n\n```\nnginx -V 2>&1 | grep -o with-http_dav_module\n```\n\n如果输出包含 `with-http_dav_module`​，则模块已启用。否则，你需要重新编译 Nginx 并添加此模块。\n\n### 2. 配置 Nginx 以支持 WebDAV\n\n编辑你的 Nginx 配置文件（通常位于 `/etc/nginx/nginx.conf`​ 或 `/etc/nginx/sites-available/default`​），添加或修改以下配置：\n\n```\nserver {\n    listen 80;\n    server_name your_domain.com;\n\n    location /webdav {\n        root /path/to/webdav/storage;\n        autoindex on;\n        dav_methods PUT DELETE MKCOL COPY MOVE;\n        dav_ext_methods PROPFIND PROPPATCH MKACTIVITY CHECKOUT;\n        dav_access user:rw group:rw all:r;\n        create_full_path on;\n\n        # 认证配置（可选）\n        auth_basic \"WebDAV Authentication\";\n        auth_basic_user_file /etc/nginx/.htpasswd;\n    }\n}\n```\n\n**配置说明：**\n\n* ​`root /path/to/webdav/storage;`​：指定 WebDAV 存储目录。\n* ​`dav_methods`​ 和 `dav_ext_methods`​：启用 WebDAV 方法。\n* ​`dav_access`​：设置访问权限。\n* ​`create_full_path`​：允许创建完整路径。\n* ​`auth_basic`​ 和 `auth_basic_user_file`​：启用基本认证（可选）。\n\n### 3. 创建存储目录并设置权限\n\n创建 WebDAV 存储目录并设置适当的权限：\n\n```\nsudo mkdir -p /path/to/webdav/storage\nsudo chown -R www-data:www-data /path/to/webdav/storage\nsudo chmod -R 755 /path/to/webdav/storage\n```\n\n### 4. 配置基本认证（可选）\n\n如果启用了认证，生成密码文件：\n\n```\nsudo htpasswd -c /etc/nginx/.htpasswd username\n```\n\n**注意：**  将 `username`​ 替换为实际的用户名，并根据提示设置密码。\n\n### 5. 测试 Nginx 配置并重启服务\n\n测试 Nginx 配置是否正确：\n\n```\nsudo nginx -t\n```\n\n如果配置正确，重启 Nginx 以应用更改：\n\n```\nsudo systemctl restart nginx\n```\n\n或者\n\n```\nsudo service nginx restart\n```\n\n### 6. 测试 WebDAV 服务\n\n你可以使用 `cadaver`​ 工具来测试 WebDAV 服务：\n\n```\nsudo apt-get install cadaver\ncadaver http://your_domain.com/webdav\n```\n\n输入认证信息后，你应该能够进行文件上传、下载等操作。\n\n### 7. 防火墙设置\n\n确保防火墙允许 HTTP（端口 80）或 HTTPS（端口 443）流量。\n\n```\nsudo ufw allow 80/tcp\n```\n\n或者\n\n```\nsudo firewall-cmd --permanent --add-service=http\nsudo firewall-cmd --reload\n```\n\n### 8. 完成\n\n现在，你已经成功在 Nginx 上开启了 WebDAV 服务。你可以通过 WebDAV 客户端访问该服务并进行文件管理。\n","slug":"nginx-turn-on-the-webdav-service-zadzub","published":1,"__permalink":"/post/nginx-turn-on-the-webdav-service-zadzub.html","_id":"cmclcaf40000jp8vwf5h7929p","layout":"post","photos":[],"content":"<h1 id=\"nginx-开启webdav服务\"><a href=\"#nginx-开启webdav服务\" class=\"headerlink\" title=\"nginx 开启webdav服务\"></a>nginx 开启webdav服务</h1><h2 id=\"如何在-Nginx-上开启-WebDAV-服务\"><a href=\"#如何在-Nginx-上开启-WebDAV-服务\" class=\"headerlink\" title=\"如何在 Nginx 上开启 WebDAV 服务\"></a>如何在 Nginx 上开启 WebDAV 服务</h2><p>要在 Nginx 上开启 WebDAV 服务，你需要配置 Nginx 以支持 WebDAV 请求。以下是详细的步骤：</p>\n<h3 id=\"1-确保-Nginx-安装了-WebDAV-模块\"><a href=\"#1-确保-Nginx-安装了-WebDAV-模块\" class=\"headerlink\" title=\"1. 确保 Nginx 安装了 WebDAV 模块\"></a>1. 确保 Nginx 安装了 WebDAV 模块</h3><p>Nginx 的 WebDAV 功能由 <code>http_dav_module</code>​ 模块提供。默认情况下，这个模块是包含在标准 Nginx 编译中的，但某些情况下可能需要重新编译 Nginx 以包含此模块。</p>\n<p>检查 Nginx 是否包含 <code>http_dav_module</code>​ 模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -V 2&gt;&amp;1 | grep -o with-http_dav_module</span><br></pre></td></tr></table></figure>\n\n<p>如果输出包含 <code>with-http_dav_module</code>​，则模块已启用。否则，你需要重新编译 Nginx 并添加此模块。</p>\n<h3 id=\"2-配置-Nginx-以支持-WebDAV\"><a href=\"#2-配置-Nginx-以支持-WebDAV\" class=\"headerlink\" title=\"2. 配置 Nginx 以支持 WebDAV\"></a>2. 配置 Nginx 以支持 WebDAV</h3><p>编辑你的 Nginx 配置文件（通常位于 <code>/etc/nginx/nginx.conf</code>​ 或 <code>/etc/nginx/sites-available/default</code>​），添加或修改以下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name your_domain.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location /webdav &#123;</span><br><span class=\"line\">        root /path/to/webdav/storage;</span><br><span class=\"line\">        autoindex on;</span><br><span class=\"line\">        dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class=\"line\">        dav_ext_methods PROPFIND PROPPATCH MKACTIVITY CHECKOUT;</span><br><span class=\"line\">        dav_access user:rw group:rw all:r;</span><br><span class=\"line\">        create_full_path on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 认证配置（可选）</span><br><span class=\"line\">        auth_basic &quot;WebDAV Authentication&quot;;</span><br><span class=\"line\">        auth_basic_user_file /etc/nginx/.htpasswd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>配置说明：</strong></p>\n<ul>\n<li>​<code>root /path/to/webdav/storage;</code>​：指定 WebDAV 存储目录。</li>\n<li>​<code>dav_methods</code>​ 和 <code>dav_ext_methods</code>​：启用 WebDAV 方法。</li>\n<li>​<code>dav_access</code>​：设置访问权限。</li>\n<li>​<code>create_full_path</code>​：允许创建完整路径。</li>\n<li>​<code>auth_basic</code>​ 和 <code>auth_basic_user_file</code>​：启用基本认证（可选）。</li>\n</ul>\n<h3 id=\"3-创建存储目录并设置权限\"><a href=\"#3-创建存储目录并设置权限\" class=\"headerlink\" title=\"3. 创建存储目录并设置权限\"></a>3. 创建存储目录并设置权限</h3><p>创建 WebDAV 存储目录并设置适当的权限：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /path/to/webdav/storage</span><br><span class=\"line\">sudo chown -R www-data:www-data /path/to/webdav/storage</span><br><span class=\"line\">sudo chmod -R 755 /path/to/webdav/storage</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-配置基本认证（可选）\"><a href=\"#4-配置基本认证（可选）\" class=\"headerlink\" title=\"4. 配置基本认证（可选）\"></a>4. 配置基本认证（可选）</h3><p>如果启用了认证，生成密码文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo htpasswd -c /etc/nginx/.htpasswd username</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>  将 <code>username</code>​ 替换为实际的用户名，并根据提示设置密码。</p>\n<h3 id=\"5-测试-Nginx-配置并重启服务\"><a href=\"#5-测试-Nginx-配置并重启服务\" class=\"headerlink\" title=\"5. 测试 Nginx 配置并重启服务\"></a>5. 测试 Nginx 配置并重启服务</h3><p>测试 Nginx 配置是否正确：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure>\n\n<p>如果配置正确，重启 Nginx 以应用更改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service nginx restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-测试-WebDAV-服务\"><a href=\"#6-测试-WebDAV-服务\" class=\"headerlink\" title=\"6. 测试 WebDAV 服务\"></a>6. 测试 WebDAV 服务</h3><p>你可以使用 <code>cadaver</code>​ 工具来测试 WebDAV 服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install cadaver</span><br><span class=\"line\">cadaver http://your_domain.com/webdav</span><br></pre></td></tr></table></figure>\n\n<p>输入认证信息后，你应该能够进行文件上传、下载等操作。</p>\n<h3 id=\"7-防火墙设置\"><a href=\"#7-防火墙设置\" class=\"headerlink\" title=\"7. 防火墙设置\"></a>7. 防火墙设置</h3><p>确保防火墙允许 HTTP（端口 80）或 HTTPS（端口 443）流量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ufw allow 80/tcp</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --add-service=http</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-完成\"><a href=\"#8-完成\" class=\"headerlink\" title=\"8. 完成\"></a>8. 完成</h3><p>现在，你已经成功在 Nginx 上开启了 WebDAV 服务。你可以通过 WebDAV 客户端访问该服务并进行文件管理。</p>\n","more":"<h1 id=\"nginx-开启webdav服务\"><a href=\"#nginx-开启webdav服务\" class=\"headerlink\" title=\"nginx 开启webdav服务\"></a>nginx 开启webdav服务</h1><h2 id=\"如何在-Nginx-上开启-WebDAV-服务\"><a href=\"#如何在-Nginx-上开启-WebDAV-服务\" class=\"headerlink\" title=\"如何在 Nginx 上开启 WebDAV 服务\"></a>如何在 Nginx 上开启 WebDAV 服务</h2><p>要在 Nginx 上开启 WebDAV 服务，你需要配置 Nginx 以支持 WebDAV 请求。以下是详细的步骤：</p>\n<h3 id=\"1-确保-Nginx-安装了-WebDAV-模块\"><a href=\"#1-确保-Nginx-安装了-WebDAV-模块\" class=\"headerlink\" title=\"1. 确保 Nginx 安装了 WebDAV 模块\"></a>1. 确保 Nginx 安装了 WebDAV 模块</h3><p>Nginx 的 WebDAV 功能由 <code>http_dav_module</code>​ 模块提供。默认情况下，这个模块是包含在标准 Nginx 编译中的，但某些情况下可能需要重新编译 Nginx 以包含此模块。</p>\n<p>检查 Nginx 是否包含 <code>http_dav_module</code>​ 模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -V 2&gt;&amp;1 | grep -o with-http_dav_module</span><br></pre></td></tr></table></figure>\n\n<p>如果输出包含 <code>with-http_dav_module</code>​，则模块已启用。否则，你需要重新编译 Nginx 并添加此模块。</p>\n<h3 id=\"2-配置-Nginx-以支持-WebDAV\"><a href=\"#2-配置-Nginx-以支持-WebDAV\" class=\"headerlink\" title=\"2. 配置 Nginx 以支持 WebDAV\"></a>2. 配置 Nginx 以支持 WebDAV</h3><p>编辑你的 Nginx 配置文件（通常位于 <code>/etc/nginx/nginx.conf</code>​ 或 <code>/etc/nginx/sites-available/default</code>​），添加或修改以下配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name your_domain.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location /webdav &#123;</span><br><span class=\"line\">        root /path/to/webdav/storage;</span><br><span class=\"line\">        autoindex on;</span><br><span class=\"line\">        dav_methods PUT DELETE MKCOL COPY MOVE;</span><br><span class=\"line\">        dav_ext_methods PROPFIND PROPPATCH MKACTIVITY CHECKOUT;</span><br><span class=\"line\">        dav_access user:rw group:rw all:r;</span><br><span class=\"line\">        create_full_path on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 认证配置（可选）</span><br><span class=\"line\">        auth_basic &quot;WebDAV Authentication&quot;;</span><br><span class=\"line\">        auth_basic_user_file /etc/nginx/.htpasswd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>配置说明：</strong></p>\n<ul>\n<li>​<code>root /path/to/webdav/storage;</code>​：指定 WebDAV 存储目录。</li>\n<li>​<code>dav_methods</code>​ 和 <code>dav_ext_methods</code>​：启用 WebDAV 方法。</li>\n<li>​<code>dav_access</code>​：设置访问权限。</li>\n<li>​<code>create_full_path</code>​：允许创建完整路径。</li>\n<li>​<code>auth_basic</code>​ 和 <code>auth_basic_user_file</code>​：启用基本认证（可选）。</li>\n</ul>\n<h3 id=\"3-创建存储目录并设置权限\"><a href=\"#3-创建存储目录并设置权限\" class=\"headerlink\" title=\"3. 创建存储目录并设置权限\"></a>3. 创建存储目录并设置权限</h3><p>创建 WebDAV 存储目录并设置适当的权限：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /path/to/webdav/storage</span><br><span class=\"line\">sudo chown -R www-data:www-data /path/to/webdav/storage</span><br><span class=\"line\">sudo chmod -R 755 /path/to/webdav/storage</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-配置基本认证（可选）\"><a href=\"#4-配置基本认证（可选）\" class=\"headerlink\" title=\"4. 配置基本认证（可选）\"></a>4. 配置基本认证（可选）</h3><p>如果启用了认证，生成密码文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo htpasswd -c /etc/nginx/.htpasswd username</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>  将 <code>username</code>​ 替换为实际的用户名，并根据提示设置密码。</p>\n<h3 id=\"5-测试-Nginx-配置并重启服务\"><a href=\"#5-测试-Nginx-配置并重启服务\" class=\"headerlink\" title=\"5. 测试 Nginx 配置并重启服务\"></a>5. 测试 Nginx 配置并重启服务</h3><p>测试 Nginx 配置是否正确：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure>\n\n<p>如果配置正确，重启 Nginx 以应用更改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service nginx restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-测试-WebDAV-服务\"><a href=\"#6-测试-WebDAV-服务\" class=\"headerlink\" title=\"6. 测试 WebDAV 服务\"></a>6. 测试 WebDAV 服务</h3><p>你可以使用 <code>cadaver</code>​ 工具来测试 WebDAV 服务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install cadaver</span><br><span class=\"line\">cadaver http://your_domain.com/webdav</span><br></pre></td></tr></table></figure>\n\n<p>输入认证信息后，你应该能够进行文件上传、下载等操作。</p>\n<h3 id=\"7-防火墙设置\"><a href=\"#7-防火墙设置\" class=\"headerlink\" title=\"7. 防火墙设置\"></a>7. 防火墙设置</h3><p>确保防火墙允许 HTTP（端口 80）或 HTTPS（端口 443）流量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ufw allow 80/tcp</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --add-service=http</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-完成\"><a href=\"#8-完成\" class=\"headerlink\" title=\"8. 完成\"></a>8. 完成</h3><p>现在，你已经成功在 Nginx 上开启了 WebDAV 服务。你可以通过 WebDAV 客户端访问该服务并进行文件管理。</p>\n"},{"title":"端口占用处理","date":"2024-12-19T01:57:31.000Z","updated":"2024-12-26T08:31:12.000Z","excerpt":"本文详细介绍了在Windows和Linux系统中处理端口占用的方法。在Windows中，首先使用`netstat -aon|findstr \"端口号\"`查找占用端口的PID，然后通过`tasklist|findstr \"PID\"`确认进程，最后使用`taskkill -F -pid PID`或任务管理器结束进程。在Linux中，使用`sudo lsof -i :端口号`查找占用端口的进程，通过`sudo kill -9 PID`结束进程，并使用`sudo lsof -i :端口号`确认端口是否释放。文章还提供了防止端口被占用的建议，如修改应用程序端口、检查启动脚本和使用端口管理工具。通过这些步骤，用户可以轻松解决端口占用问题。","comments":1,"toc":true,"abbrlink":20316,"_content":"\n# 端口占用处理\n\n## 项目启动报端口正在使用\n\n```\n09:25:12.866 [restartedMain]  ERROR org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter : \n\n***************************\nAPPLICATION FAILED TO START\n***************************\n\nDescription:\n\nWeb server failed to start. Port 8092 was already in use.\n\nAction:\n\nIdentify and stop the process that's listening on port 8092 or configure this application to listen on another port.\n\nDisconnected from the target VM, address: '127.0.0.1:59259', transport: 'socket'\n\nProcess finished with exit code 0\n```\n\n# windows端口占用处理\n\n### 1.**查看被占用端口所对应的 PID**\n\n输入命令【netstat -aon|findstr + “端口号”】后按回车。假设我们要查的是端口号“8092”，那么就输入【netstat -aon|findstr “8092”】，然后回车。这样我们就可以查到这端口的PID是“13160”。\n\n```\nC:\\Users\\X Bear>netstat -ano | findstr 8092\n  TCP    0.0.0.0:8092           0.0.0.0:0              LISTENING       13160\n  TCP    [::]:8092              [::]:0                 LISTENING       13160\n```\n\n### 2.**查看指定PID的进程**\n\n如果想查看是哪个进程占用了“8092”端口，就输入命令【tasklist|findstr ”8092”】后回车。就可以看到结果是“Java. exe”。\n\n### 3.**结束进程**\n\n方法一：输入命令【taskkill -pid 进程号 -f】后回车，就可以终止进程。如我们要终止PID号“13160”，那么就输入【taskkill -pid 13160-f】。-f 强制执行\n\n```\nC:\\Users\\X Bear>taskkill -pid 13160\n错误: 无法终止 PID 为 13160 的进程。\n原因: 只能强行终止这个进程(带 /F 选项)。\n```\n\n```\nC:\\Users\\X Bear>taskkill -F -pid 13160\n成功: 已终止 PID 为 13160 的进程。\n```\n\n　　方法二：win10可以打开按“Shift + Ctrl + Esc” 组合键，打开任务管理器，切换到【详细信息】板块，找到PID对应的程序，然后右键选择“结束任务”。\n\n‍\n\n‍\n\n## Linux 端口占用处理\n\n### **1. 查找占用端口的进程**\n\n使用以下命令查看哪个进程占用了端口（以端口 `8080`​ 为例）：\n\n```\nsudo lsof -i :8080\n```\n\n* 输出示例：\n\n  ```\n  COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n  java     12345  user   123  IPv6  12345      0t0  TCP *:http-alt (LISTEN)\n  ```\n\n  * ​`COMMAND`​：进程名称。\n  * ​`PID`​：进程 ID。\n  * ​`USER`​：运行该进程的用户。\n  * ​`NAME`​：端口信息。\n\n如果不知道具体端口，可以使用以下命令列出所有占用端口的进程：\n\n```\nsudo netstat -tuln\n\n#如果数据太多可以使用管道符精确查询\nsudo netstat -tuln | grep 8080\n```\n\n---\n\n### **2. 结束占用端口的进程**\n\n找到进程 ID (PID) 后，使用以下命令结束进程：\n\n```\nsudo kill -9 12345\n```\n\n* ​`-9`​ 表示强制结束进程。\n\n如果需要结束多个进程，可以一次性结束：\n\n```\nsudo kill -9 12345 54321\n```\n\n---\n\n### **3. 检查端口是否已释放**\n\n再次运行以下命令，确认端口是否已释放：\n\n```\nsudo lsof -i :8080\n```\n\n如果没有输出，说明端口已成功释放。\n\n---\n\n### **4. 其他常用命令**\n\n* **查找所有占用端口的进程**：\n\n  ```\n  sudo netstat -tuln\n  ```\n* **根据进程名称查找 PID**：\n\n  ```\n  pgrep java\n  ```\n* **查看某个进程的详细信息**：\n\n  ```\n  ps -fp 12345\n  ```\n\n---\n\n### **5. 防止端口被占用**\n\n如果端口经常被占用，可以采取以下措施：\n\n1. **修改应用程序端口**：将应用程序的端口改为其他未被占用的端口。\n2. **检查启动脚本**：确保没有重复启动同一应用程序。\n3. **使用端口管理工具**：如 `nmap`​ 或 `netstat`​，定期检查端口使用情况。\n\n---\n\n### **6. 示例：解除端口 8080 占用**\n\n```\n# 查找占用 8080 端口的进程sudo lsof -i :8080# 结束进程（假设 PID 为 12345）sudo kill -9 12345# 确认端口是否已释放\nsudo lsof -i :8080\n```\n\n---\n\n通过以上步骤，你可以轻松解除 Linux 上的端口占用问题！\n","source":"_posts/port-occupation-treatment-2ogd9p.md","raw":"---\ntitle: 端口占用处理\ndate: '2024-12-19 09:57:31'\nupdated: '2024-12-26 16:31:12'\nexcerpt: >-\n  本文详细介绍了在Windows和Linux系统中处理端口占用的方法。在Windows中，首先使用`netstat -aon|findstr\n  \"端口号\"`查找占用端口的PID，然后通过`tasklist|findstr \"PID\"`确认进程，最后使用`taskkill -F -pid\n  PID`或任务管理器结束进程。在Linux中，使用`sudo lsof -i :端口号`查找占用端口的进程，通过`sudo kill -9\n  PID`结束进程，并使用`sudo lsof -i\n  :端口号`确认端口是否释放。文章还提供了防止端口被占用的建议，如修改应用程序端口、检查启动脚本和使用端口管理工具。通过这些步骤，用户可以轻松解决端口占用问题。\ntags:\n  - 端口占用\n  - 错误处理\n  - Windows\n  - Linux\n  - 进程管理\npermalink: /post/port-occupation-treatment-2ogd9p.html\ncomments: true\ntoc: true\nabbrlink: 20316\n---\n\n# 端口占用处理\n\n## 项目启动报端口正在使用\n\n```\n09:25:12.866 [restartedMain]  ERROR org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter : \n\n***************************\nAPPLICATION FAILED TO START\n***************************\n\nDescription:\n\nWeb server failed to start. Port 8092 was already in use.\n\nAction:\n\nIdentify and stop the process that's listening on port 8092 or configure this application to listen on another port.\n\nDisconnected from the target VM, address: '127.0.0.1:59259', transport: 'socket'\n\nProcess finished with exit code 0\n```\n\n# windows端口占用处理\n\n### 1.**查看被占用端口所对应的 PID**\n\n输入命令【netstat -aon|findstr + “端口号”】后按回车。假设我们要查的是端口号“8092”，那么就输入【netstat -aon|findstr “8092”】，然后回车。这样我们就可以查到这端口的PID是“13160”。\n\n```\nC:\\Users\\X Bear>netstat -ano | findstr 8092\n  TCP    0.0.0.0:8092           0.0.0.0:0              LISTENING       13160\n  TCP    [::]:8092              [::]:0                 LISTENING       13160\n```\n\n### 2.**查看指定PID的进程**\n\n如果想查看是哪个进程占用了“8092”端口，就输入命令【tasklist|findstr ”8092”】后回车。就可以看到结果是“Java. exe”。\n\n### 3.**结束进程**\n\n方法一：输入命令【taskkill -pid 进程号 -f】后回车，就可以终止进程。如我们要终止PID号“13160”，那么就输入【taskkill -pid 13160-f】。-f 强制执行\n\n```\nC:\\Users\\X Bear>taskkill -pid 13160\n错误: 无法终止 PID 为 13160 的进程。\n原因: 只能强行终止这个进程(带 /F 选项)。\n```\n\n```\nC:\\Users\\X Bear>taskkill -F -pid 13160\n成功: 已终止 PID 为 13160 的进程。\n```\n\n　　方法二：win10可以打开按“Shift + Ctrl + Esc” 组合键，打开任务管理器，切换到【详细信息】板块，找到PID对应的程序，然后右键选择“结束任务”。\n\n‍\n\n‍\n\n## Linux 端口占用处理\n\n### **1. 查找占用端口的进程**\n\n使用以下命令查看哪个进程占用了端口（以端口 `8080`​ 为例）：\n\n```\nsudo lsof -i :8080\n```\n\n* 输出示例：\n\n  ```\n  COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n  java     12345  user   123  IPv6  12345      0t0  TCP *:http-alt (LISTEN)\n  ```\n\n  * ​`COMMAND`​：进程名称。\n  * ​`PID`​：进程 ID。\n  * ​`USER`​：运行该进程的用户。\n  * ​`NAME`​：端口信息。\n\n如果不知道具体端口，可以使用以下命令列出所有占用端口的进程：\n\n```\nsudo netstat -tuln\n\n#如果数据太多可以使用管道符精确查询\nsudo netstat -tuln | grep 8080\n```\n\n---\n\n### **2. 结束占用端口的进程**\n\n找到进程 ID (PID) 后，使用以下命令结束进程：\n\n```\nsudo kill -9 12345\n```\n\n* ​`-9`​ 表示强制结束进程。\n\n如果需要结束多个进程，可以一次性结束：\n\n```\nsudo kill -9 12345 54321\n```\n\n---\n\n### **3. 检查端口是否已释放**\n\n再次运行以下命令，确认端口是否已释放：\n\n```\nsudo lsof -i :8080\n```\n\n如果没有输出，说明端口已成功释放。\n\n---\n\n### **4. 其他常用命令**\n\n* **查找所有占用端口的进程**：\n\n  ```\n  sudo netstat -tuln\n  ```\n* **根据进程名称查找 PID**：\n\n  ```\n  pgrep java\n  ```\n* **查看某个进程的详细信息**：\n\n  ```\n  ps -fp 12345\n  ```\n\n---\n\n### **5. 防止端口被占用**\n\n如果端口经常被占用，可以采取以下措施：\n\n1. **修改应用程序端口**：将应用程序的端口改为其他未被占用的端口。\n2. **检查启动脚本**：确保没有重复启动同一应用程序。\n3. **使用端口管理工具**：如 `nmap`​ 或 `netstat`​，定期检查端口使用情况。\n\n---\n\n### **6. 示例：解除端口 8080 占用**\n\n```\n# 查找占用 8080 端口的进程sudo lsof -i :8080# 结束进程（假设 PID 为 12345）sudo kill -9 12345# 确认端口是否已释放\nsudo lsof -i :8080\n```\n\n---\n\n通过以上步骤，你可以轻松解除 Linux 上的端口占用问题！\n","slug":"port-occupation-treatment-2ogd9p","published":1,"__permalink":"/post/port-occupation-treatment-2ogd9p.html","_id":"cmclcaf44000np8vw767c3kp2","layout":"post","photos":[],"content":"<h1 id=\"端口占用处理\"><a href=\"#端口占用处理\" class=\"headerlink\" title=\"端口占用处理\"></a>端口占用处理</h1><h2 id=\"项目启动报端口正在使用\"><a href=\"#项目启动报端口正在使用\" class=\"headerlink\" title=\"项目启动报端口正在使用\"></a>项目启动报端口正在使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">09:25:12.866 [restartedMain]  ERROR org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter : </span><br><span class=\"line\"></span><br><span class=\"line\">***************************</span><br><span class=\"line\">APPLICATION FAILED TO START</span><br><span class=\"line\">***************************</span><br><span class=\"line\"></span><br><span class=\"line\">Description:</span><br><span class=\"line\"></span><br><span class=\"line\">Web server failed to start. Port 8092 was already in use.</span><br><span class=\"line\"></span><br><span class=\"line\">Action:</span><br><span class=\"line\"></span><br><span class=\"line\">Identify and stop the process that&#x27;s listening on port 8092 or configure this application to listen on another port.</span><br><span class=\"line\"></span><br><span class=\"line\">Disconnected from the target VM, address: &#x27;127.0.0.1:59259&#x27;, transport: &#x27;socket&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"windows端口占用处理\"><a href=\"#windows端口占用处理\" class=\"headerlink\" title=\"windows端口占用处理\"></a>windows端口占用处理</h1><h3 id=\"1-查看被占用端口所对应的-PID\"><a href=\"#1-查看被占用端口所对应的-PID\" class=\"headerlink\" title=\"1.查看被占用端口所对应的 PID\"></a>1.<strong>查看被占用端口所对应的 PID</strong></h3><p>输入命令【netstat -aon|findstr + “端口号”】后按回车。假设我们要查的是端口号“8092”，那么就输入【netstat -aon|findstr “8092”】，然后回车。这样我们就可以查到这端口的PID是“13160”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\X Bear&gt;netstat -ano | findstr 8092</span><br><span class=\"line\">  TCP    0.0.0.0:8092           0.0.0.0:0              LISTENING       13160</span><br><span class=\"line\">  TCP    [::]:8092              [::]:0                 LISTENING       13160</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看指定PID的进程\"><a href=\"#2-查看指定PID的进程\" class=\"headerlink\" title=\"2.查看指定PID的进程\"></a>2.<strong>查看指定PID的进程</strong></h3><p>如果想查看是哪个进程占用了“8092”端口，就输入命令【tasklist|findstr ”8092”】后回车。就可以看到结果是“Java. exe”。</p>\n<h3 id=\"3-结束进程\"><a href=\"#3-结束进程\" class=\"headerlink\" title=\"3.结束进程\"></a>3.<strong>结束进程</strong></h3><p>方法一：输入命令【taskkill -pid 进程号 -f】后回车，就可以终止进程。如我们要终止PID号“13160”，那么就输入【taskkill -pid 13160-f】。-f 强制执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\X Bear&gt;taskkill -pid 13160</span><br><span class=\"line\">错误: 无法终止 PID 为 13160 的进程。</span><br><span class=\"line\">原因: 只能强行终止这个进程(带 /F 选项)。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\X Bear&gt;taskkill -F -pid 13160</span><br><span class=\"line\">成功: 已终止 PID 为 13160 的进程。</span><br></pre></td></tr></table></figure>\n\n<p>　　方法二：win10可以打开按“Shift + Ctrl + Esc” 组合键，打开任务管理器，切换到【详细信息】板块，找到PID对应的程序，然后右键选择“结束任务”。</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"Linux-端口占用处理\"><a href=\"#Linux-端口占用处理\" class=\"headerlink\" title=\"Linux 端口占用处理\"></a>Linux 端口占用处理</h2><h3 id=\"1-查找占用端口的进程\"><a href=\"#1-查找占用端口的进程\" class=\"headerlink\" title=\"1. 查找占用端口的进程\"></a><strong>1. 查找占用端口的进程</strong></h3><p>使用以下命令查看哪个进程占用了端口（以端口 <code>8080</code>​ 为例）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>输出示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java     12345  user   123  IPv6  12345      0t0  TCP *:http-alt (LISTEN)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​<code>COMMAND</code>​：进程名称。</li>\n<li>​<code>PID</code>​：进程 ID。</li>\n<li>​<code>USER</code>​：运行该进程的用户。</li>\n<li>​<code>NAME</code>​：端口信息。</li>\n</ul>\n</li>\n</ul>\n<p>如果不知道具体端口，可以使用以下命令列出所有占用端口的进程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -tuln</span><br><span class=\"line\"></span><br><span class=\"line\">#如果数据太多可以使用管道符精确查询</span><br><span class=\"line\">sudo netstat -tuln | grep 8080</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-结束占用端口的进程\"><a href=\"#2-结束占用端口的进程\" class=\"headerlink\" title=\"2. 结束占用端口的进程\"></a><strong>2. 结束占用端口的进程</strong></h3><p>找到进程 ID (PID) 后，使用以下命令结束进程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo kill -9 12345</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​<code>-9</code>​ 表示强制结束进程。</li>\n</ul>\n<p>如果需要结束多个进程，可以一次性结束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo kill -9 12345 54321</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-检查端口是否已释放\"><a href=\"#3-检查端口是否已释放\" class=\"headerlink\" title=\"3. 检查端口是否已释放\"></a><strong>3. 检查端口是否已释放</strong></h3><p>再次运行以下命令，确认端口是否已释放：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<p>如果没有输出，说明端口已成功释放。</p>\n<hr>\n<h3 id=\"4-其他常用命令\"><a href=\"#4-其他常用命令\" class=\"headerlink\" title=\"4. 其他常用命令\"></a><strong>4. 其他常用命令</strong></h3><ul>\n<li><p><strong>查找所有占用端口的进程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -tuln</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>根据进程名称查找 PID</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pgrep java</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查看某个进程的详细信息</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -fp 12345</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"5-防止端口被占用\"><a href=\"#5-防止端口被占用\" class=\"headerlink\" title=\"5. 防止端口被占用\"></a><strong>5. 防止端口被占用</strong></h3><p>如果端口经常被占用，可以采取以下措施：</p>\n<ol>\n<li><strong>修改应用程序端口</strong>：将应用程序的端口改为其他未被占用的端口。</li>\n<li><strong>检查启动脚本</strong>：确保没有重复启动同一应用程序。</li>\n<li><strong>使用端口管理工具</strong>：如 <code>nmap</code>​ 或 <code>netstat</code>​，定期检查端口使用情况。</li>\n</ol>\n<hr>\n<h3 id=\"6-示例：解除端口-8080-占用\"><a href=\"#6-示例：解除端口-8080-占用\" class=\"headerlink\" title=\"6. 示例：解除端口 8080 占用\"></a><strong>6. 示例：解除端口 8080 占用</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查找占用 8080 端口的进程sudo lsof -i :8080# 结束进程（假设 PID 为 12345）sudo kill -9 12345# 确认端口是否已释放</span><br><span class=\"line\">sudo lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>通过以上步骤，你可以轻松解除 Linux 上的端口占用问题！</p>\n","more":"<h1 id=\"端口占用处理\"><a href=\"#端口占用处理\" class=\"headerlink\" title=\"端口占用处理\"></a>端口占用处理</h1><h2 id=\"项目启动报端口正在使用\"><a href=\"#项目启动报端口正在使用\" class=\"headerlink\" title=\"项目启动报端口正在使用\"></a>项目启动报端口正在使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">09:25:12.866 [restartedMain]  ERROR org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter : </span><br><span class=\"line\"></span><br><span class=\"line\">***************************</span><br><span class=\"line\">APPLICATION FAILED TO START</span><br><span class=\"line\">***************************</span><br><span class=\"line\"></span><br><span class=\"line\">Description:</span><br><span class=\"line\"></span><br><span class=\"line\">Web server failed to start. Port 8092 was already in use.</span><br><span class=\"line\"></span><br><span class=\"line\">Action:</span><br><span class=\"line\"></span><br><span class=\"line\">Identify and stop the process that&#x27;s listening on port 8092 or configure this application to listen on another port.</span><br><span class=\"line\"></span><br><span class=\"line\">Disconnected from the target VM, address: &#x27;127.0.0.1:59259&#x27;, transport: &#x27;socket&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"windows端口占用处理\"><a href=\"#windows端口占用处理\" class=\"headerlink\" title=\"windows端口占用处理\"></a>windows端口占用处理</h1><h3 id=\"1-查看被占用端口所对应的-PID\"><a href=\"#1-查看被占用端口所对应的-PID\" class=\"headerlink\" title=\"1.查看被占用端口所对应的 PID\"></a>1.<strong>查看被占用端口所对应的 PID</strong></h3><p>输入命令【netstat -aon|findstr + “端口号”】后按回车。假设我们要查的是端口号“8092”，那么就输入【netstat -aon|findstr “8092”】，然后回车。这样我们就可以查到这端口的PID是“13160”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\X Bear&gt;netstat -ano | findstr 8092</span><br><span class=\"line\">  TCP    0.0.0.0:8092           0.0.0.0:0              LISTENING       13160</span><br><span class=\"line\">  TCP    [::]:8092              [::]:0                 LISTENING       13160</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看指定PID的进程\"><a href=\"#2-查看指定PID的进程\" class=\"headerlink\" title=\"2.查看指定PID的进程\"></a>2.<strong>查看指定PID的进程</strong></h3><p>如果想查看是哪个进程占用了“8092”端口，就输入命令【tasklist|findstr ”8092”】后回车。就可以看到结果是“Java. exe”。</p>\n<h3 id=\"3-结束进程\"><a href=\"#3-结束进程\" class=\"headerlink\" title=\"3.结束进程\"></a>3.<strong>结束进程</strong></h3><p>方法一：输入命令【taskkill -pid 进程号 -f】后回车，就可以终止进程。如我们要终止PID号“13160”，那么就输入【taskkill -pid 13160-f】。-f 强制执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\X Bear&gt;taskkill -pid 13160</span><br><span class=\"line\">错误: 无法终止 PID 为 13160 的进程。</span><br><span class=\"line\">原因: 只能强行终止这个进程(带 /F 选项)。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\X Bear&gt;taskkill -F -pid 13160</span><br><span class=\"line\">成功: 已终止 PID 为 13160 的进程。</span><br></pre></td></tr></table></figure>\n\n<p>　　方法二：win10可以打开按“Shift + Ctrl + Esc” 组合键，打开任务管理器，切换到【详细信息】板块，找到PID对应的程序，然后右键选择“结束任务”。</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"Linux-端口占用处理\"><a href=\"#Linux-端口占用处理\" class=\"headerlink\" title=\"Linux 端口占用处理\"></a>Linux 端口占用处理</h2><h3 id=\"1-查找占用端口的进程\"><a href=\"#1-查找占用端口的进程\" class=\"headerlink\" title=\"1. 查找占用端口的进程\"></a><strong>1. 查找占用端口的进程</strong></h3><p>使用以下命令查看哪个进程占用了端口（以端口 <code>8080</code>​ 为例）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>输出示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class=\"line\">java     12345  user   123  IPv6  12345      0t0  TCP *:http-alt (LISTEN)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​<code>COMMAND</code>​：进程名称。</li>\n<li>​<code>PID</code>​：进程 ID。</li>\n<li>​<code>USER</code>​：运行该进程的用户。</li>\n<li>​<code>NAME</code>​：端口信息。</li>\n</ul>\n</li>\n</ul>\n<p>如果不知道具体端口，可以使用以下命令列出所有占用端口的进程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -tuln</span><br><span class=\"line\"></span><br><span class=\"line\">#如果数据太多可以使用管道符精确查询</span><br><span class=\"line\">sudo netstat -tuln | grep 8080</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-结束占用端口的进程\"><a href=\"#2-结束占用端口的进程\" class=\"headerlink\" title=\"2. 结束占用端口的进程\"></a><strong>2. 结束占用端口的进程</strong></h3><p>找到进程 ID (PID) 后，使用以下命令结束进程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo kill -9 12345</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>​<code>-9</code>​ 表示强制结束进程。</li>\n</ul>\n<p>如果需要结束多个进程，可以一次性结束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo kill -9 12345 54321</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"3-检查端口是否已释放\"><a href=\"#3-检查端口是否已释放\" class=\"headerlink\" title=\"3. 检查端口是否已释放\"></a><strong>3. 检查端口是否已释放</strong></h3><p>再次运行以下命令，确认端口是否已释放：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<p>如果没有输出，说明端口已成功释放。</p>\n<hr>\n<h3 id=\"4-其他常用命令\"><a href=\"#4-其他常用命令\" class=\"headerlink\" title=\"4. 其他常用命令\"></a><strong>4. 其他常用命令</strong></h3><ul>\n<li><p><strong>查找所有占用端口的进程</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo netstat -tuln</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>根据进程名称查找 PID</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pgrep java</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查看某个进程的详细信息</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -fp 12345</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"5-防止端口被占用\"><a href=\"#5-防止端口被占用\" class=\"headerlink\" title=\"5. 防止端口被占用\"></a><strong>5. 防止端口被占用</strong></h3><p>如果端口经常被占用，可以采取以下措施：</p>\n<ol>\n<li><strong>修改应用程序端口</strong>：将应用程序的端口改为其他未被占用的端口。</li>\n<li><strong>检查启动脚本</strong>：确保没有重复启动同一应用程序。</li>\n<li><strong>使用端口管理工具</strong>：如 <code>nmap</code>​ 或 <code>netstat</code>​，定期检查端口使用情况。</li>\n</ol>\n<hr>\n<h3 id=\"6-示例：解除端口-8080-占用\"><a href=\"#6-示例：解除端口-8080-占用\" class=\"headerlink\" title=\"6. 示例：解除端口 8080 占用\"></a><strong>6. 示例：解除端口 8080 占用</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查找占用 8080 端口的进程sudo lsof -i :8080# 结束进程（假设 PID 为 12345）sudo kill -9 12345# 确认端口是否已释放</span><br><span class=\"line\">sudo lsof -i :8080</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>通过以上步骤，你可以轻松解除 Linux 上的端口占用问题！</p>\n"},{"title":"实现点击复制文本功能的Vue组件","date":"2024-12-23T08:24:35.000Z","updated":"2024-12-23T08:49:14.000Z","excerpt":"本文介绍了如何创建一个名为 `CopyButton.vue` 的 Vue 组件，用于实现点击复制功能。该组件接收一个 `text` prop，表示要复制的内容，并在点击按钮时执行复制操作。主要步骤包括：1. **创建 `CopyButton.vue` 组件**：定义按钮并实现复制逻辑，支持现代浏览器和旧版浏览器的兼容性。2. **在父组件中引入并注册 `CopyButton` 组件**：在表格列的模板中使用 `CopyButton`，传入要复制的文本。3. **确保组件和依赖项正确导入**：在父组件中导入 `CopyButton` 和 Element Plus 的组件。4. **处理兼容性和国际化**：兼容不同浏览器，并可对消息提示文本进行国际化处理。通过这些步骤，实现了在表格中点击按钮即可复制指定文本的功能，并提供了成功或失败的提示消息。","comments":1,"toc":true,"abbrlink":30813,"_content":"\n\n\n# 实现点击复制文本功能的Vue组件\n\n思路：\n\n```cmd\n首先，我需要创建一个新的组件，专门用于点击复制功能。这个组件应该接收要复制的文本，并在点击时执行复制操作。\n\n我应该把这个组件命名为`CopyButton.vue`，然后在其中定义一个按钮，点击时调用复制方法。\n\n在`CopyButton.vue`中，我需要：\n\n1. 接收一个`text` prop，表示要复制的内容。\n\n2. 定义一个方法`copyToClipboard`来执行复制操作。\n\n3. 在按钮的点击事件中调用这个方法。\n\n4. 可能需要导入Element Plus的图标和消息提示组件。\n\n然后，在父组件中，我需要引入这个`CopyButton.vue`组件，并在表格的列模板中使用它。\n\n具体步骤如下：\n\n1. 创建`CopyButton.vue`组件。\n\n2. 在`CopyButton.vue`中实现复制逻辑。\n\n3. 在父组件中引入并注册`CopyButton`组件。\n\n4. 在表格列的模板中使用`CopyButton`，传入要复制的文本。\n\n我还需要确保在`CopyButton.vue`中正确导入并使用Element Plus的组件，比如图标和消息提示。\n\n另外，为了提高复用性，可能需要将消息提示也抽出来，或者直接使用ElMessage。\n\n我还需要考虑组件的props定义，确保`text`是必需的，并且是字符串类型。\n\n在实现过程中，我可能会遇到以下问题：\n\n- 组件注册不正确，导致组件无法显示。\n\n- 事件绑定错误，导致点击按钮时无法触发复制操作。\n\n- 复制逻辑在某些浏览器中不兼容，需要处理兼容性问题。\n\n为了解决这些问题，我需要：\n\n- 确保组件正确注册和引入。\n\n- 检查事件绑定和方法调用是否正确。\n\n- 测试不同浏览器的兼容性，确保复制功能正常工作。\n\n此外，我还需要考虑国际化，如果需要的话，可以将消息提示文本进行国际化处理。\n\n最后，我需要测试整个功能，确保点击按钮时能够正确复制文本，并显示相应的提示消息。\n```\n\n### 实现步骤\n\n#### 1. 创建 `CopyButton.vue`​ 组件\n\n```js\n<!-- CopyButton.vue -->\n<template>\n  <el-button\n    type=\"primary\"\n    size=\"small\"\n    @click=\"copyToClipboard\"\n    :icon=\"DocumentCopy\"\n    :title=\"`复制${label}`\"\n  />\n</template>\n\n<script setup>\nimport { ElMessage } from 'element-plus';\nimport { DocumentCopy } from '@element-plus/icons-vue';\n\nconst props = defineProps({\n  text: {\n    type: String,\n    required: true\n  },\n  label: {\n    type: String,\n    default: '文本'\n  }\n});\n\nconst copyToClipboard = () => {\n  if (props.text) {\n    if (navigator.clipboard && navigator.clipboard.writeText) {\n      navigator.clipboard.writeText(props.text).then(() => {\n        ElMessage.success('复制成功');\n      }).catch((err) => {\n        ElMessage.error('复制失败: ' + err);\n      });\n    } else {\n      const textarea = document.createElement('textarea');\n      textarea.value = props.text;\n      document.body.appendChild(textarea);\n      textarea.select();\n      document.execCommand('copy');\n      document.body.removeChild(textarea);\n      ElMessage.success('复制成功');\n    }\n  } else {\n    ElMessage.warning('无内容可复制');\n  }\n};\n</script>\n```\n\n#### 2. 在父组件中引入并注册 `CopyButton`​ 组件\n\n```js\n<script setup>\nimport CopyButton from './CopyButton.vue';\nimport { ElTable, ElTableColumn } from 'element-plus';\n</script>\n\n<template>\n  <el-table :data=\"tableData\" border>\n    <el-table-column label=\"物流单号\" align=\"center\" prop=\"trackingNumber\">\n      <template #default=\"scope\">\n        <span>{{ scope.row.trackingNumber }}</span>\n        <CopyButton\n          class=\"ml-2\"\n          :text=\"scope.row.trackingNumber\"\n          label=\"物流单号\"\n        />\n      </template>\n    </el-table-column>\n    <!-- 其他列定义 -->\n  </el-table>\n</template>\n```\n\n#### 3. 确保所有组件和依赖项已正确导入\n\n在父组件中，确保导入了 `CopyButton`​ 和 Element Plus 的组件。\n\n```js\nimport { ElTable, ElTableColumn } from 'element-plus';\nimport CopyButton from './CopyButton.vue';\n```\n\n#### 4. 处理兼容性和国际化\n\n* **兼容性**: 已在 `copyToClipboard`​ 方法中处理现代和旧版浏览器的兼容性。\n* **国际化**: 可以将 `ElMessage`​ 的消息文本进行国际化处理，例如使用 `i18n`​。\n\n### 完整代码示例\n\n#### `CopyButton.vue`​\n\n```js\n<template>\n  <el-button\n   type=\"primary\"\n    size=\"small\"\n    @click=\"copyToClipboard\"\n    :icon=\"DocumentCopy\"\n    :title=\"`复制${label}`\"\n  />\n</template>\n\n<script setup>\nimport { ElMessage } from 'element-plus';\nimport { DocumentCopy } from '@element-plus/icons-vue';\n\nconst props = defineProps({\n  text: {\n    type: String,\n    required: true\n  },\n  label: {\n    type: String,\n    default: '文本'\n  }\n});\n\nconst copyToClipboard = () => {\n  if (props.text) {\n    if (navigator.clipboard && navigator.clipboard.writeText) {\n      navigator.clipboard.writeText(props.text).then(() => {\n        ElMessage.success('复制成功');\n      }).catch((err) => {\n        ElMessage.error('复制失败: ' + err);\n      });\n    } else {\n      const textarea = document.createElement('textarea');\n      textarea.value = props.text;\n      document.body.appendChild(textarea);\n      textarea.select();\n      document.execCommand('copy');\n      document.body.removeChild(textarea);\n      ElMessage.success('复制成功');\n    }\n  } else {\n    ElMessage.warning('无内容可复制');\n  }\n};\n</script>\n```\n\n#### 父组件\n\n```js\n<script setup>\nimport { ElTable, ElTableColumn } from 'element-plus';\nimport CopyButton from './CopyButton.vue';\n\nconst tableData = [\n  { trackingNumber: '123456789' },\n  // 其他数据\n];\n</script>\n\n<template>\n  <el-table :data=\"tableData\" border>\n    <el-table-column label=\"物流单号\" align=\"center\" prop=\"trackingNumber\">\n      <template #default=\"scope\">\n        <span>{{ scope.row.trackingNumber }}</span>\n        <CopyButton\n          class=\"ml-2\"\n          :text=\"scope.row.trackingNumber\"\n          label=\"物流单号\"\n        />\n      </template>\n    </el-table-column>\n    <!-- 其他列定义 -->\n  </el-table>\n</template>\n```\n\n通过以上步骤，我们成功地将点击复制功能提取为一个独立的组件，并在父组件中复用该组件，提高了代码的可维护性和复用性。\n\n#### 最终效果：\n\n![](https://8715aa8.webp.li/20241223163653.png)\n\n‍\n","source":"_posts/press-a-copy-component-z2ezflv.md","raw":"---\ntitle: 实现点击复制文本功能的Vue组件\ndate: '2024-12-23 16:24:35'\nupdated: '2024-12-23 16:49:14'\nexcerpt: >-\n  本文介绍了如何创建一个名为 `CopyButton.vue` 的 Vue 组件，用于实现点击复制功能。该组件接收一个 `text`\n  prop，表示要复制的内容，并在点击按钮时执行复制操作。主要步骤包括：1. **创建 `CopyButton.vue`\n  组件**：定义按钮并实现复制逻辑，支持现代浏览器和旧版浏览器的兼容性。2. **在父组件中引入并注册 `CopyButton`\n  组件**：在表格列的模板中使用 `CopyButton`，传入要复制的文本。3. **确保组件和依赖项正确导入**：在父组件中导入 `CopyButton`\n  和 Element Plus 的组件。4.\n  **处理兼容性和国际化**：兼容不同浏览器，并可对消息提示文本进行国际化处理。通过这些步骤，实现了在表格中点击按钮即可复制指定文本的功能，并提供了成功或失败的提示消息。\ntags:\n  - 复制组件\n  - vue\n  - element-plus\n  - 剪贴板\n  - 国际化\ncategories:\n  - 前端开发\n  - 组件设计\n  - 代码示例\npermalink: /post/press-a-copy-component-z2ezflv.html\ncomments: true\ntoc: true\nabbrlink: 30813\n---\n\n\n\n# 实现点击复制文本功能的Vue组件\n\n思路：\n\n```cmd\n首先，我需要创建一个新的组件，专门用于点击复制功能。这个组件应该接收要复制的文本，并在点击时执行复制操作。\n\n我应该把这个组件命名为`CopyButton.vue`，然后在其中定义一个按钮，点击时调用复制方法。\n\n在`CopyButton.vue`中，我需要：\n\n1. 接收一个`text` prop，表示要复制的内容。\n\n2. 定义一个方法`copyToClipboard`来执行复制操作。\n\n3. 在按钮的点击事件中调用这个方法。\n\n4. 可能需要导入Element Plus的图标和消息提示组件。\n\n然后，在父组件中，我需要引入这个`CopyButton.vue`组件，并在表格的列模板中使用它。\n\n具体步骤如下：\n\n1. 创建`CopyButton.vue`组件。\n\n2. 在`CopyButton.vue`中实现复制逻辑。\n\n3. 在父组件中引入并注册`CopyButton`组件。\n\n4. 在表格列的模板中使用`CopyButton`，传入要复制的文本。\n\n我还需要确保在`CopyButton.vue`中正确导入并使用Element Plus的组件，比如图标和消息提示。\n\n另外，为了提高复用性，可能需要将消息提示也抽出来，或者直接使用ElMessage。\n\n我还需要考虑组件的props定义，确保`text`是必需的，并且是字符串类型。\n\n在实现过程中，我可能会遇到以下问题：\n\n- 组件注册不正确，导致组件无法显示。\n\n- 事件绑定错误，导致点击按钮时无法触发复制操作。\n\n- 复制逻辑在某些浏览器中不兼容，需要处理兼容性问题。\n\n为了解决这些问题，我需要：\n\n- 确保组件正确注册和引入。\n\n- 检查事件绑定和方法调用是否正确。\n\n- 测试不同浏览器的兼容性，确保复制功能正常工作。\n\n此外，我还需要考虑国际化，如果需要的话，可以将消息提示文本进行国际化处理。\n\n最后，我需要测试整个功能，确保点击按钮时能够正确复制文本，并显示相应的提示消息。\n```\n\n### 实现步骤\n\n#### 1. 创建 `CopyButton.vue`​ 组件\n\n```js\n<!-- CopyButton.vue -->\n<template>\n  <el-button\n    type=\"primary\"\n    size=\"small\"\n    @click=\"copyToClipboard\"\n    :icon=\"DocumentCopy\"\n    :title=\"`复制${label}`\"\n  />\n</template>\n\n<script setup>\nimport { ElMessage } from 'element-plus';\nimport { DocumentCopy } from '@element-plus/icons-vue';\n\nconst props = defineProps({\n  text: {\n    type: String,\n    required: true\n  },\n  label: {\n    type: String,\n    default: '文本'\n  }\n});\n\nconst copyToClipboard = () => {\n  if (props.text) {\n    if (navigator.clipboard && navigator.clipboard.writeText) {\n      navigator.clipboard.writeText(props.text).then(() => {\n        ElMessage.success('复制成功');\n      }).catch((err) => {\n        ElMessage.error('复制失败: ' + err);\n      });\n    } else {\n      const textarea = document.createElement('textarea');\n      textarea.value = props.text;\n      document.body.appendChild(textarea);\n      textarea.select();\n      document.execCommand('copy');\n      document.body.removeChild(textarea);\n      ElMessage.success('复制成功');\n    }\n  } else {\n    ElMessage.warning('无内容可复制');\n  }\n};\n</script>\n```\n\n#### 2. 在父组件中引入并注册 `CopyButton`​ 组件\n\n```js\n<script setup>\nimport CopyButton from './CopyButton.vue';\nimport { ElTable, ElTableColumn } from 'element-plus';\n</script>\n\n<template>\n  <el-table :data=\"tableData\" border>\n    <el-table-column label=\"物流单号\" align=\"center\" prop=\"trackingNumber\">\n      <template #default=\"scope\">\n        <span>{{ scope.row.trackingNumber }}</span>\n        <CopyButton\n          class=\"ml-2\"\n          :text=\"scope.row.trackingNumber\"\n          label=\"物流单号\"\n        />\n      </template>\n    </el-table-column>\n    <!-- 其他列定义 -->\n  </el-table>\n</template>\n```\n\n#### 3. 确保所有组件和依赖项已正确导入\n\n在父组件中，确保导入了 `CopyButton`​ 和 Element Plus 的组件。\n\n```js\nimport { ElTable, ElTableColumn } from 'element-plus';\nimport CopyButton from './CopyButton.vue';\n```\n\n#### 4. 处理兼容性和国际化\n\n* **兼容性**: 已在 `copyToClipboard`​ 方法中处理现代和旧版浏览器的兼容性。\n* **国际化**: 可以将 `ElMessage`​ 的消息文本进行国际化处理，例如使用 `i18n`​。\n\n### 完整代码示例\n\n#### `CopyButton.vue`​\n\n```js\n<template>\n  <el-button\n   type=\"primary\"\n    size=\"small\"\n    @click=\"copyToClipboard\"\n    :icon=\"DocumentCopy\"\n    :title=\"`复制${label}`\"\n  />\n</template>\n\n<script setup>\nimport { ElMessage } from 'element-plus';\nimport { DocumentCopy } from '@element-plus/icons-vue';\n\nconst props = defineProps({\n  text: {\n    type: String,\n    required: true\n  },\n  label: {\n    type: String,\n    default: '文本'\n  }\n});\n\nconst copyToClipboard = () => {\n  if (props.text) {\n    if (navigator.clipboard && navigator.clipboard.writeText) {\n      navigator.clipboard.writeText(props.text).then(() => {\n        ElMessage.success('复制成功');\n      }).catch((err) => {\n        ElMessage.error('复制失败: ' + err);\n      });\n    } else {\n      const textarea = document.createElement('textarea');\n      textarea.value = props.text;\n      document.body.appendChild(textarea);\n      textarea.select();\n      document.execCommand('copy');\n      document.body.removeChild(textarea);\n      ElMessage.success('复制成功');\n    }\n  } else {\n    ElMessage.warning('无内容可复制');\n  }\n};\n</script>\n```\n\n#### 父组件\n\n```js\n<script setup>\nimport { ElTable, ElTableColumn } from 'element-plus';\nimport CopyButton from './CopyButton.vue';\n\nconst tableData = [\n  { trackingNumber: '123456789' },\n  // 其他数据\n];\n</script>\n\n<template>\n  <el-table :data=\"tableData\" border>\n    <el-table-column label=\"物流单号\" align=\"center\" prop=\"trackingNumber\">\n      <template #default=\"scope\">\n        <span>{{ scope.row.trackingNumber }}</span>\n        <CopyButton\n          class=\"ml-2\"\n          :text=\"scope.row.trackingNumber\"\n          label=\"物流单号\"\n        />\n      </template>\n    </el-table-column>\n    <!-- 其他列定义 -->\n  </el-table>\n</template>\n```\n\n通过以上步骤，我们成功地将点击复制功能提取为一个独立的组件，并在父组件中复用该组件，提高了代码的可维护性和复用性。\n\n#### 最终效果：\n\n![](https://8715aa8.webp.li/20241223163653.png)\n\n‍\n","slug":"press-a-copy-component-z2ezflv","published":1,"__permalink":"/post/press-a-copy-component-z2ezflv.html","_id":"cmclcaf45000op8vwdzo14onn","layout":"post","photos":[],"content":"<h1 id=\"实现点击复制文本功能的Vue组件\"><a href=\"#实现点击复制文本功能的Vue组件\" class=\"headerlink\" title=\"实现点击复制文本功能的Vue组件\"></a>实现点击复制文本功能的Vue组件</h1><p>思路：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先，我需要创建一个新的组件，专门用于点击复制功能。这个组件应该接收要复制的文本，并在点击时执行复制操作。</span><br><span class=\"line\"></span><br><span class=\"line\">我应该把这个组件命名为`CopyButton.vue`，然后在其中定义一个按钮，点击时调用复制方法。</span><br><span class=\"line\"></span><br><span class=\"line\">在`CopyButton.vue`中，我需要：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. 接收一个`text` prop，表示要复制的内容。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>. 定义一个方法`copyToClipboard`来执行复制操作。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>. 在按钮的点击事件中调用这个方法。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>. 可能需要导入Element Plus的图标和消息提示组件。</span><br><span class=\"line\"></span><br><span class=\"line\">然后，在父组件中，我需要引入这个`CopyButton.vue`组件，并在表格的列模板中使用它。</span><br><span class=\"line\"></span><br><span class=\"line\">具体步骤如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. 创建`CopyButton.vue`组件。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>. 在`CopyButton.vue`中实现复制逻辑。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>. 在父组件中引入并注册`CopyButton`组件。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>. 在表格列的模板中使用`CopyButton`，传入要复制的文本。</span><br><span class=\"line\"></span><br><span class=\"line\">我还需要确保在`CopyButton.vue`中正确导入并使用Element Plus的组件，比如图标和消息提示。</span><br><span class=\"line\"></span><br><span class=\"line\">另外，为了提高复用性，可能需要将消息提示也抽出来，或者直接使用ElMessage。</span><br><span class=\"line\"></span><br><span class=\"line\">我还需要考虑组件的props定义，确保`text`是必需的，并且是字符串类型。</span><br><span class=\"line\"></span><br><span class=\"line\">在实现过程中，我可能会遇到以下问题：</span><br><span class=\"line\"></span><br><span class=\"line\">- 组件注册不正确，导致组件无法显示。</span><br><span class=\"line\"></span><br><span class=\"line\">- 事件绑定错误，导致点击按钮时无法触发复制操作。</span><br><span class=\"line\"></span><br><span class=\"line\">- 复制逻辑在某些浏览器中不兼容，需要处理兼容性问题。</span><br><span class=\"line\"></span><br><span class=\"line\">为了解决这些问题，我需要：</span><br><span class=\"line\"></span><br><span class=\"line\">- 确保组件正确注册和引入。</span><br><span class=\"line\"></span><br><span class=\"line\">- 检查事件绑定和方法调用是否正确。</span><br><span class=\"line\"></span><br><span class=\"line\">- 测试不同浏览器的兼容性，确保复制功能正常工作。</span><br><span class=\"line\"></span><br><span class=\"line\">此外，我还需要考虑国际化，如果需要的话，可以将消息提示文本进行国际化处理。</span><br><span class=\"line\"></span><br><span class=\"line\">最后，我需要测试整个功能，确保点击按钮时能够正确复制文本，并显示相应的提示消息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><h4 id=\"1-创建-CopyButton-vue​-组件\"><a href=\"#1-创建-CopyButton-vue​-组件\" class=\"headerlink\" title=\"1. 创建 CopyButton.vue​ 组件\"></a>1. 创建 <code>CopyButton.vue</code>​ 组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"title class_\">CopyButton</span>.<span class=\"property\">vue</span> --&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">el-button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;primary&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;small&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    @<span class=\"attr\">click</span>=<span class=\"string\">&quot;copyToClipboard&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:icon</span>=<span class=\"string\">&quot;DocumentCopy&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:title</span>=<span class=\"string\">&quot;`复制$&#123;label&#125;`&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElMessage</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DocumentCopy</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@element-plus/icons-vue&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> props = <span class=\"title function_\">defineProps</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">text</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">label</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">default</span>: <span class=\"string\">&#x27;文本&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">copyToClipboard</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"keyword\">if</span> (props.<span class=\"property\">text</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">if</span> (navigator.<span class=\"property\">clipboard</span> &amp;&amp; navigator.<span class=\"property\">clipboard</span>.<span class=\"property\">writeText</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      navigator.<span class=\"property\">clipboard</span>.<span class=\"title function_\">writeText</span>(props.<span class=\"property\">text</span>).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;复制失败: &#x27;</span> + err);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"keyword\">const</span> textarea = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;textarea&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"property\">value</span> = props.<span class=\"property\">text</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"title function_\">select</span>();</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">warning</span>(<span class=\"string\">&#x27;无内容可复制&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-在父组件中引入并注册-CopyButton​-组件\"><a href=\"#2-在父组件中引入并注册-CopyButton​-组件\" class=\"headerlink\" title=\"2. 在父组件中引入并注册 CopyButton​ 组件\"></a>2. 在父组件中引入并注册 <code>CopyButton</code>​ 组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CopyButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./CopyButton.vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElTable</span>, <span class=\"title class_\">ElTableColumn</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">el-table</span> <span class=\"attr\">:data</span>=<span class=\"string\">&quot;tableData&quot;</span> <span class=\"attr\">border</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">el-table-column</span> <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span> <span class=\"attr\">align</span>=<span class=\"string\">&quot;center&quot;</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;trackingNumber&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">default</span>=<span class=\"string\">&quot;scope&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; scope.row.trackingNumber &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">CopyButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">class</span>=<span class=\"string\">&quot;ml-2&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">:text</span>=<span class=\"string\">&quot;scope.row.trackingNumber&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">el-table-column</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"comment\">&lt;!-- 其他列定义 --&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">el-table</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-确保所有组件和依赖项已正确导入\"><a href=\"#3-确保所有组件和依赖项已正确导入\" class=\"headerlink\" title=\"3. 确保所有组件和依赖项已正确导入\"></a>3. 确保所有组件和依赖项已正确导入</h4><p>在父组件中，确保导入了 <code>CopyButton</code>​ 和 Element Plus 的组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElTable</span>, <span class=\"title class_\">ElTableColumn</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CopyButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./CopyButton.vue&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-处理兼容性和国际化\"><a href=\"#4-处理兼容性和国际化\" class=\"headerlink\" title=\"4. 处理兼容性和国际化\"></a>4. 处理兼容性和国际化</h4><ul>\n<li><strong>兼容性</strong>: 已在 <code>copyToClipboard</code>​ 方法中处理现代和旧版浏览器的兼容性。</li>\n<li><strong>国际化</strong>: 可以将 <code>ElMessage</code>​ 的消息文本进行国际化处理，例如使用 <code>i18n</code>​。</li>\n</ul>\n<h3 id=\"完整代码示例\"><a href=\"#完整代码示例\" class=\"headerlink\" title=\"完整代码示例\"></a>完整代码示例</h3><h4 id=\"CopyButton-vue​\"><a href=\"#CopyButton-vue​\" class=\"headerlink\" title=\"CopyButton.vue​\"></a><code>CopyButton.vue</code>​</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">el-button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">   <span class=\"attr\">type</span>=<span class=\"string\">&quot;primary&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;small&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    @<span class=\"attr\">click</span>=<span class=\"string\">&quot;copyToClipboard&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:icon</span>=<span class=\"string\">&quot;DocumentCopy&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:title</span>=<span class=\"string\">&quot;`复制$&#123;label&#125;`&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  /&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElMessage</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DocumentCopy</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@element-plus/icons-vue&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> props = <span class=\"title function_\">defineProps</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">text</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">label</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">default</span>: <span class=\"string\">&#x27;文本&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">copyToClipboard</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"keyword\">if</span> (props.<span class=\"property\">text</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">if</span> (navigator.<span class=\"property\">clipboard</span> &amp;&amp; navigator.<span class=\"property\">clipboard</span>.<span class=\"property\">writeText</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      navigator.<span class=\"property\">clipboard</span>.<span class=\"title function_\">writeText</span>(props.<span class=\"property\">text</span>).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;复制失败: &#x27;</span> + err);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"keyword\">const</span> textarea = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;textarea&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"property\">value</span> = props.<span class=\"property\">text</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"title function_\">select</span>();</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">warning</span>(<span class=\"string\">&#x27;无内容可复制&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"父组件\"><a href=\"#父组件\" class=\"headerlink\" title=\"父组件\"></a>父组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElTable</span>, <span class=\"title class_\">ElTableColumn</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CopyButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./CopyButton.vue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> tableData = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">trackingNumber</span>: <span class=\"string\">&#x27;123456789&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 其他数据</span></span><br><span class=\"line\">];</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">el-table</span> <span class=\"attr\">:data</span>=<span class=\"string\">&quot;tableData&quot;</span> <span class=\"attr\">border</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">el-table-column</span> <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span> <span class=\"attr\">align</span>=<span class=\"string\">&quot;center&quot;</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;trackingNumber&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">default</span>=<span class=\"string\">&quot;scope&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; scope.row.trackingNumber &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">CopyButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">class</span>=<span class=\"string\">&quot;ml-2&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">:text</span>=<span class=\"string\">&quot;scope.row.trackingNumber&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">el-table-column</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"comment\">&lt;!-- 其他列定义 --&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">el-table</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>通过以上步骤，我们成功地将点击复制功能提取为一个独立的组件，并在父组件中复用该组件，提高了代码的可维护性和复用性。</p>\n<h4 id=\"最终效果：\"><a href=\"#最终效果：\" class=\"headerlink\" title=\"最终效果：\"></a>最终效果：</h4><p><img src=\"https://8715aa8.webp.li/20241223163653.png\"></p>\n<p>‍</p>\n","more":"<h1 id=\"实现点击复制文本功能的Vue组件\"><a href=\"#实现点击复制文本功能的Vue组件\" class=\"headerlink\" title=\"实现点击复制文本功能的Vue组件\"></a>实现点击复制文本功能的Vue组件</h1><p>思路：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首先，我需要创建一个新的组件，专门用于点击复制功能。这个组件应该接收要复制的文本，并在点击时执行复制操作。</span><br><span class=\"line\"></span><br><span class=\"line\">我应该把这个组件命名为`CopyButton.vue`，然后在其中定义一个按钮，点击时调用复制方法。</span><br><span class=\"line\"></span><br><span class=\"line\">在`CopyButton.vue`中，我需要：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. 接收一个`text` prop，表示要复制的内容。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>. 定义一个方法`copyToClipboard`来执行复制操作。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>. 在按钮的点击事件中调用这个方法。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>. 可能需要导入Element Plus的图标和消息提示组件。</span><br><span class=\"line\"></span><br><span class=\"line\">然后，在父组件中，我需要引入这个`CopyButton.vue`组件，并在表格的列模板中使用它。</span><br><span class=\"line\"></span><br><span class=\"line\">具体步骤如下：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>. 创建`CopyButton.vue`组件。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>. 在`CopyButton.vue`中实现复制逻辑。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>. 在父组件中引入并注册`CopyButton`组件。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>. 在表格列的模板中使用`CopyButton`，传入要复制的文本。</span><br><span class=\"line\"></span><br><span class=\"line\">我还需要确保在`CopyButton.vue`中正确导入并使用Element Plus的组件，比如图标和消息提示。</span><br><span class=\"line\"></span><br><span class=\"line\">另外，为了提高复用性，可能需要将消息提示也抽出来，或者直接使用ElMessage。</span><br><span class=\"line\"></span><br><span class=\"line\">我还需要考虑组件的props定义，确保`text`是必需的，并且是字符串类型。</span><br><span class=\"line\"></span><br><span class=\"line\">在实现过程中，我可能会遇到以下问题：</span><br><span class=\"line\"></span><br><span class=\"line\">- 组件注册不正确，导致组件无法显示。</span><br><span class=\"line\"></span><br><span class=\"line\">- 事件绑定错误，导致点击按钮时无法触发复制操作。</span><br><span class=\"line\"></span><br><span class=\"line\">- 复制逻辑在某些浏览器中不兼容，需要处理兼容性问题。</span><br><span class=\"line\"></span><br><span class=\"line\">为了解决这些问题，我需要：</span><br><span class=\"line\"></span><br><span class=\"line\">- 确保组件正确注册和引入。</span><br><span class=\"line\"></span><br><span class=\"line\">- 检查事件绑定和方法调用是否正确。</span><br><span class=\"line\"></span><br><span class=\"line\">- 测试不同浏览器的兼容性，确保复制功能正常工作。</span><br><span class=\"line\"></span><br><span class=\"line\">此外，我还需要考虑国际化，如果需要的话，可以将消息提示文本进行国际化处理。</span><br><span class=\"line\"></span><br><span class=\"line\">最后，我需要测试整个功能，确保点击按钮时能够正确复制文本，并显示相应的提示消息。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><h4 id=\"1-创建-CopyButton-vue​-组件\"><a href=\"#1-创建-CopyButton-vue​-组件\" class=\"headerlink\" title=\"1. 创建 CopyButton.vue​ 组件\"></a>1. 创建 <code>CopyButton.vue</code>​ 组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- <span class=\"title class_\">CopyButton</span>.<span class=\"property\">vue</span> --&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">el-button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">type</span>=<span class=\"string\">&quot;primary&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;small&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    @<span class=\"attr\">click</span>=<span class=\"string\">&quot;copyToClipboard&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:icon</span>=<span class=\"string\">&quot;DocumentCopy&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:title</span>=<span class=\"string\">&quot;`复制$&#123;label&#125;`&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElMessage</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DocumentCopy</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@element-plus/icons-vue&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> props = <span class=\"title function_\">defineProps</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">text</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">label</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">default</span>: <span class=\"string\">&#x27;文本&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">copyToClipboard</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"keyword\">if</span> (props.<span class=\"property\">text</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">if</span> (navigator.<span class=\"property\">clipboard</span> &amp;&amp; navigator.<span class=\"property\">clipboard</span>.<span class=\"property\">writeText</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      navigator.<span class=\"property\">clipboard</span>.<span class=\"title function_\">writeText</span>(props.<span class=\"property\">text</span>).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;复制失败: &#x27;</span> + err);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"keyword\">const</span> textarea = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;textarea&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"property\">value</span> = props.<span class=\"property\">text</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"title function_\">select</span>();</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">warning</span>(<span class=\"string\">&#x27;无内容可复制&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-在父组件中引入并注册-CopyButton​-组件\"><a href=\"#2-在父组件中引入并注册-CopyButton​-组件\" class=\"headerlink\" title=\"2. 在父组件中引入并注册 CopyButton​ 组件\"></a>2. 在父组件中引入并注册 <code>CopyButton</code>​ 组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CopyButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./CopyButton.vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElTable</span>, <span class=\"title class_\">ElTableColumn</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">el-table</span> <span class=\"attr\">:data</span>=<span class=\"string\">&quot;tableData&quot;</span> <span class=\"attr\">border</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">el-table-column</span> <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span> <span class=\"attr\">align</span>=<span class=\"string\">&quot;center&quot;</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;trackingNumber&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">default</span>=<span class=\"string\">&quot;scope&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; scope.row.trackingNumber &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">CopyButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">class</span>=<span class=\"string\">&quot;ml-2&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">:text</span>=<span class=\"string\">&quot;scope.row.trackingNumber&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">el-table-column</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"comment\">&lt;!-- 其他列定义 --&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">el-table</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-确保所有组件和依赖项已正确导入\"><a href=\"#3-确保所有组件和依赖项已正确导入\" class=\"headerlink\" title=\"3. 确保所有组件和依赖项已正确导入\"></a>3. 确保所有组件和依赖项已正确导入</h4><p>在父组件中，确保导入了 <code>CopyButton</code>​ 和 Element Plus 的组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElTable</span>, <span class=\"title class_\">ElTableColumn</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CopyButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./CopyButton.vue&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-处理兼容性和国际化\"><a href=\"#4-处理兼容性和国际化\" class=\"headerlink\" title=\"4. 处理兼容性和国际化\"></a>4. 处理兼容性和国际化</h4><ul>\n<li><strong>兼容性</strong>: 已在 <code>copyToClipboard</code>​ 方法中处理现代和旧版浏览器的兼容性。</li>\n<li><strong>国际化</strong>: 可以将 <code>ElMessage</code>​ 的消息文本进行国际化处理，例如使用 <code>i18n</code>​。</li>\n</ul>\n<h3 id=\"完整代码示例\"><a href=\"#完整代码示例\" class=\"headerlink\" title=\"完整代码示例\"></a>完整代码示例</h3><h4 id=\"CopyButton-vue​\"><a href=\"#CopyButton-vue​\" class=\"headerlink\" title=\"CopyButton.vue​\"></a><code>CopyButton.vue</code>​</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">el-button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">   <span class=\"attr\">type</span>=<span class=\"string\">&quot;primary&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">size</span>=<span class=\"string\">&quot;small&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    @<span class=\"attr\">click</span>=<span class=\"string\">&quot;copyToClipboard&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:icon</span>=<span class=\"string\">&quot;DocumentCopy&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:title</span>=<span class=\"string\">&quot;`复制$&#123;label&#125;`&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  /&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElMessage</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">DocumentCopy</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@element-plus/icons-vue&#x27;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> props = <span class=\"title function_\">defineProps</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">text</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">required</span>: <span class=\"literal\">true</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">label</span>: &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">type</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"attr\">default</span>: <span class=\"string\">&#x27;文本&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">copyToClipboard</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"keyword\">if</span> (props.<span class=\"property\">text</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">if</span> (navigator.<span class=\"property\">clipboard</span> &amp;&amp; navigator.<span class=\"property\">clipboard</span>.<span class=\"property\">writeText</span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      navigator.<span class=\"property\">clipboard</span>.<span class=\"title function_\">writeText</span>(props.<span class=\"property\">text</span>).<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;复制失败: &#x27;</span> + err);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"keyword\">const</span> textarea = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;textarea&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"property\">value</span> = props.<span class=\"property\">text</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      textarea.<span class=\"title function_\">select</span>();</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(textarea);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">success</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125; <span class=\"keyword\">else</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">warning</span>(<span class=\"string\">&#x27;无内容可复制&#x27;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"父组件\"><a href=\"#父组件\" class=\"headerlink\" title=\"父组件\"></a>父组件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">ElTable</span>, <span class=\"title class_\">ElTableColumn</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;element-plus&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">CopyButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./CopyButton.vue&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> tableData = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">trackingNumber</span>: <span class=\"string\">&#x27;123456789&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 其他数据</span></span><br><span class=\"line\">];</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">el-table</span> <span class=\"attr\">:data</span>=<span class=\"string\">&quot;tableData&quot;</span> <span class=\"attr\">border</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">el-table-column</span> <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span> <span class=\"attr\">align</span>=<span class=\"string\">&quot;center&quot;</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;trackingNumber&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">default</span>=<span class=\"string\">&quot;scope&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; scope.row.trackingNumber &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">CopyButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">class</span>=<span class=\"string\">&quot;ml-2&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">:text</span>=<span class=\"string\">&quot;scope.row.trackingNumber&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">label</span>=<span class=\"string\">&quot;物流单号&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">el-table-column</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"comment\">&lt;!-- 其他列定义 --&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">el-table</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>通过以上步骤，我们成功地将点击复制功能提取为一个独立的组件，并在父组件中复用该组件，提高了代码的可维护性和复用性。</p>\n<h4 id=\"最终效果：\"><a href=\"#最终效果：\" class=\"headerlink\" title=\"最终效果：\"></a>最终效果：</h4><p><img src=\"https://8715aa8.webp.li/20241223163653.png\"></p>\n<p>‍</p>\n"},{"title":"思源笔记 Docker-Compose 一键部署及解锁付费功能教程","date":"2024-12-19T02:39:24.000Z","updated":"2024-12-23T09:00:54.000Z","excerpt":"这篇文章介绍了如何使用Docker Compose一键部署思源笔记的两个版本：官方开源版本和解锁付费功能的版本。官方版本使用`b3log/siyuan`镜像，配置了工作区路径和访问授权码，并设置了时区和端口映射。解锁版本使用`apkdv/siyuan-unlock`镜像，解锁了云备份等付费功能，并通过Docker网络实现容器间通讯。两个版本都配置了持久化存储和自动重启策略。","comments":1,"toc":true,"abbrlink":44245,"_content":"\n# 思源笔记-docker-compose一键部署\n\n## 官方开源版本\n\n```docker-compose\nversion: \"3.9\"\nservices:\n  siyuan:\n    image: b3log/siyuan\n    container_name: siyuan\n    user: root\n    command: ['--workspace=/siyuan/workspace/', '--accessAuthCode=Qsxzxc123@']\n    environment:\n      - TZ=Asia/Shanghai\n    ports:\n      - 6806:6806\n    volumes:\n      - ./workspace:/siyuan/workspace\n    restart: always\n```\n\n## 热心网友[github.com/appdev/siyuan-unlock](https://github.com/appdev/siyuan-unlock)unlook版本(解锁相关云备份付费功能)\n\n```bash\n# 创建网卡，方便容器间网络通讯\ndocker network create mynet\n# 创建文件夹\nmkdir SiYuan\n# 创建docker-compose.yml文件\ntouch docker-compose.yml\n\n# 把以下内容复制进文件后执行\ndocker-compose -f docker-compose.yml up -d\n\n# 然后访问你的云主机ip http:IP:6806\n```\n\n```js\nversion: \"3.9\"\nservices:\n  siyuan:\n#    image: b3log/siyuan\n    image: apkdv/siyuan-unlock\n    container_name: siyuan\n    user: root  # 可选，偷懒做法\n    command: ['--workspace=/siyuan/SiYuan/', '--accessAuthCode=yourAccessAuthCode']\n    environment:\n      - TZ=Asia/Shanghai\n    ports:\n      - 6806:6806\n    volumes:\n      - ./SiYuan:/siyuan/SiYuan\n    restart: always\n    networks:\n      - mynet\nnetworks:\n  mynet:\n    external: true\n```\n\n‍\n","source":"_posts/siyuan-notedockercompose-oneclick-deployment-1wlgle.md","raw":"---\ntitle: 思源笔记 Docker-Compose 一键部署及解锁付费功能教程\ndate: '2024-12-19 10:39:24'\nupdated: '2024-12-23 17:00:54'\nexcerpt: >-\n  这篇文章介绍了如何使用Docker\n  Compose一键部署思源笔记的两个版本：官方开源版本和解锁付费功能的版本。官方版本使用`b3log/siyuan`镜像，配置了工作区路径和访问授权码，并设置了时区和端口映射。解锁版本使用`apkdv/siyuan-unlock`镜像，解锁了云备份等付费功能，并通过Docker网络实现容器间通讯。两个版本都配置了持久化存储和自动重启策略。\ntags:\n  - 思源笔记\n  - docker\n  - 一键部署\n  - 云备份\n  - 解锁版\ncategories:\n  - Docker\n  - 笔记软件\n  - 开源\npermalink: /post/siyuan-notedockercompose-oneclick-deployment-1wlgle.html\ncomments: true\ntoc: true\nabbrlink: 44245\n---\n\n# 思源笔记-docker-compose一键部署\n\n## 官方开源版本\n\n```docker-compose\nversion: \"3.9\"\nservices:\n  siyuan:\n    image: b3log/siyuan\n    container_name: siyuan\n    user: root\n    command: ['--workspace=/siyuan/workspace/', '--accessAuthCode=Qsxzxc123@']\n    environment:\n      - TZ=Asia/Shanghai\n    ports:\n      - 6806:6806\n    volumes:\n      - ./workspace:/siyuan/workspace\n    restart: always\n```\n\n## 热心网友[github.com/appdev/siyuan-unlock](https://github.com/appdev/siyuan-unlock)unlook版本(解锁相关云备份付费功能)\n\n```bash\n# 创建网卡，方便容器间网络通讯\ndocker network create mynet\n# 创建文件夹\nmkdir SiYuan\n# 创建docker-compose.yml文件\ntouch docker-compose.yml\n\n# 把以下内容复制进文件后执行\ndocker-compose -f docker-compose.yml up -d\n\n# 然后访问你的云主机ip http:IP:6806\n```\n\n```js\nversion: \"3.9\"\nservices:\n  siyuan:\n#    image: b3log/siyuan\n    image: apkdv/siyuan-unlock\n    container_name: siyuan\n    user: root  # 可选，偷懒做法\n    command: ['--workspace=/siyuan/SiYuan/', '--accessAuthCode=yourAccessAuthCode']\n    environment:\n      - TZ=Asia/Shanghai\n    ports:\n      - 6806:6806\n    volumes:\n      - ./SiYuan:/siyuan/SiYuan\n    restart: always\n    networks:\n      - mynet\nnetworks:\n  mynet:\n    external: true\n```\n\n‍\n","slug":"siyuan-notedockercompose-oneclick-deployment-1wlgle","published":1,"__permalink":"/post/siyuan-notedockercompose-oneclick-deployment-1wlgle.html","_id":"cmclcaf49000rp8vw76yr1ndh","layout":"post","photos":[],"content":"<h1 id=\"思源笔记-docker-compose一键部署\"><a href=\"#思源笔记-docker-compose一键部署\" class=\"headerlink\" title=\"思源笔记-docker-compose一键部署\"></a>思源笔记-docker-compose一键部署</h1><h2 id=\"官方开源版本\"><a href=\"#官方开源版本\" class=\"headerlink\" title=\"官方开源版本\"></a>官方开源版本</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &quot;3.9&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  siyuan:</span><br><span class=\"line\">    image: b3log/siyuan</span><br><span class=\"line\">    container_name: siyuan</span><br><span class=\"line\">    user: root</span><br><span class=\"line\">    command: [&#x27;--workspace=/siyuan/workspace/&#x27;, &#x27;--accessAuthCode=Qsxzxc123@&#x27;]</span><br><span class=\"line\">    environment:</span><br><span class=\"line\">      - TZ=Asia/Shanghai</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - 6806:6806</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - ./workspace:/siyuan/workspace</span><br><span class=\"line\">    restart: always</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"热心网友github-com-appdev-siyuan-unlockunlook版本-解锁相关云备份付费功能\"><a href=\"#热心网友github-com-appdev-siyuan-unlockunlook版本-解锁相关云备份付费功能\" class=\"headerlink\" title=\"热心网友github.com&#x2F;appdev&#x2F;siyuan-unlockunlook版本(解锁相关云备份付费功能)\"></a>热心网友<a href=\"https://github.com/appdev/siyuan-unlock\">github.com&#x2F;appdev&#x2F;siyuan-unlock</a>unlook版本(解锁相关云备份付费功能)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建网卡，方便容器间网络通讯</span></span><br><span class=\"line\">docker network create mynet</span><br><span class=\"line\"><span class=\"comment\"># 创建文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> SiYuan</span><br><span class=\"line\"><span class=\"comment\"># 创建docker-compose.yml文件</span></span><br><span class=\"line\"><span class=\"built_in\">touch</span> docker-compose.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把以下内容复制进文件后执行</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml up -d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后访问你的云主机ip http:IP:6806</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version</span>: <span class=\"string\">&quot;3.9&quot;</span></span><br><span class=\"line\"><span class=\"attr\">services</span>:</span><br><span class=\"line\">  <span class=\"attr\">siyuan</span>:</span><br><span class=\"line\">#    <span class=\"attr\">image</span>: b3log/siyuan</span><br><span class=\"line\">    <span class=\"attr\">image</span>: apkdv/siyuan-unlock</span><br><span class=\"line\">    <span class=\"attr\">container_name</span>: siyuan</span><br><span class=\"line\">    <span class=\"attr\">user</span>: root  # 可选，偷懒做法</span><br><span class=\"line\">    <span class=\"attr\">command</span>: [<span class=\"string\">&#x27;--workspace=/siyuan/SiYuan/&#x27;</span>, <span class=\"string\">&#x27;--accessAuthCode=yourAccessAuthCode&#x27;</span>]</span><br><span class=\"line\">    <span class=\"attr\">environment</span>:</span><br><span class=\"line\">      - <span class=\"variable constant_\">TZ</span>=<span class=\"title class_\">Asia</span>/<span class=\"title class_\">Shanghai</span></span><br><span class=\"line\">    <span class=\"attr\">ports</span>:</span><br><span class=\"line\">      - <span class=\"number\">6806</span>:<span class=\"number\">6806</span></span><br><span class=\"line\">    <span class=\"attr\">volumes</span>:</span><br><span class=\"line\">      - ./<span class=\"title class_\">SiYuan</span>:<span class=\"regexp\">/siyuan/</span><span class=\"title class_\">SiYuan</span></span><br><span class=\"line\">    <span class=\"attr\">restart</span>: always</span><br><span class=\"line\">    <span class=\"attr\">networks</span>:</span><br><span class=\"line\">      - mynet</span><br><span class=\"line\"><span class=\"attr\">networks</span>:</span><br><span class=\"line\">  <span class=\"attr\">mynet</span>:</span><br><span class=\"line\">    <span class=\"attr\">external</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n","more":"<h1 id=\"思源笔记-docker-compose一键部署\"><a href=\"#思源笔记-docker-compose一键部署\" class=\"headerlink\" title=\"思源笔记-docker-compose一键部署\"></a>思源笔记-docker-compose一键部署</h1><h2 id=\"官方开源版本\"><a href=\"#官方开源版本\" class=\"headerlink\" title=\"官方开源版本\"></a>官方开源版本</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &quot;3.9&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  siyuan:</span><br><span class=\"line\">    image: b3log/siyuan</span><br><span class=\"line\">    container_name: siyuan</span><br><span class=\"line\">    user: root</span><br><span class=\"line\">    command: [&#x27;--workspace=/siyuan/workspace/&#x27;, &#x27;--accessAuthCode=Qsxzxc123@&#x27;]</span><br><span class=\"line\">    environment:</span><br><span class=\"line\">      - TZ=Asia/Shanghai</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - 6806:6806</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - ./workspace:/siyuan/workspace</span><br><span class=\"line\">    restart: always</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"热心网友github-com-appdev-siyuan-unlockunlook版本-解锁相关云备份付费功能\"><a href=\"#热心网友github-com-appdev-siyuan-unlockunlook版本-解锁相关云备份付费功能\" class=\"headerlink\" title=\"热心网友github.com&#x2F;appdev&#x2F;siyuan-unlockunlook版本(解锁相关云备份付费功能)\"></a>热心网友<a href=\"https://github.com/appdev/siyuan-unlock\">github.com&#x2F;appdev&#x2F;siyuan-unlock</a>unlook版本(解锁相关云备份付费功能)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建网卡，方便容器间网络通讯</span></span><br><span class=\"line\">docker network create mynet</span><br><span class=\"line\"><span class=\"comment\"># 创建文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> SiYuan</span><br><span class=\"line\"><span class=\"comment\"># 创建docker-compose.yml文件</span></span><br><span class=\"line\"><span class=\"built_in\">touch</span> docker-compose.yml</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把以下内容复制进文件后执行</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml up -d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后访问你的云主机ip http:IP:6806</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version</span>: <span class=\"string\">&quot;3.9&quot;</span></span><br><span class=\"line\"><span class=\"attr\">services</span>:</span><br><span class=\"line\">  <span class=\"attr\">siyuan</span>:</span><br><span class=\"line\">#    <span class=\"attr\">image</span>: b3log/siyuan</span><br><span class=\"line\">    <span class=\"attr\">image</span>: apkdv/siyuan-unlock</span><br><span class=\"line\">    <span class=\"attr\">container_name</span>: siyuan</span><br><span class=\"line\">    <span class=\"attr\">user</span>: root  # 可选，偷懒做法</span><br><span class=\"line\">    <span class=\"attr\">command</span>: [<span class=\"string\">&#x27;--workspace=/siyuan/SiYuan/&#x27;</span>, <span class=\"string\">&#x27;--accessAuthCode=yourAccessAuthCode&#x27;</span>]</span><br><span class=\"line\">    <span class=\"attr\">environment</span>:</span><br><span class=\"line\">      - <span class=\"variable constant_\">TZ</span>=<span class=\"title class_\">Asia</span>/<span class=\"title class_\">Shanghai</span></span><br><span class=\"line\">    <span class=\"attr\">ports</span>:</span><br><span class=\"line\">      - <span class=\"number\">6806</span>:<span class=\"number\">6806</span></span><br><span class=\"line\">    <span class=\"attr\">volumes</span>:</span><br><span class=\"line\">      - ./<span class=\"title class_\">SiYuan</span>:<span class=\"regexp\">/siyuan/</span><span class=\"title class_\">SiYuan</span></span><br><span class=\"line\">    <span class=\"attr\">restart</span>: always</span><br><span class=\"line\">    <span class=\"attr\">networks</span>:</span><br><span class=\"line\">      - mynet</span><br><span class=\"line\"><span class=\"attr\">networks</span>:</span><br><span class=\"line\">  <span class=\"attr\">mynet</span>:</span><br><span class=\"line\">    <span class=\"attr\">external</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n"},{"title":"SpringBoot引入本地Jar包","date":"2025-02-06T06:24:57.000Z","updated":"2025-02-06T06:30:22.000Z","excerpt":"本文介绍了在SpringBoot项目中引入本地Jar包的两种方法。方法一是直接在项目中引用：创建*src/main/resources/lib*目录并放入Jar包，然后在*pom.xml*中添加依赖配置，使用`<scope>system</scope>`并指定`<systemPath>`路径，同时配置Spring Boot Maven插件以包含系统范围的依赖。方法二是将Jar包安装到本地Maven仓库：使用Maven命令`mvn install:install-file`将Jar包安装到本地仓库，然后在*pom.xml*中添加普通依赖配置。两种方法均可有效实现本地Jar包的引入。","comments":1,"toc":true,"abbrlink":13810,"_content":"\n# SpringBoot引入本地Jar包\n\n## SpringBoot引入本地Jar包\n\n在SpringBoot项目中引入本地Jar包有两种常见的方法：直接在项目中引用和将Jar包安装到本地Maven仓库。\n\n方法一：直接在项目中引用\n\n1. **创建lib目录**：在项目的*src/main/resources*目录下创建一个名为*lib*的文件夹，并将本地Jar包放入其中。\n2. **修改pom.xml**：在*pom.xml*文件中添加以下依赖配置：\n\n```JAVA\n<dependency>\n\t<groupId>com.example</groupId>\n\t<artifactId>example-jar</artifactId>\n\t<version>1.0</version>\n\t<scope>system</scope>\n\t<systemPath>${project.basedir}/src/main/resources/lib/example-jar-1.0.jar</systemPath>\n</dependency>\n```\n\n* **配置插件**：为了确保打包时包含这些Jar包，需要在*pom.xml*文件中添加Spring Boot Maven插件配置：\n\n```JAVA\n<build>\n\t<plugins>\n\t\t<plugin>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t\t<configuration>\n\t\t\t\t\t<includeSystemScope>true</includeSystemScope>\n\t\t\t\t</configuration>\n\t\t</plugin>\n\t</plugins>\n</build>\n```\n\n方法二：将Jar包安装到本地Maven仓库\n\n* **安装Jar包**：使用Maven命令将Jar包安装到本地仓库：\n\n```JAVA\nmvn install:install-file -Dfile=path/to/your.jar -DgroupId=com.example -DartifactId=example-jar -Dversion=1.0 -Dpackaging=jar\n```\n\n* **修改pom.xml**：在*pom.xml*文件中添加以下依赖配置：\n\n```JAVA\n<dependency>\n\t<groupId>com.example</groupId>\n\t<artifactId>example-jar</artifactId>\n\t<version>1.0</version>\n</dependency>\n```\n\n这两种方法都可以有效地将本地Jar包引入到SpringBoot项目中。\n","source":"_posts/springboot-introduces-local-jar-packages-1lmxzy.md","raw":"---\ntitle: SpringBoot引入本地Jar包\ndate: '2025-02-06 14:24:57'\nupdated: '2025-02-06 14:30:22'\nexcerpt: >-\n  本文介绍了在SpringBoot项目中引入本地Jar包的两种方法。方法一是直接在项目中引用：创建*src/main/resources/lib*目录并放入Jar包，然后在*pom.xml*中添加依赖配置，使用`<scope>system</scope>`并指定`<systemPath>`路径，同时配置Spring\n  Boot Maven插件以包含系统范围的依赖。方法二是将Jar包安装到本地Maven仓库：使用Maven命令`mvn\n  install:install-file`将Jar包安装到本地仓库，然后在*pom.xml*中添加普通依赖配置。两种方法均可有效实现本地Jar包的引入。\ntags:\n  - springboot\n  - 本地jar\n  - maven\n  - 依赖管理\n  - 项目配置\ncategories:\n  - Spring\n  - Java\n  - Maven\npermalink: /post/springboot-introduces-local-jar-packages-1lmxzy.html\ncomments: true\ntoc: true\nabbrlink: 13810\n---\n\n# SpringBoot引入本地Jar包\n\n## SpringBoot引入本地Jar包\n\n在SpringBoot项目中引入本地Jar包有两种常见的方法：直接在项目中引用和将Jar包安装到本地Maven仓库。\n\n方法一：直接在项目中引用\n\n1. **创建lib目录**：在项目的*src/main/resources*目录下创建一个名为*lib*的文件夹，并将本地Jar包放入其中。\n2. **修改pom.xml**：在*pom.xml*文件中添加以下依赖配置：\n\n```JAVA\n<dependency>\n\t<groupId>com.example</groupId>\n\t<artifactId>example-jar</artifactId>\n\t<version>1.0</version>\n\t<scope>system</scope>\n\t<systemPath>${project.basedir}/src/main/resources/lib/example-jar-1.0.jar</systemPath>\n</dependency>\n```\n\n* **配置插件**：为了确保打包时包含这些Jar包，需要在*pom.xml*文件中添加Spring Boot Maven插件配置：\n\n```JAVA\n<build>\n\t<plugins>\n\t\t<plugin>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t\t<configuration>\n\t\t\t\t\t<includeSystemScope>true</includeSystemScope>\n\t\t\t\t</configuration>\n\t\t</plugin>\n\t</plugins>\n</build>\n```\n\n方法二：将Jar包安装到本地Maven仓库\n\n* **安装Jar包**：使用Maven命令将Jar包安装到本地仓库：\n\n```JAVA\nmvn install:install-file -Dfile=path/to/your.jar -DgroupId=com.example -DartifactId=example-jar -Dversion=1.0 -Dpackaging=jar\n```\n\n* **修改pom.xml**：在*pom.xml*文件中添加以下依赖配置：\n\n```JAVA\n<dependency>\n\t<groupId>com.example</groupId>\n\t<artifactId>example-jar</artifactId>\n\t<version>1.0</version>\n</dependency>\n```\n\n这两种方法都可以有效地将本地Jar包引入到SpringBoot项目中。\n","slug":"springboot-introduces-local-jar-packages-1lmxzy","published":1,"__permalink":"/post/springboot-introduces-local-jar-packages-1lmxzy.html","_id":"cmclcaf4a000sp8vw1tm6dp4t","layout":"post","photos":[],"content":"<h1 id=\"SpringBoot引入本地Jar包\"><a href=\"#SpringBoot引入本地Jar包\" class=\"headerlink\" title=\"SpringBoot引入本地Jar包\"></a>SpringBoot引入本地Jar包</h1><h2 id=\"SpringBoot引入本地Jar包-1\"><a href=\"#SpringBoot引入本地Jar包-1\" class=\"headerlink\" title=\"SpringBoot引入本地Jar包\"></a>SpringBoot引入本地Jar包</h2><p>在SpringBoot项目中引入本地Jar包有两种常见的方法：直接在项目中引用和将Jar包安装到本地Maven仓库。</p>\n<p>方法一：直接在项目中引用</p>\n<ol>\n<li><strong>创建lib目录</strong>：在项目的<em>src&#x2F;main&#x2F;resources</em>目录下创建一个名为<em>lib</em>的文件夹，并将本地Jar包放入其中。</li>\n<li><strong>修改pom.xml</strong>：在<em>pom.xml</em>文件中添加以下依赖配置：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;example-jar&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;<span class=\"number\">1.0</span>&lt;/version&gt;</span><br><span class=\"line\">\t&lt;scope&gt;system&lt;/scope&gt;</span><br><span class=\"line\">\t&lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/resources/lib/example-jar-<span class=\"number\">1.0</span>.jar&lt;/systemPath&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>配置插件</strong>：为了确保打包时包含这些Jar包，需要在<em>pom.xml</em>文件中添加Spring Boot Maven插件配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;includeSystemScope&gt;<span class=\"literal\">true</span>&lt;/includeSystemScope&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/configuration&gt;</span><br><span class=\"line\">\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t&lt;/plugins&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：将Jar包安装到本地Maven仓库</p>\n<ul>\n<li><strong>安装Jar包</strong>：使用Maven命令将Jar包安装到本地仓库：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn install:install-file -Dfile=path/to/your.jar -DgroupId=com.example -DartifactId=example-jar -Dversion=<span class=\"number\">1.0</span> -Dpackaging=jar</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>修改pom.xml</strong>：在<em>pom.xml</em>文件中添加以下依赖配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;example-jar&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;<span class=\"number\">1.0</span>&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这两种方法都可以有效地将本地Jar包引入到SpringBoot项目中。</p>\n","more":"<h1 id=\"SpringBoot引入本地Jar包\"><a href=\"#SpringBoot引入本地Jar包\" class=\"headerlink\" title=\"SpringBoot引入本地Jar包\"></a>SpringBoot引入本地Jar包</h1><h2 id=\"SpringBoot引入本地Jar包-1\"><a href=\"#SpringBoot引入本地Jar包-1\" class=\"headerlink\" title=\"SpringBoot引入本地Jar包\"></a>SpringBoot引入本地Jar包</h2><p>在SpringBoot项目中引入本地Jar包有两种常见的方法：直接在项目中引用和将Jar包安装到本地Maven仓库。</p>\n<p>方法一：直接在项目中引用</p>\n<ol>\n<li><strong>创建lib目录</strong>：在项目的<em>src&#x2F;main&#x2F;resources</em>目录下创建一个名为<em>lib</em>的文件夹，并将本地Jar包放入其中。</li>\n<li><strong>修改pom.xml</strong>：在<em>pom.xml</em>文件中添加以下依赖配置：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;example-jar&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;<span class=\"number\">1.0</span>&lt;/version&gt;</span><br><span class=\"line\">\t&lt;scope&gt;system&lt;/scope&gt;</span><br><span class=\"line\">\t&lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/resources/lib/example-jar-<span class=\"number\">1.0</span>.jar&lt;/systemPath&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>配置插件</strong>：为了确保打包时包含这些Jar包，需要在<em>pom.xml</em>文件中添加Spring Boot Maven插件配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;includeSystemScope&gt;<span class=\"literal\">true</span>&lt;/includeSystemScope&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/configuration&gt;</span><br><span class=\"line\">\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t&lt;/plugins&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：将Jar包安装到本地Maven仓库</p>\n<ul>\n<li><strong>安装Jar包</strong>：使用Maven命令将Jar包安装到本地仓库：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn install:install-file -Dfile=path/to/your.jar -DgroupId=com.example -DartifactId=example-jar -Dversion=<span class=\"number\">1.0</span> -Dpackaging=jar</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>修改pom.xml</strong>：在<em>pom.xml</em>文件中添加以下依赖配置：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;example-jar&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;<span class=\"number\">1.0</span>&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这两种方法都可以有效地将本地Jar包引入到SpringBoot项目中。</p>\n"},{"title":"is-a 、have-a、和 like-a 的区别","date":"2024-12-19T15:27:21.000Z","updated":"2024-12-19T16:11:26.000Z","comments":1,"toc":true,"abbrlink":53580,"_content":"\n# is-a 、have-a、和 like-a 的区别\n\n### 1、is-a，has-a，like-a 是什么\n\n在面向对象设计的领域里，有若干种设计思路，主要有如下三种： \nis-a、has-a、like-a \njava 中在类、接口、抽象类中有很多体现。 \n了解 java 看这里：[什么是 Java](http://blog.csdn.net/ooppookid/article/details/51931003) \n了解类和对象看这里：[类、对象到底有什么秘密](http://blog.csdn.net/ooppookid/article/details/51161448) \n了解接口和抽象类看这里：[接口和抽象类有什么区别](http://blog.csdn.net/ooppookid/article/details/51173179)\n\n### 2、is-a 是什么\n\nis-a，顾名思义，是一个，代表继承关系。 \n如果 A is-a B，那么 B 就是 A 的父类。 \n一个类完全包含另一个类的所有属性及行为。 \n例如 PC 机是计算机，工作站也是计算机，PC 机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java 语言实现时，应该将 PC 机和工作站定义成两种类，均继承计算机类。 \n了解更多继承看这里：[java 类的继承有什么意义](http://blog.csdn.net/ooppookid/article/details/51193477)\n\n### *3、has-a 是什么*\n\nhas-a，顾名思义，有一个，代表从属关系。 \n如果 A has a B，那么 B 就是 A 的组成部分。 \n同一种类的对象，通过它们的属性的不同值来区别。 \n例如一台 PC 机的操作系统是 Windows，另一台 PC 机的操作系统是 Linux。操作系统是 PC 机的一个成员变量，根据这一成员变量的不同值，可以区分不同的 PC 机对象。\n\n### 4、 like-a 是什么\n\nlike-a，顾名思义，像一个，代表组合关系。 \n如果 A like a B，那么 B 就是 A 的接口。 \n新类型有老类型的接口，但还包含其他函数，所以不能说它们完全相同。 \n例如一台手机可以说是一个微型计算机，但是手机的通讯功能显然不是计算机具备的行为，所以手机继承了计算机的特性，同时需要实现通讯功能，而通讯功能需要作为单独接口，而不是计算机的行为。\n\n### 5、is-a，has-a，like-a 如何应用\n\n如果你确定两件对象之间是 is-a 的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承。 \n如果你确定两件对象之间是 has-a 的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。 \n如果你确定两件对象之间是 like-a 的关系，那么此时你应该使用组合；比如空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。\n","source":"_posts/the-difference-between-isa-havea-and-likea-1u8avc.md","raw":"---\ntitle: is-a 、have-a、和 like-a 的区别\ndate: '2024-12-19 23:27:21'\nupdated: '2024-12-20 00:11:26'\npermalink: /post/the-difference-between-isa-havea-and-likea-1u8avc.html\ncomments: true\ntoc: true\nabbrlink: 53580\n---\n\n# is-a 、have-a、和 like-a 的区别\n\n### 1、is-a，has-a，like-a 是什么\n\n在面向对象设计的领域里，有若干种设计思路，主要有如下三种： \nis-a、has-a、like-a \njava 中在类、接口、抽象类中有很多体现。 \n了解 java 看这里：[什么是 Java](http://blog.csdn.net/ooppookid/article/details/51931003) \n了解类和对象看这里：[类、对象到底有什么秘密](http://blog.csdn.net/ooppookid/article/details/51161448) \n了解接口和抽象类看这里：[接口和抽象类有什么区别](http://blog.csdn.net/ooppookid/article/details/51173179)\n\n### 2、is-a 是什么\n\nis-a，顾名思义，是一个，代表继承关系。 \n如果 A is-a B，那么 B 就是 A 的父类。 \n一个类完全包含另一个类的所有属性及行为。 \n例如 PC 机是计算机，工作站也是计算机，PC 机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java 语言实现时，应该将 PC 机和工作站定义成两种类，均继承计算机类。 \n了解更多继承看这里：[java 类的继承有什么意义](http://blog.csdn.net/ooppookid/article/details/51193477)\n\n### *3、has-a 是什么*\n\nhas-a，顾名思义，有一个，代表从属关系。 \n如果 A has a B，那么 B 就是 A 的组成部分。 \n同一种类的对象，通过它们的属性的不同值来区别。 \n例如一台 PC 机的操作系统是 Windows，另一台 PC 机的操作系统是 Linux。操作系统是 PC 机的一个成员变量，根据这一成员变量的不同值，可以区分不同的 PC 机对象。\n\n### 4、 like-a 是什么\n\nlike-a，顾名思义，像一个，代表组合关系。 \n如果 A like a B，那么 B 就是 A 的接口。 \n新类型有老类型的接口，但还包含其他函数，所以不能说它们完全相同。 \n例如一台手机可以说是一个微型计算机，但是手机的通讯功能显然不是计算机具备的行为，所以手机继承了计算机的特性，同时需要实现通讯功能，而通讯功能需要作为单独接口，而不是计算机的行为。\n\n### 5、is-a，has-a，like-a 如何应用\n\n如果你确定两件对象之间是 is-a 的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承。 \n如果你确定两件对象之间是 has-a 的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。 \n如果你确定两件对象之间是 like-a 的关系，那么此时你应该使用组合；比如空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。\n","slug":"the-difference-between-isa-havea-and-likea-1u8avc","published":1,"__permalink":"/post/the-difference-between-isa-havea-and-likea-1u8avc.html","_id":"cmclcaf4b000tp8vwekfygz9p","layout":"post","photos":[],"content":"<h1 id=\"is-a-、have-a、和-like-a-的区别\"><a href=\"#is-a-、have-a、和-like-a-的区别\" class=\"headerlink\" title=\"is-a 、have-a、和 like-a 的区别\"></a>is-a 、have-a、和 like-a 的区别</h1><h3 id=\"1、is-a，has-a，like-a-是什么\"><a href=\"#1、is-a，has-a，like-a-是什么\" class=\"headerlink\" title=\"1、is-a，has-a，like-a 是什么\"></a>1、is-a，has-a，like-a 是什么</h3><p>在面向对象设计的领域里，有若干种设计思路，主要有如下三种：<br>is-a、has-a、like-a<br>java 中在类、接口、抽象类中有很多体现。<br>了解 java 看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51931003\">什么是 Java</a><br>了解类和对象看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51161448\">类、对象到底有什么秘密</a><br>了解接口和抽象类看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51173179\">接口和抽象类有什么区别</a></p>\n<h3 id=\"2、is-a-是什么\"><a href=\"#2、is-a-是什么\" class=\"headerlink\" title=\"2、is-a 是什么\"></a>2、is-a 是什么</h3><p>is-a，顾名思义，是一个，代表继承关系。<br>如果 A is-a B，那么 B 就是 A 的父类。<br>一个类完全包含另一个类的所有属性及行为。<br>例如 PC 机是计算机，工作站也是计算机，PC 机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java 语言实现时，应该将 PC 机和工作站定义成两种类，均继承计算机类。<br>了解更多继承看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51193477\">java 类的继承有什么意义</a></p>\n<h3 id=\"3、has-a-是什么\"><a href=\"#3、has-a-是什么\" class=\"headerlink\" title=\"3、has-a 是什么\"></a><em>3、has-a 是什么</em></h3><p>has-a，顾名思义，有一个，代表从属关系。<br>如果 A has a B，那么 B 就是 A 的组成部分。<br>同一种类的对象，通过它们的属性的不同值来区别。<br>例如一台 PC 机的操作系统是 Windows，另一台 PC 机的操作系统是 Linux。操作系统是 PC 机的一个成员变量，根据这一成员变量的不同值，可以区分不同的 PC 机对象。</p>\n<h3 id=\"4、-like-a-是什么\"><a href=\"#4、-like-a-是什么\" class=\"headerlink\" title=\"4、 like-a 是什么\"></a>4、 like-a 是什么</h3><p>like-a，顾名思义，像一个，代表组合关系。<br>如果 A like a B，那么 B 就是 A 的接口。<br>新类型有老类型的接口，但还包含其他函数，所以不能说它们完全相同。<br>例如一台手机可以说是一个微型计算机，但是手机的通讯功能显然不是计算机具备的行为，所以手机继承了计算机的特性，同时需要实现通讯功能，而通讯功能需要作为单独接口，而不是计算机的行为。</p>\n<h3 id=\"5、is-a，has-a，like-a-如何应用\"><a href=\"#5、is-a，has-a，like-a-如何应用\" class=\"headerlink\" title=\"5、is-a，has-a，like-a 如何应用\"></a>5、is-a，has-a，like-a 如何应用</h3><p>如果你确定两件对象之间是 is-a 的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承。<br>如果你确定两件对象之间是 has-a 的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。<br>如果你确定两件对象之间是 like-a 的关系，那么此时你应该使用组合；比如空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</p>\n","excerpt":"","more":"<h1 id=\"is-a-、have-a、和-like-a-的区别\"><a href=\"#is-a-、have-a、和-like-a-的区别\" class=\"headerlink\" title=\"is-a 、have-a、和 like-a 的区别\"></a>is-a 、have-a、和 like-a 的区别</h1><h3 id=\"1、is-a，has-a，like-a-是什么\"><a href=\"#1、is-a，has-a，like-a-是什么\" class=\"headerlink\" title=\"1、is-a，has-a，like-a 是什么\"></a>1、is-a，has-a，like-a 是什么</h3><p>在面向对象设计的领域里，有若干种设计思路，主要有如下三种：<br>is-a、has-a、like-a<br>java 中在类、接口、抽象类中有很多体现。<br>了解 java 看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51931003\">什么是 Java</a><br>了解类和对象看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51161448\">类、对象到底有什么秘密</a><br>了解接口和抽象类看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51173179\">接口和抽象类有什么区别</a></p>\n<h3 id=\"2、is-a-是什么\"><a href=\"#2、is-a-是什么\" class=\"headerlink\" title=\"2、is-a 是什么\"></a>2、is-a 是什么</h3><p>is-a，顾名思义，是一个，代表继承关系。<br>如果 A is-a B，那么 B 就是 A 的父类。<br>一个类完全包含另一个类的所有属性及行为。<br>例如 PC 机是计算机，工作站也是计算机，PC 机和工作站是两种不同类型的计算机，但都继承了计算机的共同特性。因此在用 Java 语言实现时，应该将 PC 机和工作站定义成两种类，均继承计算机类。<br>了解更多继承看这里：<a href=\"http://blog.csdn.net/ooppookid/article/details/51193477\">java 类的继承有什么意义</a></p>\n<h3 id=\"3、has-a-是什么\"><a href=\"#3、has-a-是什么\" class=\"headerlink\" title=\"3、has-a 是什么\"></a><em>3、has-a 是什么</em></h3><p>has-a，顾名思义，有一个，代表从属关系。<br>如果 A has a B，那么 B 就是 A 的组成部分。<br>同一种类的对象，通过它们的属性的不同值来区别。<br>例如一台 PC 机的操作系统是 Windows，另一台 PC 机的操作系统是 Linux。操作系统是 PC 机的一个成员变量，根据这一成员变量的不同值，可以区分不同的 PC 机对象。</p>\n<h3 id=\"4、-like-a-是什么\"><a href=\"#4、-like-a-是什么\" class=\"headerlink\" title=\"4、 like-a 是什么\"></a>4、 like-a 是什么</h3><p>like-a，顾名思义，像一个，代表组合关系。<br>如果 A like a B，那么 B 就是 A 的接口。<br>新类型有老类型的接口，但还包含其他函数，所以不能说它们完全相同。<br>例如一台手机可以说是一个微型计算机，但是手机的通讯功能显然不是计算机具备的行为，所以手机继承了计算机的特性，同时需要实现通讯功能，而通讯功能需要作为单独接口，而不是计算机的行为。</p>\n<h3 id=\"5、is-a，has-a，like-a-如何应用\"><a href=\"#5、is-a，has-a，like-a-如何应用\" class=\"headerlink\" title=\"5、is-a，has-a，like-a 如何应用\"></a>5、is-a，has-a，like-a 如何应用</h3><p>如果你确定两件对象之间是 is-a 的关系，那么此时你应该使用继承；比如菱形、圆形和方形都是形状的一种，那么他们都应该从形状类继承。<br>如果你确定两件对象之间是 has-a 的关系，那么此时你应该使用聚合；比如电脑是由显示器、CPU、硬盘等组成的，那么你应该把显示器、CPU、硬盘这些类聚合成电脑类。<br>如果你确定两件对象之间是 like-a 的关系，那么此时你应该使用组合；比如空调继承于制冷机，但它同时有加热功能，那么你应该把让空调继承制冷机类，并实现加热接口。</p>\n"},{"title":"测试Linux系统磁盘读写性能（linux磁盘读写测试）","date":"2024-12-19T01:56:33.000Z","updated":"2025-01-17T10:46:27.000Z","excerpt":"本文介绍了在Linux系统下测试磁盘读写性能的三种方法。一是使用dd命令，如“dd if=/dev/zero of=/dev/hda1 bs=1k count=10000”等，通过设置不同参数来测试。二是利用Iozone软件，它能测试特定文件大小、数量及类型的I/O性能，安装使用可参考文档。三是基于文件系统的测试，以EXT4文件系统为例，通过“mkfs.ext4 /dev/hda1 & mount /dev/hda1 /mnt/test”和“iozone -Rab ./result.xls -i 0 -i 1 -i 2 -t 8 /mnt/test”等命令进行，可生成详细结果文件。通过比较不同分区结果，可了解各分区性能，从而选择合适方法准确测试磁盘读写性能，优化系统。","comments":1,"toc":true,"abbrlink":54934,"_content":"\n# 测试Linux系统磁盘读写性能（linux磁盘读写测试）\n\n# 测试Linux系统磁盘读写性能（linux磁盘读写测试）\n\n测试Linux系统磁盘读写性能（linux磁盘读写测试）\n\n---\n\nLinux系统磁盘读写性能测试广泛应用于云计算、分布式计算、嵌入式系统等地方，用于了解磁盘I/O操作效率，合理调整配置以改进系统性能，下面介绍在Linux系统下如何测试磁盘读写性能。\n\n1、在Linux系统下，可以使用dd命令测试磁盘读写性能，具体命令行格式为：dd if=\\[输入文件\\] of=\\[输出文件\\] bs=\\[块大小\\] count=\\[块数\\]。输入文件通常是/dev/zero，输出文件为要测试的磁盘分区，这里使用/dev/hda1表示分区块，块大小可设为1k或4k，块数设置为10000或100000，这里以1M大小的文件为例，命令如下：\n\n```sh\ndd if=/dev/zero of=/dev/hda1 bs=1k count=10000\n```\n\n```sh\ndd if=/dev/zero of=/volume1/testfile.txt bs=32k count=40k oflag=dsync\n```\n\n2、为了更准确的测试磁盘读写性能，可以使用Iozone进行测试。Iozone是一款开源的磁盘I/O性能测试软件，可以测试某一特定的文件大小、文件数量以及文件类型的I/O性能，来获取更精准的测试数据，具体安装使用可以参考相关文档。\n\n3、基于文件系统的IOzone测试也可以更加准确的测试磁盘读写性能，这里以EXT4文件系统为例，可以使用以下命令进行测试：\n\n```sh\nmkfs.ext4 /dev/hda1 & mount /dev/hda1 /mnt/test\n\niozone -Rab ./result.xls -i 0 -i 1 -i 2 -t 8 /mnt/test\n```\n\n上述命令中，“-Rab”用于生成详细的结果文件result.xls，“-i 0、-i 1、-i 2”分别代表不同的测试参数，“-t 8”表示同时使用8个线程测试，/mnt/test是挂载的分区。\n\n4、最后，通过比较不同的分区的结果信息，就可以知道不同的分区的性能情况。\n\n综上，我们介绍了Linux系统下测试磁盘读写性能的三种方法：dd命令、Iozone软件以及基于文件系统的测试，选择合适的方法可以更准确的测试磁盘读写性能，改进系统性能，完成更加高效的工作。\n","source":"_posts/test-the-linux-system-disk-read-and-write-performance-linux-disk-read-and-write-test-z1eep63.md","raw":"---\ntitle: 测试Linux系统磁盘读写性能（linux磁盘读写测试）\ndate: '2024-12-19 09:56:33'\nupdated: '2025-01-17 18:46:27'\nexcerpt: >-\n  本文介绍了在Linux系统下测试磁盘读写性能的三种方法。一是使用dd命令，如“dd if=/dev/zero of=/dev/hda1 bs=1k\n  count=10000”等，通过设置不同参数来测试。二是利用Iozone软件，它能测试特定文件大小、数量及类型的I/O性能，安装使用可参考文档。三是基于文件系统的测试，以EXT4文件系统为例，通过“mkfs.ext4\n  /dev/hda1 & mount /dev/hda1 /mnt/test”和“iozone -Rab ./result.xls -i 0 -i 1 -i\n  2 -t 8 /mnt/test”等命令进行，可生成详细结果文件。通过比较不同分区结果，可了解各分区性能，从而选择合适方法准确测试磁盘读写性能，优化系统。\ntags:\n  - 磁盘测试\n  - iozone\n  - dd命令\n  - 文件系统\n  - 性能优化\ncategories:\n  - Linux系统\n  - 磁盘测试\npermalink: >-\n  /post/test-the-linux-system-disk-read-and-write-performance-linux-disk-read-and-write-test-z1eep63.html\ncomments: true\ntoc: true\nabbrlink: 54934\n---\n\n# 测试Linux系统磁盘读写性能（linux磁盘读写测试）\n\n# 测试Linux系统磁盘读写性能（linux磁盘读写测试）\n\n测试Linux系统磁盘读写性能（linux磁盘读写测试）\n\n---\n\nLinux系统磁盘读写性能测试广泛应用于云计算、分布式计算、嵌入式系统等地方，用于了解磁盘I/O操作效率，合理调整配置以改进系统性能，下面介绍在Linux系统下如何测试磁盘读写性能。\n\n1、在Linux系统下，可以使用dd命令测试磁盘读写性能，具体命令行格式为：dd if=\\[输入文件\\] of=\\[输出文件\\] bs=\\[块大小\\] count=\\[块数\\]。输入文件通常是/dev/zero，输出文件为要测试的磁盘分区，这里使用/dev/hda1表示分区块，块大小可设为1k或4k，块数设置为10000或100000，这里以1M大小的文件为例，命令如下：\n\n```sh\ndd if=/dev/zero of=/dev/hda1 bs=1k count=10000\n```\n\n```sh\ndd if=/dev/zero of=/volume1/testfile.txt bs=32k count=40k oflag=dsync\n```\n\n2、为了更准确的测试磁盘读写性能，可以使用Iozone进行测试。Iozone是一款开源的磁盘I/O性能测试软件，可以测试某一特定的文件大小、文件数量以及文件类型的I/O性能，来获取更精准的测试数据，具体安装使用可以参考相关文档。\n\n3、基于文件系统的IOzone测试也可以更加准确的测试磁盘读写性能，这里以EXT4文件系统为例，可以使用以下命令进行测试：\n\n```sh\nmkfs.ext4 /dev/hda1 & mount /dev/hda1 /mnt/test\n\niozone -Rab ./result.xls -i 0 -i 1 -i 2 -t 8 /mnt/test\n```\n\n上述命令中，“-Rab”用于生成详细的结果文件result.xls，“-i 0、-i 1、-i 2”分别代表不同的测试参数，“-t 8”表示同时使用8个线程测试，/mnt/test是挂载的分区。\n\n4、最后，通过比较不同的分区的结果信息，就可以知道不同的分区的性能情况。\n\n综上，我们介绍了Linux系统下测试磁盘读写性能的三种方法：dd命令、Iozone软件以及基于文件系统的测试，选择合适的方法可以更准确的测试磁盘读写性能，改进系统性能，完成更加高效的工作。\n","slug":"test-the-linux-system-disk-read-and-write-performance-linux-disk-read-and-write-test-z1eep63","published":1,"__permalink":"/post/test-the-linux-system-disk-read-and-write-performance-linux-disk-read-and-write-test-z1eep63.html","_id":"cmclcaf4d000xp8vwbzhphejq","layout":"post","photos":[],"content":"<h1 id=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）\"><a href=\"#测试Linux系统磁盘读写性能（linux磁盘读写测试）\" class=\"headerlink\" title=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）\"></a>测试Linux系统磁盘读写性能（linux磁盘读写测试）</h1><h1 id=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）-1\"><a href=\"#测试Linux系统磁盘读写性能（linux磁盘读写测试）-1\" class=\"headerlink\" title=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）\"></a>测试Linux系统磁盘读写性能（linux磁盘读写测试）</h1><p>测试Linux系统磁盘读写性能（linux磁盘读写测试）</p>\n<hr>\n<p>Linux系统磁盘读写性能测试广泛应用于云计算、分布式计算、嵌入式系统等地方，用于了解磁盘I&#x2F;O操作效率，合理调整配置以改进系统性能，下面介绍在Linux系统下如何测试磁盘读写性能。</p>\n<p>1、在Linux系统下，可以使用dd命令测试磁盘读写性能，具体命令行格式为：dd if&#x3D;[输入文件] of&#x3D;[输出文件] bs&#x3D;[块大小] count&#x3D;[块数]。输入文件通常是&#x2F;dev&#x2F;zero，输出文件为要测试的磁盘分区，这里使用&#x2F;dev&#x2F;hda1表示分区块，块大小可设为1k或4k，块数设置为10000或100000，这里以1M大小的文件为例，命令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/dev/hda1 bs=1k count=10000</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/volume1/testfile.txt bs=32k count=40k oflag=dsync</span><br></pre></td></tr></table></figure>\n\n<p>2、为了更准确的测试磁盘读写性能，可以使用Iozone进行测试。Iozone是一款开源的磁盘I&#x2F;O性能测试软件，可以测试某一特定的文件大小、文件数量以及文件类型的I&#x2F;O性能，来获取更精准的测试数据，具体安装使用可以参考相关文档。</p>\n<p>3、基于文件系统的IOzone测试也可以更加准确的测试磁盘读写性能，这里以EXT4文件系统为例，可以使用以下命令进行测试：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkfs.ext4 /dev/hda1 &amp; mount /dev/hda1 /mnt/test</span><br><span class=\"line\"></span><br><span class=\"line\">iozone -Rab ./result.xls -i 0 -i 1 -i 2 -t 8 /mnt/test</span><br></pre></td></tr></table></figure>\n\n<p>上述命令中，“-Rab”用于生成详细的结果文件result.xls，“-i 0、-i 1、-i 2”分别代表不同的测试参数，“-t 8”表示同时使用8个线程测试，&#x2F;mnt&#x2F;test是挂载的分区。</p>\n<p>4、最后，通过比较不同的分区的结果信息，就可以知道不同的分区的性能情况。</p>\n<p>综上，我们介绍了Linux系统下测试磁盘读写性能的三种方法：dd命令、Iozone软件以及基于文件系统的测试，选择合适的方法可以更准确的测试磁盘读写性能，改进系统性能，完成更加高效的工作。</p>\n","more":"<h1 id=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）\"><a href=\"#测试Linux系统磁盘读写性能（linux磁盘读写测试）\" class=\"headerlink\" title=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）\"></a>测试Linux系统磁盘读写性能（linux磁盘读写测试）</h1><h1 id=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）-1\"><a href=\"#测试Linux系统磁盘读写性能（linux磁盘读写测试）-1\" class=\"headerlink\" title=\"测试Linux系统磁盘读写性能（linux磁盘读写测试）\"></a>测试Linux系统磁盘读写性能（linux磁盘读写测试）</h1><p>测试Linux系统磁盘读写性能（linux磁盘读写测试）</p>\n<hr>\n<p>Linux系统磁盘读写性能测试广泛应用于云计算、分布式计算、嵌入式系统等地方，用于了解磁盘I&#x2F;O操作效率，合理调整配置以改进系统性能，下面介绍在Linux系统下如何测试磁盘读写性能。</p>\n<p>1、在Linux系统下，可以使用dd命令测试磁盘读写性能，具体命令行格式为：dd if&#x3D;[输入文件] of&#x3D;[输出文件] bs&#x3D;[块大小] count&#x3D;[块数]。输入文件通常是&#x2F;dev&#x2F;zero，输出文件为要测试的磁盘分区，这里使用&#x2F;dev&#x2F;hda1表示分区块，块大小可设为1k或4k，块数设置为10000或100000，这里以1M大小的文件为例，命令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/dev/hda1 bs=1k count=10000</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/volume1/testfile.txt bs=32k count=40k oflag=dsync</span><br></pre></td></tr></table></figure>\n\n<p>2、为了更准确的测试磁盘读写性能，可以使用Iozone进行测试。Iozone是一款开源的磁盘I&#x2F;O性能测试软件，可以测试某一特定的文件大小、文件数量以及文件类型的I&#x2F;O性能，来获取更精准的测试数据，具体安装使用可以参考相关文档。</p>\n<p>3、基于文件系统的IOzone测试也可以更加准确的测试磁盘读写性能，这里以EXT4文件系统为例，可以使用以下命令进行测试：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkfs.ext4 /dev/hda1 &amp; mount /dev/hda1 /mnt/test</span><br><span class=\"line\"></span><br><span class=\"line\">iozone -Rab ./result.xls -i 0 -i 1 -i 2 -t 8 /mnt/test</span><br></pre></td></tr></table></figure>\n\n<p>上述命令中，“-Rab”用于生成详细的结果文件result.xls，“-i 0、-i 1、-i 2”分别代表不同的测试参数，“-t 8”表示同时使用8个线程测试，&#x2F;mnt&#x2F;test是挂载的分区。</p>\n<p>4、最后，通过比较不同的分区的结果信息，就可以知道不同的分区的性能情况。</p>\n<p>综上，我们介绍了Linux系统下测试磁盘读写性能的三种方法：dd命令、Iozone软件以及基于文件系统的测试，选择合适的方法可以更准确的测试磁盘读写性能，改进系统性能，完成更加高效的工作。</p>\n"},{"title":"在 MyBatis-Plus 中使用 IN 语法","date":"2024-12-31T03:19:30.000Z","updated":"2024-12-31T03:26:42.000Z","excerpt":"在 MyBatis-Plus 中使用 `IN` 语法可以通过多种方式实现。首先，可以使用 `QueryWrapper` 或 `LambdaQueryWrapper` 的 `in` 方法动态构建查询条件，适合在 Java 代码中直接操作。其次，可以在 XML 映射文件中编写 SQL 语句，使用 `<foreach>` 标签处理 `IN` 查询，适合复杂 SQL 场景。此外，注解方式也可用于编写 `IN` 查询，但需手动处理列表转换。需要注意的是，当传入的列表为空时，可能导致 SQL 语法错误，因此应提前检查列表是否为空。根据需求选择合适的方式，既能提高代码可读性，又能避免潜在问题。","comments":1,"toc":true,"abbrlink":42944,"_content":"\n# 在 MyBatis-Plus 中使用 IN 语法\n\n在 MyBatis-Plus 中使用 `IN`​ 语法可以通过以下几种方式实现：\n\n### 1. 使用 `QueryWrapper`​ 的 `in`​ 方法\n\n​`QueryWrapper`​ 是 MyBatis-Plus 提供的查询条件构造器，可以使用 `in`​ 方法来构建 `IN`​ 查询。\n\n```JAVA\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\n\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {\n\n    public List<User> findUsersByIds(List<Long> ids) {\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.in(\"id\", ids);\n        return baseMapper.selectList(queryWrapper);\n    }\n}\n```\n\n**SQL 输出：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n### 2. 使用 `LambdaQueryWrapper`​ 的 `in`​ 方法\n\n​`LambdaQueryWrapper`​ 提供了类型安全的查询条件构造，可以使用 `in`​ 方法来构建 `IN`​ 查询。\n\n```\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\n\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {\n\n    public List<User> findUsersByIds(List<Long> ids) {\n        LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();\n        lambdaQueryWrapper.in(User::getId, ids);\n        return baseMapper.selectList(lambdaQueryWrapper);\n    }\n}\n```\n\n**SQL 输出：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n### 3. 使用 XML 映射文件\n\n在 MyBatis 的 XML 映射文件中，可以直接编写 SQL 语句，使用 `IN`​ 语法。\n\n```\n<select id=\"findUsersByIds\" resultType=\"User\">\n    SELECT * FROM user WHERE id IN\n    <foreach collection=\"ids\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n        #{id}\n    </foreach>\n</select>\n```\n\n运行 HTML\n\n**Java 代码：**\n\n```\npublic interface UserMapper extends BaseMapper<User> {\n    List<User> findUsersByIds(@Param(\"ids\") List<Long> ids);\n}\n```\n\n**SQL 输出：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n### 4. 使用注解方式\n\n在 MyBatis 的注解方式中，可以使用 `@Select`​ 注解编写 SQL 语句，使用 `IN`​ 语法。\n\n```\nimport org.apache.ibatis.annotations.Param;\nimport org.apache.ibatis.annotations.Select;\n\nimport java.util.List;\n\npublic interface UserMapper extends BaseMapper<User> {\n\n    @Select(\"SELECT * FROM user WHERE id IN (#{ids})\")\n    List<User> findUsersByIds(@Param(\"ids\") List<Long> ids);\n}\n```\n\n**注意：**  这种方式需要手动将 `List`​ 转换为逗号分隔的字符串。\n\n### 5. 处理空列表的情况\n\n在使用 `IN`​ 语法时，如果传入的列表为空，可能会导致 SQL 语法错误。可以通过以下方式处理：\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    if (ids == null || ids.isEmpty()) {\n        return new ArrayList<>();\n    }\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.in(\"id\", ids);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n### 总结\n\n* ​**​`QueryWrapper`​**​ **和** **​`LambdaQueryWrapper`​**​ 是 MyBatis-Plus 提供的便捷查询条件构造器，适合在 Java 代码中动态构建查询条件。\n* **XML 映射文件** 和 **注解方式** 适合在需要编写复杂 SQL 或需要复用 SQL 的场景下使用。\n* **处理空列表** 是使用 `IN`​ 语法时需要注意的一个细节，避免 SQL 语法错误。\n\n根据具体需求选择合适的方式来实现 `IN`​ 查询。\n\n‍\n\n除此之外，在使用 `LambdaQueryWrapper`​ 的 `in`​ 方法时，如果传入的数组或列表为空，可能会导致生成的 SQL 语句不合法（例如 `IN ()`​），从而引发 SQL 语法错误。为了避免这种情况，可以在调用 `in`​ 方法之前对数组或列表进行判空处理。\n\n以下是处理空数组的几种常见方式：\n\n---\n\n### 1. **直接返回空结果**\n\n如果传入的数组为空，直接返回一个空列表，避免执行 SQL 查询。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    if (ids == null || ids.isEmpty()) {\n        return new ArrayList<>();\n    }\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    queryWrapper.in(User::getId, ids);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**优点：**\n\n* 简单直接，避免执行无意义的查询。\n\n**缺点：**\n\n* 需要在业务逻辑中显式处理空列表。\n\n---\n\n### 2. **添加空值检查条件**\n\n如果希望即使传入空列表也能执行查询，可以通过添加一个永假条件（例如 `1 = 0`​）来避免生成 `IN ()`​。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    if (ids == null || ids.isEmpty()) {\n        queryWrapper.apply(\"1 = 0\"); // 永假条件，避免生成 IN ()\n    } else {\n        queryWrapper.in(User::getId, ids);\n    }\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**生成的 SQL：**\n\n```\nSELECT * FROM user WHERE 1 = 0;\n```\n\n**优点：**\n\n* 统一处理空列表，避免在业务逻辑中显式返回空列表。\n\n**缺点：**\n\n* 生成的 SQL 可能不够直观。\n\n---\n\n### 3. **使用** **​`Optional`​**​ **处理空值**\n\n使用 `Optional`​ 对传入的列表进行包装，避免空指针异常。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    List<Long> nonNullIds = Optional.ofNullable(ids).orElse(Collections.emptyList());\n    if (nonNullIds.isEmpty()) {\n        return new ArrayList<>();\n    }\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    queryWrapper.in(User::getId, nonNullIds);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**优点：**\n\n* 代码更健壮，避免空指针异常。\n\n**缺点：**\n\n* 需要额外引入 `Optional`​。\n\n---\n\n### 4. **自定义工具方法**\n\n封装一个工具方法，统一处理 `in`​ 方法的空列表问题。\n\n```\npublic class QueryWrapperUtils {\n    public static <T, R> void inIfNotEmpty(LambdaQueryWrapper<T> queryWrapper, SFunction<T, R> column, Collection<R> values) {\n        if (values != null && !values.isEmpty()) {\n            queryWrapper.in(column, values);\n        } else {\n            queryWrapper.apply(\"1 = 0\"); // 永假条件\n        }\n    }\n}\n\n// 使用工具方法\npublic List<User> findUsersByIds(List<Long> ids) {\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    QueryWrapperUtils.inIfNotEmpty(queryWrapper, User::getId, ids);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**优点：**\n\n* 代码复用，逻辑清晰。\n\n**缺点：**\n\n* 需要额外定义工具类。\n\n---\n\n### 5. **使用 MyBatis-Plus 的** **​`apply`​**​ **方法动态生成 SQL**\n\n通过 `apply`​ 方法动态生成 `IN`​ 子句，避免空列表问题。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    if (ids != null && !ids.isEmpty()) {\n        String inClause = ids.stream()\n                .map(String::valueOf)\n                .collect(Collectors.joining(\",\", \"(\", \")\"));\n        queryWrapper.apply(\"id IN \" + inClause);\n    } else {\n        queryWrapper.apply(\"1 = 0\");\n    }\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**生成的 SQL：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n**优点：**\n\n* 灵活控制 SQL 生成。\n\n**缺点：**\n\n* 需要手动拼接 SQL，可能引入 SQL 注入风险（需确保输入安全）。\n\n---\n\n### 总结\n\n|方法|优点|缺点|\n| ----------------| --------------------------| ---------------------------------------|\n|直接返回空结果|简单直接|需在业务逻辑中显式处理|\n|添加永假条件|统一处理空列表|生成的 SQL 不够直观|\n|使用 `Optional`​|避免空指针异常，代码健壮|需要额外引入 `Optional`​|\n|自定义工具方法|代码复用，逻辑清晰|需要额外定义工具类|\n|动态生成 SQL|灵活控制 SQL 生成|需手动拼接 SQL，可能引入 SQL 注入风险|\n\n根据具体场景选择合适的方式处理空数组问题。推荐使用 **直接返回空结果** 或 **自定义工具方法**，既简单又安全。\n","source":"_posts/use-in-grammar-in-mybatisplus-1bihse.md","raw":"---\ntitle: 在 MyBatis-Plus 中使用 IN 语法\ndate: '2024-12-31 11:19:30'\nupdated: '2024-12-31 11:26:42'\nexcerpt: >-\n  在 MyBatis-Plus 中使用 `IN` 语法可以通过多种方式实现。首先，可以使用 `QueryWrapper` 或\n  `LambdaQueryWrapper` 的 `in` 方法动态构建查询条件，适合在 Java 代码中直接操作。其次，可以在 XML 映射文件中编写 SQL\n  语句，使用 `<foreach>` 标签处理 `IN` 查询，适合复杂 SQL 场景。此外，注解方式也可用于编写 `IN`\n  查询，但需手动处理列表转换。需要注意的是，当传入的列表为空时，可能导致 SQL\n  语法错误，因此应提前检查列表是否为空。根据需求选择合适的方式，既能提高代码可读性，又能避免潜在问题。\ntags:\n  - mybatis-plus\n  - in语法\n  - 查询\n  - 空列表处理\n  - lambda\ncategories:\n  - mybatis\npermalink: /post/use-in-grammar-in-mybatisplus-1bihse.html\ncomments: true\ntoc: true\nabbrlink: 42944\n---\n\n# 在 MyBatis-Plus 中使用 IN 语法\n\n在 MyBatis-Plus 中使用 `IN`​ 语法可以通过以下几种方式实现：\n\n### 1. 使用 `QueryWrapper`​ 的 `in`​ 方法\n\n​`QueryWrapper`​ 是 MyBatis-Plus 提供的查询条件构造器，可以使用 `in`​ 方法来构建 `IN`​ 查询。\n\n```JAVA\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\n\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {\n\n    public List<User> findUsersByIds(List<Long> ids) {\n        QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n        queryWrapper.in(\"id\", ids);\n        return baseMapper.selectList(queryWrapper);\n    }\n}\n```\n\n**SQL 输出：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n### 2. 使用 `LambdaQueryWrapper`​ 的 `in`​ 方法\n\n​`LambdaQueryWrapper`​ 提供了类型安全的查询条件构造，可以使用 `in`​ 方法来构建 `IN`​ 查询。\n\n```\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\n\npublic class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {\n\n    public List<User> findUsersByIds(List<Long> ids) {\n        LambdaQueryWrapper<User> lambdaQueryWrapper = new LambdaQueryWrapper<>();\n        lambdaQueryWrapper.in(User::getId, ids);\n        return baseMapper.selectList(lambdaQueryWrapper);\n    }\n}\n```\n\n**SQL 输出：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n### 3. 使用 XML 映射文件\n\n在 MyBatis 的 XML 映射文件中，可以直接编写 SQL 语句，使用 `IN`​ 语法。\n\n```\n<select id=\"findUsersByIds\" resultType=\"User\">\n    SELECT * FROM user WHERE id IN\n    <foreach collection=\"ids\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n        #{id}\n    </foreach>\n</select>\n```\n\n运行 HTML\n\n**Java 代码：**\n\n```\npublic interface UserMapper extends BaseMapper<User> {\n    List<User> findUsersByIds(@Param(\"ids\") List<Long> ids);\n}\n```\n\n**SQL 输出：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n### 4. 使用注解方式\n\n在 MyBatis 的注解方式中，可以使用 `@Select`​ 注解编写 SQL 语句，使用 `IN`​ 语法。\n\n```\nimport org.apache.ibatis.annotations.Param;\nimport org.apache.ibatis.annotations.Select;\n\nimport java.util.List;\n\npublic interface UserMapper extends BaseMapper<User> {\n\n    @Select(\"SELECT * FROM user WHERE id IN (#{ids})\")\n    List<User> findUsersByIds(@Param(\"ids\") List<Long> ids);\n}\n```\n\n**注意：**  这种方式需要手动将 `List`​ 转换为逗号分隔的字符串。\n\n### 5. 处理空列表的情况\n\n在使用 `IN`​ 语法时，如果传入的列表为空，可能会导致 SQL 语法错误。可以通过以下方式处理：\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    if (ids == null || ids.isEmpty()) {\n        return new ArrayList<>();\n    }\n    QueryWrapper<User> queryWrapper = new QueryWrapper<>();\n    queryWrapper.in(\"id\", ids);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n### 总结\n\n* ​**​`QueryWrapper`​**​ **和** **​`LambdaQueryWrapper`​**​ 是 MyBatis-Plus 提供的便捷查询条件构造器，适合在 Java 代码中动态构建查询条件。\n* **XML 映射文件** 和 **注解方式** 适合在需要编写复杂 SQL 或需要复用 SQL 的场景下使用。\n* **处理空列表** 是使用 `IN`​ 语法时需要注意的一个细节，避免 SQL 语法错误。\n\n根据具体需求选择合适的方式来实现 `IN`​ 查询。\n\n‍\n\n除此之外，在使用 `LambdaQueryWrapper`​ 的 `in`​ 方法时，如果传入的数组或列表为空，可能会导致生成的 SQL 语句不合法（例如 `IN ()`​），从而引发 SQL 语法错误。为了避免这种情况，可以在调用 `in`​ 方法之前对数组或列表进行判空处理。\n\n以下是处理空数组的几种常见方式：\n\n---\n\n### 1. **直接返回空结果**\n\n如果传入的数组为空，直接返回一个空列表，避免执行 SQL 查询。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    if (ids == null || ids.isEmpty()) {\n        return new ArrayList<>();\n    }\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    queryWrapper.in(User::getId, ids);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**优点：**\n\n* 简单直接，避免执行无意义的查询。\n\n**缺点：**\n\n* 需要在业务逻辑中显式处理空列表。\n\n---\n\n### 2. **添加空值检查条件**\n\n如果希望即使传入空列表也能执行查询，可以通过添加一个永假条件（例如 `1 = 0`​）来避免生成 `IN ()`​。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    if (ids == null || ids.isEmpty()) {\n        queryWrapper.apply(\"1 = 0\"); // 永假条件，避免生成 IN ()\n    } else {\n        queryWrapper.in(User::getId, ids);\n    }\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**生成的 SQL：**\n\n```\nSELECT * FROM user WHERE 1 = 0;\n```\n\n**优点：**\n\n* 统一处理空列表，避免在业务逻辑中显式返回空列表。\n\n**缺点：**\n\n* 生成的 SQL 可能不够直观。\n\n---\n\n### 3. **使用** **​`Optional`​**​ **处理空值**\n\n使用 `Optional`​ 对传入的列表进行包装，避免空指针异常。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    List<Long> nonNullIds = Optional.ofNullable(ids).orElse(Collections.emptyList());\n    if (nonNullIds.isEmpty()) {\n        return new ArrayList<>();\n    }\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    queryWrapper.in(User::getId, nonNullIds);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**优点：**\n\n* 代码更健壮，避免空指针异常。\n\n**缺点：**\n\n* 需要额外引入 `Optional`​。\n\n---\n\n### 4. **自定义工具方法**\n\n封装一个工具方法，统一处理 `in`​ 方法的空列表问题。\n\n```\npublic class QueryWrapperUtils {\n    public static <T, R> void inIfNotEmpty(LambdaQueryWrapper<T> queryWrapper, SFunction<T, R> column, Collection<R> values) {\n        if (values != null && !values.isEmpty()) {\n            queryWrapper.in(column, values);\n        } else {\n            queryWrapper.apply(\"1 = 0\"); // 永假条件\n        }\n    }\n}\n\n// 使用工具方法\npublic List<User> findUsersByIds(List<Long> ids) {\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    QueryWrapperUtils.inIfNotEmpty(queryWrapper, User::getId, ids);\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**优点：**\n\n* 代码复用，逻辑清晰。\n\n**缺点：**\n\n* 需要额外定义工具类。\n\n---\n\n### 5. **使用 MyBatis-Plus 的** **​`apply`​**​ **方法动态生成 SQL**\n\n通过 `apply`​ 方法动态生成 `IN`​ 子句，避免空列表问题。\n\n```\npublic List<User> findUsersByIds(List<Long> ids) {\n    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();\n    if (ids != null && !ids.isEmpty()) {\n        String inClause = ids.stream()\n                .map(String::valueOf)\n                .collect(Collectors.joining(\",\", \"(\", \")\"));\n        queryWrapper.apply(\"id IN \" + inClause);\n    } else {\n        queryWrapper.apply(\"1 = 0\");\n    }\n    return baseMapper.selectList(queryWrapper);\n}\n```\n\n**生成的 SQL：**\n\n```\nSELECT * FROM user WHERE id IN (1, 2, 3);\n```\n\n**优点：**\n\n* 灵活控制 SQL 生成。\n\n**缺点：**\n\n* 需要手动拼接 SQL，可能引入 SQL 注入风险（需确保输入安全）。\n\n---\n\n### 总结\n\n|方法|优点|缺点|\n| ----------------| --------------------------| ---------------------------------------|\n|直接返回空结果|简单直接|需在业务逻辑中显式处理|\n|添加永假条件|统一处理空列表|生成的 SQL 不够直观|\n|使用 `Optional`​|避免空指针异常，代码健壮|需要额外引入 `Optional`​|\n|自定义工具方法|代码复用，逻辑清晰|需要额外定义工具类|\n|动态生成 SQL|灵活控制 SQL 生成|需手动拼接 SQL，可能引入 SQL 注入风险|\n\n根据具体场景选择合适的方式处理空数组问题。推荐使用 **直接返回空结果** 或 **自定义工具方法**，既简单又安全。\n","slug":"use-in-grammar-in-mybatisplus-1bihse","published":1,"__permalink":"/post/use-in-grammar-in-mybatisplus-1bihse.html","_id":"cmclcaf4e000zp8vw6fgy2i1w","layout":"post","photos":[],"content":"<h1 id=\"在-MyBatis-Plus-中使用-IN-语法\"><a href=\"#在-MyBatis-Plus-中使用-IN-语法\" class=\"headerlink\" title=\"在 MyBatis-Plus 中使用 IN 语法\"></a>在 MyBatis-Plus 中使用 IN 语法</h1><p>在 MyBatis-Plus 中使用 <code>IN</code>​ 语法可以通过以下几种方式实现：</p>\n<h3 id=\"1-使用-QueryWrapper​-的-in​-方法\"><a href=\"#1-使用-QueryWrapper​-的-in​-方法\" class=\"headerlink\" title=\"1. 使用 QueryWrapper​ 的 in​ 方法\"></a>1. 使用 <code>QueryWrapper</code>​ 的 <code>in</code>​ 方法</h3><p>​<code>QueryWrapper</code>​ 是 MyBatis-Plus 提供的查询条件构造器，可以使用 <code>in</code>​ 方法来构建 <code>IN</code>​ 查询。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ServiceImpl</span>&lt;UserMapper, User&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title function_\">findUsersByIds</span><span class=\"params\">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class=\"line\">        QueryWrapper&lt;User&gt; queryWrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;&gt;();</span><br><span class=\"line\">        queryWrapper.in(<span class=\"string\">&quot;id&quot;</span>, ids);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SQL 输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-LambdaQueryWrapper​-的-in​-方法\"><a href=\"#2-使用-LambdaQueryWrapper​-的-in​-方法\" class=\"headerlink\" title=\"2. 使用 LambdaQueryWrapper​ 的 in​ 方法\"></a>2. 使用 <code>LambdaQueryWrapper</code>​ 的 <code>in</code>​ 方法</h3><p>​<code>LambdaQueryWrapper</code>​ 提供了类型安全的查询条件构造，可以使用 <code>in</code>​ 方法来构建 <code>IN</code>​ 查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class=\"line\">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class=\"line\"></span><br><span class=\"line\">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">        lambdaQueryWrapper.in(User::getId, ids);</span><br><span class=\"line\">        return baseMapper.selectList(lambdaQueryWrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SQL 输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用-XML-映射文件\"><a href=\"#3-使用-XML-映射文件\" class=\"headerlink\" title=\"3. 使用 XML 映射文件\"></a>3. 使用 XML 映射文件</h3><p>在 MyBatis 的 XML 映射文件中，可以直接编写 SQL 语句，使用 <code>IN</code>​ 语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt;</span><br><span class=\"line\">    SELECT * FROM user WHERE id IN</span><br><span class=\"line\">    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class=\"line\">        #&#123;id&#125;</span><br><span class=\"line\">    &lt;/foreach&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行 HTML</p>\n<p><strong>Java 代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class=\"line\">    List&lt;User&gt; findUsersByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SQL 输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-使用注解方式\"><a href=\"#4-使用注解方式\" class=\"headerlink\" title=\"4. 使用注解方式\"></a>4. 使用注解方式</h3><p>在 MyBatis 的注解方式中，可以使用 <code>@Select</code>​ 注解编写 SQL 语句，使用 <code>IN</code>​ 语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.ibatis.annotations.Param;</span><br><span class=\"line\">import org.apache.ibatis.annotations.Select;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Select(&quot;SELECT * FROM user WHERE id IN (#&#123;ids&#125;)&quot;)</span><br><span class=\"line\">    List&lt;User&gt; findUsersByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>  这种方式需要手动将 <code>List</code>​ 转换为逗号分隔的字符串。</p>\n<h3 id=\"5-处理空列表的情况\"><a href=\"#5-处理空列表的情况\" class=\"headerlink\" title=\"5. 处理空列表的情况\"></a>5. 处理空列表的情况</h3><p>在使用 <code>IN</code>​ 语法时，如果传入的列表为空，可能会导致 SQL 语法错误。可以通过以下方式处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    if (ids == null || ids.isEmpty()) &#123;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class=\"line\">    queryWrapper.in(&quot;id&quot;, ids);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>​<strong>​<code>QueryWrapper</code>​</strong>​ <strong>和</strong> <strong>​<code>LambdaQueryWrapper</code>​</strong>​ 是 MyBatis-Plus 提供的便捷查询条件构造器，适合在 Java 代码中动态构建查询条件。</li>\n<li><strong>XML 映射文件</strong> 和 <strong>注解方式</strong> 适合在需要编写复杂 SQL 或需要复用 SQL 的场景下使用。</li>\n<li><strong>处理空列表</strong> 是使用 <code>IN</code>​ 语法时需要注意的一个细节，避免 SQL 语法错误。</li>\n</ul>\n<p>根据具体需求选择合适的方式来实现 <code>IN</code>​ 查询。</p>\n<p>‍</p>\n<p>除此之外，在使用 <code>LambdaQueryWrapper</code>​ 的 <code>in</code>​ 方法时，如果传入的数组或列表为空，可能会导致生成的 SQL 语句不合法（例如 <code>IN ()</code>​），从而引发 SQL 语法错误。为了避免这种情况，可以在调用 <code>in</code>​ 方法之前对数组或列表进行判空处理。</p>\n<p>以下是处理空数组的几种常见方式：</p>\n<hr>\n<h3 id=\"1-直接返回空结果\"><a href=\"#1-直接返回空结果\" class=\"headerlink\" title=\"1. 直接返回空结果\"></a>1. <strong>直接返回空结果</strong></h3><p>如果传入的数组为空，直接返回一个空列表，避免执行 SQL 查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    if (ids == null || ids.isEmpty()) &#123;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    queryWrapper.in(User::getId, ids);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>简单直接，避免执行无意义的查询。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要在业务逻辑中显式处理空列表。</li>\n</ul>\n<hr>\n<h3 id=\"2-添加空值检查条件\"><a href=\"#2-添加空值检查条件\" class=\"headerlink\" title=\"2. 添加空值检查条件\"></a>2. <strong>添加空值检查条件</strong></h3><p>如果希望即使传入空列表也能执行查询，可以通过添加一个永假条件（例如 <code>1 = 0</code>​）来避免生成 <code>IN ()</code>​。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    if (ids == null || ids.isEmpty()) &#123;</span><br><span class=\"line\">        queryWrapper.apply(&quot;1 = 0&quot;); // 永假条件，避免生成 IN ()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        queryWrapper.in(User::getId, ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>生成的 SQL：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE 1 = 0;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>统一处理空列表，避免在业务逻辑中显式返回空列表。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>生成的 SQL 可能不够直观。</li>\n</ul>\n<hr>\n<h3 id=\"3-使用-​Optional​​-处理空值\"><a href=\"#3-使用-​Optional​​-处理空值\" class=\"headerlink\" title=\"3. 使用 ​Optional​​ 处理空值\"></a>3. <strong>使用</strong> <strong>​<code>Optional</code>​</strong>​ <strong>处理空值</strong></h3><p>使用 <code>Optional</code>​ 对传入的列表进行包装，避免空指针异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    List&lt;Long&gt; nonNullIds = Optional.ofNullable(ids).orElse(Collections.emptyList());</span><br><span class=\"line\">    if (nonNullIds.isEmpty()) &#123;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    queryWrapper.in(User::getId, nonNullIds);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>代码更健壮，避免空指针异常。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要额外引入 <code>Optional</code>​。</li>\n</ul>\n<hr>\n<h3 id=\"4-自定义工具方法\"><a href=\"#4-自定义工具方法\" class=\"headerlink\" title=\"4. 自定义工具方法\"></a>4. <strong>自定义工具方法</strong></h3><p>封装一个工具方法，统一处理 <code>in</code>​ 方法的空列表问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class QueryWrapperUtils &#123;</span><br><span class=\"line\">    public static &lt;T, R&gt; void inIfNotEmpty(LambdaQueryWrapper&lt;T&gt; queryWrapper, SFunction&lt;T, R&gt; column, Collection&lt;R&gt; values) &#123;</span><br><span class=\"line\">        if (values != null &amp;&amp; !values.isEmpty()) &#123;</span><br><span class=\"line\">            queryWrapper.in(column, values);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            queryWrapper.apply(&quot;1 = 0&quot;); // 永假条件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用工具方法</span><br><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    QueryWrapperUtils.inIfNotEmpty(queryWrapper, User::getId, ids);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>代码复用，逻辑清晰。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要额外定义工具类。</li>\n</ul>\n<hr>\n<h3 id=\"5-使用-MyBatis-Plus-的-​apply​​-方法动态生成-SQL\"><a href=\"#5-使用-MyBatis-Plus-的-​apply​​-方法动态生成-SQL\" class=\"headerlink\" title=\"5. 使用 MyBatis-Plus 的 ​apply​​ 方法动态生成 SQL\"></a>5. <strong>使用 MyBatis-Plus 的</strong> <strong>​<code>apply</code>​</strong>​ <strong>方法动态生成 SQL</strong></h3><p>通过 <code>apply</code>​ 方法动态生成 <code>IN</code>​ 子句，避免空列表问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    if (ids != null &amp;&amp; !ids.isEmpty()) &#123;</span><br><span class=\"line\">        String inClause = ids.stream()</span><br><span class=\"line\">                .map(String::valueOf)</span><br><span class=\"line\">                .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;));</span><br><span class=\"line\">        queryWrapper.apply(&quot;id IN &quot; + inClause);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        queryWrapper.apply(&quot;1 = 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>生成的 SQL：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>灵活控制 SQL 生成。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要手动拼接 SQL，可能引入 SQL 注入风险（需确保输入安全）。</li>\n</ul>\n<hr>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>直接返回空结果</td>\n<td>简单直接</td>\n<td>需在业务逻辑中显式处理</td>\n</tr>\n<tr>\n<td>添加永假条件</td>\n<td>统一处理空列表</td>\n<td>生成的 SQL 不够直观</td>\n</tr>\n<tr>\n<td>使用 <code>Optional</code>​</td>\n<td>避免空指针异常，代码健壮</td>\n<td>需要额外引入 <code>Optional</code>​</td>\n</tr>\n<tr>\n<td>自定义工具方法</td>\n<td>代码复用，逻辑清晰</td>\n<td>需要额外定义工具类</td>\n</tr>\n<tr>\n<td>动态生成 SQL</td>\n<td>灵活控制 SQL 生成</td>\n<td>需手动拼接 SQL，可能引入 SQL 注入风险</td>\n</tr>\n</tbody></table>\n<p>根据具体场景选择合适的方式处理空数组问题。推荐使用 <strong>直接返回空结果</strong> 或 <strong>自定义工具方法</strong>，既简单又安全。</p>\n","more":"<h1 id=\"在-MyBatis-Plus-中使用-IN-语法\"><a href=\"#在-MyBatis-Plus-中使用-IN-语法\" class=\"headerlink\" title=\"在 MyBatis-Plus 中使用 IN 语法\"></a>在 MyBatis-Plus 中使用 IN 语法</h1><p>在 MyBatis-Plus 中使用 <code>IN</code>​ 语法可以通过以下几种方式实现：</p>\n<h3 id=\"1-使用-QueryWrapper​-的-in​-方法\"><a href=\"#1-使用-QueryWrapper​-的-in​-方法\" class=\"headerlink\" title=\"1. 使用 QueryWrapper​ 的 in​ 方法\"></a>1. 使用 <code>QueryWrapper</code>​ 的 <code>in</code>​ 方法</h3><p>​<code>QueryWrapper</code>​ 是 MyBatis-Plus 提供的查询条件构造器，可以使用 <code>in</code>​ 方法来构建 <code>IN</code>​ 查询。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ServiceImpl</span>&lt;UserMapper, User&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"title function_\">findUsersByIds</span><span class=\"params\">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class=\"line\">        QueryWrapper&lt;User&gt; queryWrapper = <span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;&gt;();</span><br><span class=\"line\">        queryWrapper.in(<span class=\"string\">&quot;id&quot;</span>, ids);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SQL 输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-LambdaQueryWrapper​-的-in​-方法\"><a href=\"#2-使用-LambdaQueryWrapper​-的-in​-方法\" class=\"headerlink\" title=\"2. 使用 LambdaQueryWrapper​ 的 in​ 方法\"></a>2. 使用 <code>LambdaQueryWrapper</code>​ 的 <code>in</code>​ 方法</h3><p>​<code>LambdaQueryWrapper</code>​ 提供了类型安全的查询条件构造，可以使用 <code>in</code>​ 方法来构建 <code>IN</code>​ 查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class=\"line\">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class=\"line\"></span><br><span class=\"line\">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">        lambdaQueryWrapper.in(User::getId, ids);</span><br><span class=\"line\">        return baseMapper.selectList(lambdaQueryWrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SQL 输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用-XML-映射文件\"><a href=\"#3-使用-XML-映射文件\" class=\"headerlink\" title=\"3. 使用 XML 映射文件\"></a>3. 使用 XML 映射文件</h3><p>在 MyBatis 的 XML 映射文件中，可以直接编写 SQL 语句，使用 <code>IN</code>​ 语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select id=&quot;findUsersByIds&quot; resultType=&quot;User&quot;&gt;</span><br><span class=\"line\">    SELECT * FROM user WHERE id IN</span><br><span class=\"line\">    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class=\"line\">        #&#123;id&#125;</span><br><span class=\"line\">    &lt;/foreach&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br></pre></td></tr></table></figure>\n\n<p>运行 HTML</p>\n<p><strong>Java 代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class=\"line\">    List&lt;User&gt; findUsersByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SQL 输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-使用注解方式\"><a href=\"#4-使用注解方式\" class=\"headerlink\" title=\"4. 使用注解方式\"></a>4. 使用注解方式</h3><p>在 MyBatis 的注解方式中，可以使用 <code>@Select</code>​ 注解编写 SQL 语句，使用 <code>IN</code>​ 语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.ibatis.annotations.Param;</span><br><span class=\"line\">import org.apache.ibatis.annotations.Select;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Select(&quot;SELECT * FROM user WHERE id IN (#&#123;ids&#125;)&quot;)</span><br><span class=\"line\">    List&lt;User&gt; findUsersByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong>  这种方式需要手动将 <code>List</code>​ 转换为逗号分隔的字符串。</p>\n<h3 id=\"5-处理空列表的情况\"><a href=\"#5-处理空列表的情况\" class=\"headerlink\" title=\"5. 处理空列表的情况\"></a>5. 处理空列表的情况</h3><p>在使用 <code>IN</code>​ 语法时，如果传入的列表为空，可能会导致 SQL 语法错误。可以通过以下方式处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    if (ids == null || ids.isEmpty()) &#123;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class=\"line\">    queryWrapper.in(&quot;id&quot;, ids);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>​<strong>​<code>QueryWrapper</code>​</strong>​ <strong>和</strong> <strong>​<code>LambdaQueryWrapper</code>​</strong>​ 是 MyBatis-Plus 提供的便捷查询条件构造器，适合在 Java 代码中动态构建查询条件。</li>\n<li><strong>XML 映射文件</strong> 和 <strong>注解方式</strong> 适合在需要编写复杂 SQL 或需要复用 SQL 的场景下使用。</li>\n<li><strong>处理空列表</strong> 是使用 <code>IN</code>​ 语法时需要注意的一个细节，避免 SQL 语法错误。</li>\n</ul>\n<p>根据具体需求选择合适的方式来实现 <code>IN</code>​ 查询。</p>\n<p>‍</p>\n<p>除此之外，在使用 <code>LambdaQueryWrapper</code>​ 的 <code>in</code>​ 方法时，如果传入的数组或列表为空，可能会导致生成的 SQL 语句不合法（例如 <code>IN ()</code>​），从而引发 SQL 语法错误。为了避免这种情况，可以在调用 <code>in</code>​ 方法之前对数组或列表进行判空处理。</p>\n<p>以下是处理空数组的几种常见方式：</p>\n<hr>\n<h3 id=\"1-直接返回空结果\"><a href=\"#1-直接返回空结果\" class=\"headerlink\" title=\"1. 直接返回空结果\"></a>1. <strong>直接返回空结果</strong></h3><p>如果传入的数组为空，直接返回一个空列表，避免执行 SQL 查询。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    if (ids == null || ids.isEmpty()) &#123;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    queryWrapper.in(User::getId, ids);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>简单直接，避免执行无意义的查询。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要在业务逻辑中显式处理空列表。</li>\n</ul>\n<hr>\n<h3 id=\"2-添加空值检查条件\"><a href=\"#2-添加空值检查条件\" class=\"headerlink\" title=\"2. 添加空值检查条件\"></a>2. <strong>添加空值检查条件</strong></h3><p>如果希望即使传入空列表也能执行查询，可以通过添加一个永假条件（例如 <code>1 = 0</code>​）来避免生成 <code>IN ()</code>​。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    if (ids == null || ids.isEmpty()) &#123;</span><br><span class=\"line\">        queryWrapper.apply(&quot;1 = 0&quot;); // 永假条件，避免生成 IN ()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        queryWrapper.in(User::getId, ids);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>生成的 SQL：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE 1 = 0;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>统一处理空列表，避免在业务逻辑中显式返回空列表。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>生成的 SQL 可能不够直观。</li>\n</ul>\n<hr>\n<h3 id=\"3-使用-​Optional​​-处理空值\"><a href=\"#3-使用-​Optional​​-处理空值\" class=\"headerlink\" title=\"3. 使用 ​Optional​​ 处理空值\"></a>3. <strong>使用</strong> <strong>​<code>Optional</code>​</strong>​ <strong>处理空值</strong></h3><p>使用 <code>Optional</code>​ 对传入的列表进行包装，避免空指针异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    List&lt;Long&gt; nonNullIds = Optional.ofNullable(ids).orElse(Collections.emptyList());</span><br><span class=\"line\">    if (nonNullIds.isEmpty()) &#123;</span><br><span class=\"line\">        return new ArrayList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    queryWrapper.in(User::getId, nonNullIds);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>代码更健壮，避免空指针异常。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要额外引入 <code>Optional</code>​。</li>\n</ul>\n<hr>\n<h3 id=\"4-自定义工具方法\"><a href=\"#4-自定义工具方法\" class=\"headerlink\" title=\"4. 自定义工具方法\"></a>4. <strong>自定义工具方法</strong></h3><p>封装一个工具方法，统一处理 <code>in</code>​ 方法的空列表问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class QueryWrapperUtils &#123;</span><br><span class=\"line\">    public static &lt;T, R&gt; void inIfNotEmpty(LambdaQueryWrapper&lt;T&gt; queryWrapper, SFunction&lt;T, R&gt; column, Collection&lt;R&gt; values) &#123;</span><br><span class=\"line\">        if (values != null &amp;&amp; !values.isEmpty()) &#123;</span><br><span class=\"line\">            queryWrapper.in(column, values);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            queryWrapper.apply(&quot;1 = 0&quot;); // 永假条件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用工具方法</span><br><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    QueryWrapperUtils.inIfNotEmpty(queryWrapper, User::getId, ids);</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>代码复用，逻辑清晰。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要额外定义工具类。</li>\n</ul>\n<hr>\n<h3 id=\"5-使用-MyBatis-Plus-的-​apply​​-方法动态生成-SQL\"><a href=\"#5-使用-MyBatis-Plus-的-​apply​​-方法动态生成-SQL\" class=\"headerlink\" title=\"5. 使用 MyBatis-Plus 的 ​apply​​ 方法动态生成 SQL\"></a>5. <strong>使用 MyBatis-Plus 的</strong> <strong>​<code>apply</code>​</strong>​ <strong>方法动态生成 SQL</strong></h3><p>通过 <code>apply</code>​ 方法动态生成 <code>IN</code>​ 子句，避免空列表问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;User&gt; findUsersByIds(List&lt;Long&gt; ids) &#123;</span><br><span class=\"line\">    LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class=\"line\">    if (ids != null &amp;&amp; !ids.isEmpty()) &#123;</span><br><span class=\"line\">        String inClause = ids.stream()</span><br><span class=\"line\">                .map(String::valueOf)</span><br><span class=\"line\">                .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;));</span><br><span class=\"line\">        queryWrapper.apply(&quot;id IN &quot; + inClause);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        queryWrapper.apply(&quot;1 = 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return baseMapper.selectList(queryWrapper);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>生成的 SQL：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM user WHERE id IN (1, 2, 3);</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>灵活控制 SQL 生成。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>需要手动拼接 SQL，可能引入 SQL 注入风险（需确保输入安全）。</li>\n</ul>\n<hr>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>直接返回空结果</td>\n<td>简单直接</td>\n<td>需在业务逻辑中显式处理</td>\n</tr>\n<tr>\n<td>添加永假条件</td>\n<td>统一处理空列表</td>\n<td>生成的 SQL 不够直观</td>\n</tr>\n<tr>\n<td>使用 <code>Optional</code>​</td>\n<td>避免空指针异常，代码健壮</td>\n<td>需要额外引入 <code>Optional</code>​</td>\n</tr>\n<tr>\n<td>自定义工具方法</td>\n<td>代码复用，逻辑清晰</td>\n<td>需要额外定义工具类</td>\n</tr>\n<tr>\n<td>动态生成 SQL</td>\n<td>灵活控制 SQL 生成</td>\n<td>需手动拼接 SQL，可能引入 SQL 注入风险</td>\n</tr>\n</tbody></table>\n<p>根据具体场景选择合适的方式处理空数组问题。推荐使用 <strong>直接返回空结果</strong> 或 <strong>自定义工具方法</strong>，既简单又安全。</p>\n"},{"title":"Java中使用redis作为消息队列","date":"2024-12-26T08:40:23.000Z","updated":"2024-12-26T08:48:21.000Z","excerpt":"本文介绍了在Java中使用Redis作为消息队列的两种主要方法：使用Redis的`List`数据结构和`Pub/Sub`模式。通过`List`，生产者可以使用`lpush`将消息推入队列头部，消费者可以使用`rpop`或`blpop`从队列尾部弹出消息，后者支持阻塞式消费。`Pub/Sub`模式适用于一对多的消息分发，发布者通过`publish`发送消息，订阅者通过`subscribe`接收消息。此外，文章还提到了使用Redisson库来简化操作，Redisson提供了更高层次的抽象，如消息队列和分布式锁。通过这些方法，开发者可以灵活地在Java应用中实现基于Redis的消息队列功能。","comments":1,"toc":true,"abbrlink":3202,"_content":"\n# Java中使用redis作为消息队列\n\n## 使用redis作为消息队列\n\n在Java中使用Redis作为消息队列，可以通过Redis的`List`​数据结构或者`Pub/Sub`​模式来实现。以下是一个简单的示例，展示了如何使用Redis的`List`​作为消息队列。\n\n### 1. 使用Redis的List作为消息队列\n\nRedis的`List`​数据结构非常适合用来实现消息队列，因为它支持在列表的两端进行操作。\n\n#### 1.1 生产者（发送消息）\n\n生产者将消息推入列表的头部：\n\n```java\nimport redis.clients.jedis.Jedis;\n\npublic class RedisProducer {\n    private Jedis jedis;\n\n    public RedisProducer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void produce(String queueName, String message) {\n        jedis.lpush(queueName, message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 1.2 消费者（接收消息）\n\n消费者从列表的尾部弹出消息：\n\n```\nimport redis.clients.jedis.Jedis;\n\npublic class RedisConsumer {\n    private Jedis jedis;\n\n    public RedisConsumer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public String consume(String queueName) {\n        return jedis.rpop(queueName);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 1.3 阻塞式消费（BLPOP）\n\n为了提高效率，可以使用`BLPOP`​方法，它会在没有消息时阻塞，直到有新消息到达：\n\n```\nimport redis.clients.jedis.Jedis;\n\npublic class RedisBlockingConsumer {\n    private Jedis jedis;\n\n    public RedisBlockingConsumer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public String blockingConsume(String queueName, int timeout) {\n        String message = jedis.blpop(timeout, queueName).get(1);\n        return message;\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n### 2. 使用Redis的Pub/Sub模式\n\nRedis的发布订阅模式适用于一对多的消息分发。\n\n#### 2.1 发布者（发布消息）\n\n```\nimport redis.clients.jedis.Jedis;\n\npublic class RedisPublisher {\n    private Jedis jedis;\n\n    public RedisPublisher(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void publish(String channel, String message) {\n        jedis.publish(channel, message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 2.2 订阅者（接收消息）\n\n```\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\n\npublic class RedisSubscriber {\n    private Jedis jedis;\n\n    public RedisSubscriber(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void subscribe(String channel, JedisPubSub jedisPubSub) {\n        jedis.subscribe(jedisPubSub, channel);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n### 3. 使用Redisson库\n\nRedisson是一个功能丰富的Redis Java客户端，提供了更高层次的抽象，包括消息队列、分布式锁等。\n\n#### 3.1 添加依赖\n\n```xml\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.17.5</version>\n</dependency>\n```\n\n运行 HTML\n\n#### 3.2 生产者和消费者\n\n```\nimport org.redisson.Redisson;\nimport org.redisson.api.RQueue;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\n\npublic class RedissonQueueExample {\n    public static void main(String[] args) {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        RedissonClient redisson = Redisson.create(config);\n\n        RQueue<String> queue = redisson.getQueue(\"myQueue\");\n\n        // 生产者\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                queue.offer(\"Message \" + i);\n                System.out.println(\"Produced: Message \" + i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        // 消费者\n        new Thread(() -> {\n            while (true) {\n                String message = queue.poll();\n                if (message != null) {\n                    System.out.println(\"Consumed: \" + message);\n                } else {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n\n        redisson.shutdown();\n    }\n}\n```\n\n### 4. 总结\n\n* **List**：适用于简单的队列场景，支持阻塞式操作。\n* **Pub/Sub**：适用于发布订阅场景，适合一对多的消息分发。\n* **Redisson**：提供了更高级的抽象，适合复杂的分布式应用场景。\n\n选择哪种方式取决于你的具体需求。如果需要可靠的消息传递和队列功能，建议使用`List`​或Redisson的队列实现。\n\n但是还是存在缺点，redis不存在消息确认机制，所以还得再优化一下。\n\n‍\n\n‍\n\n## Redis 作为消息队列+消息确认机制\n\n为了在使用 Redis 作为消息队列的基础上加上消息确认机制，我们可以采用以下方案：\n\n### 方案概述\n\n1. **生产者**：将消息放入 `queue:待处理`​ 列表。\n2. **消费者**：使用 Lua 脚本原子地将消息从 `queue:待处理`​ 移动到 `queue:正在处理`​，并记录处理开始时间。\n3. **消息处理**：消费者处理消息，处理完成后从 `queue:正在处理`​ 删除消息，并删除处理记录。\n4. **故障处理**：如果处理失败，可以选择不删除消息，或者将其重新放入 `queue:待处理`​。\n5. **定时检查**：使用定时任务检查 `queue:正在处理`​ 中的消息，如果超过阈值时间未处理完成，则重新放入 `queue:待处理`​。\n\n### 实现步骤\n\n#### 1. 生产者代码\n\n```java\nimport redis.clients.jedis.Jedis;\n\npublic class RedisProducer {\n    private Jedis jedis;\n\n    public RedisProducer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void produce(String queueName, String message) {\n        jedis.lpush(queueName, message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 2. 消费者代码\n\n```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Scripting;\n\npublic class RedisConsumer {\n    private Jedis jedis;\n    private String moveScript = \"local message = redis.call('RPOP', KEYS[1]); if message then redis.call('LPUSH', KEYS[2], message); end; return message;\";\n\n    public RedisConsumer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public String consume(String待处理Queue, String正在处理Queue) {\n        String message = (String) jedis.eval(moveScript, 2,待处理Queue,正在处理Queue);\n        if (message != null) {\n            jedis.hset(\"hash:正在处理\", message, String.valueOf(System.currentTimeMillis()));\n        }\n        return message;\n    }\n\n    public void confirm(String正在处理Queue, String message) {\n        jedis.lrem(正在处理Queue, 0, message);\n        jedis.hdel(\"hash:正在处理\", message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 3. 定时检查任务\n\n```java\nimport redis.clients.jedis.Jedis;\nimport java.util.Set;\nimport java.util.Date;\n\npublic class MessageMonitor {\n    private Jedis jedis;\n    private long threshold = 60000; // 1分钟\n\n    public MessageMonitor(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void checkMessages() {\n        Set<String> messages = jedis.hkeys(\"hash:正在处理\");\n        for (String message : messages) {\n            long startTime = Long.parseLong(jedis.hget(\"hash:正在处理\", message));\n            if (new Date().getTime() - startTime > threshold) {\n                jedis.lpush(\"queue:待处理\", message);\n                jedis.hdel(\"hash:正在处理\", message);\n            }\n        }\n    }\n\n    public void scheduleCheck() {\n        new ScheduledThreadPoolExecutor(1).scheduleAtFixedRate(() -> checkMessages(), 0, 30, TimeUnit.SECONDS);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n### 代码说明\n\n* **生产者**：将消息放入 `queue:待处理`​ 列表。\n* **消费者**：\n\n  * 使用 Lua 脚本原子地将消息从 `queue:待处理`​ 移动到 `queue:正在处理`​。\n  * 记录消息处理开始时间到 `hash:正在处理`​。\n  * 处理消息后，调用 `confirm`​ 方法删除消息和处理记录。\n* **定时检查任务**：\n\n  * 每 30 秒检查一次 `hash:正在处理`​ 中的消息。\n  * 如果消息处理时间超过阈值（例如 1 分钟），将其重新放入 `queue:待处理`​。\n\n### 优点\n\n* **原子操作**：使用 Lua 脚本确保消息移动的原子性。\n* **故障 tolerance**：通过定时检查任务，确保消息不会永久卡在 `queue:正在处理`​ 中。\n* **消息不丢失**：处理失败的消息会重新进入待处理队列。\n\n### 缺点\n\n* **复杂性**：需要额外的逻辑来处理消息确认和故障恢复。\n* **性能开销**：定时任务和哈希表操作可能增加系统负载。\n\n### 结论\n\n通过上述方案，我们实现了基于 Redis 的消息队列的消息确认机制，确保消息的可靠传递和处理。虽然实现较为复杂，但在 Redis 作为消息队列的场景下，这是一个可行的解决方案。\n\n‍\n\n‍\n","source":"_posts/use-redis-as-a-message-queue-in-java-zniajv.md","raw":"---\ntitle: Java中使用redis作为消息队列\ndate: '2024-12-26 16:40:23'\nupdated: '2024-12-26 16:48:21'\nexcerpt: >-\n  本文介绍了在Java中使用Redis作为消息队列的两种主要方法：使用Redis的`List`数据结构和`Pub/Sub`模式。通过`List`，生产者可以使用`lpush`将消息推入队列头部，消费者可以使用`rpop`或`blpop`从队列尾部弹出消息，后者支持阻塞式消费。`Pub/Sub`模式适用于一对多的消息分发，发布者通过`publish`发送消息，订阅者通过`subscribe`接收消息。此外，文章还提到了使用Redisson库来简化操作，Redisson提供了更高层次的抽象，如消息队列和分布式锁。通过这些方法，开发者可以灵活地在Java应用中实现基于Redis的消息队列功能。\ntags:\n  - redis\n  - 消息队列\n  - java\n  - 阻塞消费\n  - 发布订阅\ncategories:\n  - Java\n  - Redis\n  - 消息队列\npermalink: /post/use-redis-as-a-message-queue-in-java-zniajv.html\ncomments: true\ntoc: true\nabbrlink: 3202\n---\n\n# Java中使用redis作为消息队列\n\n## 使用redis作为消息队列\n\n在Java中使用Redis作为消息队列，可以通过Redis的`List`​数据结构或者`Pub/Sub`​模式来实现。以下是一个简单的示例，展示了如何使用Redis的`List`​作为消息队列。\n\n### 1. 使用Redis的List作为消息队列\n\nRedis的`List`​数据结构非常适合用来实现消息队列，因为它支持在列表的两端进行操作。\n\n#### 1.1 生产者（发送消息）\n\n生产者将消息推入列表的头部：\n\n```java\nimport redis.clients.jedis.Jedis;\n\npublic class RedisProducer {\n    private Jedis jedis;\n\n    public RedisProducer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void produce(String queueName, String message) {\n        jedis.lpush(queueName, message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 1.2 消费者（接收消息）\n\n消费者从列表的尾部弹出消息：\n\n```\nimport redis.clients.jedis.Jedis;\n\npublic class RedisConsumer {\n    private Jedis jedis;\n\n    public RedisConsumer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public String consume(String queueName) {\n        return jedis.rpop(queueName);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 1.3 阻塞式消费（BLPOP）\n\n为了提高效率，可以使用`BLPOP`​方法，它会在没有消息时阻塞，直到有新消息到达：\n\n```\nimport redis.clients.jedis.Jedis;\n\npublic class RedisBlockingConsumer {\n    private Jedis jedis;\n\n    public RedisBlockingConsumer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public String blockingConsume(String queueName, int timeout) {\n        String message = jedis.blpop(timeout, queueName).get(1);\n        return message;\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n### 2. 使用Redis的Pub/Sub模式\n\nRedis的发布订阅模式适用于一对多的消息分发。\n\n#### 2.1 发布者（发布消息）\n\n```\nimport redis.clients.jedis.Jedis;\n\npublic class RedisPublisher {\n    private Jedis jedis;\n\n    public RedisPublisher(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void publish(String channel, String message) {\n        jedis.publish(channel, message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 2.2 订阅者（接收消息）\n\n```\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\n\npublic class RedisSubscriber {\n    private Jedis jedis;\n\n    public RedisSubscriber(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void subscribe(String channel, JedisPubSub jedisPubSub) {\n        jedis.subscribe(jedisPubSub, channel);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n### 3. 使用Redisson库\n\nRedisson是一个功能丰富的Redis Java客户端，提供了更高层次的抽象，包括消息队列、分布式锁等。\n\n#### 3.1 添加依赖\n\n```xml\n<dependency>\n    <groupId>org.redisson</groupId>\n    <artifactId>redisson</artifactId>\n    <version>3.17.5</version>\n</dependency>\n```\n\n运行 HTML\n\n#### 3.2 生产者和消费者\n\n```\nimport org.redisson.Redisson;\nimport org.redisson.api.RQueue;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\n\npublic class RedissonQueueExample {\n    public static void main(String[] args) {\n        Config config = new Config();\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        RedissonClient redisson = Redisson.create(config);\n\n        RQueue<String> queue = redisson.getQueue(\"myQueue\");\n\n        // 生产者\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                queue.offer(\"Message \" + i);\n                System.out.println(\"Produced: Message \" + i);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n\n        // 消费者\n        new Thread(() -> {\n            while (true) {\n                String message = queue.poll();\n                if (message != null) {\n                    System.out.println(\"Consumed: \" + message);\n                } else {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n\n        redisson.shutdown();\n    }\n}\n```\n\n### 4. 总结\n\n* **List**：适用于简单的队列场景，支持阻塞式操作。\n* **Pub/Sub**：适用于发布订阅场景，适合一对多的消息分发。\n* **Redisson**：提供了更高级的抽象，适合复杂的分布式应用场景。\n\n选择哪种方式取决于你的具体需求。如果需要可靠的消息传递和队列功能，建议使用`List`​或Redisson的队列实现。\n\n但是还是存在缺点，redis不存在消息确认机制，所以还得再优化一下。\n\n‍\n\n‍\n\n## Redis 作为消息队列+消息确认机制\n\n为了在使用 Redis 作为消息队列的基础上加上消息确认机制，我们可以采用以下方案：\n\n### 方案概述\n\n1. **生产者**：将消息放入 `queue:待处理`​ 列表。\n2. **消费者**：使用 Lua 脚本原子地将消息从 `queue:待处理`​ 移动到 `queue:正在处理`​，并记录处理开始时间。\n3. **消息处理**：消费者处理消息，处理完成后从 `queue:正在处理`​ 删除消息，并删除处理记录。\n4. **故障处理**：如果处理失败，可以选择不删除消息，或者将其重新放入 `queue:待处理`​。\n5. **定时检查**：使用定时任务检查 `queue:正在处理`​ 中的消息，如果超过阈值时间未处理完成，则重新放入 `queue:待处理`​。\n\n### 实现步骤\n\n#### 1. 生产者代码\n\n```java\nimport redis.clients.jedis.Jedis;\n\npublic class RedisProducer {\n    private Jedis jedis;\n\n    public RedisProducer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void produce(String queueName, String message) {\n        jedis.lpush(queueName, message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 2. 消费者代码\n\n```java\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Scripting;\n\npublic class RedisConsumer {\n    private Jedis jedis;\n    private String moveScript = \"local message = redis.call('RPOP', KEYS[1]); if message then redis.call('LPUSH', KEYS[2], message); end; return message;\";\n\n    public RedisConsumer(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public String consume(String待处理Queue, String正在处理Queue) {\n        String message = (String) jedis.eval(moveScript, 2,待处理Queue,正在处理Queue);\n        if (message != null) {\n            jedis.hset(\"hash:正在处理\", message, String.valueOf(System.currentTimeMillis()));\n        }\n        return message;\n    }\n\n    public void confirm(String正在处理Queue, String message) {\n        jedis.lrem(正在处理Queue, 0, message);\n        jedis.hdel(\"hash:正在处理\", message);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n#### 3. 定时检查任务\n\n```java\nimport redis.clients.jedis.Jedis;\nimport java.util.Set;\nimport java.util.Date;\n\npublic class MessageMonitor {\n    private Jedis jedis;\n    private long threshold = 60000; // 1分钟\n\n    public MessageMonitor(String host, int port) {\n        this.jedis = new Jedis(host, port);\n    }\n\n    public void checkMessages() {\n        Set<String> messages = jedis.hkeys(\"hash:正在处理\");\n        for (String message : messages) {\n            long startTime = Long.parseLong(jedis.hget(\"hash:正在处理\", message));\n            if (new Date().getTime() - startTime > threshold) {\n                jedis.lpush(\"queue:待处理\", message);\n                jedis.hdel(\"hash:正在处理\", message);\n            }\n        }\n    }\n\n    public void scheduleCheck() {\n        new ScheduledThreadPoolExecutor(1).scheduleAtFixedRate(() -> checkMessages(), 0, 30, TimeUnit.SECONDS);\n    }\n\n    public void close() {\n        jedis.close();\n    }\n}\n```\n\n### 代码说明\n\n* **生产者**：将消息放入 `queue:待处理`​ 列表。\n* **消费者**：\n\n  * 使用 Lua 脚本原子地将消息从 `queue:待处理`​ 移动到 `queue:正在处理`​。\n  * 记录消息处理开始时间到 `hash:正在处理`​。\n  * 处理消息后，调用 `confirm`​ 方法删除消息和处理记录。\n* **定时检查任务**：\n\n  * 每 30 秒检查一次 `hash:正在处理`​ 中的消息。\n  * 如果消息处理时间超过阈值（例如 1 分钟），将其重新放入 `queue:待处理`​。\n\n### 优点\n\n* **原子操作**：使用 Lua 脚本确保消息移动的原子性。\n* **故障 tolerance**：通过定时检查任务，确保消息不会永久卡在 `queue:正在处理`​ 中。\n* **消息不丢失**：处理失败的消息会重新进入待处理队列。\n\n### 缺点\n\n* **复杂性**：需要额外的逻辑来处理消息确认和故障恢复。\n* **性能开销**：定时任务和哈希表操作可能增加系统负载。\n\n### 结论\n\n通过上述方案，我们实现了基于 Redis 的消息队列的消息确认机制，确保消息的可靠传递和处理。虽然实现较为复杂，但在 Redis 作为消息队列的场景下，这是一个可行的解决方案。\n\n‍\n\n‍\n","slug":"use-redis-as-a-message-queue-in-java-zniajv","published":1,"__permalink":"/post/use-redis-as-a-message-queue-in-java-zniajv.html","_id":"cmclcaf4g0013p8vwdgse7yq2","layout":"post","photos":[],"content":"<h1 id=\"Java中使用redis作为消息队列\"><a href=\"#Java中使用redis作为消息队列\" class=\"headerlink\" title=\"Java中使用redis作为消息队列\"></a>Java中使用redis作为消息队列</h1><h2 id=\"使用redis作为消息队列\"><a href=\"#使用redis作为消息队列\" class=\"headerlink\" title=\"使用redis作为消息队列\"></a>使用redis作为消息队列</h2><p>在Java中使用Redis作为消息队列，可以通过Redis的<code>List</code>​数据结构或者<code>Pub/Sub</code>​模式来实现。以下是一个简单的示例，展示了如何使用Redis的<code>List</code>​作为消息队列。</p>\n<h3 id=\"1-使用Redis的List作为消息队列\"><a href=\"#1-使用Redis的List作为消息队列\" class=\"headerlink\" title=\"1. 使用Redis的List作为消息队列\"></a>1. 使用Redis的List作为消息队列</h3><p>Redis的<code>List</code>​数据结构非常适合用来实现消息队列，因为它支持在列表的两端进行操作。</p>\n<h4 id=\"1-1-生产者（发送消息）\"><a href=\"#1-1-生产者（发送消息）\" class=\"headerlink\" title=\"1.1 生产者（发送消息）\"></a>1.1 生产者（发送消息）</h4><p>生产者将消息推入列表的头部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisProducer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisProducer</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">produce</span><span class=\"params\">(String queueName, String message)</span> &#123;</span><br><span class=\"line\">        jedis.lpush(queueName, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-消费者（接收消息）\"><a href=\"#1-2-消费者（接收消息）\" class=\"headerlink\" title=\"1.2 消费者（接收消息）\"></a>1.2 消费者（接收消息）</h4><p>消费者从列表的尾部弹出消息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisConsumer &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisConsumer(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String consume(String queueName) &#123;</span><br><span class=\"line\">        return jedis.rpop(queueName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-阻塞式消费（BLPOP）\"><a href=\"#1-3-阻塞式消费（BLPOP）\" class=\"headerlink\" title=\"1.3 阻塞式消费（BLPOP）\"></a>1.3 阻塞式消费（BLPOP）</h4><p>为了提高效率，可以使用<code>BLPOP</code>​方法，它会在没有消息时阻塞，直到有新消息到达：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisBlockingConsumer &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisBlockingConsumer(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String blockingConsume(String queueName, int timeout) &#123;</span><br><span class=\"line\">        String message = jedis.blpop(timeout, queueName).get(1);</span><br><span class=\"line\">        return message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用Redis的Pub-Sub模式\"><a href=\"#2-使用Redis的Pub-Sub模式\" class=\"headerlink\" title=\"2. 使用Redis的Pub&#x2F;Sub模式\"></a>2. 使用Redis的Pub&#x2F;Sub模式</h3><p>Redis的发布订阅模式适用于一对多的消息分发。</p>\n<h4 id=\"2-1-发布者（发布消息）\"><a href=\"#2-1-发布者（发布消息）\" class=\"headerlink\" title=\"2.1 发布者（发布消息）\"></a>2.1 发布者（发布消息）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisPublisher &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisPublisher(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void publish(String channel, String message) &#123;</span><br><span class=\"line\">        jedis.publish(channel, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-订阅者（接收消息）\"><a href=\"#2-2-订阅者（接收消息）\" class=\"headerlink\" title=\"2.2 订阅者（接收消息）\"></a>2.2 订阅者（接收消息）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\">import redis.clients.jedis.JedisPubSub;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisSubscriber &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisSubscriber(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void subscribe(String channel, JedisPubSub jedisPubSub) &#123;</span><br><span class=\"line\">        jedis.subscribe(jedisPubSub, channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用Redisson库\"><a href=\"#3-使用Redisson库\" class=\"headerlink\" title=\"3. 使用Redisson库\"></a>3. 使用Redisson库</h3><p>Redisson是一个功能丰富的Redis Java客户端，提供了更高层次的抽象，包括消息队列、分布式锁等。</p>\n<h4 id=\"3-1-添加依赖\"><a href=\"#3-1-添加依赖\" class=\"headerlink\" title=\"3.1 添加依赖\"></a>3.1 添加依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.17.5<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行 HTML</p>\n<h4 id=\"3-2-生产者和消费者\"><a href=\"#3-2-生产者和消费者\" class=\"headerlink\" title=\"3.2 生产者和消费者\"></a>3.2 生产者和消费者</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.redisson.Redisson;</span><br><span class=\"line\">import org.redisson.api.RQueue;</span><br><span class=\"line\">import org.redisson.api.RedissonClient;</span><br><span class=\"line\">import org.redisson.config.Config;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedissonQueueExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Config config = new Config();</span><br><span class=\"line\">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class=\"line\">        RedissonClient redisson = Redisson.create(config);</span><br><span class=\"line\"></span><br><span class=\"line\">        RQueue&lt;String&gt; queue = redisson.getQueue(&quot;myQueue&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 生产者</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                queue.offer(&quot;Message &quot; + i);</span><br><span class=\"line\">                System.out.println(&quot;Produced: Message &quot; + i);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费者</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                String message = queue.poll();</span><br><span class=\"line\">                if (message != null) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;Consumed: &quot; + message);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(1000);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        redisson.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><ul>\n<li><strong>List</strong>：适用于简单的队列场景，支持阻塞式操作。</li>\n<li><strong>Pub&#x2F;Sub</strong>：适用于发布订阅场景，适合一对多的消息分发。</li>\n<li><strong>Redisson</strong>：提供了更高级的抽象，适合复杂的分布式应用场景。</li>\n</ul>\n<p>选择哪种方式取决于你的具体需求。如果需要可靠的消息传递和队列功能，建议使用<code>List</code>​或Redisson的队列实现。</p>\n<p>但是还是存在缺点，redis不存在消息确认机制，所以还得再优化一下。</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"Redis-作为消息队列-消息确认机制\"><a href=\"#Redis-作为消息队列-消息确认机制\" class=\"headerlink\" title=\"Redis 作为消息队列+消息确认机制\"></a>Redis 作为消息队列+消息确认机制</h2><p>为了在使用 Redis 作为消息队列的基础上加上消息确认机制，我们可以采用以下方案：</p>\n<h3 id=\"方案概述\"><a href=\"#方案概述\" class=\"headerlink\" title=\"方案概述\"></a>方案概述</h3><ol>\n<li><strong>生产者</strong>：将消息放入 <code>queue:待处理</code>​ 列表。</li>\n<li><strong>消费者</strong>：使用 Lua 脚本原子地将消息从 <code>queue:待处理</code>​ 移动到 <code>queue:正在处理</code>​，并记录处理开始时间。</li>\n<li><strong>消息处理</strong>：消费者处理消息，处理完成后从 <code>queue:正在处理</code>​ 删除消息，并删除处理记录。</li>\n<li><strong>故障处理</strong>：如果处理失败，可以选择不删除消息，或者将其重新放入 <code>queue:待处理</code>​。</li>\n<li><strong>定时检查</strong>：使用定时任务检查 <code>queue:正在处理</code>​ 中的消息，如果超过阈值时间未处理完成，则重新放入 <code>queue:待处理</code>​。</li>\n</ol>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><h4 id=\"1-生产者代码\"><a href=\"#1-生产者代码\" class=\"headerlink\" title=\"1. 生产者代码\"></a>1. 生产者代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisProducer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisProducer</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">produce</span><span class=\"params\">(String queueName, String message)</span> &#123;</span><br><span class=\"line\">        jedis.lpush(queueName, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-消费者代码\"><a href=\"#2-消费者代码\" class=\"headerlink\" title=\"2. 消费者代码\"></a>2. 消费者代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Scripting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConsumer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">moveScript</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;local message = redis.call(&#x27;RPOP&#x27;, KEYS[1]); if message then redis.call(&#x27;LPUSH&#x27;, KEYS[2], message); end; return message;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisConsumer</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">consume</span><span class=\"params\">(String待处理Queue, String正在处理Queue)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (String) jedis.eval(moveScript, <span class=\"number\">2</span>,待处理Queue,正在处理Queue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            jedis.hset(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message, String.valueOf(System.currentTimeMillis()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(String正在处理Queue, String message)</span> &#123;</span><br><span class=\"line\">        jedis.lrem(正在处理Queue, <span class=\"number\">0</span>, message);</span><br><span class=\"line\">        jedis.hdel(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-定时检查任务\"><a href=\"#3-定时检查任务\" class=\"headerlink\" title=\"3. 定时检查任务\"></a>3. 定时检查任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageMonitor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">threshold</span> <span class=\"operator\">=</span> <span class=\"number\">60000</span>; <span class=\"comment\">// 1分钟</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MessageMonitor</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkMessages</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Set&lt;String&gt; messages = jedis.hkeys(<span class=\"string\">&quot;hash:正在处理&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String message : messages) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> Long.parseLong(jedis.hget(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().getTime() - startTime &gt; threshold) &#123;</span><br><span class=\"line\">                jedis.lpush(<span class=\"string\">&quot;queue:待处理&quot;</span>, message);</span><br><span class=\"line\">                jedis.hdel(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleCheck</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ScheduledThreadPoolExecutor</span>(<span class=\"number\">1</span>).scheduleAtFixedRate(() -&gt; checkMessages(), <span class=\"number\">0</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码说明\"><a href=\"#代码说明\" class=\"headerlink\" title=\"代码说明\"></a>代码说明</h3><ul>\n<li><p><strong>生产者</strong>：将消息放入 <code>queue:待处理</code>​ 列表。</p>\n</li>\n<li><p><strong>消费者</strong>：</p>\n<ul>\n<li>使用 Lua 脚本原子地将消息从 <code>queue:待处理</code>​ 移动到 <code>queue:正在处理</code>​。</li>\n<li>记录消息处理开始时间到 <code>hash:正在处理</code>​。</li>\n<li>处理消息后，调用 <code>confirm</code>​ 方法删除消息和处理记录。</li>\n</ul>\n</li>\n<li><p><strong>定时检查任务</strong>：</p>\n<ul>\n<li>每 30 秒检查一次 <code>hash:正在处理</code>​ 中的消息。</li>\n<li>如果消息处理时间超过阈值（例如 1 分钟），将其重新放入 <code>queue:待处理</code>​。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><strong>原子操作</strong>：使用 Lua 脚本确保消息移动的原子性。</li>\n<li><strong>故障 tolerance</strong>：通过定时检查任务，确保消息不会永久卡在 <code>queue:正在处理</code>​ 中。</li>\n<li><strong>消息不丢失</strong>：处理失败的消息会重新进入待处理队列。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li><strong>复杂性</strong>：需要额外的逻辑来处理消息确认和故障恢复。</li>\n<li><strong>性能开销</strong>：定时任务和哈希表操作可能增加系统负载。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>通过上述方案，我们实现了基于 Redis 的消息队列的消息确认机制，确保消息的可靠传递和处理。虽然实现较为复杂，但在 Redis 作为消息队列的场景下，这是一个可行的解决方案。</p>\n<p>‍</p>\n<p>‍</p>\n","more":"<h1 id=\"Java中使用redis作为消息队列\"><a href=\"#Java中使用redis作为消息队列\" class=\"headerlink\" title=\"Java中使用redis作为消息队列\"></a>Java中使用redis作为消息队列</h1><h2 id=\"使用redis作为消息队列\"><a href=\"#使用redis作为消息队列\" class=\"headerlink\" title=\"使用redis作为消息队列\"></a>使用redis作为消息队列</h2><p>在Java中使用Redis作为消息队列，可以通过Redis的<code>List</code>​数据结构或者<code>Pub/Sub</code>​模式来实现。以下是一个简单的示例，展示了如何使用Redis的<code>List</code>​作为消息队列。</p>\n<h3 id=\"1-使用Redis的List作为消息队列\"><a href=\"#1-使用Redis的List作为消息队列\" class=\"headerlink\" title=\"1. 使用Redis的List作为消息队列\"></a>1. 使用Redis的List作为消息队列</h3><p>Redis的<code>List</code>​数据结构非常适合用来实现消息队列，因为它支持在列表的两端进行操作。</p>\n<h4 id=\"1-1-生产者（发送消息）\"><a href=\"#1-1-生产者（发送消息）\" class=\"headerlink\" title=\"1.1 生产者（发送消息）\"></a>1.1 生产者（发送消息）</h4><p>生产者将消息推入列表的头部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisProducer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisProducer</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">produce</span><span class=\"params\">(String queueName, String message)</span> &#123;</span><br><span class=\"line\">        jedis.lpush(queueName, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-消费者（接收消息）\"><a href=\"#1-2-消费者（接收消息）\" class=\"headerlink\" title=\"1.2 消费者（接收消息）\"></a>1.2 消费者（接收消息）</h4><p>消费者从列表的尾部弹出消息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisConsumer &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisConsumer(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String consume(String queueName) &#123;</span><br><span class=\"line\">        return jedis.rpop(queueName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-阻塞式消费（BLPOP）\"><a href=\"#1-3-阻塞式消费（BLPOP）\" class=\"headerlink\" title=\"1.3 阻塞式消费（BLPOP）\"></a>1.3 阻塞式消费（BLPOP）</h4><p>为了提高效率，可以使用<code>BLPOP</code>​方法，它会在没有消息时阻塞，直到有新消息到达：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisBlockingConsumer &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisBlockingConsumer(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String blockingConsume(String queueName, int timeout) &#123;</span><br><span class=\"line\">        String message = jedis.blpop(timeout, queueName).get(1);</span><br><span class=\"line\">        return message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用Redis的Pub-Sub模式\"><a href=\"#2-使用Redis的Pub-Sub模式\" class=\"headerlink\" title=\"2. 使用Redis的Pub&#x2F;Sub模式\"></a>2. 使用Redis的Pub&#x2F;Sub模式</h3><p>Redis的发布订阅模式适用于一对多的消息分发。</p>\n<h4 id=\"2-1-发布者（发布消息）\"><a href=\"#2-1-发布者（发布消息）\" class=\"headerlink\" title=\"2.1 发布者（发布消息）\"></a>2.1 发布者（发布消息）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisPublisher &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisPublisher(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void publish(String channel, String message) &#123;</span><br><span class=\"line\">        jedis.publish(channel, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-订阅者（接收消息）\"><a href=\"#2-2-订阅者（接收消息）\" class=\"headerlink\" title=\"2.2 订阅者（接收消息）\"></a>2.2 订阅者（接收消息）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import redis.clients.jedis.Jedis;</span><br><span class=\"line\">import redis.clients.jedis.JedisPubSub;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedisSubscriber &#123;</span><br><span class=\"line\">    private Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    public RedisSubscriber(String host, int port) &#123;</span><br><span class=\"line\">        this.jedis = new Jedis(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void subscribe(String channel, JedisPubSub jedisPubSub) &#123;</span><br><span class=\"line\">        jedis.subscribe(jedisPubSub, channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void close() &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用Redisson库\"><a href=\"#3-使用Redisson库\" class=\"headerlink\" title=\"3. 使用Redisson库\"></a>3. 使用Redisson库</h3><p>Redisson是一个功能丰富的Redis Java客户端，提供了更高层次的抽象，包括消息队列、分布式锁等。</p>\n<h4 id=\"3-1-添加依赖\"><a href=\"#3-1-添加依赖\" class=\"headerlink\" title=\"3.1 添加依赖\"></a>3.1 添加依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.17.5<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行 HTML</p>\n<h4 id=\"3-2-生产者和消费者\"><a href=\"#3-2-生产者和消费者\" class=\"headerlink\" title=\"3.2 生产者和消费者\"></a>3.2 生产者和消费者</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.redisson.Redisson;</span><br><span class=\"line\">import org.redisson.api.RQueue;</span><br><span class=\"line\">import org.redisson.api.RedissonClient;</span><br><span class=\"line\">import org.redisson.config.Config;</span><br><span class=\"line\"></span><br><span class=\"line\">public class RedissonQueueExample &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Config config = new Config();</span><br><span class=\"line\">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class=\"line\">        RedissonClient redisson = Redisson.create(config);</span><br><span class=\"line\"></span><br><span class=\"line\">        RQueue&lt;String&gt; queue = redisson.getQueue(&quot;myQueue&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 生产者</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                queue.offer(&quot;Message &quot; + i);</span><br><span class=\"line\">                System.out.println(&quot;Produced: Message &quot; + i);</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Thread.sleep(1000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 消费者</span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                String message = queue.poll();</span><br><span class=\"line\">                if (message != null) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;Consumed: &quot; + message);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(1000);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        redisson.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><ul>\n<li><strong>List</strong>：适用于简单的队列场景，支持阻塞式操作。</li>\n<li><strong>Pub&#x2F;Sub</strong>：适用于发布订阅场景，适合一对多的消息分发。</li>\n<li><strong>Redisson</strong>：提供了更高级的抽象，适合复杂的分布式应用场景。</li>\n</ul>\n<p>选择哪种方式取决于你的具体需求。如果需要可靠的消息传递和队列功能，建议使用<code>List</code>​或Redisson的队列实现。</p>\n<p>但是还是存在缺点，redis不存在消息确认机制，所以还得再优化一下。</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"Redis-作为消息队列-消息确认机制\"><a href=\"#Redis-作为消息队列-消息确认机制\" class=\"headerlink\" title=\"Redis 作为消息队列+消息确认机制\"></a>Redis 作为消息队列+消息确认机制</h2><p>为了在使用 Redis 作为消息队列的基础上加上消息确认机制，我们可以采用以下方案：</p>\n<h3 id=\"方案概述\"><a href=\"#方案概述\" class=\"headerlink\" title=\"方案概述\"></a>方案概述</h3><ol>\n<li><strong>生产者</strong>：将消息放入 <code>queue:待处理</code>​ 列表。</li>\n<li><strong>消费者</strong>：使用 Lua 脚本原子地将消息从 <code>queue:待处理</code>​ 移动到 <code>queue:正在处理</code>​，并记录处理开始时间。</li>\n<li><strong>消息处理</strong>：消费者处理消息，处理完成后从 <code>queue:正在处理</code>​ 删除消息，并删除处理记录。</li>\n<li><strong>故障处理</strong>：如果处理失败，可以选择不删除消息，或者将其重新放入 <code>queue:待处理</code>​。</li>\n<li><strong>定时检查</strong>：使用定时任务检查 <code>queue:正在处理</code>​ 中的消息，如果超过阈值时间未处理完成，则重新放入 <code>queue:待处理</code>​。</li>\n</ol>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><h4 id=\"1-生产者代码\"><a href=\"#1-生产者代码\" class=\"headerlink\" title=\"1. 生产者代码\"></a>1. 生产者代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisProducer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisProducer</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">produce</span><span class=\"params\">(String queueName, String message)</span> &#123;</span><br><span class=\"line\">        jedis.lpush(queueName, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-消费者代码\"><a href=\"#2-消费者代码\" class=\"headerlink\" title=\"2. 消费者代码\"></a>2. 消费者代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Scripting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConsumer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">moveScript</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;local message = redis.call(&#x27;RPOP&#x27;, KEYS[1]); if message then redis.call(&#x27;LPUSH&#x27;, KEYS[2], message); end; return message;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RedisConsumer</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">consume</span><span class=\"params\">(String待处理Queue, String正在处理Queue)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (String) jedis.eval(moveScript, <span class=\"number\">2</span>,待处理Queue,正在处理Queue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            jedis.hset(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message, String.valueOf(System.currentTimeMillis()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(String正在处理Queue, String message)</span> &#123;</span><br><span class=\"line\">        jedis.lrem(正在处理Queue, <span class=\"number\">0</span>, message);</span><br><span class=\"line\">        jedis.hdel(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-定时检查任务\"><a href=\"#3-定时检查任务\" class=\"headerlink\" title=\"3. 定时检查任务\"></a>3. 定时检查任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> redis.clients.jedis.Jedis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageMonitor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Jedis jedis;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">threshold</span> <span class=\"operator\">=</span> <span class=\"number\">60000</span>; <span class=\"comment\">// 1分钟</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MessageMonitor</span><span class=\"params\">(String host, <span class=\"type\">int</span> port)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.jedis = <span class=\"keyword\">new</span> <span class=\"title class_\">Jedis</span>(host, port);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkMessages</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Set&lt;String&gt; messages = jedis.hkeys(<span class=\"string\">&quot;hash:正在处理&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String message : messages) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> Long.parseLong(jedis.hget(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().getTime() - startTime &gt; threshold) &#123;</span><br><span class=\"line\">                jedis.lpush(<span class=\"string\">&quot;queue:待处理&quot;</span>, message);</span><br><span class=\"line\">                jedis.hdel(<span class=\"string\">&quot;hash:正在处理&quot;</span>, message);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">scheduleCheck</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ScheduledThreadPoolExecutor</span>(<span class=\"number\">1</span>).scheduleAtFixedRate(() -&gt; checkMessages(), <span class=\"number\">0</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        jedis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码说明\"><a href=\"#代码说明\" class=\"headerlink\" title=\"代码说明\"></a>代码说明</h3><ul>\n<li><p><strong>生产者</strong>：将消息放入 <code>queue:待处理</code>​ 列表。</p>\n</li>\n<li><p><strong>消费者</strong>：</p>\n<ul>\n<li>使用 Lua 脚本原子地将消息从 <code>queue:待处理</code>​ 移动到 <code>queue:正在处理</code>​。</li>\n<li>记录消息处理开始时间到 <code>hash:正在处理</code>​。</li>\n<li>处理消息后，调用 <code>confirm</code>​ 方法删除消息和处理记录。</li>\n</ul>\n</li>\n<li><p><strong>定时检查任务</strong>：</p>\n<ul>\n<li>每 30 秒检查一次 <code>hash:正在处理</code>​ 中的消息。</li>\n<li>如果消息处理时间超过阈值（例如 1 分钟），将其重新放入 <code>queue:待处理</code>​。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><strong>原子操作</strong>：使用 Lua 脚本确保消息移动的原子性。</li>\n<li><strong>故障 tolerance</strong>：通过定时检查任务，确保消息不会永久卡在 <code>queue:正在处理</code>​ 中。</li>\n<li><strong>消息不丢失</strong>：处理失败的消息会重新进入待处理队列。</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li><strong>复杂性</strong>：需要额外的逻辑来处理消息确认和故障恢复。</li>\n<li><strong>性能开销</strong>：定时任务和哈希表操作可能增加系统负载。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>通过上述方案，我们实现了基于 Redis 的消息队列的消息确认机制，确保消息的可靠传递和处理。虽然实现较为复杂，但在 Redis 作为消息队列的场景下，这是一个可行的解决方案。</p>\n<p>‍</p>\n<p>‍</p>\n"},{"title":"yum源更换","date":"2024-12-19T01:56:33.000Z","updated":"2024-12-22T11:39:15.000Z","excerpt":"yum源更换","comments":1,"toc":true,"abbrlink":30940,"_content":"\n# yum源更换\n\n# yum源更换\n\n### 概括\n\n1.备份\n\n2.下载新的CentOs-Base.repo\n\n3.yum makecache生成缓存\n\n4.更换DNS，重启Centos\n\n### 1、备份\n\n将原本的/etc/yum.repos.d/CentOS-Base.repo 文件备份，命令如下：\n\n```shell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n### 2、下载新的CentOs-Base.repo\n\n下载新的CentOS-Base.repo 到/etc/yum.repos.d/ ，命令如下：\n\n```shell\n# CentOS 6 下载链接\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo\n# CentOS 7 下载链接\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n### 3、yum makecache生成缓存\n\n重新生成缓存，更换新的yum.repos.d/CentOS-Base.repo，命令如下：\n\n```shell\nyum makecache\n```\n\n### 4、更换DNS，重启Centos\n\n建议更换一下DNS，然后重启一下哦 DNS推荐《[一些好用的DNS服务器](https://link.zhihu.com/?target=http%3A//blog.yxccan.cn/blog/detail/17)》 选择阿里的DNS可以比较有效加速\n\n```shell\nshutdown -r now\n```\n\n### 总结\n\n1.备份\n\n2.下载新的CentOs-Base.repo\n\n3.yum makecache生成缓存\n\n4.重启Centos\n","source":"_posts/yum-source-replacement-1jg9tx.md","raw":"---\ntitle: yum源更换\ndate: '2024-12-19 09:56:33'\nupdated: '2024-12-22 19:39:15'\nexcerpt: yum源更换\ntags:\n  - yum源更换\ncategories:\n  - linux\npermalink: /post/yum-source-replacement-1jg9tx.html\ncomments: true\ntoc: true\nabbrlink: 30940\n---\n\n# yum源更换\n\n# yum源更换\n\n### 概括\n\n1.备份\n\n2.下载新的CentOs-Base.repo\n\n3.yum makecache生成缓存\n\n4.更换DNS，重启Centos\n\n### 1、备份\n\n将原本的/etc/yum.repos.d/CentOS-Base.repo 文件备份，命令如下：\n\n```shell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n### 2、下载新的CentOs-Base.repo\n\n下载新的CentOS-Base.repo 到/etc/yum.repos.d/ ，命令如下：\n\n```shell\n# CentOS 6 下载链接\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo\n# CentOS 7 下载链接\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n### 3、yum makecache生成缓存\n\n重新生成缓存，更换新的yum.repos.d/CentOS-Base.repo，命令如下：\n\n```shell\nyum makecache\n```\n\n### 4、更换DNS，重启Centos\n\n建议更换一下DNS，然后重启一下哦 DNS推荐《[一些好用的DNS服务器](https://link.zhihu.com/?target=http%3A//blog.yxccan.cn/blog/detail/17)》 选择阿里的DNS可以比较有效加速\n\n```shell\nshutdown -r now\n```\n\n### 总结\n\n1.备份\n\n2.下载新的CentOs-Base.repo\n\n3.yum makecache生成缓存\n\n4.重启Centos\n","slug":"yum-source-replacement-1jg9tx","published":1,"__permalink":"/post/yum-source-replacement-1jg9tx.html","_id":"cmclcaf4i0015p8vwd9w20w35","layout":"post","photos":[],"content":"<h1 id=\"yum源更换\"><a href=\"#yum源更换\" class=\"headerlink\" title=\"yum源更换\"></a>yum源更换</h1><h1 id=\"yum源更换-1\"><a href=\"#yum源更换-1\" class=\"headerlink\" title=\"yum源更换\"></a>yum源更换</h1><h3 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h3><p>1.备份</p>\n<p>2.下载新的CentOs-Base.repo</p>\n<p>3.yum makecache生成缓存</p>\n<p>4.更换DNS，重启Centos</p>\n<h3 id=\"1、备份\"><a href=\"#1、备份\" class=\"headerlink\" title=\"1、备份\"></a>1、备份</h3><p>将原本的&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo 文件备份，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、下载新的CentOs-Base-repo\"><a href=\"#2、下载新的CentOs-Base-repo\" class=\"headerlink\" title=\"2、下载新的CentOs-Base.repo\"></a>2、下载新的CentOs-Base.repo</h3><p>下载新的CentOS-Base.repo 到&#x2F;etc&#x2F;yum.repos.d&#x2F; ，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CentOS 6 下载链接</span></span><br><span class=\"line\">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CentOS 7 下载链接</span></span><br><span class=\"line\">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、yum-makecache生成缓存\"><a href=\"#3、yum-makecache生成缓存\" class=\"headerlink\" title=\"3、yum makecache生成缓存\"></a>3、yum makecache生成缓存</h3><p>重新生成缓存，更换新的yum.repos.d&#x2F;CentOS-Base.repo，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum makecache</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、更换DNS，重启Centos\"><a href=\"#4、更换DNS，重启Centos\" class=\"headerlink\" title=\"4、更换DNS，重启Centos\"></a>4、更换DNS，重启Centos</h3><p>建议更换一下DNS，然后重启一下哦 DNS推荐《<a href=\"https://link.zhihu.com/?target=http://blog.yxccan.cn/blog/detail/17\">一些好用的DNS服务器</a>》 选择阿里的DNS可以比较有效加速</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>1.备份</p>\n<p>2.下载新的CentOs-Base.repo</p>\n<p>3.yum makecache生成缓存</p>\n<p>4.重启Centos</p>\n","more":"<h1 id=\"yum源更换\"><a href=\"#yum源更换\" class=\"headerlink\" title=\"yum源更换\"></a>yum源更换</h1><h1 id=\"yum源更换-1\"><a href=\"#yum源更换-1\" class=\"headerlink\" title=\"yum源更换\"></a>yum源更换</h1><h3 id=\"概括\"><a href=\"#概括\" class=\"headerlink\" title=\"概括\"></a>概括</h3><p>1.备份</p>\n<p>2.下载新的CentOs-Base.repo</p>\n<p>3.yum makecache生成缓存</p>\n<p>4.更换DNS，重启Centos</p>\n<h3 id=\"1、备份\"><a href=\"#1、备份\" class=\"headerlink\" title=\"1、备份\"></a>1、备份</h3><p>将原本的&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo 文件备份，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、下载新的CentOs-Base-repo\"><a href=\"#2、下载新的CentOs-Base-repo\" class=\"headerlink\" title=\"2、下载新的CentOs-Base.repo\"></a>2、下载新的CentOs-Base.repo</h3><p>下载新的CentOS-Base.repo 到&#x2F;etc&#x2F;yum.repos.d&#x2F; ，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CentOS 6 下载链接</span></span><br><span class=\"line\">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">CentOS 7 下载链接</span></span><br><span class=\"line\">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、yum-makecache生成缓存\"><a href=\"#3、yum-makecache生成缓存\" class=\"headerlink\" title=\"3、yum makecache生成缓存\"></a>3、yum makecache生成缓存</h3><p>重新生成缓存，更换新的yum.repos.d&#x2F;CentOS-Base.repo，命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum makecache</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、更换DNS，重启Centos\"><a href=\"#4、更换DNS，重启Centos\" class=\"headerlink\" title=\"4、更换DNS，重启Centos\"></a>4、更换DNS，重启Centos</h3><p>建议更换一下DNS，然后重启一下哦 DNS推荐《<a href=\"https://link.zhihu.com/?target=http://blog.yxccan.cn/blog/detail/17\">一些好用的DNS服务器</a>》 选择阿里的DNS可以比较有效加速</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>1.备份</p>\n<p>2.下载新的CentOs-Base.repo</p>\n<p>3.yum makecache生成缓存</p>\n<p>4.重启Centos</p>\n"},{"title":"mysql后缀匹配问题","date":"2025-05-26T06:17:36.000Z","updated":"2025-07-02T05:58:09.000Z","excerpt":"MySQL 后缀匹配手机号后四位的几种方法及优化建议：  \n\n1. **基础方法**：  \n   - `RIGHT(phone_number, 4)` 或 `LIKE '%5678'` 简单易用，但无法利用索引，适合小数据量。  \n   - 正则 `REGEXP '5678$'` 灵活性高，但性能最差。  \n\n2. **高性能优化**：  \n   - **虚拟列+索引**（MySQL 5.7+）：自动提取后四位并建立索引，查询快且无存储开销。  \n   - **冗余字段+索引**（兼容低版本）：手动维护后四位字段，需保证数据一致性。  \n\n3. **建议**：  \n   - 小数据用 `RIGHT()` 或 `LIKE`；  \n   - 大数据优先虚拟列方案，次选冗余字段；  \n   - 正则仅用于复杂匹配。  \n\n注意：确保手机号格式统一（纯数字），无效数据需提前清洗。","comments":1,"toc":true,"abbrlink":20979,"_content":"\n\n\n# mysql后缀匹配问题\n\n在 MySQL 中匹配手机号的后四位，可以通过多种方法实现。以下是不同方法的详细说明及对比，帮助你根据实际场景选择最优方案：\n\n---\n\n### 一、直接使用 `RIGHT()`​ 函数截取后四位\n\n#### 语法\n\n```sql\nSELECT * \nFROM users \nWHERE RIGHT(phone_number, 4) = '5678';\n```\n\n#### 特点\n\n* **简单直接**：通过截取手机号末尾4位字符进行精确匹配。\n* **无法利用索引**：由于使用了函数 `RIGHT()`​，即使 `phone_number`​ 字段有索引，也无法生效。\n* **适用场景**：数据量较小的表或低频查询。\n\n---\n\n### 二、使用 `LIKE`​ 模糊匹配\n\n#### 语法\n\n```sql\nSELECT * \nFROM users \nWHERE phone_number LIKE '%5678';\n```\n\n#### 特点\n\n* **语法简洁**：直接通过通配符 `%`​ 匹配末尾4位。\n* **无法利用索引**：以通配符 `%`​ 开头的 `LIKE`​ 操作会导致全表扫描。\n* **性能对比**：通常比正则表达式快，但仍需全表扫描。\n\n---\n\n### 三、使用正则表达式 `REGEXP`​\n\n#### 语法\n\n```sql\nSELECT * \nFROM users \nWHERE phone_number REGEXP '5678$';\n```\n\n#### 特点\n\n* **灵活性高**：支持更复杂的模式（如同时匹配后缀和其他规则）。\n* **性能最低**：正则表达式无法使用索引，且匹配逻辑更复杂。\n* **适用场景**：需要复杂匹配规则（例如同时验证手机号格式）。\n\n---\n\n### 四、优化方案：虚拟列 + 索引（推荐）\n\n如果查询频繁且数据量大，可以通过 **虚拟列（Generated Column）**  对手机号后四位单独存储并建立索引，显著提升性能。\n\n#### 步骤\n\n1. **添加虚拟列**（MySQL 5.7+ 支持）：\n\n    ```sql\n    ALTER TABLE users\n    ADD COLUMN last_four CHAR(4) GENERATED ALWAYS AS (RIGHT(phone_number, 4)) VIRTUAL;\n    ```\n2. **为虚拟列创建索引**：\n\n    ```sql\n    CREATE INDEX idx_last_four ON users(last_four);\n    ```\n3. **查询优化后的语句**：\n\n    ```sql\n    SELECT * \n    FROM users \n    WHERE last_four = '5678';\n    ```\n\n#### 特点\n\n* **利用索引**：查询速度极快，适合大数据量。\n* **无冗余存储**：虚拟列不占用实际存储空间（选择 `VIRTUAL`​ 类型时）。\n\n---\n\n### 五、优化方案：冗余字段 + 索引\n\n如果无法使用虚拟列（如 MySQL 5.6 或以下版本），可以手动维护一个冗余字段。\n\n#### 步骤\n\n1. **添加新字段**：\n\n    ```sql\n    ALTER TABLE users \n    ADD COLUMN last_four CHAR(4);\n    ```\n2. **填充数据**（初始化和后续更新）：\n\n    ```sql\n    UPDATE users \n    SET last_four = RIGHT(phone_number, 4);\n    ```\n3. **创建索引**：\n\n    ```sql\n    CREATE INDEX idx_last_four ON users(last_four);\n    ```\n4. **查询**：\n\n    ```sql\n    SELECT * \n    FROM users \n    WHERE last_four = '5678';\n    ```\n\n#### 特点\n\n* **兼容性好**：适用于所有 MySQL 版本。\n* **需维护数据一致性**：需要在插入或更新手机号时同步更新 `last_four`​ 字段。\n\n---\n\n### 六、性能对比\n\n|方法|是否走索引|适合数据量|维护成本|\n| -----------------| ------------| ------------| ----------------|\n|​`RIGHT()`​ 函数|否|小|无|\n|​`LIKE '%5678'`​|否|小|无|\n|正则表达式 `REGEXP`​|否|小|无|\n|虚拟列 + 索引|是|大|低（自动维护）|\n|冗余字段 + 索引|是|大|中（手动维护）|\n\n---\n\n### 七、注意事项\n\n1. **手机号格式统一**：确保所有手机号存储为纯数字且长度一致（如 11 位）。\n2. **清理无效数据**：如果手机号包含非数字字符（如空格、`-`​），需先清洗数据：\n\n    ```sql\n    -- 示例：去除非数字字符\n    UPDATE users \n    SET phone_number = REPLACE(REPLACE(phone_number, '-', ''), ' ', '');\n    ```\n\n---\n\n### 最终建议\n\n* **小数据量**：直接使用 `RIGHT(phone_number, 4) = '5678'`​ 或 `LIKE '%5678'`​。\n* **大数据量**：使用 **虚拟列 + 索引**（MySQL 5.7+）或 **冗余字段 + 索引**。\n* **复杂匹配需求**：正则表达式可作为兜底方案，但需注意性能损耗。\n\n‍\n","source":"_posts/mysql-suffix-matching-problem-vwtyk.md","raw":"---\ntitle: mysql后缀匹配问题\ndate: '2025-05-26 14:17:36'\nupdated: '2025-07-02 13:58:09'\nexcerpt: |-\n  MySQL 后缀匹配手机号后四位的几种方法及优化建议：  \n\n  1. **基础方法**：  \n     - `RIGHT(phone_number, 4)` 或 `LIKE '%5678'` 简单易用，但无法利用索引，适合小数据量。  \n     - 正则 `REGEXP '5678$'` 灵活性高，但性能最差。  \n\n  2. **高性能优化**：  \n     - **虚拟列+索引**（MySQL 5.7+）：自动提取后四位并建立索引，查询快且无存储开销。  \n     - **冗余字段+索引**（兼容低版本）：手动维护后四位字段，需保证数据一致性。  \n\n  3. **建议**：  \n     - 小数据用 `RIGHT()` 或 `LIKE`；  \n     - 大数据优先虚拟列方案，次选冗余字段；  \n     - 正则仅用于复杂匹配。  \n\n  注意：确保手机号格式统一（纯数字），无效数据需提前清洗。\ntags:\n  - mysql\n  - 后缀匹配\n  - 索引优化\n  - 正则表达式\n  - 虚拟列\ncategories:\n  - 数据库\n  - 性能优化\n  - MySQL\npermalink: /post/mysql-suffix-matching-problem-vwtyk.html\ncomments: true\ntoc: true\nabbrlink: 20979\n---\n\n\n\n# mysql后缀匹配问题\n\n在 MySQL 中匹配手机号的后四位，可以通过多种方法实现。以下是不同方法的详细说明及对比，帮助你根据实际场景选择最优方案：\n\n---\n\n### 一、直接使用 `RIGHT()`​ 函数截取后四位\n\n#### 语法\n\n```sql\nSELECT * \nFROM users \nWHERE RIGHT(phone_number, 4) = '5678';\n```\n\n#### 特点\n\n* **简单直接**：通过截取手机号末尾4位字符进行精确匹配。\n* **无法利用索引**：由于使用了函数 `RIGHT()`​，即使 `phone_number`​ 字段有索引，也无法生效。\n* **适用场景**：数据量较小的表或低频查询。\n\n---\n\n### 二、使用 `LIKE`​ 模糊匹配\n\n#### 语法\n\n```sql\nSELECT * \nFROM users \nWHERE phone_number LIKE '%5678';\n```\n\n#### 特点\n\n* **语法简洁**：直接通过通配符 `%`​ 匹配末尾4位。\n* **无法利用索引**：以通配符 `%`​ 开头的 `LIKE`​ 操作会导致全表扫描。\n* **性能对比**：通常比正则表达式快，但仍需全表扫描。\n\n---\n\n### 三、使用正则表达式 `REGEXP`​\n\n#### 语法\n\n```sql\nSELECT * \nFROM users \nWHERE phone_number REGEXP '5678$';\n```\n\n#### 特点\n\n* **灵活性高**：支持更复杂的模式（如同时匹配后缀和其他规则）。\n* **性能最低**：正则表达式无法使用索引，且匹配逻辑更复杂。\n* **适用场景**：需要复杂匹配规则（例如同时验证手机号格式）。\n\n---\n\n### 四、优化方案：虚拟列 + 索引（推荐）\n\n如果查询频繁且数据量大，可以通过 **虚拟列（Generated Column）**  对手机号后四位单独存储并建立索引，显著提升性能。\n\n#### 步骤\n\n1. **添加虚拟列**（MySQL 5.7+ 支持）：\n\n    ```sql\n    ALTER TABLE users\n    ADD COLUMN last_four CHAR(4) GENERATED ALWAYS AS (RIGHT(phone_number, 4)) VIRTUAL;\n    ```\n2. **为虚拟列创建索引**：\n\n    ```sql\n    CREATE INDEX idx_last_four ON users(last_four);\n    ```\n3. **查询优化后的语句**：\n\n    ```sql\n    SELECT * \n    FROM users \n    WHERE last_four = '5678';\n    ```\n\n#### 特点\n\n* **利用索引**：查询速度极快，适合大数据量。\n* **无冗余存储**：虚拟列不占用实际存储空间（选择 `VIRTUAL`​ 类型时）。\n\n---\n\n### 五、优化方案：冗余字段 + 索引\n\n如果无法使用虚拟列（如 MySQL 5.6 或以下版本），可以手动维护一个冗余字段。\n\n#### 步骤\n\n1. **添加新字段**：\n\n    ```sql\n    ALTER TABLE users \n    ADD COLUMN last_four CHAR(4);\n    ```\n2. **填充数据**（初始化和后续更新）：\n\n    ```sql\n    UPDATE users \n    SET last_four = RIGHT(phone_number, 4);\n    ```\n3. **创建索引**：\n\n    ```sql\n    CREATE INDEX idx_last_four ON users(last_four);\n    ```\n4. **查询**：\n\n    ```sql\n    SELECT * \n    FROM users \n    WHERE last_four = '5678';\n    ```\n\n#### 特点\n\n* **兼容性好**：适用于所有 MySQL 版本。\n* **需维护数据一致性**：需要在插入或更新手机号时同步更新 `last_four`​ 字段。\n\n---\n\n### 六、性能对比\n\n|方法|是否走索引|适合数据量|维护成本|\n| -----------------| ------------| ------------| ----------------|\n|​`RIGHT()`​ 函数|否|小|无|\n|​`LIKE '%5678'`​|否|小|无|\n|正则表达式 `REGEXP`​|否|小|无|\n|虚拟列 + 索引|是|大|低（自动维护）|\n|冗余字段 + 索引|是|大|中（手动维护）|\n\n---\n\n### 七、注意事项\n\n1. **手机号格式统一**：确保所有手机号存储为纯数字且长度一致（如 11 位）。\n2. **清理无效数据**：如果手机号包含非数字字符（如空格、`-`​），需先清洗数据：\n\n    ```sql\n    -- 示例：去除非数字字符\n    UPDATE users \n    SET phone_number = REPLACE(REPLACE(phone_number, '-', ''), ' ', '');\n    ```\n\n---\n\n### 最终建议\n\n* **小数据量**：直接使用 `RIGHT(phone_number, 4) = '5678'`​ 或 `LIKE '%5678'`​。\n* **大数据量**：使用 **虚拟列 + 索引**（MySQL 5.7+）或 **冗余字段 + 索引**。\n* **复杂匹配需求**：正则表达式可作为兜底方案，但需注意性能损耗。\n\n‍\n","slug":"mysql-suffix-matching-problem-vwtyk","published":1,"__permalink":"/post/mysql-suffix-matching-problem-vwtyk.html","_id":"cmdxvwf0v00000wsdhygc5lds","layout":"post","photos":[],"content":"<h1 id=\"mysql后缀匹配问题\"><a href=\"#mysql后缀匹配问题\" class=\"headerlink\" title=\"mysql后缀匹配问题\"></a>mysql后缀匹配问题</h1><p>在 MySQL 中匹配手机号的后四位，可以通过多种方法实现。以下是不同方法的详细说明及对比，帮助你根据实际场景选择最优方案：</p>\n<hr>\n<h3 id=\"一、直接使用-RIGHT-​-函数截取后四位\"><a href=\"#一、直接使用-RIGHT-​-函数截取后四位\" class=\"headerlink\" title=\"一、直接使用 RIGHT()​ 函数截取后四位\"></a>一、直接使用 <code>RIGHT()</code>​ 函数截取后四位</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">RIGHT</span>(phone_number, <span class=\"number\">4</span>) <span class=\"operator\">=</span> <span class=\"string\">&#x27;5678&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>简单直接</strong>：通过截取手机号末尾4位字符进行精确匹配。</li>\n<li><strong>无法利用索引</strong>：由于使用了函数 <code>RIGHT()</code>​，即使 <code>phone_number</code>​ 字段有索引，也无法生效。</li>\n<li><strong>适用场景</strong>：数据量较小的表或低频查询。</li>\n</ul>\n<hr>\n<h3 id=\"二、使用-LIKE​-模糊匹配\"><a href=\"#二、使用-LIKE​-模糊匹配\" class=\"headerlink\" title=\"二、使用 LIKE​ 模糊匹配\"></a>二、使用 <code>LIKE</code>​ 模糊匹配</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> phone_number <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%5678&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>语法简洁</strong>：直接通过通配符 <code>%</code>​ 匹配末尾4位。</li>\n<li><strong>无法利用索引</strong>：以通配符 <code>%</code>​ 开头的 <code>LIKE</code>​ 操作会导致全表扫描。</li>\n<li><strong>性能对比</strong>：通常比正则表达式快，但仍需全表扫描。</li>\n</ul>\n<hr>\n<h3 id=\"三、使用正则表达式-REGEXP​\"><a href=\"#三、使用正则表达式-REGEXP​\" class=\"headerlink\" title=\"三、使用正则表达式 REGEXP​\"></a>三、使用正则表达式 <code>REGEXP</code>​</h3><h4 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> phone_number REGEXP <span class=\"string\">&#x27;5678$&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>灵活性高</strong>：支持更复杂的模式（如同时匹配后缀和其他规则）。</li>\n<li><strong>性能最低</strong>：正则表达式无法使用索引，且匹配逻辑更复杂。</li>\n<li><strong>适用场景</strong>：需要复杂匹配规则（例如同时验证手机号格式）。</li>\n</ul>\n<hr>\n<h3 id=\"四、优化方案：虚拟列-索引（推荐）\"><a href=\"#四、优化方案：虚拟列-索引（推荐）\" class=\"headerlink\" title=\"四、优化方案：虚拟列 + 索引（推荐）\"></a>四、优化方案：虚拟列 + 索引（推荐）</h3><p>如果查询频繁且数据量大，可以通过 <strong>虚拟列（Generated Column）</strong>  对手机号后四位单独存储并建立索引，显著提升性能。</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li><p><strong>添加虚拟列</strong>（MySQL 5.7+ 支持）：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users</span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">COLUMN</span> last_four <span class=\"type\">CHAR</span>(<span class=\"number\">4</span>) GENERATED ALWAYS <span class=\"keyword\">AS</span> (<span class=\"keyword\">RIGHT</span>(phone_number, <span class=\"number\">4</span>)) VIRTUAL;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>为虚拟列创建索引</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_last_four <span class=\"keyword\">ON</span> users(last_four);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查询优化后的语句</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> last_four <span class=\"operator\">=</span> <span class=\"string\">&#x27;5678&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>利用索引</strong>：查询速度极快，适合大数据量。</li>\n<li><strong>无冗余存储</strong>：虚拟列不占用实际存储空间（选择 <code>VIRTUAL</code>​ 类型时）。</li>\n</ul>\n<hr>\n<h3 id=\"五、优化方案：冗余字段-索引\"><a href=\"#五、优化方案：冗余字段-索引\" class=\"headerlink\" title=\"五、优化方案：冗余字段 + 索引\"></a>五、优化方案：冗余字段 + 索引</h3><p>如果无法使用虚拟列（如 MySQL 5.6 或以下版本），可以手动维护一个冗余字段。</p>\n<h4 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li><p><strong>添加新字段</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">COLUMN</span> last_four <span class=\"type\">CHAR</span>(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>填充数据</strong>（初始化和后续更新）：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> users </span><br><span class=\"line\"><span class=\"keyword\">SET</span> last_four <span class=\"operator\">=</span> <span class=\"keyword\">RIGHT</span>(phone_number, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>创建索引</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_last_four <span class=\"keyword\">ON</span> users(last_four);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查询</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> last_four <span class=\"operator\">=</span> <span class=\"string\">&#x27;5678&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"特点-4\"><a href=\"#特点-4\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>兼容性好</strong>：适用于所有 MySQL 版本。</li>\n<li><strong>需维护数据一致性</strong>：需要在插入或更新手机号时同步更新 <code>last_four</code>​ 字段。</li>\n</ul>\n<hr>\n<h3 id=\"六、性能对比\"><a href=\"#六、性能对比\" class=\"headerlink\" title=\"六、性能对比\"></a>六、性能对比</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>是否走索引</th>\n<th>适合数据量</th>\n<th>维护成本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<code>RIGHT()</code>​ 函数</td>\n<td>否</td>\n<td>小</td>\n<td>无</td>\n</tr>\n<tr>\n<td>​<code>LIKE &#39;%5678&#39;</code>​</td>\n<td>否</td>\n<td>小</td>\n<td>无</td>\n</tr>\n<tr>\n<td>正则表达式 <code>REGEXP</code>​</td>\n<td>否</td>\n<td>小</td>\n<td>无</td>\n</tr>\n<tr>\n<td>虚拟列 + 索引</td>\n<td>是</td>\n<td>大</td>\n<td>低（自动维护）</td>\n</tr>\n<tr>\n<td>冗余字段 + 索引</td>\n<td>是</td>\n<td>大</td>\n<td>中（手动维护）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"七、注意事项\"><a href=\"#七、注意事项\" class=\"headerlink\" title=\"七、注意事项\"></a>七、注意事项</h3><ol>\n<li><p><strong>手机号格式统一</strong>：确保所有手机号存储为纯数字且长度一致（如 11 位）。</p>\n</li>\n<li><p><strong>清理无效数据</strong>：如果手机号包含非数字字符（如空格、<code>-</code>​），需先清洗数据：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 示例：去除非数字字符</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> users </span><br><span class=\"line\"><span class=\"keyword\">SET</span> phone_number <span class=\"operator\">=</span> REPLACE(REPLACE(phone_number, <span class=\"string\">&#x27;-&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>), <span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h3 id=\"最终建议\"><a href=\"#最终建议\" class=\"headerlink\" title=\"最终建议\"></a>最终建议</h3><ul>\n<li><strong>小数据量</strong>：直接使用 <code>RIGHT(phone_number, 4) = &#39;5678&#39;</code>​ 或 <code>LIKE &#39;%5678&#39;</code>​。</li>\n<li><strong>大数据量</strong>：使用 <strong>虚拟列 + 索引</strong>（MySQL 5.7+）或 <strong>冗余字段 + 索引</strong>。</li>\n<li><strong>复杂匹配需求</strong>：正则表达式可作为兜底方案，但需注意性能损耗。</li>\n</ul>\n<p>‍</p>\n","more":"<h1 id=\"mysql后缀匹配问题\"><a href=\"#mysql后缀匹配问题\" class=\"headerlink\" title=\"mysql后缀匹配问题\"></a>mysql后缀匹配问题</h1><p>在 MySQL 中匹配手机号的后四位，可以通过多种方法实现。以下是不同方法的详细说明及对比，帮助你根据实际场景选择最优方案：</p>\n<hr>\n<h3 id=\"一、直接使用-RIGHT-​-函数截取后四位\"><a href=\"#一、直接使用-RIGHT-​-函数截取后四位\" class=\"headerlink\" title=\"一、直接使用 RIGHT()​ 函数截取后四位\"></a>一、直接使用 <code>RIGHT()</code>​ 函数截取后四位</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">RIGHT</span>(phone_number, <span class=\"number\">4</span>) <span class=\"operator\">=</span> <span class=\"string\">&#x27;5678&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>简单直接</strong>：通过截取手机号末尾4位字符进行精确匹配。</li>\n<li><strong>无法利用索引</strong>：由于使用了函数 <code>RIGHT()</code>​，即使 <code>phone_number</code>​ 字段有索引，也无法生效。</li>\n<li><strong>适用场景</strong>：数据量较小的表或低频查询。</li>\n</ul>\n<hr>\n<h3 id=\"二、使用-LIKE​-模糊匹配\"><a href=\"#二、使用-LIKE​-模糊匹配\" class=\"headerlink\" title=\"二、使用 LIKE​ 模糊匹配\"></a>二、使用 <code>LIKE</code>​ 模糊匹配</h3><h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> phone_number <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%5678&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>语法简洁</strong>：直接通过通配符 <code>%</code>​ 匹配末尾4位。</li>\n<li><strong>无法利用索引</strong>：以通配符 <code>%</code>​ 开头的 <code>LIKE</code>​ 操作会导致全表扫描。</li>\n<li><strong>性能对比</strong>：通常比正则表达式快，但仍需全表扫描。</li>\n</ul>\n<hr>\n<h3 id=\"三、使用正则表达式-REGEXP​\"><a href=\"#三、使用正则表达式-REGEXP​\" class=\"headerlink\" title=\"三、使用正则表达式 REGEXP​\"></a>三、使用正则表达式 <code>REGEXP</code>​</h3><h4 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> phone_number REGEXP <span class=\"string\">&#x27;5678$&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>灵活性高</strong>：支持更复杂的模式（如同时匹配后缀和其他规则）。</li>\n<li><strong>性能最低</strong>：正则表达式无法使用索引，且匹配逻辑更复杂。</li>\n<li><strong>适用场景</strong>：需要复杂匹配规则（例如同时验证手机号格式）。</li>\n</ul>\n<hr>\n<h3 id=\"四、优化方案：虚拟列-索引（推荐）\"><a href=\"#四、优化方案：虚拟列-索引（推荐）\" class=\"headerlink\" title=\"四、优化方案：虚拟列 + 索引（推荐）\"></a>四、优化方案：虚拟列 + 索引（推荐）</h3><p>如果查询频繁且数据量大，可以通过 <strong>虚拟列（Generated Column）</strong>  对手机号后四位单独存储并建立索引，显著提升性能。</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li><p><strong>添加虚拟列</strong>（MySQL 5.7+ 支持）：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users</span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">COLUMN</span> last_four <span class=\"type\">CHAR</span>(<span class=\"number\">4</span>) GENERATED ALWAYS <span class=\"keyword\">AS</span> (<span class=\"keyword\">RIGHT</span>(phone_number, <span class=\"number\">4</span>)) VIRTUAL;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>为虚拟列创建索引</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_last_four <span class=\"keyword\">ON</span> users(last_four);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查询优化后的语句</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> last_four <span class=\"operator\">=</span> <span class=\"string\">&#x27;5678&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>利用索引</strong>：查询速度极快，适合大数据量。</li>\n<li><strong>无冗余存储</strong>：虚拟列不占用实际存储空间（选择 <code>VIRTUAL</code>​ 类型时）。</li>\n</ul>\n<hr>\n<h3 id=\"五、优化方案：冗余字段-索引\"><a href=\"#五、优化方案：冗余字段-索引\" class=\"headerlink\" title=\"五、优化方案：冗余字段 + 索引\"></a>五、优化方案：冗余字段 + 索引</h3><p>如果无法使用虚拟列（如 MySQL 5.6 或以下版本），可以手动维护一个冗余字段。</p>\n<h4 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li><p><strong>添加新字段</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> users </span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">COLUMN</span> last_four <span class=\"type\">CHAR</span>(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>填充数据</strong>（初始化和后续更新）：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> users </span><br><span class=\"line\"><span class=\"keyword\">SET</span> last_four <span class=\"operator\">=</span> <span class=\"keyword\">RIGHT</span>(phone_number, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>创建索引</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX idx_last_four <span class=\"keyword\">ON</span> users(last_four);</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查询</strong>：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> users </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> last_four <span class=\"operator\">=</span> <span class=\"string\">&#x27;5678&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"特点-4\"><a href=\"#特点-4\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li><strong>兼容性好</strong>：适用于所有 MySQL 版本。</li>\n<li><strong>需维护数据一致性</strong>：需要在插入或更新手机号时同步更新 <code>last_four</code>​ 字段。</li>\n</ul>\n<hr>\n<h3 id=\"六、性能对比\"><a href=\"#六、性能对比\" class=\"headerlink\" title=\"六、性能对比\"></a>六、性能对比</h3><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>是否走索引</th>\n<th>适合数据量</th>\n<th>维护成本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<code>RIGHT()</code>​ 函数</td>\n<td>否</td>\n<td>小</td>\n<td>无</td>\n</tr>\n<tr>\n<td>​<code>LIKE &#39;%5678&#39;</code>​</td>\n<td>否</td>\n<td>小</td>\n<td>无</td>\n</tr>\n<tr>\n<td>正则表达式 <code>REGEXP</code>​</td>\n<td>否</td>\n<td>小</td>\n<td>无</td>\n</tr>\n<tr>\n<td>虚拟列 + 索引</td>\n<td>是</td>\n<td>大</td>\n<td>低（自动维护）</td>\n</tr>\n<tr>\n<td>冗余字段 + 索引</td>\n<td>是</td>\n<td>大</td>\n<td>中（手动维护）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"七、注意事项\"><a href=\"#七、注意事项\" class=\"headerlink\" title=\"七、注意事项\"></a>七、注意事项</h3><ol>\n<li><p><strong>手机号格式统一</strong>：确保所有手机号存储为纯数字且长度一致（如 11 位）。</p>\n</li>\n<li><p><strong>清理无效数据</strong>：如果手机号包含非数字字符（如空格、<code>-</code>​），需先清洗数据：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 示例：去除非数字字符</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> users </span><br><span class=\"line\"><span class=\"keyword\">SET</span> phone_number <span class=\"operator\">=</span> REPLACE(REPLACE(phone_number, <span class=\"string\">&#x27;-&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>), <span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h3 id=\"最终建议\"><a href=\"#最终建议\" class=\"headerlink\" title=\"最终建议\"></a>最终建议</h3><ul>\n<li><strong>小数据量</strong>：直接使用 <code>RIGHT(phone_number, 4) = &#39;5678&#39;</code>​ 或 <code>LIKE &#39;%5678&#39;</code>​。</li>\n<li><strong>大数据量</strong>：使用 <strong>虚拟列 + 索引</strong>（MySQL 5.7+）或 <strong>冗余字段 + 索引</strong>。</li>\n<li><strong>复杂匹配需求</strong>：正则表达式可作为兜底方案，但需注意性能损耗。</li>\n</ul>\n<p>‍</p>\n"},{"title":"全设备仿真的定制固件开发指南","date":"2025-07-07T02:35:21.000Z","updated":"2025-07-07T02:36:52.000Z","excerpt":"**《全设备仿真的定制固件开发指南》摘要**\n\n本指南系统介绍了基于FPGA的PCIe设备固件开发全流程，涵盖基础概念到高级优化技术。作者在个人困境中坚持完成这一开源项目，并特别纪念FPGA之父Ross Freeman的贡献。\n\n**核心内容：**\n1. **开发基础**  \n   - 支持Xilinx Artix-7等FPGA硬件  \n   - 需Vivado工具链及PCIe流量分析软件  \n   - 详细说明设备信息收集（如Arbor扫描工具）和初始固件配置（DSN/PCIe空间修改）\n\n2. **关键技术**  \n   - PCIe参数配置与BAR内存映射调整  \n   - 事务层数据包(TLP)的捕获与定制  \n   - 电源管理/中断仿真等设备特性实现  \n\n3. **实践指南**  \n   - 提供Vivado项目设置、IP核修改、比特流烧录的完整流程  \n   - 集成逻辑分析仪调试和性能优化方案  \n   - 常见故障（设备检测/DMA错误）的解决方案  \n\n**特点：**  \n- 强调仿真精度与动态响应技术  \n- 包含安全规范与版本管理最佳实践  \n- 配套维基文档和社区支持资源  \n\n作者呼吁开发者参与完善项目，并感谢捐助者支持其持续维护。指南兼具技术深度与人文关怀，既是FPGA开发的实用手册，也体现了开源共享精神。  \n\n（字数：498中文字符）","comments":1,"toc":true,"abbrlink":36758,"_content":"\n\n\n# 全设备仿真的定制固件开发指南\n\n# **全设备仿真的定制固件开发指南**\n\n---\n\n**特别鸣谢慷慨捐助的传奇人物，我将很快与您联系。如果您愿意，请DM我，我会在本文中添加鸣谢并提供更多信息！**\n\n正在将此指南整理到[维基](https://github.com/JPShag/PCILeech-DMA-Firmware/wiki/Introduction)中。欢迎提供帮助！\n\n---\n\n**作者留言及指南状态：**\n\n我正在透明地分享这一切，因为最近的日子异常艰难。除了因欺诈性退款造成的巨大经济损失外，我还面临多重生活和健康困境，严重影响了我上网和投入项目的时间。坦率地说，在这些个人困难中，继续创作像本指南这样全面的资源已成为一项深刻的挣扎。\n\n这预计是主指南的最后一次重大迭代。对于已经熟悉基本硬件概念（例如，FTDI芯片的功能）的更有经验的用户，我们将提供一个简洁的精简版。\n\n如果您觉得这项工作有价值并能够提供帮助，任何形式的支持都将不胜感激。您的慷慨使我尽管面临持续的挑战，仍能继续为这个社区做出贡献。我真诚地希望本指南已经并将继续成为一份宝贵的资源。\n\n---\n\n## 纪念与献词\n\n![Ross](https://github.com/user-attachments/assets/de7f12fe-8992-4738-a6af-712dc48217ee)\n\n本指南谨献给\n**Ross Freeman (1947–1989)**  的记忆\n\n作为一位富有远见的工程师、杰出的密歇根人，以及Xilinx的联合创始人，Ross Freeman被广泛认为是现场可编程门阵列（FPGA）技术之父，该技术彻底改变了计算领域。\n\n在1984年，半导体行业主要专注于固定功能芯片之时，Freeman敢于想象一种不同的范式：制造后可以重新编程的硬件。他的革命性专利（#4,870,302）和对可重构计算的不懈倡导，开启了一个四十年后仍在改变我们世界的科技范式。\n\n他的开创性创新使得在无需承担传统ASIC开发高昂成本的情况下，快速原型化和部署定制芯片解决方案成为可能，从而使硬件设计民主化，并加速了无数领域的技术进步。\n\n如今，Freeman的愿景驱动着人工智能、高性能计算、电信、汽车系统、航空航天应用以及他在世时仅是梦想的许多其他领域的尖端发展。\n\n他于2009年被追授进入国家发明家名人堂，其遗产不仅体现在硅片中，更体现在挑战我们所有人质疑既定限制并想象新可能性的技术勇气精神中。\n\n *\"FPGA的最终目标是制造可编程逻辑器件，以取代标准数字芯片。\"*  — Ross Freeman\n\n---\n\n## **目录**\n\n### **第一部分：基础概念**\n\n1. [引言](#1-引言)\n   * [1.1 本指南的目的](#11-本指南的目的)\n   * [1.2 目标读者](#12-目标读者)\n   * [1.3 如何使用本指南](#13-如何使用本指南)\n2. [关键定义](#2-关键定义)\n3. [设备兼容性](#3-设备兼容性)\n   * [3.1 支持的基于FPGA的硬件](#31-支持的基于fpga的硬件)\n   * [3.2 PCIe硬件注意事项](#32-pcie硬件注意事项)\n   * [3.3 系统要求](#33-系统要求)\n4. [要求](#4-要求)\n   * [4.1 硬件](#41-硬件)\n   * [4.2 软件](#42-软件)\n   * [4.3 环境设置](#43-环境设置)\n5. [收集捐赠设备信息](#5-收集捐赠设备信息)\n   * [5.1 使用Arbor进行PCIe设备扫描](#51-使用arbor进行pcie设备扫描)\n   * [5.2 提取和记录设备属性](#52-提取和记录设备属性)\n6. [初始固件定制](#6-初始固件定制)\n   * [6.1 修改配置空间](#61-修改配置空间)\n   * [6.2 插入设备序列号（DSN）](#62-插入设备序列号dsn)\n7. [Vivado项目设置与定制](#7-vivado项目设置与定制)\n   * [7.1 生成Vivado项目文件](#71-生成vivado项目文件)\n   * [7.2 修改IP核](#72-修改ip核)\n\n### **第二部分：中级概念与实现**\n\n8. [高级固件定制](#8-高级固件定制)\n   * [8.1 配置PCIe参数以进行仿真](#81-配置pcie参数以进行仿真)\n   * [8.2 调整BARs和内存映射](#82-调整bars和内存映射)\n   * [8.3 仿真设备电源管理和中断](#83-仿真设备电源管理和中断)\n9. [仿真设备特定功能](#9-仿真设备特定功能)\n   * [9.1 实现高级PCIe功能](#91-实现高级pcie功能)\n   * [9.2 仿真厂商特定功能](#92-仿真厂商特定功能)\n10. [事务层数据包（TLP）仿真](#10-事务层数据包tlp仿真)\n    * [10.1 理解和捕获TLP](#101-理解和捕获tlp)\n    * [10.2 制作用于特定操作的定制TLP](#102-制作用于特定操作的定制tlp)\n\n### **第三部分：高级技术与优化**\n\n11. [构建、烧录与测试](#11-构建烧录与测试)\n    * [11.1 综合与实现](#111-综合与实现)\n    * [11.2 烧录比特流](#112-烧录比特流)\n    * [11.3 测试与验证](#113-测试与验证)\n12. [高级调试技术](#12-高级调试技术)\n    * [12.1 使用Vivado的集成逻辑分析仪](#121-使用vivado的集成逻辑分析仪)\n    * [12.2 PCIe流量分析工具](#122-pcie流量分析工具)\n13. [故障排除](#13-故障排除)\n    * [13.1 设备检测问题](#131-设备检测问题)\n    * [13.2 内存映射和BAR配置错误](#132-内存映射和bar配置错误)\n    * [13.3 DMA性能和TLP错误](#133-dma性能和tlp错误)\n14. [仿真精度与优化](#14-仿真精度与优化)\n    * [14.1 精确定时仿真技术](#141-精确定时仿真技术)\n    * [14.2 对系统调用的动态响应](#142-对系统调用的动态响应)\n15. [固件开发最佳实践](#15-固件开发最佳实践)\n    * [15.1 持续测试与文档](#151-持续测试与文档)\n    * [15.2 管理固件版本](#152-管理固件版本)\n    * [15.3 安全注意事项](#153-安全注意事项)\n16. [其他资源](#16-其他资源)\n17. [联系方式](#17-联系方式)\n18. [支持与贡献](#18-支持与贡献)\n\n---\n\n## **第一部分：基础概念**\n\n---\n\n## **1. 引言**\n\n### **1.1 本指南的目的**\n\n本指南的总体目标是让您掌握开发基于现场可编程门阵列（FPGA）设备的定制直接内存访问（DMA）固件的知识和实践技能。这种专用固件允许您的FPGA精确地仿真其他PCIe（Peripheral Component Interconnect Express）硬件设备的身份和行为。这种仿真是一种强大的技术，在多个高级领域具有深远意义：\n\n**硬件安全研究**：\n\n* **漏洞发现**：通过仿真设备，您可以创建一个受控环境，向主机驱动程序发送格式错误或意外数据，系统性地进行模糊测试，以发现可能通过硬件外设利用的漏洞（例如，缓冲区溢出、竞态条件）。\n* **驱动程序分析**：观察操作系统和特定驱动程序如何与硬件交互。您可以仿真具有非标准配置或未文档化功能的设备，以了解驱动程序行为、识别安全假设或逆向工程专有协议。\n* **侧信道分析**：虽然更复杂，但仿真设备可以通过精确控制外设操作，潜在地协助进行与通过时序或功耗分析进行信息泄漏相关的实验。\n\n**红队演练与渗透测试**：\n\n* **绕过安全措施**：仿真一个看似良性或白名单的硬件设备（例如，一个常见的网卡或存储控制器），以获取DMA权限。一旦实现，这允许直接与系统内存交互，可能绕过在更高软件层运行的端点检测和响应（EDR）系统或反恶意软件解决方案。\n* **隐蔽持久性**：仿真恶意设备可以提供一种隐蔽的方式来维护对受损系统的访问，因为它可能比基于软件的植入物更难检测。\n* **利用信任关系**：系统通常对连接的硬件有隐式信任。定制固件可以通过模仿被授予特定权限或访问的设备来利用这一点。\n\n**系统调试与诊断**：\n\n* **可复现的测试平台**：创建高度特定的硬件场景，以可靠地复现可能仅在特定设备状态或数据模式下发生的难以捉摸的错误。\n* **故障注入**：故意仿真有缺陷的设备行为（例如，错误的TLP形成、延迟响应），以测试主机系统及其驱动程序的健壮性和错误处理能力。\n\n**硬件测试与验证**：\n\n* **驱动程序开发**：在物理原型可用之前，或为了模拟比物理可访问的更广泛的硬件变体，针对仿真硬件配置文件测试新的或修改的驱动程序。\n* **合规性测试**：虽然不能替代官方合规性测试，但仿真设备可以帮助预验证PCIe协议遵守的某些方面。\n\n**传统系统支持与互操作性**：\n\n* 仿真老旧、停产或难以采购的PCIe设备，以保持传统系统运行或弥合不同硬件代之间的兼容性差距。\n\n通过学习本指南，您将熟练掌握：\n\n* 精细地从物理“捐赠”PCIe设备中提取识别属性和配置细节。\n* 修改和扩展现有开源FPGA固件框架（主要关注广泛使用的PCILeech-FPGA项目），以采用捐赠设备的身份。\n* 配置和利用以Xilinx Vivado为核心的专业FPGA开发工具链，以及Visual Studio Code等基本代码编辑工具。\n* 对PCIe架构的分层模型、DMA数据传输机制以及低级别复制硬件行为的固件开发细微之处，形成扎实的理解。\n\n### **1.2 目标读者**\n\n本指南专为已具备计算机系统、硬件原理和软件开发基础到中级知识的个人量身定制。内容技术性强，并假定读者具备进行详细、低级别工作的能力。具体来说，它面向以下人群：\n\n* **固件开发人员**：旨在为FPGA设计或改编固件的工程师，特别是涉及高速数据传输（DMA）和通过PCIe直接硬件接口操作的应用。强烈建议具备Verilog/VHDL背景和FPGA开发工具经验。\n* **硬件工程师**：参与PCIe硬件设计、测试或验证的专业人员。本指南可以帮助创建复杂的测试线束或在更大的系统设计中仿真组件。预计熟悉PCIe协议和数字设计。\n* **网络安全专业人员与研究人员**：\n  * **漏洞研究员与漏洞利用开发人员**：希望探索硬件级攻击面或开发利用DMA的概念验证漏洞。操作系统内部、内存管理和驱动程序架构的理解至关重要。\n  * **红队成员**：寻求通过直接硬件操作来获取系统访问、持久性和数据窃取的先进技术操作员。\n  * **数字取证与事件响应人员**：虽然本指南侧重于攻击，但理解这些技术有助于识别和分析复杂的基于硬件的攻击。\n* **FPGA爱好者与高级业余爱好者**：有FPGA项目经验，渴望应对PCIe通信和硬件仿真等复杂挑战的个人。愿意深入研究数据手册和技术规范是关键。\n\n学习曲线可能很陡峭，特别是如果PCIe或高级FPGA概念是新知识。然而，本指南旨在将复杂主题分解为可管理的步骤。\n\n### **1.3 如何使用本指南**\n\n本指南分为三个逻辑递进的部分，旨在逐步构建您的知识：\n\n* **第一部分：基础概念**：这第一部分至关重要。它介绍了核心术语、PCIe和DMA的基本原理、必要的硬件和软件堆栈（包括Xilinx Vivado和PCILeech-FPGA框架等工具的设置说明），以及从目标“捐赠”设备获取重要信息和进行基本固件修改的初始程序。强烈建议按顺序彻底学习本部分。\n* **第二部分：中级概念与实现**：（后续章节）在基础知识之上，本部分将引导您进行更高级的固件定制。主题将包括微调PCIe操作参数、仿真设备特定寄存器和功能（如电源管理状态和消息信号中断 - MSI/MSI-X），以及初步理解事务层数据包（TLP）的构建和解释。\n* **第三部分：高级技术与优化**：（后续章节）最后一部分将探讨复杂的调试方法（包括使用集成逻辑分析仪 - ILA和外部PCIe协议分析仪）、优化固件性能和仿真精度的技术、常见和复杂问题的全面故障排除，以及关于最佳实践的关键讨论，特别关注开发和部署仿真PCIe设备的安全影响。\n\n**学习本指南的步骤**：\n\n* **顺序学习**：特别是对于第一部分和第二部分，请按顺序学习各节，因为后面的概念建立在前面的基础之上。\n* **动手实践**：这是一份实践指南。请在您自己的硬件上积极执行设置步骤、代码修改和实验。\n* **适应您的环境**：文件路径、特定设备ID和软件版本可能有所不同。理解指令背后的概念，以使其适应您的特定设置。\n* **查阅外部资源**：PCIe规范和FPGA文档是您的最终参考。本指南进行简化和引导，但深入研究通常需要查阅原始资料。\n* **迭代开发**：固件开发很少是线性的。预期会进行迭代、调试和改进您的设计。广泛使用故障排除部分和调试技术。\n\n您将使用HDL（PCILeech-FPGA中的SystemVerilog）、FPGA综合和实现工具（Vivado），并可能使用主机端编程工具和PCIe分析实用程序。\n\n---\n\n## **2. 关键定义**\n\n牢固掌握以下术语对于理解PCIe设备仿真和定制固件开发的复杂性至关重要。这些术语将在整个指南中广泛使用。\n\n* **DMA (Direct Memory Access)**  (直接内存访问)：\n\n  * **定义**：现代计算机体系结构的一项基本功能，允许硬件外设（如网卡、GPU或您的基于FPGA的仿真设备）直接读取和写入主系统内存（RAM），而无需CPU参与每个字节的传输。\n  * **重要性**：DMA对于高性能I/O操作至关重要。通过将数据传输任务从CPU卸载，它使CPU能够执行其他计算，显著提高整体系统吞吐量和效率。在本指南中，您的FPGA将利用DMA与主机系统的内存进行交互，这是一种在安全研究和红队演练中经常被利用的强大功能。\n* **PCIe (Peripheral Component Interconnect Express)**  (外围组件互连高速)：\n\n  * **定义**：一种高速串行计算机扩展总线标准，旨在取代旧的总线标准，如PCI、PCI-X和AGP。它采用点对点拓扑结构，每个设备通过独立的串行链路连接到根联合体（通常是芯片组或CPU的一部分）。通信通过数据包进行。\n  * **重要性**：PCIe是连接高性能外设到主板的主导标准。理解其协议、分层架构（物理层、数据链路层、事务层）和配置机制对于仿真任何现代硬件设备至关重要。\n* **TLP (Transaction Layer Packet)**  (事务层数据包)：\n\n  * **定义**：PCIe协议事务层的数据交换基本单位。TLP负责在PCIe设备之间传输请求（例如，内存读/写、I/O读/写、配置读/写）和完成（对请求的响应）。每个TLP由一个报头、一个可选的数据有效载荷和一个可选的端到端CRC（ECRC）组成。\n  * **重要性**：为了精确仿真设备，您的FPGA固件必须能够正确地形成、传输、接收和解释与捐赠设备行为匹配的TLP。理解TLP类型、格式和流控制对于高级仿真至关重要。\n* **BAR (Base Address Register)**  (基地址寄存器)：\n\n  * **定义**：位于PCIe设备的配置空间内，BAR是特殊的寄存器，设备通过它们向主机系统请求地址空间资源。一个设备最多可以有六个32位BAR（或更少，或成对的32位BAR可以形成64位BAR）。这些寄存器定义了设备用于向主机CPU公开其寄存器和内部内存的内存映射I/O（MMIO）区域或I/O端口区域的起始地址和大小。\n  * **重要性**：当主机系统枚举PCIe设备时，它会读取BAR以确定设备的内存和I/O要求，然后分配并用系统中物理地址图中的实际基地址来编程这些BAR。您的仿真设备必须精确定义其BAR以匹配捐赠设备，以便主机操作系统和驱动程序能够正确地与其交互。\n* **FPGA (Field-Programmable Gate Array)**  (现场可编程门阵列)：\n\n  * **定义**：一种集成电路（IC），可以在制造后由设计者或客户进行配置——因此称为“现场可编程”。FPGA包含一个可编程逻辑块阵列和可重构互连的层次结构，允许这些块“连接”起来以实现定制数字逻辑电路。\n  * **重要性**：FPGA是本指南中使用的核心硬件。其可重构特性使其成为仿真其他硬件设备的理想选择，因为您可以定义精确的逻辑和接口来模仿捐赠设备的PCIe存在和行为。\n* **MSI/MSI-X (Message Signaled Interrupts / Message Signaled Interrupts Extended)**  (消息信号中断 / 扩展消息信号中断)：\n\n  * **定义**：允许PCIe设备通过向系统定义的内存地址写入特殊消息（TLP，特别是内存写入TLP）来向CPU传递中断的机制，而不是使用专用的物理中断线（如传统PCI）。MSI-X是MSI的增强版，提供更多的中断向量和更大的灵活性。\n  * **重要性**：大多数现代PCIe设备使用MSI或MSI-X以实现更高效、更灵活的中断处理。精确仿真通常需要实现捐赠设备选择的中断机制，包括配置MSI/MSI-X能力结构并正确生成中断消息。\n* **DSN (Device Serial Number)**  (设备序列号)：\n\n  * **定义**：一个64位全局唯一标识符，可由PCIe设备可选实现。如果存在，它通常位于设备配置空间内的扩展能力结构中。\n  * **重要性**：虽然并非所有设备都具有DSN，但某些驱动程序或管理软件可能会使用它进行唯一标识、许可或跟踪。正确仿真它对于完全透明和避免检测到仿真设备可能很重要。\n* **PCIe Configuration Space** (PCIe配置空间)：\n\n  * **定义**：与每个PCIe功能（一个设备可以有多个功能）关联的标准化256字节（对于Type 0、端点设备）或4KB地址区域。此空间包含有关设备的重要信息，包括其厂商ID、设备ID、类别代码、修订ID、BAR、能力指针以及各种状态和控制寄存器。主机系统使用特殊的配置读和配置写TLP访问此空间。\n  * **重要性**：配置空间是PCIe设备的“身份证”。设备仿真的第一步就是将捐赠设备配置空间的相关部分精确复制到您的FPGA固件中。主机系统使用此信息来识别、配置和分配资源给设备。\n* **Donor Device** (捐赠设备)：\n\n  * **定义**：您旨在在FPGA上仿真其身份和行为的物理PCIe硬件设备。该设备作为提取配置细节（厂商ID、设备ID、BAR设置、能力等）和行为模式的来源。\n  * **重要性**：您的仿真 fidelity 直接取决于您能够多么精确和完整地收集并复制捐赠设备的特性。\n* **Root Complex (RC)**  (根联合体)：\n\n  * **定义**：PCIe层级结构中将CPU和内存子系统连接到PCIe结构的实体。它代表CPU生成PCIe事务，并处理下游PCIe设备发起的事务。它还执行初始的总线枚举和配置。\n  * **重要性**：您的仿真设备在与主机系统通信时，将主要与根联合体（或与其连接的交换机）交互。\n* **Endpoint (EP)**  (端点)：\n\n  * **定义**：位于PCIe结构外围，消费或生产数据的一种PCIe设备。示例包括网卡、显卡、存储控制器以及您将要编程的FPGA设备。端点请求资源并向根联合体发起事务。\n  * **重要性**：在本指南中，您的FPGA将被编程为充当一个端点设备，仿真一个特定的捐赠端点。\n* **HDL (Hardware Description Language)**  (硬件描述语言)：\n\n  * **定义**：一种专用计算机语言，用于描述电子电路的结构、设计和操作，特别是数字逻辑电路。常见的HDL包括Verilog和VHDL。\n  * **重要性**：您将在PCILeech-FPGA项目中使用Verilog（特别是SystemVerilog，Verilog的扩展）来定义仿真设备的定制逻辑。\n* **Bitstream** (比特流)：\n\n  * **定义**：加载到FPGA上的最终配置文件，用于编程其逻辑块和互连，从而实现您的定制硬件设计。它是FPGA开发工具（如Xilinx Vivado）的编译输出。\n  * **重要性**：生成和烧录正确的比特流是将定制固件部署到FPGA的最终步骤。\n\n---\n\n## **3. 设备兼容性**\n\n成功且精确的PCIe设备仿真取决于确保您选择的基于FPGA的硬件和主机系统配置完全兼容。本节详细介绍了支持的FPGA平台、关键的PCIe硬件注意事项以及设置开发环境所需的系统要求。\n\n### **3.1 支持的基于FPGA的硬件**\n\n虽然本指南提供了一种可适用于各种基于FPGA的DMA硬件的通用方法，但我们的主要示例和具体说明将侧重于 **Xilinx 7系列FPGA**，由于其性能和可访问性的平衡，它们在开源DMA板中很常见。**Squirrel DMA (35T)**  卡因其受欢迎程度以及与PCILeech-FPGA框架的良好兼容性而受到强调。\n\n定制PCIe IP核和开发硬件描述语言（HDL）逻辑的核心原则和技术广泛适用于以下FPGA系列和特定板卡：\n\n* **Squirrel (Artix-7 35T)**\n  * **描述**：一种广泛可用且经济高效的基于FPGA的DMA设备，采用Xilinx Artix-7 35T FPGA。它为标准内存采集任务以及各种基本到中级设备仿真项目提供了足够的逻辑资源和内存。它是初次接触基于FPGA的DMA的优秀起点。\n  * **主要特点**：Artix-7提供了良好的性能价格比，适用于教育和研究目的。\n* **Enigma-X1 (Artix-7 75T)**\n  * **描述**：与35T相比，提供增强的逻辑和内存资源的中级FPGA，通常基于Xilinx Artix-7 75T FPGA。这为更复杂的仿真场景、更大的内存映射区域或需要额外FPGA逻辑的更复杂的DMA操作提供了更大的灵活性。\n  * **主要特点**：增加的逻辑单元和块RAM（BRAM）支持更复杂的设计。\n* **ZDMA (Artix-7 100T)**\n  * **描述**：基于更高性能的Artix-7 100T FPGA，针对要求更高的内存交互和大量的读/写操作进行了优化。此板卡适用于大规模DMA解决方案、高吞吐量仿真或需要大量片上内存的项目。\n  * **主要特点**：100T变体在资源方面提供了显著升级，是突破仿真界限的理想选择。\n* **Kintex-7 (K325T, K410T等)**\n  * **描述**：代表高级别，Kintex-7 FPGA（例如K325T、K410T）为高度复杂的项目、大规模DMA解决方案以及需要更高PCIe通道数或速度（例如，Gen3 x8/x16）的应用提供了强大的功能。虽然价格更昂贵，但它们提供了更多的逻辑、DSP切片和内存，从而能够仿真高度复杂和苛刻的捐赠设备。\n  * **主要特点**：用于更快PCIe世代的高性能收发器，丰富的逻辑和内存资源，适用于复杂设计。\n\n**关于FPGA系列的重要说明**：尽管原理相似，但不同的Xilinx 7系列FPGA（Artix-7、Kintex-7、Zynq-7000 PS/PL）之间，特定的IP核配置和时钟结构可能略有不同。请始终参考特定板卡文档和您所选FPGA系列的Xilinx PCIe IP核用户指南。PCILeech-FPGA项目通常提供板卡特定的Tcl脚本和源文件以简化此过程。\n\n### **3.2 PCIe硬件注意事项**\n\n为了确保基于FPGA的DMA设备在仿真中平稳无限制地运行，需要仔细考虑一些PCIe特定和主机系统功能，并在某些情况下进行修改。\n\n* **IOMMU / VT-d / AMD-Vi 设置**\n  * **建议**：对于初始设置和测试，**强烈建议在系统的BIOS/UEFI设置中禁用IOMMU（Intel的定向I/O虚拟化技术 - VT-d）或AMD的等效技术（AMD-Vi）** 。\n  * **理由**：IOMMU是为DMA功能设备提供内存管理单元的硬件组件。它们执行地址转换，类似于CPU的MMU，并且可以强制执行内存访问权限。虽然它们对于安全和虚拟化（防止恶意设备访问未经授权的内存区域）至关重要，但它们**会**限制DMA设备对系统内存的访问，可能干扰内存采集和设备仿真。禁用IOMMU允许DMA设备不受限制地访问内存，这对于高级仿真和安全研究目的通常是必要的。\n  * **位置**：通常在BIOS/UEFI中的“CPU Configuration”、“Virtualization”、“Advanced Settings”或“I/O Virtualization”下找到。\n* **内核DMA保护（Windows）/ Thunderbolt安全级别（Linux）**\n  * **建议（Windows）** ：在现代Windows系统中禁用**内核DMA保护**功能。这包括**基于虚拟化的安全性（VBS）**和**内存完整性（HVCI）**等设置。这些功能利用IOMMU来防止通过Thunderbolt或PCIe连接的外部外设进行未经授权的DMA攻击。\n  * **步骤（Windows）** ：\n    * 访问Windows安全设置：**开始 &gt; 设置 &gt; 隐私和安全性 &gt; Windows 安全中心 &gt; 设备安全性**。\n    * 在“核心隔离”下，点击“核心隔离详细信息”。\n    * 关闭“内存完整性”。\n    * 您可能还需要在BIOS/UEFI中禁用安全启动，因为VBS通常依赖于它。\n    * **注意**：禁用这些功能会显著**降低您系统的安全态势**，使其容易受到包括涉及恶意DMA设备的各种攻击。这应该只在专用测试系统上进行，而不是在您的主机器上，并且在您了解风险的安全、隔离环境中进行。\n  * **建议（Linux/Thunderbolt）** ：如果使用带有Thunderbolt端口的系统，请了解并可能调整BIOS/UEFI中的**Thunderbolt安全级别**。较低的安全级别（例如，“无安全”、“用户授权”）通常是任意Thunderbolt/PCIe设备在未经明确主机批准的情况下执行DMA所必需的。\n* **PCIe插槽要求**\n  * **建议**：使用与FPGA设备要求物理匹配的兼容PCIe插槽。大多数基于Artix-7的DMA卡在PCIe Gen2 x1或x4下运行。\n  * **理由**：\n    * **物理匹配**：x1卡可以插入x1、x4、x8或x16插槽，但x4卡至少需要x4插槽。\n    * **性能**：虽然x4卡*可能*在x1插槽中工作（如果物理连接是开放式或已修改的），但它将以x1速度运行，严重限制数据传输速率。为了获得最佳性能和精确仿真捐赠设备的功能，请确保FPGA板卡安装在提供至少*仿真*链路宽度和速度的插槽中（例如，如果您要仿真Gen2 x4设备，请在主机上使用Gen2 x4插槽）。\n  * **主板BIOS设置**：一些主板允许配置PCIe插槽速度（例如，强制Gen1或Gen2）。确保这些设置不与您期望的仿真速度冲突。\n\n### **3.3 系统要求**\n\n建立一个健壮的开发环境对于高效的固件开发、综合和调试至关重要。\n\n* **主机系统**\n  * **处理器**：现代多核CPU对于运行Vivado等FPGA开发工具至关重要，这些工具在综合和实现过程中计算密集。（例如，Intel Core i5/i7/i9 或 AMD Ryzen 5/7/9 等效处理器，建议8代或更新）。\n  * **内存（RAM）** ：强烈建议最低16 GB RAM；对于复杂FPGA设计，**32 GB 或更高是理想选择**，因为Vivado会消耗大量内存，尤其是在实现阶段。\n  * **存储**：一个固态硬盘（SSD）并至少有 **200 GB 的可用空间** 至关重要。FPGA工具安装（仅Vivado就可能超过50 GB）、项目文件以及综合/实现输出会迅速占用磁盘空间。SSD的速度能显著缩短构建时间。\n  * **操作系统**：\n    * **Windows 10/11 (64位 专业版或企业版)** ：Xilinx Vivado 和许多硬件调试工具广泛支持。请记住内核DMA保护的注意事项。\n    * **兼容的Linux发行版 (64位)** ：Ubuntu LTS（长期支持）版本（例如 20.04、22.04）是Vivado常用且支持良好的系统。Linux通常为脚本编写和低级PCIe交互工具提供更灵活的环境。\n* **外围设备**\n  * **JTAG编程器**：将编译后的比特流烧录到基于FPGA的DMA卡上绝对必需。示例包括Xilinx Platform Cable USB II、Digilent JTAG-HS3 或某些开发板上集成的JTAG编程器。确保它与您的FPGA板卡和Vivado兼容。\n  * **PCIe插槽**：如第3.2节所述，确保您的主机系统有可用的兼容PCIe插槽用于DMA卡。\n  * **USB端口**：用于连接JTAG编程器，并可能用于连接FPGA板卡的UART/串行控制台以进行调试输出。\n\n---\n\n## **4. 要求**\n\n本节概述了进行PCIe设备仿真定制固件开发所必需的基本硬件和软件组件，以及推荐的环境设置。在开始之前，具备这些先决条件将简化您的开发过程。\n\n### **4.1 硬件**\n\n* **捐赠PCIe设备**\n  * **目的**：这是您打算在FPGA上仿真其配置和行为的物理硬件设备。它作为关键识别细节、寄存器值和操作特性的权威来源。\n  * **示例**：常见示例包括标准网卡（NIC）、SATA或NVMe存储控制器、USB控制器，或任何其他您可以安全地从系统中移除进行分析的通用PCIe扩展卡。强烈建议使用对系统操作非必需的设备，因为您将检查其低级配置。\n* **DMA FPGA卡**\n  * **描述**：一种基于FPGA的开发板，专门设计或改编用于通过PCIe接口执行直接内存访问（DMA）操作。这是您的定制固件将加载到的平台。\n  * **示例**：如第3.1节所述，兼容卡包括 **Squirrel (Artix-7 35T)** 、**Enigma-X1 (Artix-7 75T)** 、**ZDMA (Artix-7 100T)**  或各种基于 **Kintex-7** 的解决方案。确保您选择的卡具有PCIe金手指连接器。\n* **JTAG编程器**\n  * **目的**：这个关键工具促进了您的开发PC与DMA卡上FPGA之间的通信。它用于将编译后的比特流编程（烧录）到FPGA上，更重要的是，用于使用Vivado的硬件管理器和集成逻辑分析仪（ILA）等工具进行交互式调试。\n  * **示例**：\n    * **Xilinx Platform Cable USB II**：Xilinx FPGA传统且广泛兼容的编程器。确保您已安装必要的驱动程序。\n    * **Digilent JTAG-HS3 / JTAG-HS2**：流行且可靠的编程器，以良好的Vivado集成和支持而闻名。HS3提供更快的编程速度。\n    * **集成JTAG**：某些FPGA板可能具有板载USB转JTAG桥（例如FTDI芯片），这消除了对独立编程器的需求。请查阅您的板卡文档。\n\n### **4.2 软件**\n\n* **Xilinx Vivado Design Suite**\n  * **描述**：Xilinx（现为AMD）官方的、全面的FPGA开发环境。Vivado对于综合您的HDL代码、将设计实现到目标FPGA上、生成最终比特流以及执行硬件调试至关重要。它包括必要的IP核、编译器和实用程序。\n  * **下载**：访问Xilinx（AMD）官方下载页面：[https://www.xilinx.com/support/download.html](https://www.xilinx.com/support/download.html)。\n  * **版本说明**：虽然一些旧指南可能引用Vivado 2020.1等旧版本，但强烈建议下载与您的目标FPGA系列（Artix-7、Kintex-7）兼容的**最新稳定版本**（例如Vivado 2023.x或更高版本）。PCILeech-FPGA项目通常支持较新的Vivado版本。\n* **Visual Studio Code**\n  * **描述**：Microsoft出品的高度可定制且功能丰富的代码编辑器。它是编写和编辑Verilog/SystemVerilog HDL代码的绝佳选择，因为它拥有广泛的扩展生态系统，提供语法高亮、代码检查、自动补全和版本控制集成等功能。\n  * **下载**：[https://code.visualstudio.com/](https://code.visualstudio.com/)\n* **PCILeech-FPGA**\n  * **描述**：一个用于基于FPGA的DMA开发的开源框架和基础代码库。它提供了即插即用的PCIe IP核实例化和一个结构良好的项目，是定制固件的绝佳起点。本指南将大量利用其架构。\n  * **仓库**：[https://github.com/ufrisk/pcileech-fpga](https://github.com/ufrisk/pcileech-fpga)\n* **Arbor (MindShare)**\n  * **描述**：一款强大且用户友好的软件工具，专门设计用于深入扫描和分析PCIe设备。它提供了对连接PCIe硬件的配置空间、功能和寄存器的详细洞察，对于收集捐赠设备信息来说非常有价值。\n  * **下载**：可从MindShare网站获取：[https://www.mindshare.com/](https://www.mindshare.com/)（您可能需要导航到他们的软件部分）。\n  * **注意**：通常需要创建账户，并且可能提供限时试用。\n* **替代PCIe设备分析工具**\n  * **Telescan PE (Teledyne LeCroy)** ：\n    * **描述**：Teledyne LeCroy提供的一款免费PCIe流量分析和设备枚举工具。虽然它主要是一款与其硬件协议分析仪交互的软件工具，但它也可以在没有专用硬件的情况下提供一些基本的配置空间视图。\n    * **下载**：[https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software](https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software)\n    * **注意**：需要手动注册和批准才能下载。\n  * **OS原生工具（用于基本检查）** ：\n    * **Windows设备管理器**：在设备属性的“详细信息”选项卡下提供基本的厂商ID、设备ID、子系统ID和类别代码信息。\n    * **Linux **​**​`lspci`​**​ ** 工具**：一个强大的命令行工具，用于检查PCIe设备。使用`lspci -nn`查看厂商/设备ID，`lspci -vvv`查看包括BAR和功能在内的详细信息，`lspci -s <BUS:DEV.FUN> -xxxx`用于原始配置空间转储。\n\n### **4.3 环境设置**\n\n一个干净且正确配置的开发环境对于避免常见陷阱并确保流畅的工作流程至关重要。\n\n#### **4.3.1 安装Xilinx Vivado设计套件**\n\n**步骤**：\n\n1. **访问Xilinx (AMD) Vivado下载页面**：[https://www.xilinx.com/support/download.html](https://www.xilinx.com/support/download.html)。\n2. **下载适当版本**：选择与您的操作系统兼容的最新稳定版Vivado，更重要的是，它必须与您的特定FPGA设备（例如Artix-7、Kintex-7）兼容。查阅Vivado发行说明以了解设备支持情况。\n3. **运行安装程序**：执行下载的安装程序并仔细遵循屏幕上的说明。\n4. **选择必要组件**：在安装过程中，系统会提示您选择要安装的设备家族。**至关重要的是，选择与您的FPGA板卡对应的设备家族（例如，Artix-7/Kintex-7的“7 Series”）** 。这与安装所有家族相比，能节省大量磁盘空间。确保您选择“设计工具”（综合、实现）和“编程与调试”组件。\n5. **启动Vivado**：安装完成后，启动Vivado以确认它能无错误打开，并且许可证（如果适用）已正确配置。\n\n#### **4.3.2 安装Visual Studio Code**\n\n**步骤**：\n\n1. **访问Visual Studio Code下载页面**：[https://code.visualstudio.com/](https://code.visualstudio.com/)。\n2. **下载并安装**：下载适用于您操作系统的安装程序，并遵循标准安装提示。\n3. **安装HDL支持扩展**：安装VS Code后，打开它并导航到扩展视图（Ctrl+Shift+X或Cmd+Shift+X）。搜索并安装适用于Verilog/SystemVerilog的相关扩展，例如：\n   * **Verilog-HDL/SystemVerilog** (由mshr-h提供)\n   * **VHDL** (如果您也使用VHDL)\n     这些扩展提供了语法高亮、代码检查和其他有用的功能。\n\n#### **4.3.3 克隆PCILeech-FPGA仓库**\n\n此仓库包含您将要修改的基础固件结构和脚本。\n\n**步骤**：\n\n1. **打开终端或命令提示符**：（例如，Windows上的Git Bash，Linux上的Terminal）。\n2. **导航到您想要的目录**：选择一个您想存储项目的位置。\n   ```bash\n   cd ~/Projects/ # 在Linux/macOS上\n   cd C:\\Users\\YourUsername\\Documents\\Projects\\ # 在Windows上\n   ```\n3. **克隆仓库**：\n   ```bash\n   git clone https://github.com/ufrisk/pcileech-fpga.git\n   ```\n4. **导航到克隆的目录**：\n   ```bash\n   cd pcileech-fpga\n   ```\n\n   这将是您的主项目目录。PCILeech-FPGA项目通常包含不同板卡变体的子目录（例如`pcileech-artix-7-50t`、`pcileech-squirrel-35t`）。您将根据您的特定硬件导航到相关的板卡特定目录。\n\n#### **4.3.4 设置一个干净的开发环境**\n\n**建议**：始终在隔离或专用的环境中工作，尤其是在处理低级硬件和潜在的安全隐患时。\n\n**步骤**：\n\n1. **使用专用开发机或虚拟机**：\n   * **物理机**：如果可能，使用一台单独的物理计算机进行FPGA开发和测试。这可以防止在您的主机器上发生意外的系统不稳定或安全风险。\n   * **虚拟机（VM）** ：虚拟机可以是隔离开发环境的好选择。然而，通常需要向虚拟机进行直接PCIe直通（PCIe热插拔或VT-d直通），FPGA卡才能被正确检测和操作，这可能配置复杂，并且如果操作不当，仍然可能暴露主机。对于初始工具安装和代码编辑，虚拟机完全没问题。\n2. **最小化后台应用程序**：确保没有其他资源密集型应用程序正在运行，这些应用程序可能会干扰Vivado在综合和实现过程中的性能。\n3. **禁用冲突软件**：在开发和测试期间，暂时禁用任何可能干扰低级硬件访问或JTAG通信的防病毒、防火墙或安全软件。完成工作后请记得重新启用它们。\n\n---\n\n## **5. 收集捐赠设备信息**\n\n精确的设备仿真取决于精细地提取和复制捐赠设备的关键信息。这种全面的数据收集使您的FPGA能够忠实地模仿目标硬件的PCIe配置和行为，确保与主机系统接口时的兼容性和功能性。\n\n### **5.1 使用Arbor进行PCIe设备扫描**\n\n**Arbor** 是一款强大且用户友好的工具，专为深入扫描PCIe设备而设计。它提供了对连接硬件配置空间的详细洞察，使其成为提取设备仿真所需信息的宝贵资源。\n\n#### **5.1.1 安装Arbor**\n\n要开始使用Arbor进行设备扫描，您必须首先在系统上安装该软件。\n\n**步骤：**\n\n1. **访问Arbor下载页面：**\n   * 使用您偏好的网页浏览器导航到MindShare官方网站（[https://www.mindshare.com/](https://www.mindshare.com/)）。您需要找到他们的“Software”或“Downloads”部分来定位Arbor。\n   * 确保您直接访问该网站，以避免任何恶意重定向。\n2. **创建账户（如果需要）：**\n   * Arbor可能要求您创建用户账户才能访问下载链接。\n   * 提供必要的信息，例如您的姓名、电子邮件地址和组织。\n   * 如果出现提示，请验证您的电子邮件以激活您的账户。\n3. **下载Arbor：**\n   * 登录后，找到Arbor的下载部分。\n   * 选择与您的操作系统兼容的版本（例如，Windows 10/11 64位）。\n   * 点击 **Download** 按钮并将安装程序保存到计算机上已知的位置。\n4. **安装Arbor：**\n   * 找到下载的安装程序文件（例如，`ArborSetup.exe`）。\n   * 右键单击安装程序并选择 **以管理员身份运行** 以确保它具有必要的权限。\n   * 按照屏幕上的说明完成安装过程。\n     * 接受许可协议。\n     * 选择安装目录。\n     * 如果需要，选择创建桌面快捷方式。\n5. **验证安装：**\n   * 安装完成后，确保Arbor列在您的“开始”菜单或桌面上。\n   * 启动Arbor以确认它能无错误打开。\n\n#### **5.1.2 扫描PCIe设备**\n\n安装Arbor后，您可以继续扫描系统中的PCIe设备。\n\n**步骤：**\n\n1. **启动Arbor：**\n   * 双击桌面上的Arbor图标或通过“开始”菜单找到它。\n   * 如果用户账户控制（UAC）提示，允许应用程序对设备进行更改。\n2. **导航到本地系统选项卡：**\n   * 在Arbor界面中，找到导航窗格或选项卡。\n   * 单击 **Local System** 以访问扫描本地机器的工具。\n3. **扫描PCIe设备：**\n   * 查找 **Scan** 或 **Rescan** 按钮，通常位于界面的顶部或底部。\n   * 点击 **Scan/Rescan** 以启动检测过程。\n   * 等待扫描过程完成；这可能需要几分钟，具体取决于连接的设备数量。\n4. **审查检测到的设备：**\n   * 扫描完成后，Arbor将显示所有检测到的PCIe设备的列表。\n   * 设备通常会列出其名称、设备ID和其他识别信息。\n\n#### **5.1.3 识别捐赠设备**\n\n识别正确的捐赠设备对于精确仿真至关重要。\n\n**步骤：**\n\n1. **在列表中找到您的捐赠设备：**\n   * 滚动浏览Arbor检测到的设备列表。\n   * 查找与您的捐赠硬件的品牌和型号匹配的设备。\n   * 设备可能按其厂商名称、设备类型或功能列出。\n2. **验证设备详细信息：**\n   * 单击设备以选中它。\n   * 确认 **Device ID** 和 **Vendor ID** 与您的捐赠设备匹配。\n     * **提示：**  这些ID通常可以在设备文档或制造商网站上找到。对于常见设备，快速在网上搜索“\\[设备名称] Vendor ID Device ID”通常能得到结果。\n3. **查看详细配置：**\n   * 选中设备后，找到并单击类似 **View Details** 或 **Properties** 的选项。\n   * 这将打开一个详细视图，显示设备的配置空间和功能。\n4. **与物理硬件交叉引用：**\n   * 如果列出了多个类似设备，请将 **Slot Number** 或 **Bus Address** 与安装捐赠设备的物理插槽交叉引用。这有助于确认您正在分析正确的硬件。\n\n#### **5.1.4 捕获设备数据**\n\n从捐赠设备中提取详细信息对于精确仿真至关重要。\n\n**要提取的信息：**\n\n* **设备ID (0xXXXX)：**  唯一标识设备型号的16位标识符。\n* **厂商ID (0xYYYY)：**  分配给制造商的16位标识符。\n* **子系统ID (0xZZZZ)：**  标识特定子系统或变体（例如，产品线中的特定型号）。\n* **子系统厂商ID (0xWWWW)：**  标识子系统的厂商（通常与主厂商ID相同，但对于OEM版本可能会有所不同）。\n* **修订ID (0xRR)：**  指示设备的硬件修订级别。\n* **类别代码 (0xCCCCCC)：**  一个24位代码，定义设备的主要功能/类型（例如，`0x020000`用于以太网控制器，`0x010802`用于NVMe控制器）。这有助于操作系统加载通用驱动程序。\n* **基地址寄存器 (BARs)：**\n  * 定义设备使用的内存或I/O地址区域的寄存器。\n  * 包括BAR0到BAR5，每个都可能是32位或64位。对于每个BAR，请记录其 **类型（内存或I/O）** 、**位宽（32位或64位）** 、**大小（例如，256 MB，4KB）**  和 **可预取状态（是/否）** 。这对于内存映射至关重要。\n* **功能：**  列出支持的功能及其配置，通常在配置空间中的链表结构中找到。示例包括：\n  * **PCIe功能结构**：PCIe链路速度（例如，Gen2，Gen3），链路宽度（例如，x1，x4），最大载荷大小，最大读取请求大小。\n  * **MSI/MSI-X功能结构**：消息信号中断信息，包括支持的向量数量。\n  * **电源管理功能结构**：支持的电源状态（D0，D1，D2，D3hot，D3cold）。\n* **设备序列号 (DSN)：**  一个64位唯一标识符，如果设备支持（在“设备序列号”扩展功能中找到）。并非所有设备都实现了此功能。\n\n**步骤：**\n\n1. **导航到PCI配置选项卡：**\n   * 在设备详细视图中，找到并选择 **PCI Config** 或 **Configuration Space** 选项卡。这通常会以解码视图显示原始配置空间寄存器。\n2. **记录相关详细信息：**\n   * 仔细记录上面列出的每个所需字段。\n   * 使用截图或将值复制到文本文件、专用电子表格或结构化文档格式中以确保准确性。\n   * 确保十六进制值正确记录，包括是否使用`0x`前缀。\n3. **展开功能列表：**\n   * 查找标记为 **Capabilities** 或 **Advanced Features** 的部分。这些通常是可点击或可展开以显示子部分的。\n   * 记录存在的每个功能及其相关参数（例如，MSI消息控制，电源状态标志，当前/最大PCIe链路设置）。\n4. **详细检查BAR：**\n   * 在配置空间中，找到BAR0到BAR5的条目。\n   * 对于每个活动的BAR，记录其分配的大小、是内存映射还是I/O、其位宽（32位或64位）以及是否可预取。这些信息通常在Arbor的GUI中清晰显示。\n5. **保存数据以备参考：**\n   * 将所有提取的信息编译成一个组织良好的文档（例如，Markdown文件、`.txt`文件或Excel电子表格）。\n   * 为每个部分清晰标记，以便在固件定制期间轻松参考。\n\n### **5.2 提取和记录设备属性**\n\n捕获数据后，理解每个属性的重要性并确保其准确记录对于成功仿真至关重要。\n\n**确保您已准确记录以下内容：**\n\n1. **设备ID：**\n   * **目的：**  唯一标识PCIe设备的特定型号。\n   * **仿真用法：**  对于主机操作系统（OS）正确识别仿真设备至关重要，更重要的是，它能尝试加载适当的设备驱动程序。\n2. **厂商ID：**\n   * **目的：**  标识PCIe设备的制造商。\n   * **仿真用法：**  与设备ID结合使用，形成主机操作系统用于将设备与相应驱动程序匹配的唯一标识符（`VendorID:DeviceID`）。\n3. **子系统ID和子系统厂商ID：**\n   * **目的：**  这些可选ID允许区分同一厂商设备的变体，或区分主厂商/设备ID可能为通用的OEM特定版本。\n   * **仿真用法：**  对于仿真具有多种配置的设备或OEM提供的设备很重要，因为驱动程序可能会专门查找这些值。\n4. **修订ID：**\n   * **目的：**  指示设备的硬件修订级别。\n   * **仿真用法：**  有助于识别可能需要不同驱动程序、固件或具有细微行为差异的特定硬件版本。\n5. **类别代码：**\n   * **目的：**  一个24位代码，用于对设备的通用功能进行分类（例如，`0x020000`用于以太网控制器，`0x010802`用于NVMe控制器，`0x0C0300`用于USB主机控制器）。它由基本类别、子类别和编程接口组成。\n   * **仿真用法：**  允许操作系统理解设备的通用功能，并在找不到特定厂商驱动程序时加载通用类别驱动程序。这对于初始设备识别至关重要。\n6. **基地址寄存器（BARs）：**\n   * **目的：**  定义设备用于寄存器、内部缓冲区或配置空间扩展的内存映射或I/O端口地址区域。主机操作系统在枚举期间将物理地址分配给这些BAR。\n   * **仿真用法：**  对于将仿真设备的内部内存和寄存器映射到主机系统的地址空间至关重要。每个BAR的大小、类型（内存/I/O，32/64位）和可预取状态必须与捐赠设备精确匹配。\n7. **功能：**\n   * **目的：**  列出设备支持的高级功能，如高级错误报告、电源管理、MSI/MSI-X、PCIe高级功能（如AER、VC/PF）等。每个功能由一个具有其自身寄存器的结构定义。\n   * **仿真用法：**  对于准确复制捐赠设备如何宣传其功能以及主机系统如何与这些功能交互（例如，中断传递机制、电源状态转换、错误报告）至关重要。\n8. **设备序列号（DSN）：**\n   * **目的：**  设备的唯一64位标识符，通常是可选的扩展功能。\n   * **仿真用法：**  虽然可选，但某些驱动程序或管理应用程序可能会专门查询并依赖DSN进行识别、许可或安全检查。准确仿真此功能可以防止您的设备被检测为通用或修改的外设。\n\n**数据收集的最佳实践：**\n\n* **组织数据：**  创建一个结构化的文档或电子表格。为每个属性使用清晰的标题和子标题。模板会很有益。\n* **包含单位和格式：**  始终注明大小的单位（例如，MB、KB），并为十六进制值使用一致的格式（例如，`0x1234`、`16'h1234`）。\n* **与规范交叉引用（如果可能）：**  如果可用，查阅捐赠设备的数据手册或公开可用的规范以验证值。这有助于识别原始扫描中不明显或不寻常的配置。\n* **保护数据：**  安全存储收集到的信息。请注意，这些数据可能包含专有或敏感信息。\n* **理解“缺少什么”：**  像Arbor这样的专业工具非常出色，但它们可能无法捕捉复杂、高度专有设备的每一个细微之处（例如，标准配置空间之外的特定厂商定义寄存器）。对于高级仿真，您可能需要将此信息与捐赠设备驱动程序的逆向工程结合起来。\n\n---\n\n## **6. 初始固件定制**\n\n在细致地记录了捐赠设备的信息之后，下一个关键阶段是定制您的FPGA固件，以准确仿真捐赠设备。这个过程首先要修改PCIe配置空间中的关键识别寄存器，并确保设备序列号等特定标识符被正确集成。\n\n### **6.1 修改配置空间**\n\nPCIe配置空间是定义设备如何被识别并与主机系统在枚举期间交互的基本组件。精确定制此空间以匹配捐赠设备的配置文件对于成功仿真绝对至关重要，它能让主机操作系统加载正确的驱动程序并按预期交互。\n\n#### **6.1.1 导航到配置文件**\n\nPCIe配置空间参数通常在PCILeech-FPGA项目中的特定SystemVerilog（`.sv`）文件中定义。此文件将综合成配置PCIe IP核并向主机公开设备身份的逻辑。\n\n**PCILeech-FPGA（基于Artix-7的板卡，如Squirrel）的常见路径：** \n找到负责为您特定板卡配置PCIe参数的文件。对于许多Artix-7 PCILeech变体，这将是：\n\n```\npcileech-fpga/<your_board_variant>/src/pcileech_pcie_cfg_a7.sv\n```\n\n* **示例（对于Squirrel 35T）** ：\n  ```\n  pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv\n  ```\n\n  *注意：实际的文件夹名称，如*​*​`pcileech-squirrel-35t`​*​ *，可能会根据您克隆的PCILeech-FPGA的具体版本或分支略有不同。克隆主仓库后，请始终导航到相关的板卡特定子目录。*\n\n#### **6.1.2 在Visual Studio Code中打开文件**\n\n编辑配置文件需要一个合适的代码编辑器，该编辑器支持SystemVerilog（或Verilog）的语法高亮，使代码更易于阅读和修改。\n\n**步骤：**\n\n1. **启动Visual Studio Code：**\n   * 点击VS Code图标或通过“开始”菜单找到它。\n2. **打开文件：**\n   * 使用 **文件 &gt; 打开文件** 或按下 `Ctrl + O`（macOS上为 `Cmd + O`）。\n   * 导航到第6.1.1节中确定的配置文件路径（例如，`pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv`）。\n   * 选择文件并点击 **打开**。\n3. **验证语法高亮：**\n   * 确保编辑器识别 `.sv` 文件扩展名并应用正确的SystemVerilog语法高亮。如果不行，请返回第4.3.2节，确保您已安装推荐的Verilog/SystemVerilog扩展程序。\n4. **熟悉文件结构：**\n   * 滚动浏览文件。您通常会发现使用`localparam`或`reg`赋值定义的参数，通常附有解释其目的的注释。查找定义和赋值标准PCIe配置寄存器（厂商ID、设备ID等）的部分。\n\n#### **6.1.3 修改设备ID和厂商ID**\n\n更新这些基本标识符是主机系统正确将仿真设备识别为您的捐赠设备的最关键步骤。操作系统严重依赖 `Vendor ID` 和 `Device ID` 对来识别连接的硬件并加载适当的设备驱动程序。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_deviceid`​**​ **：**\n   * 在VS Code中使用搜索功能（`Ctrl + F`或`Cmd + F`）。\n   * 找到定义`cfg_deviceid`的行。它通常看起来像这样：\n     ```verilog\n     reg [15:0] cfg_deviceid = 16'hAAAA; // 默认或占位符设备ID\n     ```\n2. **更新设备ID：**\n   * 将`AAAA`替换为您使用Arbor从捐赠设备中提取的16位十六进制设备ID（例如，`0x1234`）。\n   * **示例：** \n     如果捐赠设备的设备ID是`0x1234`，则将该行更新为：\n     ```verilog\n     reg [15:0] cfg_deviceid = 16'h1234; // 更新为捐赠设备的设备ID（例如，来自网卡）\n     ```\n3. **搜索 **​**​`cfg_vendorid`​**​ **：**\n   * 找到定义`cfg_vendorid`的行。其格式将类似于`cfg_deviceid`：\n     ```verilog\n     reg [15:0] cfg_vendorid = 16'hBBBB; // 默认或占位符厂商ID\n     ```\n4. **更新厂商ID：**\n   * 将`BBBB`替换为您从捐赠设备中提取的16位十六进制厂商ID（例如，`0xABCD`）。\n   * **示例：** \n     如果捐赠设备的厂商ID是`0xABCD`，则将该行更新为：\n     ```verilog\n     reg [15:0] cfg_vendorid = 16'hABCD; // 更新为捐赠设备的厂商ID（例如，Intel Corporation）\n     ```\n5. **确保格式正确：**\n   * 验证十六进制值是否正确以`16'h`为前缀（表示一个16位十六进制数）。\n   * 保持一致的缩进和注释风格以提高可读性。\n\n#### **6.1.4 修改子系统ID和修订ID**\n\n这些标识符提供了关于设备变体、特定产品型号或硬件修订的额外详细信息。虽然通常是可选的，但匹配它们能增强仿真的真实性，并且对于执行细粒度检查的驱动程序可能至关重要。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_subsysid`​**​ **：**\n   * 找到定义`cfg_subsysid`的行。\n\n   ```verilog\n   reg [15:0] cfg_subsysid = 16'hCCCC; // 占位符子系统ID\n   ```\n2. **更新子系统ID：**\n   * 将`CCCC`替换为您捐赠设备的16位十六进制子系统ID（例如，`0x5678`）。\n   * **示例：**\n     ```verilog\n     reg [15:0] cfg_subsysid = 16'h5678; // 设置为捐赠设备的子系统ID\n     ```\n3. **搜索 **​**​`cfg_subsysvendorid`​**​ **：**\n   * 找到定义`cfg_subsysvendorid`的行。\n\n   ```verilog\n   reg [15:0] cfg_subsysvendorid = 16'hDDDD; // 占位符子系统厂商ID\n   ```\n4. **更新子系统厂商ID（如果适用）：**\n   * 将`DDDD`替换为您捐赠设备的16位十六进制子系统厂商ID（例如，`0x9ABC`）。如果您的捐赠设备没有唯一的子系统厂商ID（即与主厂商ID相同），您仍应将其设置为该值。\n   * **示例：**\n     ```verilog\n     reg [15:0] cfg_subsysvendorid = 16'h9ABC; // 设置为捐赠设备的子系统厂商ID\n     ```\n5. **搜索 **​**​`cfg_revisionid`​**​ **：**\n   * 找到定义`cfg_revisionid`的行。\n\n   ```verilog\n   reg [7:0] cfg_revisionid = 8'hEE; // 占位符修订ID\n   ```\n6. **更新修订ID：**\n   * 将`EE`替换为您捐赠设备的8位十六进制修订ID（例如，`0x01`）。\n   * **示例：**\n     ```verilog\n     reg [7:0] cfg_revisionid = 8'h01; // 设置为捐赠设备的修订ID\n     ```\n\n#### **6.1.5 更新类别代码**\n\n类别代码通知主机操作系统设备的通用类型和功能（例如，网络控制器、存储设备）。这对于操作系统加载通用类别驱动程序至关重要，即使没有安装特定厂商驱动程序。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_classcode`​**​ **：**\n   * 找到定义`cfg_classcode`的行。\n\n   ```verilog\n   reg [23:0] cfg_classcode = 24'hFFFFFF; // 默认或占位符类别代码\n   ```\n2. **更新类别代码：**\n   * 将`FFFFFF`替换为您从捐赠设备中提取的24位十六进制类别代码（例如，`0x020000`用于以太网控制器）。请记住格式：基本类别、子类别、编程接口。\n   * **示例：** \n     如果捐赠设备的类别代码是`0x020000`（表示基本类别：0x02 - 网络控制器，子类别：0x00 - 以太网控制器，编程接口：0x00），则更新为：\n     ```verilog\n     reg [23:0] cfg_classcode = 24'h020000; // 设置为捐赠设备的类别代码（例如，以太网控制器）\n     ```\n3. **验证正确的位宽：**\n   * 确保类别代码使用`24'h`前缀正确表示为24位十六进制值。\n\n#### **6.1.6 保存更改**\n\n在对配置参数进行所有修改后，保存和审查更改至关重要。\n\n**步骤：**\n\n1. **保存文件：**\n   * 在VS Code中点击 **文件 &gt; 保存**，或按下 `Ctrl + S`（macOS上为 `Cmd + S`）。\n2. **审查更改：**\n   * 在关闭之前，快速重新阅读修改过的行，以根据您的捐赠设备信息文档确认其准确性。\n   * 检查是否有任何明显的语法错误或拼写错误（VS Code的扩展可能会高亮显示这些）。\n3. **可选 - 使用版本控制：**\n   * 如果您正在使用Git（强烈推荐用于任何代码项目，尤其是固件），请以清晰且有意义的消息提交您的更改。这将创建您的修改历史记录。\n   * **示例Git命令：**\n     ```bash\n     git add pcileech_pcie_cfg_a7.sv\n     git commit -m \"更新PCIe配置寄存器（VID, DID, SubIDs, Revision, Class Code）以匹配捐赠设备：[捐赠设备名称]\"\n     ```\n\n### **6.2 插入设备序列号（DSN）**\n\n设备序列号（DSN）是一些PCIe设备（特别是那些具有高级功能或特定驱动程序的设备）可能使用的独特64位标识符。包含它能增强仿真的真实性，并有助于绕过明确查询此值的驱动程序中的检查。\n\n#### **6.2.1 定位DSN字段**\n\nDSN（如果由捐赠设备实现）是PCIe扩展能力的一部分。在PCILeech-FPGA框架中，DSN字段通常作为您一直在编辑的同一配置文件中的可配置参数公开。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_dsn`​**​ **：**\n   * 在 `pcileech_pcie_cfg_a7.sv`（或您的板卡等效配置文件）中，使用搜索功能（`Ctrl + F` 或 `Cmd + F`）查找 `cfg_dsn`。\n2. **理解现有赋值：**\n   * DSN可能被设置为默认值（通常是全零）或被注释掉。它通常看起来像这样：\n     ```verilog\n     reg [63:0] cfg_dsn = 64'h0000000000000000; // 默认DSN（如果未使用，通常为0）\n     ```\n\n#### **6.2.2 插入DSN**\n\n更新DSN涉及将其设置为从捐赠设备捕获的精确64位十六进制值。\n\n**步骤：**\n\n1. **更新 **​**​`cfg_dsn`​**​ **：**\n   * 将现有的十六进制值替换为您使用Arbor从捐赠设备中提取的64位DSN。\n   * **示例：** \n     如果捐赠设备的DSN是`0x0011223344556677`，则更新为：\n     ```verilog\n     reg [63:0] cfg_dsn = 64'h0011223344556677; // 捐赠设备序列号\n     ```\n2. **处理DSN不可用或不相关的情况：**\n   * 如果您的捐赠设备*没有*DSN，或者您已确定它不是您目标驱动程序所需的参数，您可以简单地将其保留为零：\n     ```verilog\n     reg [63:0] cfg_dsn = 64'h0000000000000000; // 捐赠设备没有特定DSN，保留为默认0\n     ```\n   * **注意**：对于关键仿真，如果捐赠设备有DSN，最好准确仿真它。\n3. **确保格式正确：**\n   * DSN是64位值；确保它以`64'h`前缀正确格式化为十六进制值。\n\n#### **6.2.3 保存更改**\n\n通过保存和审查文件来完成DSN修改。\n\n**步骤：**\n\n1. **保存文件：**\n   * 在VS Code中点击 **文件 &gt; 保存**，或按下 `Ctrl + S`。\n2. **验证语法：**\n   * 检查VS Code的语法检查器是否有任何红色下划线或错误指示。立即纠正任何问题。\n3. **记录更改：**\n   * 如果使用版本控制，请使用适当的消息提交更新。\n   * **示例Git命令：**\n     ```bash\n     git commit -am \"在PCIe配置中插入捐赠设备序列号（DSN）\"\n     ```\n\n---\n\n## **7. Vivado项目设置与定制**\n\n在固件文件更新以反映捐赠设备的关键识别和配置数据后，下一个关键步骤是将这些更改集成到Vivado项目中。这包括为您的特定FPGA板卡生成项目文件，定制嵌入式PCIe IP核，并准备整个设计以进行综合和实现阶段。\n\n### **7.1 生成Vivado项目文件**\n\nVivado是Xilinx（AMD）开发套件，使用Tcl（工具命令语言）脚本来自动化项目创建、添加源文件和配置项目设置。通过运行PCILeech-FPGA框架提供的这些脚本，您可以确保您的Vivado项目已为目标FPGA板卡正确设置。\n\n#### **7.1.1 打开Vivado**\n\n启动Vivado的新会话可确保之前会话中没有残留设置或打开项目干扰当前工作。\n\n**步骤：**\n\n1. **启动Vivado：**\n   * 在“开始”菜单（Windows）或“应用程序”文件夹（Linux/macOS）中找到Vivado应用程序图标。\n   * 点击打开。\n2. **选择正确的版本：**\n   * 如果您安装了多个Vivado版本，请确保您启动的是与您的FPGA板卡和PCILeech-FPGA项目兼容的版本（如第4.3.1节所述，建议使用Vivado 2023.x等最新稳定版本）。\n3. **等待启动界面：**\n   * 让Vivado完全初始化并显示欢迎界面或项目仪表板，然后才能继续。\n\n#### **7.1.2 访问Tcl控制台**\n\nVivado内的Tcl控制台是您执行脚本和直接命令的主要界面。您将在此处运行项目生成脚本。\n\n**步骤：**\n\n1. **打开Tcl控制台：**\n   * 在Vivado界面中，导航到菜单栏。\n   * 单击 **Window** > **Tcl Console**。\n   * Tcl控制台窗格通常会出现在Vivado窗口的底部。\n2. **调整控制台大小（可选）：**\n   * 您可以拖动控制台的顶部边框来调整其大小，使其更高以便更好地查看命令和输出。\n3. **清除先前命令（可选但推荐）：**\n   * 如果存在任何先前的命令或消息，您可以在控制台内右键单击并选择“Clear Console”以获得一个干净的开始。\n\n#### **7.1.3 导航到项目目录**\n\n在运行Tcl脚本之前，您必须确保Tcl控制台的当前工作目录已设置为您的板卡特定PCILeech-FPGA项目脚本所在的正确位置。\n\n**对于Squirrel DMA (Artix-7 35T) 或类似板卡：**\n\n**典型路径（克隆**​**​`pcileech-fpga`​**​**并导航到您的板卡变体后）：**\n\n```\nC:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel-35t/  # 在Windows上\n~/Projects/pcileech-fpga/pcileech-squirrel-35t/  # 在Linux/macOS上\n```\n\n*注意：将*​ *​`<your_board_variant>`​*​*替换为您的板卡子目录的实际名称（例如，*​*​`pcileech-squirrel-35t`​*​ *，*​*​`pcileech-artix-7-50t`​*​ *）。*\n\n**步骤：**\n\n1. **在Tcl控制台中设置工作目录：**\n   * 在Vivado Tcl控制台中，输入`cd`命令，后跟您的板卡项目目录的完整路径。\n   * **示例（Windows）：**\n     ```tcl\n     cd C:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel-35t/\n     ```\n   * **示例（Linux/macOS）：**\n     ```tcl\n     cd ~/Projects/pcileech-fpga/pcileech-squirrel-35t/\n     ```\n   * *自我纠正提示：即使在Windows上，Tcl路径也使用正斜杠（*​ *​`/`​*​ *）。*\n2. **验证目录更改：**\n   * 要确认您处于正确的目录中，请在Tcl控制台中输入`pwd`（打印工作目录）。\n   * 控制台应显示您刚刚设置的完整路径，确认更改。\n\n#### **7.1.4 生成Vivado项目**\n\n运行适用于您的FPGA板卡的相应Tcl脚本将自动化Vivado内部的整个项目设置过程。这包括创建项目、添加所有必要的源文件（HDL、约束）以及配置核心项目设置。\n\n**步骤：**\n\n1. **运行Tcl脚本：**\n   * 输入`source`命令，后跟您的板卡的项​​目生成脚本的名称。PCILeech-FPGA项目通常在主板卡目录中提供这些脚本。\n   * **对于Squirrel (Artix-7 35T)（以及类似的Artix-7板卡）：**\n     ```tcl\n     source vivado_generate_project_squirrel.tcl -notrace\n     ```\n   * **对于Enigma-X1 (Artix-7 75T)：**\n     ```tcl\n     source vivado_generate_project_enigma_x1.tcl -notrace\n     ```\n   * **对于ZDMA (Artix-7 100T)：**\n     ```tcl\n     source vivado_generate_project_100t.tcl -notrace\n     ```\n   * `-notrace`选项可防止每个Tcl命令的详细输出，使控制台更整洁。\n2. **等待脚本完成：**\n   * 脚本将按顺序执行许多命令。此过程可能需要几分钟，具体取决于您的系统性能和项目的复杂性。\n   * 监控Tcl控制台的进度消息。脚本将：\n     * 在当前目录中创建一个新的Vivado项目（`.xpr`文件）。\n     * 添加所有SystemVerilog/Verilog源文件（`.sv`，`.v`）。\n     * 添加Xilinx IP核配置（`.xci`）。\n     * 添加XDC（Xilinx设计约束）文件。\n     * 可能配置各种项目设置。\n   * **处理任何错误**：如果发生任何错误（例如，“文件未找到”、“无效命令”），脚本通常会停止。检查错误消息，纠正底层问题（例如，路径不正确、文件丢失），然后重新运行脚本。\n3. **确认项目生成：**\n   * 成功完成后，Tcl控制台通常会指示项目已创建，并且您应该在项目目录中看到新生成的项目文件（例如，`pcileech_squirrel_top.xpr`）和相关目录（例如，`pcileech_squirrel_top.runs`，`pcileech_squirrel_top.ip`）。\n\n#### **7.1.5 打开生成的项目**\n\n现在Vivado项目文件已成功由Tcl脚本生成，您可以在Vivado GUI中打开该项目以进行进一步检查和定制。\n\n**步骤：**\n\n1. **打开项目：**\n   * 在Vivado中，点击 **文件** > **打开项目**。\n   * 导航到您的项目目录（与您在第7.1.3节中在Tcl控制台中设置的目录相同）。\n2. **选择项目文件：**\n   * 找到并选择与您的板卡对应的Vivado项目文件（`.xpr`扩展名）。\n   * **对于Squirrel：**  文件名通常为 `pcileech_squirrel_top.xpr`。\n   * 点击 `.xpr` 文件以选择它。\n3. **点击打开：**\n   * Vivado将加载项目，显示设计层次结构、源文件、IP集成器块设计（如果使用）和各种设计视图。这可能需要一些时间。\n4. **验证项目内容：**\n   * 在 **项目管理器** 窗口（通常在左侧）中，展开 **源文件** 窗格。\n   * 确保所有预期的源文件（Verilog/SystemVerilog、XDC、IP核）都已列出，并且设计层次结构看起来正确。\n   * 检查 **消息** 窗格（底部）中打开项目时出现的任何警告或严重警告，因为这些可能表明潜在问题。\n\n### **7.2 修改IP核**\n\nPCIe IP核是设备PCIe接口的核心。它是一个经过Xilinx（AMD）预验证、可配置的模块，用于处理复杂的PCIe协议层。尽管某些配置空间值在SystemVerilog文件中处理（第6.1节），但其他核心PCIe参数，特别是与链路能力和BAR结构相关的参数，是在Vivado中直接通过PCIe IP核的定制设置进行配置的。定制IP核可确保您的FPGA在PCIe协议级别上与捐赠硬件的行为完全一致。\n\n#### **7.2.1 访问PCIe IP核**\n\nPCIe IP核在您的Vivado项目中被实例化为一个IP块。您需要打开其定制GUI来修改其参数。\n\n**步骤：**\n\n1. **定位PCIe IP核：**\n   * 在 **Sources**（源文件）窗格（位于 **Project Manager**（项目管理器）窗口内）中，确保已选择 **Hierarchy**（层次结构）选项卡。\n   * 展开设计层次结构，直到找到PCIe IP核的实例。\n   * 对于7系列FPGA（如Squirrel中使用的Artix-7），它通常被命名为 `pcie_7x_0.xci` 或类似名称，通常位于项目源文件的 `ip` 子目录中。\n2. **打开IP定制窗口：**\n   * **右键单击** `pcie_7x_0.xci` 文件。\n   * 从上下文菜单中选择 **Customize IP**（定制IP）。\n   * 将打开 **IP Configuration**（IP配置）窗口（或类似名称，如“Customize IP”或“Re-customize IP”），显示带有各种选项卡和选项的图形界面，用于配置PCIe核。\n3. **等待IP设置加载：**\n   * IP定制界面可能需要几分钟才能初始化并填充所有设置。在您开始进行更改之前，请确保所有选项和选项卡都已完全加载并响应。\n\n#### **7.2.2 在IP核内部定制设备ID和BAR**\n\n尽管某些设备标识符在`pcileech_pcie_cfg_a7.sv`中设置，但PCIe IP核本身也包含设备ID、厂商ID以及至关重要的基地址寄存器（BARs）的定义参数。您必须确保这些参数保持一致。`.sv`文件中的某些值可能会覆盖或输入到IP核中，但在此处也确保一致性是一个好习惯。IP核中的BAR设置尤其重要，因为它们决定了内存映射的硬件实现。\n\n**步骤：**\n\n1. **导航到基本/识别参数：**\n   * 在IP定制窗口中，查找与 **基本**、**设备和厂商标识符**、**通用** 或 **PCIe能力** 相关的选项卡或部分。这是定义基本ID和初始链路设置的地方。\n2. **验证/输入设备ID、厂商ID、子系统ID、修订ID、类别代码：**\n   * **至关重要：请确认这些值与您在**​**​`pcileech_pcie_cfg_a7.sv`​**​**中设置的以及从捐赠设备中获取的值相匹配。**\n   * 查找以下字段：\n     * **设备ID**：输入`0xXXXX`（例如，`0x1234`）。\n     * **厂商ID**：输入`0xYYYY`（例如，`0xABCD`）。\n     * **子系统ID**：输入`0xZZZZ`（例如，`0x5678`）。\n     * **子系统厂商ID**：输入`0xWWWW`（例如，`0x9ABC`）。\n     * **修订ID**：输入`0xRR`（例如，`0x01`）。\n     * **类别代码**：输入`0xCCCCCC`（例如，`0x020000`）。\n   * **重要提示**：某些IP核版本或特定配置可能会直接从用户逻辑（如`pcileech_pcie_cfg_a7.sv`）拉取这些值，或者可能允许直接在此处设置它们。最可靠的方法是，如果IP GUI中提供此选项，则在两个位置都保持一致设置。\n3. **导航到基地址寄存器（BARs）选项卡：**\n   * 在IP定制窗口中，找到并选择 **BARs** 选项卡或部分。这是您定义PCIe设备暴露的内存区域的地方。\n4. **配置每个BAR：**\n   * 对于您的捐赠设备使用的每个BAR（BAR0到BAR5），根据您使用Arbor提取的信息，仔细配置以下参数：\n     * **启用BAR**：仅当捐赠设备使用此特定BAR时才选中此框。禁用（取消选中）捐赠设备不使用的任何BAR。\n     * **BAR大小**：从下拉列表中选择精确的大小（例如，**256 MB**，**64 KB**，**4 KB**）。这对于主机操作系统分配正确数量的内存至关重要。\n     * **BAR类型**：选择适当的类型：\n       * **Memory (32-bit Addressing)** （内存（32位寻址））: 用于32位地址可访问的内存映射区域。\n       * **Memory (64-bit Addressing)** （内存（64位寻址））: 用于可以驻留在64位地址空间中任何位置的内存映射区域（对于大内存区域或如果捐赠设备使用它，则需要）。\n       * **I/O**: 用于传统I/O端口区域（在现代PCIe中较不常见，但仍然可能）。\n     * **可预取**：如果捐赠设备的BAR被标记为可预取，则选中此框。此属性允许主机系统从此区域缓存或预取数据以提高性能。\n   * **示例配置（基于您的捐赠设备）：**\n     * **BAR0**：\n       * 启用：是\n       * 大小：**256 MB**\n       * 类型：**Memory (64-bit Addressing)**\n       * 可预取：是\n     * **BAR1**：\n       * 启用：否（如果捐赠设备不使用BAR1）\n     * *继续配置BAR2-BAR5，镜像捐赠设备的配置。*\n5. **确保对齐和非重叠空间**：\n   * Vivado IP核通常会根据您选择的大小自动处理对齐。但是，请注意PCIe规范要求BAR大小是2的幂，并且BAR必须对其大小进行对齐。\n   * 确保所有活动BAR映射的总内存不超过FPGA可用的块RAM（BRAM）或外部内存容量。\n\n#### **7.2.3 完成IP定制**\n\n在IP核定制窗口中配置所有必要的设置后，您必须应用这些更改，使其在Vivado项目中生效。\n\n**步骤：**\n\n1. **审查所有设置：**\n   * 在应用之前，花点时间快速最后一次审查IP定制窗口中的每个选项卡。\n   * 确认所有条目都与您捐赠设备的文档规范精确匹配。这里的一个小错误可能导致设备检测或功能问题。\n2. **应用更改：**\n   * 点击IP定制窗口底部的 **OK** 或 **Generate** 按钮（标签可能不同）。\n   * 如果Vivado提示您确认是否继续更改并重新生成IP输出产品，请点击 **Yes** 确认。\n3. **重新生成IP核：**\n   * Vivado现在将重新生成IP核的输出产品（例如，网表、仿真模型、新的`.xci`配置文件），以反映您的新配置。\n   * 监控 **消息** 窗格（Vivado窗口底部），查看在此重新生成过程中可能出现的任何错误、警告或严重警告。立即解决任何严重警告。\n4. **更新项目中的IP：**\n   * 在IP核重新生成后，Vivado可能会自动更新或提示您更新项目中的任何IP依赖项。允许它这样做，以确保在整个设计中使用最新的配置。\n\n#### **7.2.4 锁定IP核**\n\n锁定IP核是Vivado中推荐的最佳实践，可防止在后续综合和实现运行期间意外修改或重新定制，这可能会潜在地恢复您精心配置的设置。\n\n**锁定的目的：**\n\n* **防止覆盖：**  确保您在IP核GUI中进行的手动配置得以保留，不会因Vivado自动化或IP因细微项目更改而被检测为“过时”而意外覆盖。\n* **保持一致性：**  在整个构建过程中保持IP核处于已知、稳定的状态，这对于PCIe接口等关键组件尤其重要。\n\n**步骤：**\n\n1. **打开Tcl控制台：**\n   * 在Vivado中，如果Tcl控制台尚未打开，请转到 **Window** > **Tcl Console**。\n2. **执行锁定命令：**\n   * 在Tcl控制台中，精确输入以下命令。此命令将PCIe IP核实例（`pcie_7x_0`）的`IP_LOCKED`属性设置为`true`。\n\n   ```tcl\n   set_property -name {IP_LOCKED} -value true -objects [get_ips pcie_7x_0]\n   ```\n\n   * 按 **Enter** 执行命令。\n3. **验证锁定：**\n   * 检查 **消息** 窗格。您应该会看到一条确认属性已设置的消息。\n   * 您还可以右键单击源文件窗格中的 `pcie_7x_0.xci`，选择“IP Properties”（IP属性），并验证 `IP_LOCKED` 是否设置为 `true`。您可能还会注意到“Customize IP”（定制IP）选项现在已灰显，或者只允许“Re-customize IP”（重新定制IP），然后会警告您关于锁定。\n4. **解锁（如果需要）：**\n   * 如果您将来需要对PCIe IP核的设置进行进一步修改，则必须先将其解锁。使用以下Tcl命令：\n\n   ```tcl\n   set_property -name {IP_LOCKED} -value false -objects [get_ips pcie_7x_0]\n   ```\n\n   * 请记住在进行和应用更改后重新锁定它。\n5. **记录操作：**\n   * 在您的项目文档（例如，README文件、项目说明）中注明PCIe IP核已锁定是一个好习惯。这有助于项目中其他人理解其配置状态并避免混淆。\n\n---\n\n## **第二部分：中级概念与实现**\n\n---\n\n## **8. 高级固件定制**\n\n为了实现对捐赠设备精确且令人信服的仿真，除了基本识别之外，还需要对FPGA固件进行更深入的定制。这包括调整PCIe参数（例如链路速度和事务大小），细致地调整基地址寄存器（BARs）及其相关的内存映射，以及准确仿真电源管理和中断机制。这些步骤确保仿真设备不仅在主机系统看来与原始硬件相同，而且在协议和功能级别上行为也完全一致。\n\n### **8.1 配置PCIe参数以进行仿真**\n\n精确仿真要求您的FPGA设备的PCIe操作参数经过细致配置，以匹配捐赠设备的参数。这包括PCIe链路速度、链路宽度、能力指针和最大有效载荷大小等设置。正确的配置可确保与主机系统的兼容性、驱动程序和应用程序与设备交互的正确操作以及数据传输的最佳性能。\n\n#### **8.1.1 匹配PCIe链路速度和宽度**\n\nPCIe链路速度（例如，Gen1、Gen2、Gen3）和链路宽度（例如，x1、x4、x8）是决定设备最大理论数据吞吐量和性能的关键参数。将这些设置与捐赠设备匹配对于精确仿真至关重要，因为驱动程序或系统组件可能期望特定的链路能力。\n\n**步骤：**\n\n1. **访问PCIe IP核设置：**\n\n   * **打开您的Vivado项目：**  启动Vivado并打开您之前创建或修改的项目（例如，`pcileech_squirrel_top.xpr`）。确保所有源文件都已正确添加到项目中。\n   * **定位PCIe IP核：**  在 **Sources**（源文件）窗格（通常在左侧）中，展开设计层次结构以找到PCIe IP核实例。对于Xilinx 7系列设计（如Squirrel中使用的Artix-7），这通常被命名为 `pcie_7x_0.xci`。\n   * **定制IP核：**  右键单击 `pcie_7x_0.xci` 并选择 **Customize IP**（定制IP）。IP定制窗口将打开，显示多个选项卡中的各种配置选项。\n2. **设置最大链路速度：**\n\n   * **导航到链路参数：**  在IP定制窗口中，点击 **PCIe Capabilities**（PCIe功能）选项卡（有时是“PCIe Configuration”或“General”）。在此选项卡内，查找与 **Link Parameters**（链路参数）或 **Link Capability Register**（链路能力寄存器）相关的部分。\n   * **配置最大链路速度：**  找到标有 **Maximum Link Speed**（最大链路速度）的选项（或“Target Link Speed”）。\n   * 将其设置为与您的捐赠设备支持和广告的最大链路速度相匹配。\n     * **示例：**\n       * 如果捐赠设备在 **PCIe Gen2 (5.0 GT/s)**  下运行，选择 **5.0 GT/s**。\n       * 如果它在 **PCIe Gen1 (2.5 GT/s)**  或 **PCIe Gen3 (8.0 GT/s)**  下运行，请选择相应的选项。\n   * **注意**：确保您的FPGA的收发器和物理硬件（主板PCIe插槽）支持所选的链路速度。FPGA只会协商到其配置的最大速度。\n3. **设置链路宽度：**\n\n   * **配置链路宽度：**  在相同的 **Link Parameters**（链路参数）部分中，找到 **Link Width**（链路宽度）设置（或“PCIe Link Width”、“Target Link Width”）。\n   * 将其设置为与您的捐赠设备广告的最大链路宽度相匹配。\n     * **示例：**\n       * 如果捐赠设备使用 **x4** 链路，将 **Link Width** 设置为 **4**。\n       * 选项通常包括 **1**、**2**、**4**、**8**、**16** 通道。\n   * **注意**：物理PCIe插槽和FPGA的封装必须支持所选的链路宽度。尝试配置大于物理连接的宽度将导致链路协商问题。\n4. **保存并重新生成：**\n\n   * **应用更改：**  配置链路速度和宽度后，点击 **OK** 以在IP定制窗口中应用更改。\n   * **重新生成IP输出产品：**  Vivado很可能会提示您由于所做的更改而重新生成IP核的输出产品。确认并允许重新生成过程完成。这可能需要一些时间。\n   * **验证设置：**  一旦重新生成完成，您可以选择性地重新访问IP核设置，以确保配置已正确应用。检查Vivado中 **Messages**（消息）窗口中是否有任何警告或错误。\n\n#### **8.1.2 设置能力指针**\n\nPCIe配置空间中的能力指针是8位寄存器，它们形成一个链表，指向各种能力结构（例如，电源管理、MSI/MSI-X、PCIe Express能力）。正确设置这些指针可确保主机系统能够遍历能力列表并定位和利用设备广告的功能。\n\n**步骤：**\n\n1. **在固件中定位能力指针：**\n\n   * **打开配置文件：**  在Visual Studio Code中，打开您的板卡的主配置文件，通常是`pcileech_pcie_cfg_a7.sv`，位于`pcileech-fpga/<your_board_variant>/src/pcileech_pcie_cfg_a7.sv`。\n   * **理解能力指针：**  此文件中的能力指针（`cfg_cap_pointer`）指向PCIe配置空间中的*第一个*能力结构，通常从标准64字节配置头之后开始。后续的能力通过其“下一个能力指针”字段链接起来。\n2. **设置能力指针值：**\n\n   * **找到**​**​`cfg_cap_pointer`​**​**的赋值：**  在代码中搜索定义`cfg_cap_pointer`的行。\n     ```verilog\n     reg [7:0] cfg_cap_pointer = 8'hXX; // 当前值（例如，默认的8'h40）\n     ```\n   * **更新能力指针：**  将`XX`替换为您使用Arbor从捐赠设备观察到的8位十六进制能力指针值。此值通常指向设备特定配置空间（通常在偏移量`0x3F`结束）之后第一个能力结构的偏移量。能力常见的起始点是`0x40`或`0x60`。\n     * **示例：**\n       * 如果捐赠设备的第一个能力指针是`0x60`（表示其第一个能力结构在配置空间中从偏移量`0x60`开始），将该行更新为：\n         ```verilog\n         reg [7:0] cfg_cap_pointer = 8'h60; // 更新以匹配捐赠设备的第一个能力偏移量\n         ```\n   * **确保正确对齐：**  能力结构必须对齐到4字节边界。能力指针应始终指向配置空间中有效的4字节对齐偏移量。\n3. **保存更改：**\n\n   * **保存配置文件：**  进行更改后，点击 **文件 &gt; 保存** 或按下 `Ctrl + S` 保存文件。\n   * **验证语法：**  确保更改未引入任何语法错误（VS Code通常会高亮显示这些错误）。\n   * **添加注释以清晰说明：**  添加注释解释更改，以便将来参考和维护。\n     ```verilog\n     reg [7:0] cfg_cap_pointer = 8'h60; // 设置为捐赠设备的能力指针（例如，PCIe能力位于0x60）\n     ```\n\n#### **8.1.3 调整最大载荷和读取请求大小**\n\n这些参数定义了单个PCIe事务层数据包（TLP）中可以传输的最大数据量，以及非posted内存读取请求TLP的最大大小。将这些设置与捐赠设备匹配可确保兼容性并优化数据传输操作的性能。不匹配可能导致吞吐量降低或通信错误。\n\n**步骤：**\n\n1. **设置支持的最大载荷大小（IP核）：**\n\n   * **访问设备功能：**  在PCIe IP核定制窗口（Vivado中的`pcie_7x_0.xci`）中，导航到 **PCIe Capabilities**（PCIe功能）选项卡。\n   * **配置支持的最大载荷大小：**  找到标有 **Max Payload Size Supported**（支持的最大载荷大小）的设置（或类似名称）。\n   * 将其设置为与您的捐赠设备支持和广告的值相匹配（例如，128字节、256字节、512字节、1024字节、2048字节、4096字节）。\n     * **示例：**  如果捐赠设备支持的最大载荷大小为 **256字节**，请从下拉列表中选择 **256字节**。\n2. **设置支持的最大读取请求大小（IP核）：**\n\n   * **配置支持的最大读取请求大小：**  在同一选项卡中，找到 **Max Read Request Size Supported**（支持的最大读取请求大小）设置。\n   * 将其设置为与捐赠设备的能力相匹配。这指定了设备在单个读取事务中可以请求的最大数据量。\n     * **示例：**  如果捐赠设备支持的最大读取请求大小为 **512字节**，请选择 **512字节**。\n3. **调整固件参数（匹配IP核）：**\n\n   * **打开 **​**​`pcileech_pcie_cfg_a7.sv`​**​ **：**  确保配置文件在Visual Studio Code中打开。\n   * **更新固件常量：**  找到定义`max_payload_size_supported`和`max_read_request_size_supported`的行。这些通常是与您在IP核中选择的字节大小对应的位编码值。\n     ```verilog\n     reg [2:0] max_payload_size_supported = 3'bZZZ;   // 当前值\n     reg [2:0] max_read_request_size_supported = 3'bWWW; // 当前值\n     ```\n   * **设置适当的值：**  将`ZZZ`和`WWW`替换为与所选大小对应的3位二进制表示。\n     * **映射（根据PCIe规范）：**\n       * **128字节**：`3'b000`\n       * **256字节**：`3'b001`\n       * **512字节**：`3'b010`\n       * **1024字节**：`3'b011`\n       * **2048字节**：`3'b100`\n       * **4096字节**：`3'b101`\n     * **示例：**\n       * 对于 **256字节** 载荷大小：\n         ```verilog\n         reg [2:0] max_payload_size_supported = 3'b001; // 支持最大256字节 (0x100)\n         ```\n       * 对于 **512字节** 读取请求大小：\n         ```verilog\n         reg [2:0] max_read_request_size_supported = 3'b010; // 支持最大512字节 (0x200)\n         ```\n   * **原因**：这些固件参数通常决定了与PCIe核接口的用户逻辑的行为，确保您的逻辑遵循配置的最大值。\n4. **保存更改：**\n\n   * **保存文件：**  更新`pcileech_pcie_cfg_a7.sv`中的值后，保存文件。\n   * **验证一致性：**  Vivado PCIe IP核GUI中配置的值*必须*与您的HDL配置文件中设置的值*匹配*。任何不匹配都可能导致意外行为或链路训练问题。\n   * **添加注释：**  在您的代码中清晰地记录这些更改，以便将来参考。\n\n### **8.2 调整BARs和内存映射**\n\n基地址寄存器（BARs）是PCIe设备向主机系统公开其内部内存和寄存器的基本方式。正确配置BARs并在FPGA的BRAMs（块RAMs）和逻辑中定义它们的内存映射对于精确仿真和主机端设备驱动程序的正常运行至关重要。\n\n#### **8.2.1 设置BAR大小和类型（IP核和BRAM）**\n\n配置BAR大小和类型可确保您的仿真设备在枚举期间向主机请求正确的地址空间量，并且主机适当地分配和映射这些区域。这还涉及将这些地址区域与FPGA内的物理内存块关联起来。\n\n**步骤：**\n\n1. **访问BAR配置（PCIe IP核）：**\n\n   * **定制PCIe IP核：**  在Vivado中，右键单击 `pcie_7x_0.xci` 并选择 **Customize IP**（定制IP）以打开其配置GUI。\n   * **导航到BARs选项卡：**  在IP定制窗口中，点击 **Base Address Registers (BARs)** （基地址寄存器（BARs））选项卡。\n2. **配置每个BAR（IP核）：**\n\n   * **匹配捐赠设备的BARs：**  对于每个BAR（BAR0到BAR5），根据您使用Arbor从捐赠设备中提取的信息，细致地设置大小、类型和可预取状态。\n   * **启用/禁用BARs：**  确保只启用捐赠设备实际使用的BARs。禁用（取消选中）任何未使用的BARs。\n   * **设置BAR大小：**  为每个*已启用*的BAR从下拉列表中选择适当的大小。这将是2的幂次（例如，4KB、8KB、64KB、1MB、256MB、1GB）。\n     * **示例：**\n       * 如果 **BAR0** 是 **64 KB**，将 **BAR0 Size** 设置为 **64 KB**。\n       * 如果 **BAR1** 是 **128 MB**，将 **BAR1 Size** 设置为 **128 MB**。\n   * **设置BAR类型：**\n     * 如果BAR是内存映射的，选择 **Memory (32-bit Addressing)** （内存（32位寻址））或 **Memory (64-bit Addressing)** （内存（64位寻址））。如果捐赠设备的BAR是64位或您需要访问4GB以上的地址，请选择 **64-bit Addressing**。\n     * 如果BAR用于I/O端口空间（现代PCIe设备较少见），选择 **I/O**。\n   * **设置可预取状态**：如果捐赠设备的BAR被识别为可预取，请选中“Prefetchable”（可预取）框。此位允许主机预取该区域的数据，可能提高性能。\n3. **更新BRAM配置（如果适用）：**\n\n   * 许多PCILeech-FPGA项目使用Xilinx块RAM（BRAM）IP核来表示BARs暴露的内存区域。这些BRAM提供仿真设备内存的物理存储。\n   * **定位BRAM IP核：**  在您的Vivado项目 **Sources**（源文件）窗格中，在`ip`子目录（或类似目录）中，您可能会找到BRAM的`.xci`文件，名称可能类似：\n     ```\n     pcileech-fpga/<your_board_variant>/ip/bram_bar_zero4k.xci\n     pcileech-fpga/<your_board_variant>/ip/bram_pcie_cfgspace.xci\n     # 可能还有BAR1、BAR2等的其他文件\n     ```\n   * **修改BRAM大小：**  对于与*已启用*BAR关联的每个BRAM IP核，您可能需要 **Customize IP**（定制IP）（右键单击`.xci`文件）并调整其内存大小配置，以精确匹配相应的BAR大小。\n     * **示例：**  如果BAR0是256MB，请确保连接到BAR0的BRAM大小为256MB。\n     * **注意**：确保所有活动BAR所需的总内存不超过您的FPGA设备的物理BRAM容量。超出容量将导致实现失败。\n4. **保存并重新生成：**\n\n   * **应用更改（IP核）：**  在PCIe IP核中配置BAR后，点击IP定制窗口中的 **OK**。\n   * **重新生成IP核：**  Vivado将提示您由于所做的更改而重新生成PCIe IP核和任何相关的BRAM IP核。允许重新生成完成。这可确保硬件网表反映您的新BAR定义。\n   * **检查错误：**  检查 **Messages**（消息）窗口中是否有与BAR配置或BRAM实例化相关的任何警告或错误。\n\n#### **8.2.2 在固件中定义BAR地址空间**\n\n尽管PCIe IP核配置了BAR的*硬件*方面，但您的定制固件（SystemVerilog代码）需要定义当主机CPU对这些BAR区域内的地址执行读写操作时，仿真设备如何响应的*逻辑*。这涉及地址解码和实现寄存器/内存访问逻辑。\n\n**步骤：**\n\n1. **打开BAR控制器文件：**\n\n   * 在Visual Studio Code中，打开负责处理BAR访问的SystemVerilog文件。对于PCILeech-FPGA，这通常是：\n     ```\n     pcileech-fpga/<your_board_variant>/src/pcileech_tlps128_bar_controller.sv\n     ```\n\n     此模块通常接收PCIe内存读/写TLP，并解码地址以确定正在访问哪个BAR（以及该BAR内的哪个偏移量）。\n2. **实现地址解码逻辑：**\n\n   * 在`pcileech_tlps128_bar_controller.sv`模块中，您会找到确定传入事务目标是哪个BAR的逻辑。这通常涉及根据配置的BAR大小检查地址位。\n   * 您需要定义传入地址`req_addr`（来自TLP）如何映射到您的特定BAR内的偏移量。\n   * **概念示例：**\n     ```verilog\n     // 示例：BAR0的逻辑（假设它是一个256MB的64位内存BAR，用于寄存器/数据）\n     // 'bar_hit[0]'是一个指示命中BAR0的输入信号，通常来自PCIe核。\n     // 'req_addr'是传入的PCIe地址。\n     // 'req_be'是来自TLP的字节使能。\n     // 'req_data'是传入的写入数据。\n     // 'rsp_data'是传出的读取数据。\n\n     // 假设BAR0是256MB (2^28字节)，地址位 [27:0] 在BAR范围内。\n     localparam BAR0_SIZE_BITS = 28; // 2^28 = 256MB\n\n     reg [31:0] internal_register_0; // BAR0内的示例寄存器\n     reg [31:0] internal_register_1; // 另一个示例寄存器\n\n     assign bar0_offset = req_addr[BAR0_SIZE_BITS-1:0]; // 提取BAR0内的偏移量\n\n     always_comb begin\n         // 默认响应\n         rsp_data = 32'hFFFFFFFF; // 默认值为全F或类似值，表示未映射区域\n\n         if (bar_hit[0]) begin // 如果事务目标是BAR0\n             if (req_write) begin // 这是写入操作\n                 case (bar0_offset)\n                     // 示例：将偏移量0x0映射到internal_register_0\n                     32'h0000_0000: begin\n                         if (req_be[3]) internal_register_0[31:24] = req_data[31:24];\n                         if (req_be[2]) internal_register_0[23:16] = req_data[23:16];\n                         if (req_be[1]) internal_register_0[15:8]  = req_data[15:8];\n                         if (req_be[0]) internal_register_0[7:0]   = req_data[7:0];\n                     end\n                     // 示例：将偏移量0x4映射到internal_register_1\n                     32'h0000_0004: begin\n                         if (req_be[3]) internal_register_1[31:24] = req_data[31:24];\n                         if (req_be[2]) internal_register_1[23:16] = req_data[23:16];\n                         if (req_be[1]) internal_register_1[15:8]  = req_data[15:8];\n                         if (req_be[0]) internal_register_1[7:0]   = req_data[7:0];\n                     end\n                     // 添加更多寄存器映射或内存访问（例如，BRAM访问）\n                     default: begin\n                         // 处理BAR0内未映射的写入，例如，忽略或记录\n                     end\n                 endcase\n             end else if (req_read) begin // 这是读取操作\n                 case (bar0_offset)\n                     // 示例：从internal_register_0读取\n                     32'h0000_0000: rsp_data = internal_register_0;\n                     // 示例：从internal_register_1读取\n                     32'h0000_0004: rsp_data = internal_register_1;\n                     // 添加更多寄存器映射或内存访问（例如，BRAM访问）\n                     default: begin\n                         rsp_data = 32'h0; // 对于未映射的读取返回0或特定错误值\n                     end\n                 endcase\n             end\n         end\n     end\n     ```\n   * **处理数据传输：**  `always_comb`块（或`always_ff`用于时序逻辑）应定义如何为读取生成`rsp_data`，以及如何根据`bar0_offset`和字节使能（`req_be`）更新内部寄存器/内存。\n3. **实现BRAM访问（如果BAR映射到BRAM）：**\n\n   * 如果BAR映射到大块内存（例如，256MB），您通常会实例化一个BRAM IP核（如8.2.1所述）并将其`bar_controller`逻辑与它连接。`bar_controller`将向BRAM提供地址和控制信号。\n   * **概念性BRAM集成（简化）：**\n     ```verilog\n     // 在pcileech_tlps128_bar_controller.sv或子模块中\n     // BRAM接口\n     wire [BAR0_SIZE_BITS-1:0] bram_addr;\n     wire [31:0] bram_wr_data;\n     wire [3:0] bram_wr_en; // BRAM的字节使能\n     wire bram_wr_ce;\n     wire bram_rd_ce;\n     wire [31:0] bram_rd_data;\n\n     // 将TLP信号映射到BRAM接口\n     assign bram_addr = bar0_offset;\n     assign bram_wr_data = req_data;\n     assign bram_wr_en = req_be;\n     assign bram_wr_ce = bar_hit[0] && req_write;\n     assign bram_rd_ce = bar_hit[0] && req_read;\n\n     // 实例化BRAM IP核\n     bram_bar_zero bram_inst ( // 假设'bram_bar_zero'是您的BRAM IP模块\n         .clka(clk),\n         .ena(1'b1),\n         .wea(bram_wr_en),\n         .addra(bram_addr),\n         .dina(bram_wr_data),\n         .douta(bram_rd_data)\n     );\n\n     // 对于从BAR0的读取，输出BRAM的数据\n     if (bar_hit[0] && req_read) begin\n         rsp_data = bram_rd_data;\n     end\n     ```\n4. **保存更改：**\n\n   * 实现每个BAR的逻辑后，保存`pcileech_tlps128_bar_controller.sv`文件。\n   * **验证功能：**  此逻辑很复杂。彻底的仿真（使用测试平台）和后续的硬件测试对于确保正确行为至关重要。\n\n#### **8.2.3 处理多个BAR**\n\n正确管理多个BAR对于暴露多个独立内存或I/O区域的设备至关重要。`bar_controller`模块通常处理所有BAR。\n\n**步骤：**\n\n1. **实现每个BAR的逻辑：**\n\n   * 在`pcileech_tlps128_bar_controller.sv`内部，扩展逻辑以处理您的捐赠设备使用的所有已启用BAR（BAR0、BAR1、BAR2等）。\n   * **独立逻辑块：**  为清晰和可维护性，创建独立的`if/else if`块或`case`语句，根据哪个`bar_hit`信号被断言而激活。\n     ```verilog\n     // BAR0处理\n     if (bar_hit[0]) begin\n         // BAR0特定读/写逻辑，用于其寄存器/内存\n     end else if (bar_hit[1]) begin\n         // BAR1特定读/写逻辑，用于其寄存器/内存\n     end else if (bar_hit[2]) begin\n         // BAR2特定逻辑\n     end\n     // ... 继续其他BAR\n     ```\n   * **定义寄存器和内存：**  根据需要为每个BAR分配独立的寄存器集或连接不同的BRAM实例。\n2. **确保非重叠地址空间：**\n\n   * 虽然PCIe IP核处理与主机操作系统的每个BAR的不同地址空间的协商，但您的内部固件逻辑*必须*假定这些空间是独立的且不重叠的。\n   * **验证地址范围**：仔细检查PCIe IP核中的BAR大小配置，以确保它们是独立的，并且根据PCIe规范正确地对齐到2的幂次方边界。\n   * **更新地址解码**：您的`bar_controller`逻辑依赖于PCIe IP核生成的`bar_hit`信号。确保这些信号被正确解释并导致每个BAR的独特处理逻辑。\n3. **测试BAR访问：**\n\n   * **仿真测试：**  在硬件部署之前，使用仿真工具（例如Vivado仿真器）和全面的测试平台来验证对每个BAR的所有读写操作。\n     * 向每个BAR内的特定偏移量发送内存写入TLP。\n     * 向每个BAR内的特定偏移量发送内存读取TLP并验证返回的数据。\n   * **硬件测试：**  编程FPGA后，使用主机端软件工具（如PCILeech客户端软件或定制C/Python脚本）访问和验证每个BAR。\n     * **Linux**：使用`lspci -vvv`检查BAR映射（`Memory at XXXX (64-bit, prefetchable) [size=YYYY]`）。然后可以使用`devmem2`或自定义内核模块来读/写这些映射地址。\n     * **Windows**：使用“RW-Everything”等工具或自定义用户模式应用程序来检查和与映射的内存区域交互。\n     * 执行各种读/写模式以确保所有BAR之间的数据完整性和正确寻址。\n\n---\n\n### **8.3 仿真设备电源管理和中断**\n\n实现电源管理功能和中断对于需要与主机操作系统的电源管理和中断处理机制密切高效交互的设备至关重要。没有这些，仿真设备可能无法完全正常工作，或者性能可能不理想。\n\n#### **8.3.1 电源管理配置**\n\n实现电源管理允许仿真设备支持各种电源状态（例如D0、D3hot），有助于系统范围的电源效率并符合操作系统的预期。主机操作系统将查询设备的功能并发送命令以在这些状态之间转换。\n\n**步骤：**\n\n1. **在PCIe IP核中启用电源管理：**\n\n   * **访问功能：**  在PCIe IP核定制窗口（`pcie_7x_0.xci`）中，导航到 **PCIe Capabilities**（PCIe功能）选项卡。\n   * **启用电源管理：**  查找与 **Power Management Capability**（电源管理功能）相关的部分或选项。确保已选中或启用此选项，以便在设备的配置空间中包含电源管理（PM）功能结构。\n2. **设置支持的电源状态：**\n\n   * **配置支持的状态：**  在IP核的电源管理功能部分，指定设备支持的电源状态。这些通常是复选框或下拉菜单。将这些设置与您通过Arbor观察到的捐赠设备的能力相匹配。\n     * **D0（完全开启/运行）** ：始终支持。\n     * **D1、D2（中间状态）** ：可选，用于低功耗空闲状态。\n     * **D3hot（断电，辅助电源存在）** ：设备逻辑关闭，但可以响应PM事件。\n     * **D3cold（完全断电）** ：设备没有电源。\n   * **示例**：如果捐赠设备仅支持D0和D3hot，则只启用它们。\n3. **在固件中实现电源状态逻辑：**\n\n   * **打开 **​**​`pcileech_pcie_cfg_a7.sv`​**​ **（或相关控制模块）：**  您通常需要修改固件以反映并可能响应主机命令的电源状态转换。PCIe核本身处理大部分协议，但您的用户逻辑需要知道当前状态。\n   * **处理电源管理控制和状态寄存器（PMCSR）写入：**  主机操作系统通过写入PMCSR中的特定位来改变设备的电源状态，PMCSR是PM能力结构的一部分。您的固件理想情况下应有逻辑来读取这些位并调整设备行为（例如，暂停/恢复操作，启用/禁用时钟）。\n     ```verilog\n     // 示例：pcileech_pcie_cfg_a7.sv或专用PM模块的一部分\n     // 假设'cfg_write'在配置写入时被断言，'cfg_address'是偏移量，'cfg_writedata'是数据。\n     // D状态位位于PM能力结构中偏移量0x04处，位[1:0]。\n\n     // PMCSR寄存器（内部表示）\n     reg [15:0] pmcsr_reg = 16'h0000; // 初始化为D0\n\n     // 用户逻辑信号，指示当前电源状态\n     reg [1:0] current_d_state = 2'b00; // 00 = D0, 01 = D1, 10 = D2, 11 = D3hot\n\n     always @(posedge clk) begin\n         if (reset) begin\n             pmcsr_reg <= 16'h0000;\n             current_d_state <= 2'b00; // 重置为D0\n         end else begin\n             // 示例：捕获对PMCSR的写入（如果直接在用户逻辑中处理）\n             // 注意：PCIe IP核管理大部分内容，但您的用户逻辑可能需要从中读取值。\n             // 假设PCIe核提供一个反映当前D状态的输出：\n             // assign current_d_state = pcie_core_d_state_output;\n\n             // 如果用户逻辑*需要*写入PMCSR（较少见，通常是只读状态）\n             // 或者它需要处理命令\n             // if (cfg_write && (cfg_address == PM_CAP_OFFSET + 2'h04)) begin // PMCSR在PM Cap基础地址+0x04\n             //     pmcsr_reg[1:0] <= cfg_writedata[1:0]; // 捕获新D状态\n             //     // current_d_state <= cfg_writedata[1:0]; // 更新内部状态\n             // end\n\n             // 在PCILeech中，PCIe核管理PMCSR。您可能会从核读取信号。\n             // 为了演示，假设'pcie_d_state'是来自IP核的输入。\n             current_d_state <= pcie_d_state; // 根据PCIe核的状态更新\n         end\n     end\n\n     // 示例：响应D状态变化的逻辑\n     always @(*) begin\n         if (current_d_state == 2'b11) begin // D3hot状态\n             // 禁用非必要模块的电源，暂停操作，\n             // 断言信号给主DMA逻辑以停止活动。\n             // 例如：dma_engine_enable = 1'b0;\n         end else if (current_d_state == 2'b00) begin // D0状态\n             // 启用全部功能\n             // 例如：dma_engine_enable = 1'b1;\n         end\n     end\n     ```\n   * **管理电源状态效果：**  实现逻辑以根据`current_d_state`更改设备的内部行为（例如，启用/禁用时钟，将子模块置于低功耗模式）。这对于精确的功耗仿真以及确保设备正确响应操作系统命令至关重要。\n4. **保存更改：**\n\n   * 保存任何修改过的固件文件。\n   * 通过仿真或硬件测试（例如，Windows“睡眠”或“休眠”功能，或Linux `poweroff`命令）彻底测试电源管理功能，以查看设备是否正确转换。\n\n#### **8.3.2 MSI/MSI-X配置**\n\n实现消息信号中断（MSI）或其扩展版本（MSI-X）允许仿真设备使用基于消息的中断。这些中断比传统的引脚中断（INTx）效率更高、可扩展性更强，是现代PCIe设备的优选方法。MSI/MSI-X允许设备通过向特定内存地址写入特殊TLP来通知CPU。\n\n**步骤：**\n\n1. **在PCIe IP核中启用MSI/MSI-X：**\n\n   * **访问中断配置：**  在PCIe IP核定制窗口（`pcie_7x_0.xci`）中，导航到 **Interrupts**（中断）选项卡或专门标记为 **MSI/MSI-X Capabilities**（MSI/MSI-X功能）的部分。\n   * **选择中断类型：**  根据捐赠设备的功能，选择 **MSI** 或 **MSI-X**。MSI-X通常因其灵活性（更多向量，每个向量可屏蔽）而受到青睐。\n   * **配置支持的向量数量：**  设置设备将支持的中断向量（消息）数量。这应与捐赠设备匹配。\n     * **MSI** 支持最多32个向量（通常是1、2、4、8、16或32）。\n     * **MSI-X** 支持最多2048个向量，允许更细粒度的中断源。\n   * **启用功能：**  确保MSI或MSI-X功能结构已明确启用，以便包含在设备的配置空间中。这是主机操作系统发现设备中断能力的方式。\n2. **在固件中实现中断逻辑：**\n\n   * **打开 **​**​`pcileech_pcie_tlp_a7.sv`​**​ **（或用户逻辑模块）：**  此文件通常负责用户定义的TLP生成，并且可能是启动MSI/MSI-X消息的合适位置。但是，中断的*触发*将来自您的自定义逻辑。\n   * **定义中断信号：**  声明内部信号，指示何时需要生成中断。\n     ```verilog\n     // 在自定义模块中（例如，'my_device_logic.sv'），该模块与TLP生成逻辑接口\n     reg msi_trigger_signal; // 当发生中断条件时断言此信号\n     ```\n   * **实现中断生成逻辑：**  定义应该触发中断的条件。这通常涉及在仿真设备的逻辑中检测事件。\n     ```verilog\n     // 在'my_device_logic.sv'内部\n     input wire clk;\n     input wire reset;\n     input wire event_data_ready; // 示例：当数据就绪时来自您的逻辑的输入\n\n     always @(posedge clk or posedge reset) begin\n         if (reset) begin\n             msi_trigger_signal <= 1'b0;\n         end else if (event_data_ready) begin // 当特定事件发生时\n             msi_trigger_signal <= 1'b1; // 触发MSI\n         end else begin\n             msi_trigger_signal <= 1'b0; // 一个周期后或被确认后清除\n         end\n     end\n     ```\n   * **连接到PCIe核的MSI接口：**  `msi_trigger_signal`（或您的自定义逻辑的类似输出）需要连接到PCIe IP核的适当输入（例如，如果使用AXI-Stream接口进行MSI TLP，则连接到`s_axis_tdata_tready`、`s_axis_tdata_tvalid`、`s_axis_tdata_tlast`；或者连接到IP核提供的专用MSI请求端口）。然后PCIe核会形成并发送实际的MSI/MSI-X TLP。有关精确的接口详细信息，请查阅Xilinx PCIe IP核文档。\n3. **保存更改：**\n\n   * 实现中断逻辑后，保存所有修改过的固件文件。\n   * **检查时序约束：**  新逻辑，特别是中断路径，可能对时序很敏感。确保综合和实现工具不会报告与您的中断生成逻辑相关的任何时序违规。\n\n#### **8.3.3 实现中断处理逻辑（设备端）**\n\n除了启用功能之外，定义仿真设备何时以及如何生成中断对于其与主机中断处理机制和驱动程序行为的正确交互至关重要。这涉及创建断言中断请求的内部逻辑。\n\n**步骤：**\n\n1. **定义中断条件：**\n\n   * **识别触发事件：**  根据您的捐赠设备的行为，确定哪些特定的内部事件应导致您的仿真设备生成中断。\n     * **示例**：数据传输完成、接收缓冲区中有新数据、内部错误条件、特定命令完成、链路状态更改。\n   * **实现条件逻辑：**  在您的自定义SystemVerilog模块中使用组合逻辑或时序逻辑，精确检测这些事件并生成一个短脉冲或电平信号，指示中断请求。\n2. **创建中断生成模块（模块化设计）：**\n\n   * 将中断生成逻辑封装到一个单独的专用模块中是一个好习惯，这样可以提高清晰度、可重用性并方便调试。此模块将内部事件作为输入，并产生一个连接到PCIe核的`msi_req`（或类似）输出。\n     ```verilog\n     // 文件：interrupt_generator.sv\n     module interrupt_generator (\n         input wire clk,\n         input wire reset,\n         input wire event_trigger,        // 来自您的自定义逻辑的输入信号（例如，data_ready, error_flag）\n         output reg msi_req_o            // 输出：断言此信号以请求MSI/MSI-X\n     );\n\n     // MSI的简单脉冲发生器（一次性中断）\n     reg event_trigger_d1;\n\n     always @(posedge clk or posedge reset) begin\n         if (reset) begin\n             msi_req_o <= 1'b0;\n             event_trigger_d1 <= 1'b0;\n         end else begin\n             event_trigger_d1 <= event_trigger;\n             // 当event_trigger从低到高跳变时，生成一个单周期脉冲\n             if (event_trigger && !event_trigger_d1) begin\n                 msi_req_o <= 1'b1; // 断言MSI请求\n             end else begin\n                 msi_req_o <= 1'b0; // 一个周期后取消断言\n             end\n         end\n     end\n\n     endmodule // interrupt_generator\n     ```\n   * **与主固件集成：**  在您的顶层用户逻辑中（例如，在`pcileech_squirrel_top.sv`或其实例化的模块中）实例化此`interrupt_generator`模块，并将其`msi_req_o`输出连接到PCIe IP核的MSI输入。\n3. **确保正确的时序和序列：**\n\n   * **遵守PCIe规范：**  MSI/MSI-X消息是TLP。确保这些消息的生成符合PCIe TLP格式、流控制和时序要求。PCIe IP核处理大部分内容，但您提供给它的输入信号必须稳定且时序正确。\n   * **管理中断延迟：**  优化您的逻辑，以最大限度地减少内部事件发生与`msi_req_o`信号断言之间的任何不必要延迟。\n4. **测试中断传递：**\n\n   * **仿真：**  使用全面的测试平台模拟应生成中断的场景。验证您的`msi_req_o`信号是否按预期工作，以及PCIe核是否生成正确的MSI/MSI-X TLP。\n   * **硬件测试：**\n     * 用更新的固件编程FPGA。\n     * 使用主机端软件触发应引起中断的事件（例如，启动完成的DMA传输）。\n     * 确认主机操作系统接收到中断。在Linux上，`dmesg`可以显示中断消息。在Windows上，您可以使用特定的驱动程序调试工具或事件查看器。\n     * **调试工具：**  利用Vivado的集成逻辑分析仪（ILA）核（如第12节所述）实时监控`event_trigger`、`msi_req_o`和PCIe核的TLP输出信号，以验证正确的中断生成。\n5. **保存更改：**\n\n   * 完成所有代码修改并保存相关固件文件。\n   * 根据测试结果审查并改进您的中断逻辑，以确保可靠性。\n\n---\n\n## **9. 仿真设备特定功能**\n\n除了标准的PCIe配置空间和通用DMA功能之外，许多捐赠设备还具有独特的功能、自定义寄存器或厂商特定功能，这些对于其完整功能或与其专有驱动程序交互至关重要。精确的仿真需要理解和复制这些细微之处。本节将深入探讨如何实现这些高级功能，从而实现更忠实和功能更全面的仿真。\n\n### **9.1 实现高级PCIe功能**\n\nPCIe规范包含除了基本配置空间之外的各种*扩展功能*。这些功能提供了高级错误报告、电源管理、虚拟化等特性。实现这些功能有助于您的仿真设备显得更合法，并与现代主机系统正确交互。\n\n**步骤：**\n\n1. **识别所需的扩展功能：**\n\n   * 在使用Arbor等工具收集捐赠设备信息时，请仔细查找并记录捐赠设备配置空间中存在的任何扩展功能。这些通常在标准配置空间的初始256字节之外找到。\n   * **常见示例：**\n     * **高级错误报告（AER）** ：为PCIe链路提供强大的错误检测、日志记录和报告机制。\n     * **设备序列号（DSN）** ：（已在第6.2节中介绍）。\n     * **电源管理（PM）** ：（已在第8.3.1节中介绍）。\n     * **PCI Express（PCIe）功能结构**：（已在第8.1节中介绍链路速度/宽度、最大载荷/读取请求，但也包括其他字段，如设备控制/状态、链路控制/状态）。\n     * **虚拟通道（VC）/多功能虚拟通道（MFVC）** ：用于服务质量（QoS）和流量管理。\n     * **精确时间测量（PTM）** ：用于设备之间的时间同步。\n     * **延迟容忍报告（LTR）** ：基于延迟要求进行电源管理。\n     * **可重置FPC（功能级重置）** ：用于更细粒度的重置。\n2. **在Vivado PCIe IP核中启用功能：**\n\n   * 访问Vivado中的PCIe IP核定制窗口（`pcie_7x_0.xci`）。\n   * 导航到各个选项卡（例如，“PCIe Capabilities”、“Extended Capabilities”、“Advanced Options”）。\n   * 查找复选框或下拉菜单，以启用和配置从捐赠设备中识别出的特定扩展功能。\n   * **示例（AER）：**  您会找到一个“高级错误报告”部分，您可以在其中启用它并配置其寄存器（例如，严重性掩码）。\n   * **注意：**  Xilinx PCIe IP核为许多标准和扩展功能提供了高度可配置性。通常只需在GUI中启用正确的选项即可。\n3. **实现功能寄存器的固件逻辑（如果需要）：**\n\n   * 虽然PCIe IP核处理这些功能的*存在*和大部分*协议*，但某些功能会暴露您的自定义固件可能需要读写或其值需要固件响应的寄存器。\n   * **示例（AER）：**  如果您的仿真设备检测到应通过AER报告的内部错误，您的固件需要写入特定的AER错误状态寄存器（这些寄存器可能作为BAR的一部分暴露，或由PCIe核内部处理，然后反映到用户逻辑）。然后您的用户逻辑将向PCIe核断言错误输入。\n   * **示例（电源管理）：**  如8.3.1节所述，您的固件需要响应PCIe核发出的D状态变化。\n   * **流程：**\n     * 识别您的捐赠设备驱动程序交互的每个已启用功能结构中的特定寄存器。\n     * 在PCILeech-FPGA框架中找到与这些寄存器接口的相应信号或逻辑（通常在`pcileech_pcie_cfg_a7.sv`或`bar_controller`中）。\n     * 实现这些寄存器的读写逻辑，确保您的仿真设备的内部状态准确反映驱动程序期望的值。\n\n### **9.2 仿真厂商特定功能**\n\n这是真正的“全设备仿真”变得高度专业化的部分。许多实际设备具有独特的寄存器、未文档化的命令、自定义数据格式或专有控制流程，这些都使其与众不同。复制这些需要更深入的分析和定制HDL开发。\n\n**步骤：**\n\n1. **逆向工程厂商特定行为：**\n\n   * 这通常是最具挑战性的部分。\n   * **静态分析（驱动程序/固件）：**  反汇编捐赠设备的官方驱动程序（Windows `.sys`，Linux `.ko`）或设备的原始固件（如果可用）。查找独特的I/O或MMIO访问模式、魔术值或寄存器写入序列。Ghidra、IDA Pro或objdump等工具会非常有价值。\n   * **动态分析（驱动程序执行）：**  运行捐赠设备及其驱动程序，并使用**PCIe协议分析仪**（例如，Teledyne LeCroy，Keysight，如第12.2节所述）监控PCIe流量。这是理解实际TLP交换，包括厂商定义消息和寄存器访问序列的黄金标准。请注意：\n     * BARs中访问的特定内存地址。\n     * 对这些地址的读/写模式。\n     * 写入或读取特定寄存器的值。\n     * 命令和响应之间的时序关系。\n   * **系统调用/API监控**：在主机上，使用Procmon（Windows）或`strace`（Linux）等工具查看驱动程序如何与操作系统交互以及它使用了哪些特定的设备I/O控制（IOCTL）代码，这些代码可能对应于特定的硬件操作。\n   * **硬件嗅探**：如果可能，使用硬件嗅探器（如Saleae逻辑分析仪）捕获设备内部总线（例如SPI，I2C）上的信号，如果它有外部闪存或组件。\n2. **在BARs中实现自定义寄存器和逻辑：**\n\n   * 一旦您识别出厂商特定的寄存器或命令协议，您将需要将这些定义到您的FPGA固件中，通常作为可通过您的某个BAR访问的内存映射寄存器。\n   * **创建内部寄存器：**  在您的SystemVerilog代码中声明`reg`变量来表示这些自定义寄存器。\n     ```verilog\n     // 在pcileech_tlps128_bar_controller.sv或子模块中\n     reg [31:0] custom_control_reg;\n     reg [31:0] custom_status_reg;\n     reg [31:0] custom_data_reg;\n\n     // 示例：将它们映射到BAR0中的特定偏移量（假设BAR0足够大）\n     // 调整'bar0_offset' case语句（来自第8.2.2节）\n     // ...\n     if (bar_hit[0]) begin\n         if (req_write) begin\n             case (bar0_offset)\n                 32'h0000_1000: custom_control_reg <= req_data; // 自定义控制寄存器\n                 32'h0000_1004: custom_data_reg <= req_data;    // 自定义数据写入寄存器\n                 // ... 其他映射\n             endcase\n         end else if (req_read) begin\n             case (bar0_offset)\n                 32'h0000_1000: rsp_data = custom_control_reg; // 读取控制寄存器\n                 32'h0000_1008: rsp_data = custom_status_reg;  // 自定义状态寄存器\n                 // ... 其他映射\n             endcase\n         end\n     end\n     // ...\n     ```\n   * **实现行为逻辑：**  创建SystemVerilog逻辑（状态机、组合逻辑），用于：\n     * 响应对`custom_control_reg`的写入。例如，此寄存器中的某个特定位可能触发DMA传输、清除状态标志或启动内部操作。\n     * 根据仿真设备的内部状态更新`custom_status_reg`（例如，“操作完成”、“发生错误”、“数据可用”）。\n     * 处理写入`custom_data_reg`的数据，或在读取时从中提供数据，模仿捐赠设备的数据路径。\n3. **仿真厂商特定消息（如果适用）：**\n\n   * 一些复杂设备可能通过PCIe使用“厂商定义消息”（VDM）进行特定控制或通信。如果您的分析揭示了此类消息，您将需要：\n     * 在PCIe IP核中启用VDM支持（如果可用）。\n     * 实现TLP生成逻辑（如第10节所述）来制作和发送这些VDM。\n     * 实现TLP接收和解析逻辑来解释来自主机的传入VDM。\n4. **验证仿真行为：**\n\n   * **迭代测试：**  这是一个高度迭代的过程。进行小修改，编译，烧录，然后测试。\n   * **驱动程序加载：**  捐赠设备的驱动程序是否正确加载而没有错误？\n   * **功能测试：**  驱动程序能否启动基本操作？它是否从您的仿真寄存器获得预期的响应？\n   * **应用程序测试：**  依赖捐赠设备的应用程序能否在您的仿真版本下正常运行？\n   * **调试：**  广泛使用ILA和PCIe协议分析仪来比较您的仿真设备的行为与真实捐赠设备捕获的行为。寻找TLP时序、寄存器值和总体协议流中的差异。\n\n---\n\n## **10. 事务层数据包（TLP）仿真**\n\n事务层数据包（TLP）是PCIe架构中通信的基本单位。主机系统与PCIe设备之间的每一次交互，从配置读取到数据传输，都被封装在一个或多个TLP中。精确的TLP仿真不仅重要；它对于您的仿真设备与主机系统正确交互，确保驱动程序正常运行和数据按预期移动，是*至关重要*的。\n\n### **10.1 理解和捕获TLP**\n\n在您能够制作自定义TLP之前，您必须深入理解它们的结构和常见类型。从您的捐赠设备捕获真实世界的TLP可提供最精确的蓝图。\n\n* **TLP结构的学习**：\n  TLP通常由报头、可选数据载荷和可选的端到端CRC（ECRC）组成。报头至关重要，它定义了TLP的类型、事务细节和路由信息。\n\n  * **TLP的组成部分**：\n    * **报头（Header）** ：最重要的部分，通常是3或4个双字（Dword = 4字节）。它包含定义TLP目的和处理方式的关键字段：\n      * **Fmt（格式）和 Type（类型）** ：定义TLP的格式（3DW/4DW，带/不带数据）及其特定目的（例如，内存读取请求、内存写入、完成、配置读取/写入）。\n      * **Length（长度）** ：指定数据载荷的长度（以双字为单位）。\n      * **Requester ID（总线、设备、功能）** ：标识发起请求的PCIe功能。对于将完成数据路由回正确的源头至关重要。\n      * **Tag（标签）** ：由请求者分配给事务的唯一标识符，允许完成者将完成TLP与其原始请求TLP匹配。\n      * **Address（地址）** ：对于内存/IO事务，这是目标内存或I/O地址。\n      * **First DW Byte Enable (FBE)**  和 **Last DW Byte Enable (LBE)** ：指定数据载荷的第一个和最后一个双字中哪些字节对于写入操作有效，或哪些字节正在请求读取完成。\n      * **Traffic Class (TC)**  和 **Transaction ID (TID)** ：用于QoS和排序规则。\n    * **数据载荷（可选）** ：存在于内存写入、配置写入和读取完成等TLP中。它包含实际传输的数据。\n    * **端到端CRC (ECRC)（可选）** ：一个32位CRC，覆盖整个TLP，确保从源到目的地的数据完整性，通常由软件生成/检查。\n* **理解常见的TLP类型**：您的固件将主要处理这些类型：\n\n  * **Memory Read Request (MRd)** ：由请求者（例如，主机CPU，或您的FPGA作为DMA主设备）发送的TLP，用于从特定内存地址读取数据。\n  * **Memory Read Completion (CplD)** ：由完成者（例如，您的FPGA响应主机MRd）发送的TLP，携带请求的数据。\n  * **Memory Write (MWr)** ：由请求者（例如，主机CPU，或您的FPGA）发送的TLP，用于向特定内存地址写入数据。\n  * **Completion Without Data (Cpl)** ：由完成者发送的TLP，用于确认不返回数据的请求（例如，成功的MWr）。\n  * **Configuration Read Request (CfgRd)** ：来自主机的TLP，用于读取设备配置空间中的寄存器。\n  * **Configuration Read Completion (CplD)** ：来自设备返回CfgRd数据数据的TLP。\n  * **Configuration Write Request (CfgWr)** ：来自主机的TLP，用于写入设备配置空间中的寄存器。\n  * **Vendor-Defined Messages (VDM)** ：特定厂商用于专有通信的自定义TLP。\n\n#### **10.1.2 从捐赠设备捕获TLP**\n\n从您的捐赠设备捕获真实的PCIe流量是无价的。它提供了TLP结构、序列和时序的具体示例，使您能够精确地复制它们。\n\n* **步骤**：\n  1. **设置PCIe协议分析仪**：\n     * 最有效的方法是使用专用的硬件工具，通常称为“PCIe协议分析仪”。这些设备位于主机和捐赠PCIe卡之间，被动捕获所有流量。\n     * **示例**：\n       * **Teledyne LeCroy PCIe 分析仪**：行业标准，功能强大，但投资巨大。\n       * **Keysight PCIe 分析仪**：另一个领先的供应商。\n       * （对于基本调试，一些带PCIe解码器的高端逻辑分析仪可能提供有限的TLP查看功能，但真正的协议分析仪更优越）。\n  2. **捕获事务**：\n     * 在连接了协议分析仪的测试系统中安装捐赠设备。\n     * 运行捐赠设备的驱动程序和任何相关应用程序。\n     * 在正常操作期间，尤其是关键阶段，监控和记录PCIe事务，例如：\n       * 设备枚举（操作系统首次检测到它时）。\n       * 驱动程序加载和初始化。\n       * 典型数据传输操作（例如，存储设备的大文件复制，网卡的网络流量）。\n       * 设备特定命令或诊断。\n  3. **分析捕获的TLP**：\n     * 使用协议分析仪的先进软件解剖捕获的TLP。软件将解码字段，提供时间顺序视图，并允许过滤和搜索。\n     * 密切关注：\n       * 精确的`Fmt`和`Type`字段。\n       * `Requester ID`和`Tag`值（特别是对于完成）。\n       * 内存事务的`Address`和`Length`。\n       * 写入和读取完成的`Data Payload`内容。\n       * 任何厂商特定字段或自定义TLP。\n\n#### **10.1.3 记录关键TLP事务**\n\n对捕获的TLP进行结构化文档创建了一个用于您的仿真的蓝图。\n\n* **步骤**：\n  1. **识别关键事务**：\n     * 重点关注对设备核心功能至关重要的TLP。这包括：\n       * **初始化序列**：操作系统在枚举期间执行的一系列配置读/写。\n       * **驱动程序初始化**：驱动程序启动时交换的命令和数据。\n       * **主要数据传输**：`MWr`和`MRd` TLP如何为设备的主要功能构建和完成。\n       * **错误处理**：设备如何报告错误（例如，带有Completer Abort (CA)、Unsupported Request (UR)的Completion）。\n       * **电源管理转换**：与D状态变化相关的TLP。\n       * **中断生成**：MSI/MSI-X消息如何发送。\n     * 协议分析仪的截图在这里会非常有帮助。\n  2. **创建详细文档**：\n     * 对于每个关键TLP序列，记录：\n       * **TLP类型**（例如，MWr、MRd、CplD）。\n       * 其**报头字段**（Fmt、Type、Requester ID、Tag、Length、Address、Byte Enables）。\n       * **数据载荷**（如果适用）。\n       * 事务中的**序列号**或顺序。\n       * 发送它的**条件**（例如，“主机在驱动程序初始化时发送”，“设备在DMA完成时发送”）。\n       * 任何**预期的响应**或后续TLP。\n     * 协议分析仪的截图在这里会非常有帮助。\n  3. **理解时序和序列**：\n     * 除了TLP内容，TLP的*时序*和*序列*至关重要。PCIe有严格的排序规则和流控制机制。注意：\n       * **请求和完成之间的延迟**：真实设备响应的速度。\n       * **流控制信用**：设备如何管理其传入/传出TLP的缓冲区空间。虽然Xilinx PCIe IP核处理基本的流控制，但对于高级仿真，了解捐赠设备的典型信用使用情况会有所帮助。\n       * **事务层数据包排序**：理解posted（写入）和non-posted（读取、完成）事务如何排序。\n\n### **10.2 制作用于特定操作的定制TLP**\n\n一旦您理解了蓝图，您就可以将这些知识转化为您的FPGA固件（SystemVerilog），以主动生成和响应TLP。PCILeech-FPGA框架提供了抽象层，但对于深度仿真，您可能需要直接与TLP生成/解析逻辑交互。\n\n#### **10.2.1 在固件中实现TLP处理**\n\n您的固件需要逻辑来发送和接收TLP。PCIe IP核处理物理层和数据链路层，向您的用户逻辑暴露一个事务层接口（通常是AXI-Stream）。\n\n* **要修改的文件（主要）** ：\n\n  * `pcileech-fpga/<your_board_variant>/src/pcileech_pcie_tlp_a7.sv`（或类似文件，取决于板卡变体）\n    * 此文件通常包含将用户请求转换为出站TLP并将传入TLP解析为用户逻辑信号的核心逻辑。\n  * `pcileech-fpga/<your_board_variant>/src/pcileech_tlps128_bar_controller.sv`\n    * 此模块专门处理解析目标为设备BAR的传入内存读/写TLP，并生成相应的完成TLP。\n* **步骤**：\n\n  1. **理解PCIe IP核接口**：\n\n     * 在编写TLP逻辑之前，请彻底阅读Xilinx PCIe IP核用户指南（特别是关于用户应用接口或AXI4-Stream接口的部分）。这定义了您的SystemVerilog逻辑如何连接到PCIe核以发送和接收TLP。您通常会与`s_axis_rx_tdata`（接收到的TLP数据）、`s_axis_rx_tvalid`（接收到有效TLP）、`m_axis_tx_tdata`（传出TLP数据）、`m_axis_tx_tready`（核已准备好接受TLP）等进行交互。\n  2. **创建TLP生成函数（用于出站TLP）** ：\n\n     * 在`pcileech_pcie_tlp_a7.sv`（或与`m_axis_tx_*`接口的模块）中，您将编写逻辑来组装具有所需报头和载荷的TLP。这通常涉及将各种字段组合成一个`[127:0]`（对于128位接口）或`[63:0]`（对于64位接口）总线，该总线馈送PCIe核。\n     * **示例（概念性，简化函数，用于3DW TLP报头）：**\n       ```verilog\n       // 这是一个概念性辅助函数。实际上，您将构建一个状态机\n       // 通过AXI-Stream接口发送TLP，可能使用FIFO。\n       function automatic [95:0] create_3dw_tlp_header; // 假设3个双字 = 96位\n           input logic [7:0] tlp_type_fmt;   // 格式和类型字段\n           input logic [15:0] requester_id;  // BDF\n           input logic [7:0] tag;\n           input logic [7:0] lower_address_bits; // 或更复杂的地址\n           input logic [7:0] byte_enables;   // 第一个双字字节使能\n\n           begin\n               create_3dw_tlp_header = {\n                   tlp_type_fmt,                     // Fmt[6:4], Type[3:0]\n                   8'b0,                             // 保留\n                   4'b0,                             // TC[3:0] (流量类别)\n                   3'b0,                             // Attr[2:0]\n                   1'b0,                             // TH (TLP提示)\n                   2'b0,                             // D(igest) (ECRC存在)\n                   1'b0,                             // EP (Poisoned)\n                   1'b0,                             // TD (类型依赖)\n                   // DW0: Fmt, Type, TC, Attr, TH, D, EP, TD, Length (不在3DW中, 4DW有)\n\n                   requester_id,                     // 请求者ID (Bus[7:0], Device[4:0], Function[2:0])\n                   tag,                              // 标签\n                   lower_address_bits,               // 示例：地址的低位或数据的一部分\n                   byte_enables,                     // 第一个双字字节使能\n                   4'b0,                             // 保留\n                   4'b0                              // 最后一个双字字节使能 (通常用于MWr)\n                   // DW1, DW2... 字段\n               };\n           end\n       endfunction\n\n       // 示例：在状态机中生成带数据的完成（CplD）\n       // 这只是一个片段，不是完整实现\n       localparam  CPLD_3DW_FMT = 8'h4A; // Fmt=100 (4DW, 带数据), Type=1010 (Cpl)\n       localparam  CPL_D_FMT_TYPE_LEN = 8'h4A; // 根据PCIe规范调整。(带数据的4DW报头)\n\n       // ... 发送TLP的状态机\n       // 在准备发送CplD的状态下\n       if (tx_ready_from_pcie_core) begin\n           // 构建报头和载荷\n           // 对于CplD，您需要Compliter ID, Status, Byte Count, Requester ID, Tag, Completion ID, Lower Address\n           // 然后是实际的读取数据载荷\n           m_axis_tx_tdata_reg = {\n               CPL_D_FMT_TYPE_LEN,         // 字节0: Fmt/Type\n               tlp_length_dw_minus_one,    // 字节1: TLP长度 (以双字为单位) - 1\n               status_completion_bits,     // 字节2: Cpl Status, BCM, Rsvd\n               byte_count_dws_upper,       // 字节3: 字节计数 (高位)\n               requester_id,               // 字节4-5: 请求者ID (来自原始MRd)\n               tag,                        // 字节6: 标签 (来自原始MRd)\n               byte_count_dws_lower,       // 字节7: 字节计数 (低位)\n               completion_id,              // 字节8-9: 完成ID (您的BDF)\n               lower_address_from_request  // 字节10-11: 请求的低位地址\n               // ... 接着是实际的数据载荷\n           };\n           m_axis_tx_tvalid_reg = 1'b1;\n           m_axis_tx_tlast_reg = 1'b1; // 最后一个TLP片段\n           // ... 状态转换以等待tready\n       end\n       ```\n     * **注意**：实际实现涉及状态机、FIFO，以及遵循PCIe IP核的AXI-Stream协议。PCILeech-FPGA框架已经为此提供了良好的基础，但您可能需要为非常特定的TLP行为进行扩展或修改。\n  3. **处理TLP接收（用于入站TLP）** ：\n\n     * 实现逻辑以解析来自PCIe核接收接口的传入TLP（例如，`s_axis_rx_tdata`、`s_axis_rx_tvalid`）。\n     * 此解析包括：\n       * 检查`s_axis_rx_tvalid`以判断是否存在TLP。\n       * 从TLP报头中读取`Fmt`和`Type`字段以确定其目的。\n       * 提取`Requester ID`、`Tag`、`Address`、`Length`和`Data Payload`等相关字段。\n     * 使用`case`语句或`if/else if`块，根据TLP类型将信息路由到适当的内部逻辑（例如，用于内存写入的`bar_controller`，用于配置写入的配置模块）。\n     * **示例（概念性，简化解析）：**\n       ```verilog\n       // 在pcileech_pcie_tlp_a7.sv或TLP解析模块中\n       input wire [127:0] s_axis_rx_tdata;\n       input wire s_axis_rx_tvalid;\n       output wire s_axis_rx_tready; // 需要断言此信号以接受更多数据\n\n       reg [7:0] received_tlp_fmt_type;\n       reg [15:0] received_requester_id;\n       // ... 声明其他已解析的字段\n\n       assign s_axis_rx_tready = 1'b1; // 为简化起见始终准备好接收，在实际设计中管理反压\n\n       always @(posedge clk) begin\n           if (s_axis_rx_tvalid) begin\n               received_tlp_fmt_type = s_axis_rx_tdata[127:120]; // 假设最高位\n               received_requester_id = s_axis_rx_tdata[111:96]; // 示例偏移量\n\n               // 根据TLP类型解码\n               case (received_tlp_fmt_type[3:0]) // 仅TLP类型位\n                   4'h0: // 内存写入 (3DW或4DW取决于Fmt)\n                       // 提取地址、长度、载荷并传递给BAR控制器\n                       begin\n                           // 传递给BAR控制器，用于写入仿真内存\n                           // bar_write_enable = 1'b1;\n                           // bar_write_address = s_axis_rx_tdata[...];\n                           // bar_write_data = s_axis_rx_tdata[...];\n                       end\n                   4'h1: // 内存读取\n                       // 提取地址、长度，并传递给BAR控制器进行读取\n                       begin\n                           // bar_read_enable = 1'b1;\n                           // bar_read_address = s_axis_rx_tdata[...];\n                           // (完成将由BAR控制器生成)\n                       end\n                   // ... 其他TLP类型\n                   default: begin\n                       // 处理不支持或保留的TLP类型（例如，日志记录、错误）\n                   end\n               endcase\n           end\n       end\n       ```\n  4. **确保符合性**：\n\n     * 严格验证您生成和解析的TLP是否符合PCIe规范的格式、字段定义和时序。偏差将导致通信失败。\n  5. **实现完成处理**：\n\n     * 对于从主机接收到的内存读取请求（MRd）和配置读取请求（CfgRd），您的设备必须在指定的时间内返回适当的完成TLP（CplD表示数据，Cpl表示无数据）。`bar_controller`模块（第8.2.2节）是此BAR读取逻辑所在的位置。\n  6. **保存更改**：\n\n     * 保存文件（`pcileech_pcie_tlp_a7.sv`、`pcileech_tlps128_bar_controller.sv`或任何自定义模块）后，实现更改。\n\n#### **10.2.2 处理不同TLP类型**\n\n每种TLP类型都有特定的报头格式和行为。您的固件必须擅长处理与您的捐赠设备相关的那些类型。\n\n* **内存读取请求（MRd）** ：\n\n  * **实现**：\n    * 当接收到MRd TLP（由`pcileech_pcie_tlp_a7.sv`解析并路由到`bar_controller`）时，`bar_controller`需要：\n      * 解析请求的地址和长度。\n      * 从适当的内部内存位置（例如，连接到BAR的BRAM）或内部寄存器中获取数据。\n      * 组装一个**带数据的完成（CplD）**  TLP。关键是，此TLP必须包含来自MRd请求的原始`Requester ID`、`Tag`和`Completion ID`（您的设备BDF），以及获取的数据载荷。\n      * 通过PCIe IP核的传输接口将CplD TLP发送回主机。\n* **内存写入请求（MWr）** ：\n\n  * **实现**：\n    * 当接收到MWr TLP时，`bar_controller`需要：\n      * 解析目标地址、长度和`Byte Enables`（FBE/LBE）。\n      * 提取`数据载荷`。\n      * 将数据写入仿真设备内的指定内存位置（例如，BRAM或内部寄存器），并遵循字节使能。\n    * 内存写入是“posted事务”，这意味着它们不需要完成TLP进行确认，除非发生错误。\n* **配置读/写请求（CfgRd/CfgWr）** ：\n\n  * **实现**：\n    * 这些TLP针对设备的配置空间（厂商ID、设备ID、BAR、功能等）。Xilinx PCIe IP核根据其配置自动处理大部分标准配置空间访问。\n    * 但是，如果您的配置空间中存在非标准的自定义寄存器或扩展功能，您可能需要特定的逻辑来：\n      * 对于CfgRd：从您的内部`cfg_`寄存器返回请求的数据。\n      * 对于CfgWr：更新您的内部`cfg_`寄存器或根据写入的数据触发操作。\n    * 配置读取需要**带数据的完成（CplD）** ，而配置写入需要**不带数据的完成（Cpl）** 。\n* **厂商定义消息（VDM）** ：\n\n  * **实现**：\n    * 如果您的捐赠设备使用VDM，这将需要专门的解析和响应逻辑。\n    * **解析传入VDM**：根据其`Fmt`和`Type`字段识别VDM。提取厂商特定数据并根据您的逆向工程发现进行解释。\n    * **制作出站VDM**：当您的仿真设备需要发送VDM时，创建逻辑来组装具有精确厂商特定报头和载荷格式的VDM。\n\n#### **10.2.3 验证TLP时序和序列**\n\n即使TLP格式完美，不正确的时序或序列也会导致设备故障或被检测为不兼容。\n\n* **步骤**：\n\n  1. **使用仿真工具**：\n\n     * **测试平台**：为您的TLP生成和解析模块开发全面的SystemVerilog测试平台。\n     * 模拟各种场景（例如，主机发送MRd，您的设备发送CplD；主机发送MWr；主机枚举设备），以验证TLP是否正确形成、传输、接收和处理。\n     * 验证TLP的序列，并确保在合理的时间内发送完成。\n  2. **使用ILA监控（集成逻辑分析仪）** ：\n\n     * 如第12.1节所述，在您的Vivado设计中插入一个ILA核。\n     * 将ILA探头连接到PCIe IP核的AXI-Stream接口（例如，`s_axis_rx_tdata`、`s_axis_rx_tvalid`、`m_axis_tx_tdata`、`m_axis_tx_tready`）。\n     * 设置触发器以捕获特定TLP（例如，在`m_axis_tx_tvalid`上针对某种TLP类型触发）。\n     * 这使您可以在硬件操作期间实时查看FPGA上的实际TLP位，验证您的固件是否向/从PCIe IP核发送/接收正确的数据和控制信号。\n  3. **检查时序约束**：\n\n     * PCIe IP核对其AXI-Stream接口有严格的时序要求。确保您的用户逻辑向`m_axis_tx_tdata`提供数据和处理`s_axis_rx_tdata`满足这些时序约束。\n     * Vivado的时序分析报告（综合和实现后）将标记任何违规。通过优化您的逻辑或在可能的情况下调整时钟来解决这些问题。\n  4. **符合性测试（高级）** ：\n\n     * 对于高保真仿真，请考虑使用专用的PCIe符合性测试套件（通常与高端协议分析仪集成）。这些测试系统地检查是否符合PCIe规范，揭示细微的协议违规。\n  5. **保存更改**：\n\n     * 在彻底测试和验证后保存所有修改过的文件。迭代是TLP级调试的关键。\n\n---\n\n## **第三部分：高级技术与优化**\n\n---\n\n## **11. 构建、烧录与测试**\n\n完成所有定制后，就到了验证的时刻：构建固件，将其编程到您的FPGA上，并严格测试其功能，以确保它与捐赠设备的行为完全一致。此阶段将您的设计从代码转换为可工作的硬件仿真。\n\n### **11.1 综合与实现**\n\n这是FPGA设计流程中的核心步骤，您的SystemVerilog高级代码将被转换为可以加载到FPGA上的低级硬件配置。\n\n#### **11.1.1 运行综合**\n\n综合是Vivado将您的HDL代码转换为门级网表（逻辑门及其互连的描述）的过程。它还执行初步的时序分析和资源估算。\n\n* **步骤**：\n  1. **开始综合**：\n     * 在Vivado GUI中，在 **Flow Navigator**（流程导航器）窗格（通常在左侧）中，在“Synthesis”（综合）下，点击 **Run Synthesis**（运行综合）。\n  2. **监控进度**：\n     * Vivado将打开一个“Launch Runs”（启动运行）对话框。您通常只需点击“OK”。\n     * 监控Vivado窗口底部的 **Messages**（消息）选项卡。它将显示综合运行的进度。\n     * **常见警告/错误关注点**：\n       *  **​`[Synth 8-327]`​**​ ** Unconnected Ports / Unused Inputs（未连接端口/未使用的输入）** ：这表明您设计中的信号或端口未连接到任何东西。虽然有时是故意的（例如，FPGA上未使用的引脚），但它们也可能指向端口名称中的拼写错误或遗忘的连接。检查每个警告以确保这不是功能问题。\n       *  **​`[Synth 8-256]`​**​ ** Registers/Wires Not Optimized（寄存器/线未优化）** ：这可能表明逻辑推断不正确，或者您有冗余逻辑可以优化。\n       * **Syntax Errors（语法错误）** ：如果您的SystemVerilog代码中有致命的语法错误，综合将立即失败。请在Visual Studio Code中修复这些错误。\n  3. **审查综合报告**：\n     * 成功完成后，Vivado将询问您下一步要做什么。选择 **Open Synthesized Design**（打开综合设计）或 **Open Report**（打开报告）。\n     * 最重要的是，查看综合报告中的 **Utilization Summary**（资源利用率摘要）。这显示了您的设计消耗了FPGA多少资源（LUT、触发器、BRAM、DSP）。确保设计适合您的目标FPGA的容量（例如，对于Artix-7 35T，您应该在其限制内）。\n\n#### **11.1.2 运行实现**\n\n实现是最耗时的一步。它接收综合后的网表并将其物理映射到FPGA的资源上（放置逻辑块，布线连接），然后执行详细的时序分析，以确保设计能够以指定的时钟频率运行。\n\n* **步骤**：\n  1. **开始实现**：\n     * 成功综合后，在 **Flow Navigator**（流程导航器）中，在“Implementation”（实现）下，点击 **Run Implementation**（运行实现）。\n     * 确认“Launch Runs”（启动运行）对话框。\n  2. **监控进度**：\n     * 实现包括几个阶段：Opt Design（优化设计）、Power Opt Design（功耗优化设计）、Place Design（放置设计）、Post-Placement Phys Opt Design（后放置物理优化设计）、Route Design（布线设计）、Post-Route Phys Opt Design（后布线物理优化设计）。每个阶段都可能需要大量时间。\n     * 监控 **Messages**（消息）选项卡以了解进度和潜在问题。\n  3. **分析时序报告**：\n     * 这是实现后*最关键的步骤*。完成后，Vivado会再次询问下一步做什么。选择 **Open Implemented Design**（打开已实现设计），或者更重要的是，选择 **Open Report**（打开报告），然后选择 **Report Timing Summary**（报告时序摘要）。\n     * **确保所有时序约束都得到满足。**  查找“WNS (Worst Negative Slack)”值。\n       * **正WNS**：表示所有时序路径都满足其要求（有余量）。这是您想要的结果。\n       * **负WNS**：表示**时序违规**，这意味着您的设计无法在所需的时钟频率下运行，或者数据可能不稳定。**这是一个必须解决的关键问题。**\n     * **解决违规**：\n       * 如果您有负余量，请调查失败的具体路径。Vivado的时序报告将显示失败路径的源、目标和组件。\n       * 解决方案可以包括：\n         * 优化HDL代码以减少逻辑深度或关键路径延迟。\n         * 添加流水线级（寄存器）以打断长组合路径。\n         * 改进XDC（约束）文件，确保所有时钟都正确定义和传播。\n         * 调整时钟频率（如果应用程序允许）。\n         * 在Vivado中使用更快的时序收敛策略。\n         * 确保您的自定义逻辑与PCIe核的AXI-Stream接口时序要求正确接口。\n  4. **验证布局（可选）** ：\n     * 在已实现的设计中，您可以打开“Device”（器件）视图，查看您的逻辑如何在FPGA上布局。这通常适用于高级用户，以确认关键组件是否最佳布局（例如，靠近PCIe收发器）。\n\n#### **11.1.3 生成比特流**\n\n比特流是最终的二进制配置文件（`.bit`扩展名），将被加载到您的FPGA上。它是综合和实现的成果。\n\n* **步骤**：\n  1. **生成比特流**：\n     * 成功实现后（没有严重的时序违规），在 **Flow Navigator**（流程导航器）中，在“Program and Debug”（编程和调试）下，点击 **Generate Bitstream**（生成比特流）。\n  2. **等待完成**：\n     * 此过程通常比实现花费的时间少，但仍可能因设计复杂性而异。\n  3. **审查比特流生成日志**：\n     * 完成后，Vivado会指示成功。审查日志中是否有任何警告，但通常如果实现顺利通过，比特流生成也会顺利通过。\n     * `.bit`文件将生成在您的项目目录`pcileech_squirrel_top.runs/impl_1/`（或您的板卡类似路径）中。\n\n### **11.2 烧录比特流**\n\n编程（烧录）比特流会将您编译的设计加载到FPGA上，使您的仿真设备激活。\n\n#### **11.2.1 连接FPGA设备**\n\n* **步骤**：\n  1. **准备硬件**：\n     * 确保您的基于FPGA的DMA板卡已正确插入主机系统的兼容PCIe插槽。\n     * 将JTAG编程器（例如，Digilent HS3，Xilinx Platform Cable）连接到FPGA板卡上的JTAG接口和开发PC的USB端口。\n     * 打开主机系统电源。\n     * 请参阅您的特定FPGA板卡手册，了解精确的电源、JTAG和PCIe连接说明。\n  2. **打开硬件管理器**：\n     * 在Vivado中，导航到 **Flow Navigator &gt; Program and Debug &gt; Open Hardware Manager**（流程导航器 > 编程和调试 > 打开硬件管理器）。\n     * 如果Vivado未运行，您可以作为独立应用程序启动硬件管理器。\n\n#### **11.2.2 编程FPGA**\n\n* **步骤**：\n  1. **连接到目标**：\n     * 在硬件管理器窗口中，点击 **Open Target**（打开目标）（通常是一个大按钮或链接），然后选择 **Auto Connect**（自动连接）。\n     * Vivado应该自动检测到您的JTAG编程器，然后检测到JTAG链上连接的FPGA设备。如果检测失败，请检查JTAG电缆连接、板卡电源以及PC上的JTAG驱动程序。\n  2. **编程设备**：\n     * 一旦您的FPGA设备在硬件窗口中被检测并显示，**右键单击** 您的FPGA设备（例如，`xc7a35t_0`）并选择 **Program Device**（编程设备）。\n     * 将出现一个对话框。点击“Bitstream file”（比特流文件）字段旁边的“...”按钮，导航到您生成的比特流文件（例如，`pcileech_squirrel_top.runs/impl_1/pcileech_squirrel_top.bit`）。\n     * 点击 **Program**（编程）开始将固件烧录到FPGA上。\n     * 等待编程过程完成。您将看到一个进度条。\n\n#### **11.2.3 验证编程**\n\n* **步骤**：\n  1. **检查状态**：\n     * 确保编程在Vivado的硬件管理器中无错误地完成。Vivado将在完成后显示“Program Device”成功消息。\n  2. **观察LED或指示灯**：\n     * 许多FPGA板卡都有状态LED。成功的编程操作通常会导致特定LED亮起或改变状态（例如，“DONE”LED）。这是一个快速的视觉确认。\n  3. **主机系统重启（有时需要）** ：\n     * 为了让主机操作系统正确识别新编程的PCIe设备，通常需要系统重启，尤其是在Windows上，以触发完整的PCIe枚举过程。\n\n### **11.3 测试与验证**\n\n编程完成后，关键一步是验证您的仿真设备是否被主机正确检测，并且其功能是否按预期工作，模仿捐赠设备。\n\n#### **11.3.1 验证设备枚举**\n\n这证实主机操作系统根据您编程的ID将您的FPGA识别为捐赠设备。\n\n* **Windows**：\n  * **步骤**：\n    1. **打开设备管理器**：按下 `Win + X` 并从快速链接菜单中选择 **Device Manager**（设备管理器）。\n    2. **检查设备属性**：\n       * 在适当的设备类别下查找（例如，**Network Adapters**（网络适配器）、**Storage Controllers**（存储控制器）、**System devices**（系统设备））。\n       * 找到您的仿真设备。它现在应该显示为*捐赠设备的名称*（例如，“Intel(R) Ethernet Connection...”）。\n       * 右键单击该设备，选择 **Properties**（属性），然后转到 **Details**（详细信息）选项卡。\n       * 在“Property”（属性）下拉菜单中，选择“Hardware Ids”（硬件ID）。确认 **设备ID（DID）**  和 **厂商ID（VID）** （例如，`PCI\\VEN_ABCD&DEV_1234`）与您编程到固件中的值匹配。\n       * 还应检查“Class Code”（类别代码）和“Subsystem ID”（子系统ID）以进行进一步验证。\n* **Linux**：\n  * **步骤**：\n    1. **使用 **​**​`lspci`​**：打开终端并使用`lspci`命令。\n       ```bash\n       lspci -nn # 显示厂商ID:设备ID\n       lspci -vvv # 显示包括BAR、功能等详细信息\n       ```\n    2. **验证设备列表**：\n       * 检查仿真设备是否在`lspci`输出中显示了正确的厂商ID、设备ID和类别代码。\n       * **示例输出（仿真Intel NIC）** ：\n         ```\n         03:00.0 Network controller [0280]: Intel Corporation Ethernet Connection I219-V [8086:1570] (rev 21)\n         ```\n\n         （`8086`是Intel的厂商ID，`1570`是I219-V的设备ID，`0280`是网络控制器类别代码）。\n       * 使用`lspci -vvv`确认BAR是否以正确的大小和类型枚举，与您的捐赠设备配置匹配。\n\n#### **11.3.2 测试设备功能**\n\n一旦设备被枚举，最终的测试是它是否像原始设备一样工作。\n\n* **步骤**：\n  1. **安装必要的驱动程序**：\n     * 如果主机操作系统未自动加载合适的驱动程序，您将需要手动安装捐赠设备的官方驱动程序。从制造商网站下载它们。\n     * 按照制造商的说明进行安装。如果仿真成功，驱动程序应该安装并识别您的FPGA为真实硬件。\n  2. **执行功能测试**：\n     * 运行通常与捐赠设备交互的应用程序或实用程序。\n     * **示例**：\n       * **网卡**：执行ping测试、浏览网页或启动大文件传输以测试吞吐量。\n       * **存储控制器**：尝试格式化模拟驱动器（如果您的仿真包括存储功能），执行读/写操作，或运行磁盘基准测试。\n       * **USB控制器**：连接USB设备（如果您的仿真包括USB主机功能）并测试它们的检测和操作。\n     * 监控主机系统以获取预期的行为和性能特征。\n  3. **监控系统行为**：\n     * 检查系统稳定性（Windows上没有蓝屏，Linux上没有内核崩溃）。\n     * 在系统日志中查找设备特定错误（Windows上的事件查看器，Linux上的`dmesg`或`journalctl`）。\n     * 确保仿真设备在各种工作负载下（包括大数据传输或压力测试）按预期运行。\n\n#### **11.3.3 监控错误**\n\n主动的错误监控对于识别可能不会立即导致崩溃的细微仿真问题至关重要。\n\n* **Windows**：\n  * **步骤**：\n    1. **检查事件查看器**：按下 `Win + X` 并选择 **Event Viewer**（事件查看器）。\n    2. **查找与PCIe相关的错误**：导航到 **Windows Logs &gt; System**（Windows 日志 > 系统）。筛选或搜索与“PCIe”、“PCI Express”相关的警告、错误或关键事件，或源自特定设备驱动程序的事件（查找与您的仿真设备驱动程序匹配的源名称）。\n       * 常见错误包括资源冲突、驱动程序初始化失败或意外的设备响应。\n* **Linux**：\n  * **步骤**：\n    1. **检查 **​**​`dmesg`​**​ ** 日志**：打开终端并输入：\n       ```bash\n       dmesg | grep -i pci # 不区分大小写地搜索pci消息\n       dmesg | grep -i <VendorID> # 过滤您的设备的厂商ID\n       ```\n    2. **识别问题**：查找指示PCIe链路训练问题、设备初始化问题、内存分配失败或意外DMA活动的消息。Linux内核的PCIe子系统非常详细。\n  * **Systemd Journal (现代Linux)** ：\n    ```bash\n    journalctl -b | grep -i pci # 当前引导日志\n    ```\n\n---\n\n## **12. 高级调试技术**\n\n当问题出现时，特别是在复杂的PCIe设备仿真中，基本的故障排除可能不足以解决问题。高级调试工具和技术提供对FPGA内部逻辑和PCIe总线的深入可见性，使您能够高效地识别和解决问题。\n\n### **12.1 使用Vivado的集成逻辑分析仪（ILA）**\n\n集成逻辑分析仪（ILA）是Xilinx提供的一种强大、可配置的调试IP核，您可以直接将其嵌入到FPGA设计中。它允许您监控内部FPGA信号（线和寄存器）的实时行为，而无需外部探测硬件，其功能类似于一个强大的内部示波器或逻辑分析仪。\n\n#### **12.1.1 插入ILA核**\n\n* **步骤**：\n  1. **规划您的探头**：确定您需要观察的关键信号。对于PCIe仿真，这些信号通常包括：\n     * PCIe IP核的AXI-Stream接口（例如，`s_axis_rx_tdata`、`s_axis_rx_tvalid`、`m_axis_tx_tdata`、`m_axis_tx_tready`）。\n     * 内部状态机信号（`current_state`、`next_state`）。\n     * BAR地址解码输出（`bar_hit[0]`、`bar_hit[1]`）。\n     * 自定义寄存器值（`custom_control_reg`、`custom_status_reg`）。\n     * 中断请求信号（`msi_trigger_signal`）。\n  2. **添加ILA IP核**：\n     * 在Vivado中，打开 **IP Catalog**（IP目录）（通常在 **Flow Navigator**（流程导航器）窗格中）。\n     * 搜索“ILA”（Integrated Logic Analyzer）。\n     * 双击“Debug Bridge”（用于基本ILA）或“Integrated Logic Analyzer (ILA)”以打开其定制GUI。\n     * 配置ILA：\n       * 设置您需要的**捕获数据端口数量**（探头）。\n       * 设置每个探头的**宽度**以匹配您计划连接的信号。\n       * 配置**采样深度**（在触发前/后存储多少个样本）。更深的深度会消耗更多BRAM。\n       * 点击“OK”并让Vivado生成IP。\n  3. **实例化并连接信号**：\n     * Vivado将生成ILA的`.xci`文件。您可以将其直接实例化在您的顶层SystemVerilog文件（例如，`pcileech_squirrel_top.sv`）中，或在可用信号的模块中。\n     * **示例（在**​**​`pcileech_squirrel_top.sv`​**​**或子模块中）：**\n       ```verilog\n       // 假设您已从IP Catalog生成了ila_0\n       // 连接到您设计的时钟和感兴趣的信号\n       ila_0 your_ila_instance (\n           .clk(clk_125mhz), // 连接到您设计中稳定的时钟，通常是PCIe用户时钟\n           .probe0(pcie_s_axis_rx_tdata),    // 示例：PCIe入站TLP数据\n           .probe1(pcie_s_axis_rx_tvalid),   // 示例：PCIe入站TLP有效\n           .probe2(pcie_m_axis_tx_tdata),    // 示例：PCIe出站TLP数据\n           .probe3(my_bar_controller_state), // 示例：您的BAR逻辑状态\n           .probe4(my_custom_register),      // 示例：自定义寄存器的值\n           // 根据需要添加更多探头\n           .probeN(signal_to_monitor_N)\n       );\n       ```\n     * **替代方法（标记用于调试）：**  对于更简单的信号，有时可以直接在HDL代码中标记它们用于调试。使用`(* mark_debug = \"true\" *) wire my_signal;` 或 `(* mark_debug = \"true\" *) reg my_register;`。Vivado随后会自动建议将它们添加到ILA中。\n\n#### **12.1.2 配置触发条件**\n\n当您配置智能触发条件以精确地在感兴趣的事件发生时（例如，错误、特定TLP类型、状态转换）捕获数据时，ILA最强大。\n\n* **步骤**：\n  1. **生成带有ILA的比特流**：插入并连接ILA后，您必须运行综合、实现并生成新的比特流。ILA核消耗FPGA资源，并将嵌入到您的设计中。\n  2. **打开硬件管理器**：使用支持ILA的比特流编程您的FPGA（第11.2节）。然后，在Vivado中，打开硬件管理器并连接到您的目标。\n  3. **访问ILA仪表板**：在硬件管理器中，选择您的ILA实例（例如，`hw_ila_1`）。这将打开ILA仪表板。\n  4. **定义触发器**：\n     * 选择要用作触发输入的探头。\n     * 设置特定的**触发模式**（例如，`pcie_s_axis_rx_tdata`为`0x4A`以触发完成TLP）。\n     * 配置**触发条件**（例如，“等于”、“不等于”、“上升沿”、“下降沿”）。\n     * 设置**触发位置**（在触发事件*之前*捕获多少样本，用于预触发可见性）。\n     * 您可以设置多个触发序列以检测复杂事件。\n     * **触发器示例场景**：\n       * 在收到的TLP中触发特定的`Fmt/Type`以分析传入命令。\n       * 当特定寄存器（`my_custom_register`）达到某个值时触发。\n       * 在`pcie_m_axis_tx_tvalid`断言 AND `pcie_m_axis_tx_tdata[3:0]` == `4'hC`（用于内存写入TLP）时触发，以分析出站写入。\n       * 在错误信号断言时触发。\n\n#### **12.1.3 捕获和分析数据**\n\n* **步骤**：\n  1. **运行设计**：让您的主机系统与已编程的FPGA交互，从而引发您要调试的事件。\n  2. **布防ILA**：在ILA仪表板中，点击 **Run Trigger**（运行触发器）按钮（通常是绿色的“播放”图标）。ILA将等待定义的触发条件。\n  3. **捕获数据**：一旦满足触发条件，ILA将把信号快照捕获到其内部内存缓冲区中。\n  4. **分析波形**：\n     * 捕获的数据将出现在波形查看器中。\n     * 检查信号随时间的变化行为。放大、添加光标并解码值。\n     * 寻找：\n       * **意外的跳变**：信号在错误的时间改变。\n       * **不正确的值**：寄存器中保存了错误的数据。\n       * **协议违规**：您的逻辑在PCIe接口上发送了不正确的数据。\n       * **时序问题**：如果信号在预期时不稳定（尽管完整的时序分析在实现中完成，但ILA显示运行时行为）。\n     * 将捕获到的行为与您的预期设计逻辑和捐赠设备的观察行为（如果您使用协议分析仪捕获了它）进行比较。\n\n### **12.2 PCIe流量分析工具**\n\n虽然ILA提供了FPGA内部可见性，但外部PCIe流量分析工具提供了对您的仿真设备和主机之间PCIe总线上实际通信的无与伦比的视图。这对于验证协议符合性和调试链路级问题至关重要。\n\n#### **12.2.1 PCIe协议分析仪（硬件）**\n\n* **示例**：\n  * **Teledyne LeCroy PCIe 分析仪**：深度分析的黄金标准，完整的协议解码，高级触发，以及错误注入功能。\n  * **Keysight PCIe 分析仪**：另一个领先的供应商，具有类似的高端功能。\n* **步骤**：\n  1. **设置分析仪**：将硬件分析仪串联连接在主机系统的PCIe插槽和您的基于FPGA的DMA设备之间。这通常涉及一个特殊的中间卡。\n  2. **配置捕获设置**：使用分析仪的软件定义要捕获的流量。您可以按TLP类型、地址、请求者ID、错误条件等进行过滤，以关注相关事件。\n  3. **捕获流量**：在主机上运行您的仿真设备。分析仪将被动记录所有PCIe事务。\n  4. **分析结果**：\n     * 使用分析仪强大的软件查看解码的TLP、事务列表和波形视图。\n     * **检查TLP的符合性和正确性**：所有字段都正确吗？序列是否正确？\n     * **识别任何协议违规或意外行为**：这是您发现驱动程序可能失败的原因（例如，您的设备发送了带数据的完成，而规范要求不带数据的完成，或者响应太慢）。\n     * **与捐赠设备捕获进行比较**：直接比较您的仿真设备捕获的流量与您从真实捐赠设备捕获的流量。这是仿真准确性的最终测试。\n\n#### **12.2.2 基于软件的工具**\n\n对于基本的PCIe总线检查，或者在没有专用硬件分析仪的情况下，一些软件工具可以提供有限的洞察。\n\n* **示例**：\n  * **Wireshark with PCIe Plugins**：虽然Wireshark主要用于网络流量，但通过专用硬件（例如，将PCIe跟踪暴露给操作系统的网卡，或特定的捕获硬件/驱动程序），它有时可以捕获和解码PCIe数据包。这高度依赖于系统。\n  * **ChipScope Pro（传统Xilinx，现已集成到Vivado中）** ：Integrated Logic Analyzer (ILA) 是现代的等效工具，但ChipScope曾是一个独立工具。\n  * **​`lspci`​**​ ** (Linux)** ：如第11.3.1节所述，`lspci -vvv`提供了广泛的静态配置空间信息。您可以将其与`watch`或脚本结合使用来监控随时间的变化。\n  * **​`pcileech`​**​**客户端（来自PCILeech框架）** ：`pcileech`客户端软件本身可以通过您的FPGA执行内存和配置空间的读写操作，并可用于测试基本的DMA功能。虽然不是“流量分析仪”，但它对于测试功能接口至关重要。\n* **步骤**：\n  1. **安装必要的工具/插件**：确保工具已安装并配置了任何所需的驱动程序或插件。\n  2. **监控PCIe总线**：运行软件工具以捕获和显示PCIe相关信息。\n  3. **分析通信**：\n     * 查找设备配置中的差异。\n     * 如果工具支持，分析捕获数据包的结构是否存在异常或错误。\n     * 验证您的仿真设备是否正确响应了配置请求。\n\n---\n\n## **13. 故障排除**\n\n本节提供了在PCIe设备仿真定制固件开发、比特流编程和硬件测试过程中可能遇到的常见问题的解决方案。固件调试可能具有挑战性，因此采用系统方法是关键。\n\n### **13.1 设备检测问题**\n\n**问题**：您的基于FPGA的DMA设备在编程后未被主机系统识别，或者在设备管理器/lspci中显示为不正确的ID（例如，“未知设备”）或错误符号。\n\n#### **可能原因及解决方案**：\n\n1. **设备ID、厂商ID、子系统ID或类别代码不正确**：\n\n   * **原因**：最常见的原因。您编程到FPGA固件中的识别值与主机操作系统预期或您打算仿真的值不匹配。\n   * **解决方案**：\n     * **验证**：仔细检查`pcileech_pcie_cfg_a7.sv`（或等效文件）中的所有`cfg_deviceid`、`cfg_vendorid`、`cfg_subsysid`、`cfg_subsysvendorid`、`cfg_revisionid`和`cfg_classcode`参数，与您精心记录的捐赠设备信息（来自第5节）进行比对。\n     * **一致性**：确保这些值在Vivado PCIe IP核定制GUI（第7.2.2节）中也保持一致设置。\n     * **重新构建并重新烧录**：进行任何更改后，始终重新综合、重新实现、生成新的比特流并重新烧录FPGA（第11.1、11.2节）。\n     * **重启主机**：烧录后务必重启主机系统，因为Windows通常需要完全重启才能正确重新枚举PCIe设备。\n2. **PCIe链路训练失败**：\n\n   * **原因**：主机根联合体与您的FPGA卡之间的基本PCIe链路未能建立。这发生在任何配置空间读取之前。症状包括设备完全不出现（`lspci`在该总线/插槽上没有任何显示，或设备管理器显示“PCI Express Root Port”错误）。\n   * **解决方案**：\n     * **物理连接**：确保FPGA板卡牢固地插入PCIe插槽，并且所有电源连接都牢固。如果可能，尝试不同的PCIe插槽。\n     * **电源**：验证FPGA板卡是否获得足够的电源。某些板卡需要辅助PCIe电源连接器。\n     * **链路速度/宽度**：\n       * 检查Vivado PCIe IP核中的`Max Link Speed`和`Link Width`设置（第8.1.1节）。\n       * 尝试将链路速度设置为较低的代数（例如，Gen1 / 2.5 GT/s）并将宽度设置为x1，即使您的板卡支持更高。有时，在较高速度下与特定主板会产生兼容性问题。\n       * 检查主板BIOS设置中的PCIe插槽速度选项。\n     * **复位**：确保FPGA的复位逻辑正确实现（例如，与PCIe参考时钟同步），并在上电/重启时正确断言/去断言。\n     * **PCIe IP核**：确保PCIe IP核正确实例化，并且其时钟和复位在您的顶层设计中正确连接。\n3. **电源问题（电源不足或不稳定）** ：\n\n   * **原因**：FPGA板卡未获得足够的稳定电源，或电源供应不稳定，导致操作不可靠。\n   * **解决方案**：\n     * **验证连接**：仔细检查所有电源线（主PCIe插槽电源、辅助PCIe电源、如果使用则包括外部直流插孔）。\n     * **电源供应**：确保您的主机系统电源（PSU）具有足够的瓦数和稳定的12V电压轨。对于高功耗FPGA，弱电源可能导致问题。\n     * **外部电源**：如果板卡有外部电源插孔，请确保使用正确电压和电流额定值的电源。\n4. **固件错误（早期阶段）** ：\n\n   * **原因**：SystemVerilog代码中的逻辑错误，特别是顶层模块或PCIe核的包装器中，导致PCIe核无法初始化或正确呈现自身。\n   * **解决方案**：\n     * **Vivado消息**：仔细检查Vivado的综合和实现日志中与PCIe IP核相关的**严重警告**或**错误**。这些通常是配置错误或连接不当的指示。\n     * **ILA调试**：如果链路尝试训练但失败，请使用连接到PCIe IP核的状态信号（例如，`link_up`、`link_speed`、`link_width`）和AXI-Stream接口的ILA（第12.1节），以查看链路协商在哪个点失败，或者核是否生成了意外流量。\n\n### **13.2 内存映射和BAR配置错误**\n\n**问题**：仿真设备已检测到，但当主机操作系统或驱动程序尝试通过BAR访问其内存映射寄存器或缓冲区时，系统崩溃、冻结或报告错误。\n\n#### **可能原因及解决方案**：\n\n1. **BAR大小或类型不正确（IP核和固件）** ：\n\n   * **原因**：您在Vivado PCIe IP核（第7.2.2节）中配置的BAR大小或类型（32位/64位、内存/I/O、可预取/不可预取）和/或在`pcileech_tlps128_bar_controller.sv`中处理的值与捐赠设备实际提供的值不匹配。这可能导致主机分配不正确的地址空间或尝试不支持的访问。\n   * **解决方案**：\n     * **交叉验证**：返回到您的Arbor/协议分析仪数据（第5节），重新验证每个BAR配置（大小、类型、可预取）。\n     * **一致性**：确保这些值在PCIe IP核定制中完全匹配，并且您的`bar_controller`逻辑正确处理每个BAR的大小（地址解码范围）和类型。\n     * **BRAM大小**：如果您的BAR映射到BRAM，请确认BRAM IP核的大小（第8.2.1节）与BAR大小完全匹配。\n2. **固件中的地址解码错误**：\n\n   * **原因**：您的`pcileech_tlps128_bar_controller.sv`（或自定义BAR逻辑）错误地解释了传入的PCIe地址，导致访问了不正确的内部寄存器或内存位置。\n   * **解决方案**：\n     * **审查逻辑**：仔细审查`bar_controller`中的`case`语句和地址计算。\n     * **仿真**：在您的SystemVerilog测试平台中开发特定的测试用例，模拟主机对每个BAR中不同偏移量的读写访问。验证内部`bar_hit`信号是否正确，以及数据是否正确路由到/从正确的内部寄存器/BRAM。\n     * **ILA调试**：在`req_addr`、`req_write`、`req_read`、`req_data`、`rsp_data`以及`bar_controller`中与您的地址解码和寄存器访问相关的内部信号上放置ILA探头。实时观察地址如何解码以及正在读/写的数据。\n3. **内部地址空间重叠**：\n\n   * **原因**：虽然PCIe标准确保不同设备的BAR在主机的内存映射中不重叠，但在FPGA*内部*，您可能会意外地将不同的逻辑组件映射到单个BAR中的相同物理地址空间。\n   * **解决方案**：\n     * **仔细映射**：在BAR中定义内部寄存器和内存块时，显式为每个寄存器和内存块分配唯一的、不重叠的偏移量。使用`localparam`来定义这些偏移量以防止错误。\n     * **设计审查**：需要对您的`bar_controller`进行彻底的设计审查，以确保每个地址范围都得到唯一处理。\n4. **BRAM访问问题**：\n\n   * **原因**：您的逻辑与BRAM IP核接口存在问题（例如，不正确的BRAM时钟、异步复位、错误的字节使能或不正确的写入使能逻辑）。\n   * **解决方案**：\n     * **BRAM文档**：查阅Xilinx BRAM IP核文档，了解正确的实例化和接口信号。\n     * **ILA**：在BRAM接口信号（地址、写入使能、数据输入、数据输出）上放置ILA探头，以验证您的逻辑是否向BRAM发送了正确的控制信号。\n\n### **13.3 DMA性能和TLP错误**\n\n**问题**：设备已检测到并功能上看起来正常，但在大型DMA操作期间，数据传输速率缓慢，或者系统间歇性崩溃、挂起或报错。PCIe协议分析仪报告TLP格式错误或流控制问题。\n\n#### **可能原因及解决方案**：\n\n1. **TLP格式错误（报头/载荷）** ：\n\n   * **原因**：您的固件生成的TLP（特别是您的FPGA作为DMA主设备时发送的完成或出站内存写入）具有不正确的报头、长度、字节使能或载荷。主机系统的PCIe核或驱动程序将其检测为违规。\n   * **解决方案**：\n     * **PCIe协议分析仪**：这是最好的工具（第12.2.1节）。捕获流量并仔细比较您生成的TLP与PCIe规范，更重要的是，与您*真实捐赠设备*的捕获进行比较。\n     * **TLP生成逻辑**：审查您的TLP组装代码（`pcileech_pcie_tlp_a7.sv`及相关模块）。确保所有字段（Fmt、Type、Requester ID、Tag、Completion ID、Length、Byte Enables、Address）都正确派生并打包到TLP结构中。\n     * **错误检查**：在固件中实现基本的错误检查（例如，检查是否存在意外的`req_valid`而没有`req_ready`，反之亦然）。\n2. **流控制问题**：\n\n   * **原因**：PCIe使用基于信用的流控制机制。如果您的固件（或PCIe IP核与其的交互）错误地管理信用，可能导致死锁、超时或丢包。症状包括PCIe链路“停滞”、超时或低吞吐量。\n   * **解决方案**：\n     * **PCIe IP核配置**：确保Vivado PCIe IP核定制中的流控制设置适用于您预期的流量模式。默认设置通常是健壮的。\n     * **用户逻辑反压**：您的用户逻辑向PCIe IP核发送TLP（`m_axis_tx_*`接口）*必须*遵守来自IP核的`m_axis_tx_tready`信号。如果`tready`被去断言，您*必须*暂停发送数据。否则将导致核的缓冲区溢出。\n     * **ILA调试**：将ILA探头连接到PCIe IP核的流控制接口信号和您的用户逻辑，以观察`tvalid`/`tready`握手是否正常工作。\n3. **DMA逻辑效率低下/缓冲问题**：\n\n   * **原因**：FPGA内部的DMA引擎实现（读取/写入主机内存数据的部分）未优化，导致瓶颈。这可能涉及：\n     * 缺少流水线。\n     * BRAM使用效率低下。\n     * 外部内存访问延迟导致的停滞。\n     * 突发大小过小。\n   * **解决方案**：\n     * **流水线**：将长组合路径分解为更小、更连续的阶段，使用寄存器。这允许更高的时钟频率和更好的吞吐量。\n     * **缓冲**：使用FIFO（先进先出缓冲区）来解耦发送方和接收方逻辑，平滑数据流并防止停滞。\n     * **突发传输**：利用PCIe执行突发读/写的能力以提高效率。确保您的DMA逻辑以适当的突发大小请求和处理数据。\n     * **内存带宽**：确保您的BRAM或外部DDR内存接口能够足够快地提供/消耗数据，以满足您所需的DMA速率。\n     * **ILA**：监控您的DMA引擎的内部状态、读写指针和数据路径信号，以识别瓶颈。\n4. **完成超时/不支持的请求**：\n\n   * **原因**：主机发送请求（例如MRd、CfgRd），但您的FPGA设备未在允许的超时时间内响应完成TLP，或者它以错误状态（例如，带有Unsupported Request (UR) 或 Completer Abort (CA) 的完成）进行响应。\n   * **解决方案**：\n     * **响应逻辑**：验证您的`bar_controller`（用于MRd）和`pcileech_pcie_cfg_a7.sv`（用于自定义配置空间的CfgRd）是否正确识别请求并生成适当的完成。\n     * **超时值**：审查您的捐赠设备预期的完成延迟。虽然PCIe定义了默认超时，但某些驱动程序可能对此敏感。\n     * **ILA/协议分析仪**：对于查明*为什么*未发送完成或完成格式错误至关重要。请求TLP是否甚至到达了您的用户逻辑？您的逻辑是否生成了响应？PCIe核是否成功发送了响应？\n\n---\n\n## **14. 仿真精度与优化**\n\n实现真正令人信服的仿真意味着让您的基于FPGA的设备与捐赠设备难以区分，不仅在ID上，而且在行为上。这需要对时序、响应速度和微妙的操作细节进行细致的关注。\n\n### **14.1 精确定时仿真技术**\n\n精确的时序在硬件中至关重要，特别是对于PCIe这样的高速接口。不匹配可能导致驱动程序超时、数据解释不正确或系统不稳定。\n\n* **实现时序约束（XDC文件）** ：\n\n  * **目的**：时序约束是 Vivado 综合和实现工具的指令，告诉它们您的设计需要运行多快。它们定义了时钟周期、输入/输出延迟和路径延迟。\n  * **用法**：PCILeech-FPGA项目包含 XDC 文件（例如，`pcileech_squirrel_top.xdc`），它们定义了主时钟（例如，`create_clock -name sys_clk_p -period 8.0 [get_ports sys_clk_p]`）。\n  * **优化**：如果您的仿真需要非常特定的内部时序或对时间敏感的命令做出反应，您可能需要在自定义逻辑中添加进一步的约束（`set_max_delay`、`set_input_delay`、`set_output_delay`）到关键路径。\n  * **目标**：确保 Vivado 在实现后报告所有路径的 **正 WNS（最差负余量）** ，表明设计满足其时序要求。\n* **使用时钟域交叉（CDC）技术**：\n\n  * **目的**：PCIe设计通常涉及多个时钟域（例如，125MHz PCIe用户时钟，自定义逻辑的单独时钟）。在这些域之间异步移动信号（没有适当的同步）可能导致**亚稳态**，从而导致不可靠的行为。\n  * **实现**：对于跨时钟域的信号，始终使用适当的CDC电路：\n    * **双触发器同步器**：用于单比特控制信号。\n    * **异步FIFO（先进先出）** ：用于多比特数据路径，提供时钟域之间的数据缓冲和流控制。\n    * **格雷码编码器/解码器**：用于跨域的计数器或地址，以确保每次只有一个比特发生变化。\n  * **Vivado 工具**：Vivado 包含 CDC 分析工具（例如，`report_cdc`），可以识别潜在的亚稳态问题。\n* **使用时间精确模型仿真设备行为**：\n\n  * **高级测试平台**：使用 SystemVerilog 测试平台，其中包含真实的定时延迟，甚至提供时间精确的 PCIe 总线功能模型（BFM）。\n  * **验证**：这使您可以观察您的仿真设备的内部状态以及外部 TLP 生成/响应时序在各种条件下如何表现，确保它们与您捕获的捐赠设备行为相匹配。\n\n### **14.2 对系统调用的动态响应**\n\n真正精确的仿真不仅能呈现正确的ID；它还能智能且动态地响应主机系统的命令和查询，模仿真实、活动设备的行为。\n\n* **实现设备控制的状态机**：\n\n  * **目的**：设计健壮的 SystemVerilog 状态机来管理设备的操作模式、命令处理和数据流。\n  * **响应性**：确保状态机能够逻辑地、快速地响应传入命令（例如，写入 BAR 中的控制寄存器，特定的 TLP）。\n  * **优雅处理**：状态机应能够优雅地处理意外或无序的请求，可能返回错误 TLP 或仅仅忽略无效命令，而不是崩溃或冻结。\n* **监控和响应主机命令（超越简单的读写）** ：\n\n  * **配置写入**：除了初始枚举之外，驱动程序通常会写入配置空间寄存器以启用功能、设置阈值或清除状态位。您的固件必须处理这些写入并相应地更新内部状态。\n  * **厂商特定命令**：如第9.2节所述，如果捐赠设备具有专有命令（通过自定义寄存器或厂商定义消息访问），您的固件必须解析这些命令并触发适当的仿真行为。\n  * **电源管理命令**：通过启用/禁用内部逻辑并确认状态更改来响应主机发起的电源状态转换（D0、D1、D3hot 等）。\n  * **中断确认**：如果主机驱动程序通过写入特定寄存器来确认中断，请确保您的固件能够检测到此并清除内部中断请求。\n* **优化固件逻辑以提高响应性**：\n\n  * **降低延迟**：关键数据路径和控制路径应优化，以最小化组合逻辑深度和流水线停顿。\n  * **并行性**：利用 FPGA 固有的并行性来同时执行多个操作，提高吞吐量和响应时间。\n  * **高效内存访问**：优化对内部 BRAM 或外部 DDR 内存的访问，以确保在需要时为 DMA 传输或寄存器读取提供数据。\n  * **硬件加速**：对于捐赠设备执行的复杂计算或数据操作，请考虑在 FPGA 上实现专用的硬件加速器，而不是尝试以缓慢、类似软件的方式执行它们。\n\n---\n\n## **15. 固件开发最佳实践**\n\n在定制固件开发中遵循最佳实践对于保持代码质量、促进协作（如果团队合作）、简化调试以及确保项目的长期可维护性和可靠性至关重要。这对于安全敏感的应用尤为如此。\n\n### **15.1 持续测试与文档**\n\n* **定期、增量测试**：\n\n  * **单元测试**：使用专用测试平台隔离测试小型独立模块（例如，TLP解析器、寄存器块）。\n  * **集成测试**：验证不同模块是否协同工作。\n  * **系统测试**：烧录后，与主机系统执行端到端测试，确保整体功能。\n  * **尽早测试，经常测试**：在每次重大更改后，无论多小，都要测试固件，以便尽早发现问题，此时问题更容易调试。\n* **自动化测试（高级）** ：\n\n  * 对于复杂项目，在主机端实现自动化测试脚本（例如，使用Python和硬件抽象层）以重复验证功能和性能。\n  * 在团队环境中，考虑与持续集成（CI）工具（例如，Jenkins、GitLab CI）集成，以自动化每次代码提交的构建、测试和静态分析。\n* **维护全面的文档**：\n\n  * **设计文档**：创建并更新描述固件架构的文档，包括：\n    * **框图**：说明主要模块及其互连。\n    * **状态机图**：适用于所有有状态逻辑。\n    * **接口规范**：详细说明模块之间的输入/输出信号、时序和协议。\n    * **内存映射**：针对所有BAR，定义寄存器地址、位域及其功能。\n  * **代码注释**：在SystemVerilog代码中使用清晰、简洁的注释来解释复杂的逻辑、信号的目的以及任何不明显的设计选择。\n  * **更改日志/提交消息**：维护更改日志或使用详细的Git提交消息来跟踪所有修改、错误修复和功能添加，解释*为什么*进行更改。\n  * **用户指南**：对于您的定制固件，一个简单的用户指南，解释如何从主机端构建、烧录和与仿真设备交互，是无价的。\n\n### **15.2 管理固件版本**\n\n正确的版本控制对于跟踪更改、有效协作和管理发布至关重要。\n\n* **使用版本控制系统（VCS）** ：\n\n  * **Git**：强烈推荐。使用Git管理您的HDL源代码、约束文件和项目脚本。\n  * **组织仓库**：保持清晰的目录结构（例如，为`src`、`xdc`、`ip`、`scripts`、`doc`等设置单独的文件夹）。\n  * **分支**：使用功能分支开发新功能或进行重大更改。在彻底测试后合并回`main`或`develop`分支。\n  * **定期提交**：频繁提交，提交内容原子化，提交消息有意义。\n* **标记发布和里程碑**：\n\n  * **稳定版本**：使用Git标签（例如，`v1.0.0`、`v1.0.1_bugfix`）标记固件的稳定、经过测试的版本。这使得回溯或部署已知良好状态变得容易。\n  * **里程碑**：标记重要的开发里程碑（例如，“基本枚举工作正常”、“DMA读/写功能正常”）。\n* **备份和恢复策略**：\n\n  * **基于云的仓库**：将您的Git仓库托管在GitHub、GitLab或Bitbucket等平台上。这提供了异地备份并促进了协作。\n  * **本地备份**：即使有云仓库，也要定期对整个Vivado项目目录进行本地备份（由于生成的文件，它可能非常大）。\n\n### **15.3 安全注意事项**\n\n开发用于PCIe设备仿真（特别是能够直接内存访问的设备）的定制固件具有重要的安全影响。这项技术本质上是一种“两用”能力，意味着它既可以用于合法目的（例如，硬件测试、安全研究），也可以用于恶意目的（例如，DMA攻击、安全绕过）。**理解并负责任地管理这些风险至关重要。**\n\n* **两用性质与道德影响**：\n\n  * **道德黑客行为与恶意使用**：明确区分将这些知识用于授权安全测试（红队演练、渗透测试）和未经授权的非法活动。\n  * **负责任的披露**：如果您使用这些技术发现漏洞，请遵循负责任的披露准则。\n  * **法律和许可合规性**：了解并遵守所有与硬件逆向工程和设备修改相关的法律、法规和许可协议（例如，PCIe-SIG规范、Xilinx EULA）。\n  *  **“武器化”** ：认识到精确仿真受信任硬件的能力可以被武器化用于高级持久威胁（APTs）或复杂恶意软件。\n* **理解攻击向量（攻击视角）** ：\n\n  * **内存窃取**：恶意仿真设备可以执行DMA读取，以访问任何物理内存地址，包括内核、用户进程中的敏感数据、加密密钥或网络缓冲区。\n  * **内存注入/修改**：恶意仿真设备可以执行DMA写入以任意修改内存，从而实现：\n    * **权限提升**：修改内核数据结构（例如，进程令牌、SID）以获得管理员或系统权限。\n    * **代码注入**：将恶意代码注入正在运行的进程或内核，然后触发其执行。\n    * **安全软件绕过**：通过直接修改内存来禁用或颠覆端点检测和响应（EDR）、防病毒或防火墙软件。\n  * **模糊测试和崩溃**：发送格式错误或不符合规范的TLP/命令，以触发驱动程序漏洞，导致系统崩溃（蓝屏死机）或潜在的可利用内存损坏。\n  * **固件/BIOS操作**：在某些高级场景中，DMA设备可能能够与包含BIOS/UEFI的主机SPI闪存进行交互，可能用于持久性修改。\n* **防御措施和缓解策略（防御视角）** ：\n\n  * **IOMMU/VT-d/AMD-Vi**：如第3.2节所述，这些技术旨在通过为外设提供内存保护来缓解DMA攻击。**对于合法测试，您会禁用它们，但在生产系统中，它们应始终启用。**  它们阻止外设未经授权的内存访问。\n  * **内核DMA保护（Windows）/ Thunderbolt安全（Linux）** ：现代操作系统功能专门解决“冷启动”DMA攻击（攻击者在系统关闭或锁定时连接恶意设备）。在生产系统上保持这些功能启用。\n  * **安全启动**：虽然不是直接的DMA保护，但安全启动有助于确保只加载受信任的引导加载程序和内核模块，从而减少攻击者注入恶意内核组件以绕过DMA保护的机会。\n  * **物理安全**：最基本但最关键的防御。如果攻击者可以物理访问PCIe插槽或Thunderbolt端口，他们可以绕过许多软件保护。保护对关键系统的物理访问。\n  * **驱动程序强化**：驱动程序应以防御性方式编写，严格验证来自硬件的所有输入并在严格的内存边界内操作。\n  * **内存强化**：操作系统级的内存保护（例如KASLR、DEP、SMAP/SMEP）有助于减少内存损坏的影响，但直接DMA攻击会绕过这些保护。\n  * **监控和日志记录**：虽然在硬件层面很难，但异常的DMA活动或未知PCIe设备的枚举应在安全监控系统中触发警报。\n* **固件安全编码实践**：\n\n  * **输入验证**：如果您的固件接受任何输入（例如，通过UART调试接口，或由主机写入的内部寄存器），请严格验证它们，以防止缓冲区溢出、整数溢出或意外行为。\n  * **最小权限**：设计您的固件逻辑，使其仅执行其功能绝对必要的操作。避免授予不必要的功能。\n  * **状态管理**：实现健壮的状态机，以防止由于无效状态转换而导致的意外行为。\n  * **无硬编码秘密**：避免直接在固件中嵌入敏感信息（例如，加密密钥、硬编码凭据），如果它们可以轻易被提取。\n  * **篡改检测**：对于生产固件，考虑实现检测固件本身是否已被篡改或是否加载了未经授权配置的机制。\n\n---\n\n## **16. 其他资源**\n\n为了加深您对FPGA开发、PCIe和硬件安全等动态领域的理解并保持更新，请查阅以下资源：\n\n* **Xilinx (AMD) 文档**：您获取Vivado和Xilinx FPGA所有信息的主要来源。\n\n  * **主文档门户**：[https://docs.amd.com/](https://docs.amd.com/)（原Xilinx.com/support/documentation）。\n  * **Vivado 设计套件用户指南**：\n    * **UG900 - 入门指南**：Vivado新用户必备。\n    * **UG901 - 逻辑综合**：深入了解综合。\n    * **UG904 - 实现**：关于放置和布线的详细指南。\n    * **UG912 - Tcl 命令参考指南**：对于脚本编写价值巨大。\n    * **UG939 - 调试**：ILA和其他调试功能的综合指南。\n  * **PCI Express IP 核用户指南**：理解Xilinx PCIe IP至关重要（例如，**PG054 for 7 Series Integrated Block for PCI Express**）。在文档门户上搜索“PCI Express”。这详细介绍了核的配置、接口和限制。\n* **PCI-SIG 规范**：PCIe 标准的权威来源。\n\n  * **PCI Express Base Specification**：基础文档。虽然不公开免费，但基于它的摘要和教育材料广泛可用。您通常可以在其网站上找到信息：[https://pcisig.com/specifications](https://pcisig.com/specifications)（注意：完整规范通常需要PCI-SIG会员资格）。\n* **FPGA 教程和学习平台**：\n\n  * **FPGA4Fun**：[http://www.fpga4fun.com/](http://www.fpga4fun.com/) - 一个经典网站，提供许多实用的FPGA项目和教程。\n  * **Verilog/VHDL 教程**：\n    * **ASIC World Verilog 教程**：[https://www.asic-world.com/verilog/index.html](https://www.asic-world.com/verilog/index.html) - 很好的Verilog基础参考。\n    * **VHDLwhiz**：[https://www.vhdlwhiz.com/](https://www.vhdlwhiz.com/) - VHDL 参考和教程。\n  * **Stack Overflow (FPGA/Verilog/PCIe 标签)** ：[https://stackoverflow.com/questions/tagged/fpga](https://stackoverflow.com/questions/tagged/fpga) - 社区驱动的针对特定技术问题的问答。\n* **PCIe 协议分析工具**：\n\n  * **Teledyne LeCroy Protocol Analyzers**：[https://teledynelecroy.com/protocolanalyzer/](https://teledynelecroy.com/protocolanalyzer/) - 探索他们的高性能PCIe分析仪和软件系列。\n  * **Telescan PE Software**：[https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software](https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software) - 一款免费软件工具，提供一些PCIe分析功能（需要注册）。\n* **PCILeech 社区和资源**：\n\n  * `ufrisk/pcileech` GitHub 仓库是核心。积极关注其更新和问题。\n  * 寻找致力于PCILeech或类似开源DMA项目的社区论坛或Discord服务器。\n* **硬件安全与逆向工程**：\n\n  * 关于硬件黑客、逆向工程和低级系统利用的书籍。\n  * Black Hat、DEF CON、Recon 和 Troopers 等会议通常会举办关于 PCIe 和 DMA 攻击的讲座。\n  * 专注于硬件的安全研究人员的博客和研究论文。\n\n---\n\n## **17. 联系方式**\n\n如果您需要帮助、有疑问或希望就本指南、固件开发或硬件安全相关主题进行合作，请随时联系。我乐意提供指导、解决复杂问题或详细讨论想法。\n\n### **Discord**：\n\n* **用户**：**[VCPU](https://discord.com/users/196741541094621184)**\n* **服务器邀请链接**：**[加入硬件黑客与固件开发Discord](https://discord.gg/dS2gDUDQmV)**\n\n---\n\n## **18. 支持与贡献**\n\n您的支持有助于维护和改进本指南及相关项目。创建和更新全面的技术文档以及开源硬件项目需要大量时间和精力。\n\n### **捐赠**\n\n如果您觉得本指南有帮助并希望支持正在进行的工作，请考虑捐赠。每一笔捐款，无论大小，都有助于我们继续通过进一步的研究、开发和文档工作来创建、分享和支持社区。\n\n* **加密货币捐赠（LTC - 莱特币）** ：\n  * **地址**：`MPMyQD5zgy2b2CpDn1C1KZ31KmHpT7AwRi`\n\n**特别奖励**：如果您捐赠，请随时在Discord上（VCPU）与我联系，以获得个人感谢，并可能获得额外资源、新内容的早期访问或项目上的个性化帮助。\n\n**注意**：如果您需要我审查您实现的特定部分、解决问题或提供详细的代码反馈，请在您的代码中用`//VCPU-REVIEW//`注释标记相关部分，并提供您遇到的问题或疑问的详细说明。这有助于我集中精力并提供最有效的支持。\n\n愿上帝保佑您的灵魂。\n\n---\n\n**指南结束**\n","source":"_posts/custom-firmware-development-guide-for-fulldevice-simulation-z17aist.md","raw":"---\ntitle: 全设备仿真的定制固件开发指南\ndate: '2025-07-07 10:35:21'\nupdated: '2025-07-07 10:36:52'\nexcerpt: >-\n  **《全设备仿真的定制固件开发指南》摘要**\n\n\n  本指南系统介绍了基于FPGA的PCIe设备固件开发全流程，涵盖基础概念到高级优化技术。作者在个人困境中坚持完成这一开源项目，并特别纪念FPGA之父Ross\n  Freeman的贡献。\n\n\n  **核心内容：**\n\n  1. **开发基础**  \n     - 支持Xilinx Artix-7等FPGA硬件  \n     - 需Vivado工具链及PCIe流量分析软件  \n     - 详细说明设备信息收集（如Arbor扫描工具）和初始固件配置（DSN/PCIe空间修改）\n\n  2. **关键技术**  \n     - PCIe参数配置与BAR内存映射调整  \n     - 事务层数据包(TLP)的捕获与定制  \n     - 电源管理/中断仿真等设备特性实现  \n\n  3. **实践指南**  \n     - 提供Vivado项目设置、IP核修改、比特流烧录的完整流程  \n     - 集成逻辑分析仪调试和性能优化方案  \n     - 常见故障（设备检测/DMA错误）的解决方案  \n\n  **特点：**  \n\n  - 强调仿真精度与动态响应技术  \n\n  - 包含安全规范与版本管理最佳实践  \n\n  - 配套维基文档和社区支持资源  \n\n\n  作者呼吁开发者参与完善项目，并感谢捐助者支持其持续维护。指南兼具技术深度与人文关怀，既是FPGA开发的实用手册，也体现了开源共享精神。  \n\n\n  （字数：498中文字符）\ntags:\n  - 固件开发\n  - 硬件仿真\n  - pcie\n  - dma\n  - 嵌入式\ncategories:\n  - 硬件开发\n  - FPGA\n  - 固件\npermalink: /post/custom-firmware-development-guide-for-fulldevice-simulation-z17aist.html\ncomments: true\ntoc: true\nabbrlink: 36758\n---\n\n\n\n# 全设备仿真的定制固件开发指南\n\n# **全设备仿真的定制固件开发指南**\n\n---\n\n**特别鸣谢慷慨捐助的传奇人物，我将很快与您联系。如果您愿意，请DM我，我会在本文中添加鸣谢并提供更多信息！**\n\n正在将此指南整理到[维基](https://github.com/JPShag/PCILeech-DMA-Firmware/wiki/Introduction)中。欢迎提供帮助！\n\n---\n\n**作者留言及指南状态：**\n\n我正在透明地分享这一切，因为最近的日子异常艰难。除了因欺诈性退款造成的巨大经济损失外，我还面临多重生活和健康困境，严重影响了我上网和投入项目的时间。坦率地说，在这些个人困难中，继续创作像本指南这样全面的资源已成为一项深刻的挣扎。\n\n这预计是主指南的最后一次重大迭代。对于已经熟悉基本硬件概念（例如，FTDI芯片的功能）的更有经验的用户，我们将提供一个简洁的精简版。\n\n如果您觉得这项工作有价值并能够提供帮助，任何形式的支持都将不胜感激。您的慷慨使我尽管面临持续的挑战，仍能继续为这个社区做出贡献。我真诚地希望本指南已经并将继续成为一份宝贵的资源。\n\n---\n\n## 纪念与献词\n\n![Ross](https://github.com/user-attachments/assets/de7f12fe-8992-4738-a6af-712dc48217ee)\n\n本指南谨献给\n**Ross Freeman (1947–1989)**  的记忆\n\n作为一位富有远见的工程师、杰出的密歇根人，以及Xilinx的联合创始人，Ross Freeman被广泛认为是现场可编程门阵列（FPGA）技术之父，该技术彻底改变了计算领域。\n\n在1984年，半导体行业主要专注于固定功能芯片之时，Freeman敢于想象一种不同的范式：制造后可以重新编程的硬件。他的革命性专利（#4,870,302）和对可重构计算的不懈倡导，开启了一个四十年后仍在改变我们世界的科技范式。\n\n他的开创性创新使得在无需承担传统ASIC开发高昂成本的情况下，快速原型化和部署定制芯片解决方案成为可能，从而使硬件设计民主化，并加速了无数领域的技术进步。\n\n如今，Freeman的愿景驱动着人工智能、高性能计算、电信、汽车系统、航空航天应用以及他在世时仅是梦想的许多其他领域的尖端发展。\n\n他于2009年被追授进入国家发明家名人堂，其遗产不仅体现在硅片中，更体现在挑战我们所有人质疑既定限制并想象新可能性的技术勇气精神中。\n\n *\"FPGA的最终目标是制造可编程逻辑器件，以取代标准数字芯片。\"*  — Ross Freeman\n\n---\n\n## **目录**\n\n### **第一部分：基础概念**\n\n1. [引言](#1-引言)\n   * [1.1 本指南的目的](#11-本指南的目的)\n   * [1.2 目标读者](#12-目标读者)\n   * [1.3 如何使用本指南](#13-如何使用本指南)\n2. [关键定义](#2-关键定义)\n3. [设备兼容性](#3-设备兼容性)\n   * [3.1 支持的基于FPGA的硬件](#31-支持的基于fpga的硬件)\n   * [3.2 PCIe硬件注意事项](#32-pcie硬件注意事项)\n   * [3.3 系统要求](#33-系统要求)\n4. [要求](#4-要求)\n   * [4.1 硬件](#41-硬件)\n   * [4.2 软件](#42-软件)\n   * [4.3 环境设置](#43-环境设置)\n5. [收集捐赠设备信息](#5-收集捐赠设备信息)\n   * [5.1 使用Arbor进行PCIe设备扫描](#51-使用arbor进行pcie设备扫描)\n   * [5.2 提取和记录设备属性](#52-提取和记录设备属性)\n6. [初始固件定制](#6-初始固件定制)\n   * [6.1 修改配置空间](#61-修改配置空间)\n   * [6.2 插入设备序列号（DSN）](#62-插入设备序列号dsn)\n7. [Vivado项目设置与定制](#7-vivado项目设置与定制)\n   * [7.1 生成Vivado项目文件](#71-生成vivado项目文件)\n   * [7.2 修改IP核](#72-修改ip核)\n\n### **第二部分：中级概念与实现**\n\n8. [高级固件定制](#8-高级固件定制)\n   * [8.1 配置PCIe参数以进行仿真](#81-配置pcie参数以进行仿真)\n   * [8.2 调整BARs和内存映射](#82-调整bars和内存映射)\n   * [8.3 仿真设备电源管理和中断](#83-仿真设备电源管理和中断)\n9. [仿真设备特定功能](#9-仿真设备特定功能)\n   * [9.1 实现高级PCIe功能](#91-实现高级pcie功能)\n   * [9.2 仿真厂商特定功能](#92-仿真厂商特定功能)\n10. [事务层数据包（TLP）仿真](#10-事务层数据包tlp仿真)\n    * [10.1 理解和捕获TLP](#101-理解和捕获tlp)\n    * [10.2 制作用于特定操作的定制TLP](#102-制作用于特定操作的定制tlp)\n\n### **第三部分：高级技术与优化**\n\n11. [构建、烧录与测试](#11-构建烧录与测试)\n    * [11.1 综合与实现](#111-综合与实现)\n    * [11.2 烧录比特流](#112-烧录比特流)\n    * [11.3 测试与验证](#113-测试与验证)\n12. [高级调试技术](#12-高级调试技术)\n    * [12.1 使用Vivado的集成逻辑分析仪](#121-使用vivado的集成逻辑分析仪)\n    * [12.2 PCIe流量分析工具](#122-pcie流量分析工具)\n13. [故障排除](#13-故障排除)\n    * [13.1 设备检测问题](#131-设备检测问题)\n    * [13.2 内存映射和BAR配置错误](#132-内存映射和bar配置错误)\n    * [13.3 DMA性能和TLP错误](#133-dma性能和tlp错误)\n14. [仿真精度与优化](#14-仿真精度与优化)\n    * [14.1 精确定时仿真技术](#141-精确定时仿真技术)\n    * [14.2 对系统调用的动态响应](#142-对系统调用的动态响应)\n15. [固件开发最佳实践](#15-固件开发最佳实践)\n    * [15.1 持续测试与文档](#151-持续测试与文档)\n    * [15.2 管理固件版本](#152-管理固件版本)\n    * [15.3 安全注意事项](#153-安全注意事项)\n16. [其他资源](#16-其他资源)\n17. [联系方式](#17-联系方式)\n18. [支持与贡献](#18-支持与贡献)\n\n---\n\n## **第一部分：基础概念**\n\n---\n\n## **1. 引言**\n\n### **1.1 本指南的目的**\n\n本指南的总体目标是让您掌握开发基于现场可编程门阵列（FPGA）设备的定制直接内存访问（DMA）固件的知识和实践技能。这种专用固件允许您的FPGA精确地仿真其他PCIe（Peripheral Component Interconnect Express）硬件设备的身份和行为。这种仿真是一种强大的技术，在多个高级领域具有深远意义：\n\n**硬件安全研究**：\n\n* **漏洞发现**：通过仿真设备，您可以创建一个受控环境，向主机驱动程序发送格式错误或意外数据，系统性地进行模糊测试，以发现可能通过硬件外设利用的漏洞（例如，缓冲区溢出、竞态条件）。\n* **驱动程序分析**：观察操作系统和特定驱动程序如何与硬件交互。您可以仿真具有非标准配置或未文档化功能的设备，以了解驱动程序行为、识别安全假设或逆向工程专有协议。\n* **侧信道分析**：虽然更复杂，但仿真设备可以通过精确控制外设操作，潜在地协助进行与通过时序或功耗分析进行信息泄漏相关的实验。\n\n**红队演练与渗透测试**：\n\n* **绕过安全措施**：仿真一个看似良性或白名单的硬件设备（例如，一个常见的网卡或存储控制器），以获取DMA权限。一旦实现，这允许直接与系统内存交互，可能绕过在更高软件层运行的端点检测和响应（EDR）系统或反恶意软件解决方案。\n* **隐蔽持久性**：仿真恶意设备可以提供一种隐蔽的方式来维护对受损系统的访问，因为它可能比基于软件的植入物更难检测。\n* **利用信任关系**：系统通常对连接的硬件有隐式信任。定制固件可以通过模仿被授予特定权限或访问的设备来利用这一点。\n\n**系统调试与诊断**：\n\n* **可复现的测试平台**：创建高度特定的硬件场景，以可靠地复现可能仅在特定设备状态或数据模式下发生的难以捉摸的错误。\n* **故障注入**：故意仿真有缺陷的设备行为（例如，错误的TLP形成、延迟响应），以测试主机系统及其驱动程序的健壮性和错误处理能力。\n\n**硬件测试与验证**：\n\n* **驱动程序开发**：在物理原型可用之前，或为了模拟比物理可访问的更广泛的硬件变体，针对仿真硬件配置文件测试新的或修改的驱动程序。\n* **合规性测试**：虽然不能替代官方合规性测试，但仿真设备可以帮助预验证PCIe协议遵守的某些方面。\n\n**传统系统支持与互操作性**：\n\n* 仿真老旧、停产或难以采购的PCIe设备，以保持传统系统运行或弥合不同硬件代之间的兼容性差距。\n\n通过学习本指南，您将熟练掌握：\n\n* 精细地从物理“捐赠”PCIe设备中提取识别属性和配置细节。\n* 修改和扩展现有开源FPGA固件框架（主要关注广泛使用的PCILeech-FPGA项目），以采用捐赠设备的身份。\n* 配置和利用以Xilinx Vivado为核心的专业FPGA开发工具链，以及Visual Studio Code等基本代码编辑工具。\n* 对PCIe架构的分层模型、DMA数据传输机制以及低级别复制硬件行为的固件开发细微之处，形成扎实的理解。\n\n### **1.2 目标读者**\n\n本指南专为已具备计算机系统、硬件原理和软件开发基础到中级知识的个人量身定制。内容技术性强，并假定读者具备进行详细、低级别工作的能力。具体来说，它面向以下人群：\n\n* **固件开发人员**：旨在为FPGA设计或改编固件的工程师，特别是涉及高速数据传输（DMA）和通过PCIe直接硬件接口操作的应用。强烈建议具备Verilog/VHDL背景和FPGA开发工具经验。\n* **硬件工程师**：参与PCIe硬件设计、测试或验证的专业人员。本指南可以帮助创建复杂的测试线束或在更大的系统设计中仿真组件。预计熟悉PCIe协议和数字设计。\n* **网络安全专业人员与研究人员**：\n  * **漏洞研究员与漏洞利用开发人员**：希望探索硬件级攻击面或开发利用DMA的概念验证漏洞。操作系统内部、内存管理和驱动程序架构的理解至关重要。\n  * **红队成员**：寻求通过直接硬件操作来获取系统访问、持久性和数据窃取的先进技术操作员。\n  * **数字取证与事件响应人员**：虽然本指南侧重于攻击，但理解这些技术有助于识别和分析复杂的基于硬件的攻击。\n* **FPGA爱好者与高级业余爱好者**：有FPGA项目经验，渴望应对PCIe通信和硬件仿真等复杂挑战的个人。愿意深入研究数据手册和技术规范是关键。\n\n学习曲线可能很陡峭，特别是如果PCIe或高级FPGA概念是新知识。然而，本指南旨在将复杂主题分解为可管理的步骤。\n\n### **1.3 如何使用本指南**\n\n本指南分为三个逻辑递进的部分，旨在逐步构建您的知识：\n\n* **第一部分：基础概念**：这第一部分至关重要。它介绍了核心术语、PCIe和DMA的基本原理、必要的硬件和软件堆栈（包括Xilinx Vivado和PCILeech-FPGA框架等工具的设置说明），以及从目标“捐赠”设备获取重要信息和进行基本固件修改的初始程序。强烈建议按顺序彻底学习本部分。\n* **第二部分：中级概念与实现**：（后续章节）在基础知识之上，本部分将引导您进行更高级的固件定制。主题将包括微调PCIe操作参数、仿真设备特定寄存器和功能（如电源管理状态和消息信号中断 - MSI/MSI-X），以及初步理解事务层数据包（TLP）的构建和解释。\n* **第三部分：高级技术与优化**：（后续章节）最后一部分将探讨复杂的调试方法（包括使用集成逻辑分析仪 - ILA和外部PCIe协议分析仪）、优化固件性能和仿真精度的技术、常见和复杂问题的全面故障排除，以及关于最佳实践的关键讨论，特别关注开发和部署仿真PCIe设备的安全影响。\n\n**学习本指南的步骤**：\n\n* **顺序学习**：特别是对于第一部分和第二部分，请按顺序学习各节，因为后面的概念建立在前面的基础之上。\n* **动手实践**：这是一份实践指南。请在您自己的硬件上积极执行设置步骤、代码修改和实验。\n* **适应您的环境**：文件路径、特定设备ID和软件版本可能有所不同。理解指令背后的概念，以使其适应您的特定设置。\n* **查阅外部资源**：PCIe规范和FPGA文档是您的最终参考。本指南进行简化和引导，但深入研究通常需要查阅原始资料。\n* **迭代开发**：固件开发很少是线性的。预期会进行迭代、调试和改进您的设计。广泛使用故障排除部分和调试技术。\n\n您将使用HDL（PCILeech-FPGA中的SystemVerilog）、FPGA综合和实现工具（Vivado），并可能使用主机端编程工具和PCIe分析实用程序。\n\n---\n\n## **2. 关键定义**\n\n牢固掌握以下术语对于理解PCIe设备仿真和定制固件开发的复杂性至关重要。这些术语将在整个指南中广泛使用。\n\n* **DMA (Direct Memory Access)**  (直接内存访问)：\n\n  * **定义**：现代计算机体系结构的一项基本功能，允许硬件外设（如网卡、GPU或您的基于FPGA的仿真设备）直接读取和写入主系统内存（RAM），而无需CPU参与每个字节的传输。\n  * **重要性**：DMA对于高性能I/O操作至关重要。通过将数据传输任务从CPU卸载，它使CPU能够执行其他计算，显著提高整体系统吞吐量和效率。在本指南中，您的FPGA将利用DMA与主机系统的内存进行交互，这是一种在安全研究和红队演练中经常被利用的强大功能。\n* **PCIe (Peripheral Component Interconnect Express)**  (外围组件互连高速)：\n\n  * **定义**：一种高速串行计算机扩展总线标准，旨在取代旧的总线标准，如PCI、PCI-X和AGP。它采用点对点拓扑结构，每个设备通过独立的串行链路连接到根联合体（通常是芯片组或CPU的一部分）。通信通过数据包进行。\n  * **重要性**：PCIe是连接高性能外设到主板的主导标准。理解其协议、分层架构（物理层、数据链路层、事务层）和配置机制对于仿真任何现代硬件设备至关重要。\n* **TLP (Transaction Layer Packet)**  (事务层数据包)：\n\n  * **定义**：PCIe协议事务层的数据交换基本单位。TLP负责在PCIe设备之间传输请求（例如，内存读/写、I/O读/写、配置读/写）和完成（对请求的响应）。每个TLP由一个报头、一个可选的数据有效载荷和一个可选的端到端CRC（ECRC）组成。\n  * **重要性**：为了精确仿真设备，您的FPGA固件必须能够正确地形成、传输、接收和解释与捐赠设备行为匹配的TLP。理解TLP类型、格式和流控制对于高级仿真至关重要。\n* **BAR (Base Address Register)**  (基地址寄存器)：\n\n  * **定义**：位于PCIe设备的配置空间内，BAR是特殊的寄存器，设备通过它们向主机系统请求地址空间资源。一个设备最多可以有六个32位BAR（或更少，或成对的32位BAR可以形成64位BAR）。这些寄存器定义了设备用于向主机CPU公开其寄存器和内部内存的内存映射I/O（MMIO）区域或I/O端口区域的起始地址和大小。\n  * **重要性**：当主机系统枚举PCIe设备时，它会读取BAR以确定设备的内存和I/O要求，然后分配并用系统中物理地址图中的实际基地址来编程这些BAR。您的仿真设备必须精确定义其BAR以匹配捐赠设备，以便主机操作系统和驱动程序能够正确地与其交互。\n* **FPGA (Field-Programmable Gate Array)**  (现场可编程门阵列)：\n\n  * **定义**：一种集成电路（IC），可以在制造后由设计者或客户进行配置——因此称为“现场可编程”。FPGA包含一个可编程逻辑块阵列和可重构互连的层次结构，允许这些块“连接”起来以实现定制数字逻辑电路。\n  * **重要性**：FPGA是本指南中使用的核心硬件。其可重构特性使其成为仿真其他硬件设备的理想选择，因为您可以定义精确的逻辑和接口来模仿捐赠设备的PCIe存在和行为。\n* **MSI/MSI-X (Message Signaled Interrupts / Message Signaled Interrupts Extended)**  (消息信号中断 / 扩展消息信号中断)：\n\n  * **定义**：允许PCIe设备通过向系统定义的内存地址写入特殊消息（TLP，特别是内存写入TLP）来向CPU传递中断的机制，而不是使用专用的物理中断线（如传统PCI）。MSI-X是MSI的增强版，提供更多的中断向量和更大的灵活性。\n  * **重要性**：大多数现代PCIe设备使用MSI或MSI-X以实现更高效、更灵活的中断处理。精确仿真通常需要实现捐赠设备选择的中断机制，包括配置MSI/MSI-X能力结构并正确生成中断消息。\n* **DSN (Device Serial Number)**  (设备序列号)：\n\n  * **定义**：一个64位全局唯一标识符，可由PCIe设备可选实现。如果存在，它通常位于设备配置空间内的扩展能力结构中。\n  * **重要性**：虽然并非所有设备都具有DSN，但某些驱动程序或管理软件可能会使用它进行唯一标识、许可或跟踪。正确仿真它对于完全透明和避免检测到仿真设备可能很重要。\n* **PCIe Configuration Space** (PCIe配置空间)：\n\n  * **定义**：与每个PCIe功能（一个设备可以有多个功能）关联的标准化256字节（对于Type 0、端点设备）或4KB地址区域。此空间包含有关设备的重要信息，包括其厂商ID、设备ID、类别代码、修订ID、BAR、能力指针以及各种状态和控制寄存器。主机系统使用特殊的配置读和配置写TLP访问此空间。\n  * **重要性**：配置空间是PCIe设备的“身份证”。设备仿真的第一步就是将捐赠设备配置空间的相关部分精确复制到您的FPGA固件中。主机系统使用此信息来识别、配置和分配资源给设备。\n* **Donor Device** (捐赠设备)：\n\n  * **定义**：您旨在在FPGA上仿真其身份和行为的物理PCIe硬件设备。该设备作为提取配置细节（厂商ID、设备ID、BAR设置、能力等）和行为模式的来源。\n  * **重要性**：您的仿真 fidelity 直接取决于您能够多么精确和完整地收集并复制捐赠设备的特性。\n* **Root Complex (RC)**  (根联合体)：\n\n  * **定义**：PCIe层级结构中将CPU和内存子系统连接到PCIe结构的实体。它代表CPU生成PCIe事务，并处理下游PCIe设备发起的事务。它还执行初始的总线枚举和配置。\n  * **重要性**：您的仿真设备在与主机系统通信时，将主要与根联合体（或与其连接的交换机）交互。\n* **Endpoint (EP)**  (端点)：\n\n  * **定义**：位于PCIe结构外围，消费或生产数据的一种PCIe设备。示例包括网卡、显卡、存储控制器以及您将要编程的FPGA设备。端点请求资源并向根联合体发起事务。\n  * **重要性**：在本指南中，您的FPGA将被编程为充当一个端点设备，仿真一个特定的捐赠端点。\n* **HDL (Hardware Description Language)**  (硬件描述语言)：\n\n  * **定义**：一种专用计算机语言，用于描述电子电路的结构、设计和操作，特别是数字逻辑电路。常见的HDL包括Verilog和VHDL。\n  * **重要性**：您将在PCILeech-FPGA项目中使用Verilog（特别是SystemVerilog，Verilog的扩展）来定义仿真设备的定制逻辑。\n* **Bitstream** (比特流)：\n\n  * **定义**：加载到FPGA上的最终配置文件，用于编程其逻辑块和互连，从而实现您的定制硬件设计。它是FPGA开发工具（如Xilinx Vivado）的编译输出。\n  * **重要性**：生成和烧录正确的比特流是将定制固件部署到FPGA的最终步骤。\n\n---\n\n## **3. 设备兼容性**\n\n成功且精确的PCIe设备仿真取决于确保您选择的基于FPGA的硬件和主机系统配置完全兼容。本节详细介绍了支持的FPGA平台、关键的PCIe硬件注意事项以及设置开发环境所需的系统要求。\n\n### **3.1 支持的基于FPGA的硬件**\n\n虽然本指南提供了一种可适用于各种基于FPGA的DMA硬件的通用方法，但我们的主要示例和具体说明将侧重于 **Xilinx 7系列FPGA**，由于其性能和可访问性的平衡，它们在开源DMA板中很常见。**Squirrel DMA (35T)**  卡因其受欢迎程度以及与PCILeech-FPGA框架的良好兼容性而受到强调。\n\n定制PCIe IP核和开发硬件描述语言（HDL）逻辑的核心原则和技术广泛适用于以下FPGA系列和特定板卡：\n\n* **Squirrel (Artix-7 35T)**\n  * **描述**：一种广泛可用且经济高效的基于FPGA的DMA设备，采用Xilinx Artix-7 35T FPGA。它为标准内存采集任务以及各种基本到中级设备仿真项目提供了足够的逻辑资源和内存。它是初次接触基于FPGA的DMA的优秀起点。\n  * **主要特点**：Artix-7提供了良好的性能价格比，适用于教育和研究目的。\n* **Enigma-X1 (Artix-7 75T)**\n  * **描述**：与35T相比，提供增强的逻辑和内存资源的中级FPGA，通常基于Xilinx Artix-7 75T FPGA。这为更复杂的仿真场景、更大的内存映射区域或需要额外FPGA逻辑的更复杂的DMA操作提供了更大的灵活性。\n  * **主要特点**：增加的逻辑单元和块RAM（BRAM）支持更复杂的设计。\n* **ZDMA (Artix-7 100T)**\n  * **描述**：基于更高性能的Artix-7 100T FPGA，针对要求更高的内存交互和大量的读/写操作进行了优化。此板卡适用于大规模DMA解决方案、高吞吐量仿真或需要大量片上内存的项目。\n  * **主要特点**：100T变体在资源方面提供了显著升级，是突破仿真界限的理想选择。\n* **Kintex-7 (K325T, K410T等)**\n  * **描述**：代表高级别，Kintex-7 FPGA（例如K325T、K410T）为高度复杂的项目、大规模DMA解决方案以及需要更高PCIe通道数或速度（例如，Gen3 x8/x16）的应用提供了强大的功能。虽然价格更昂贵，但它们提供了更多的逻辑、DSP切片和内存，从而能够仿真高度复杂和苛刻的捐赠设备。\n  * **主要特点**：用于更快PCIe世代的高性能收发器，丰富的逻辑和内存资源，适用于复杂设计。\n\n**关于FPGA系列的重要说明**：尽管原理相似，但不同的Xilinx 7系列FPGA（Artix-7、Kintex-7、Zynq-7000 PS/PL）之间，特定的IP核配置和时钟结构可能略有不同。请始终参考特定板卡文档和您所选FPGA系列的Xilinx PCIe IP核用户指南。PCILeech-FPGA项目通常提供板卡特定的Tcl脚本和源文件以简化此过程。\n\n### **3.2 PCIe硬件注意事项**\n\n为了确保基于FPGA的DMA设备在仿真中平稳无限制地运行，需要仔细考虑一些PCIe特定和主机系统功能，并在某些情况下进行修改。\n\n* **IOMMU / VT-d / AMD-Vi 设置**\n  * **建议**：对于初始设置和测试，**强烈建议在系统的BIOS/UEFI设置中禁用IOMMU（Intel的定向I/O虚拟化技术 - VT-d）或AMD的等效技术（AMD-Vi）** 。\n  * **理由**：IOMMU是为DMA功能设备提供内存管理单元的硬件组件。它们执行地址转换，类似于CPU的MMU，并且可以强制执行内存访问权限。虽然它们对于安全和虚拟化（防止恶意设备访问未经授权的内存区域）至关重要，但它们**会**限制DMA设备对系统内存的访问，可能干扰内存采集和设备仿真。禁用IOMMU允许DMA设备不受限制地访问内存，这对于高级仿真和安全研究目的通常是必要的。\n  * **位置**：通常在BIOS/UEFI中的“CPU Configuration”、“Virtualization”、“Advanced Settings”或“I/O Virtualization”下找到。\n* **内核DMA保护（Windows）/ Thunderbolt安全级别（Linux）**\n  * **建议（Windows）** ：在现代Windows系统中禁用**内核DMA保护**功能。这包括**基于虚拟化的安全性（VBS）**和**内存完整性（HVCI）**等设置。这些功能利用IOMMU来防止通过Thunderbolt或PCIe连接的外部外设进行未经授权的DMA攻击。\n  * **步骤（Windows）** ：\n    * 访问Windows安全设置：**开始 &gt; 设置 &gt; 隐私和安全性 &gt; Windows 安全中心 &gt; 设备安全性**。\n    * 在“核心隔离”下，点击“核心隔离详细信息”。\n    * 关闭“内存完整性”。\n    * 您可能还需要在BIOS/UEFI中禁用安全启动，因为VBS通常依赖于它。\n    * **注意**：禁用这些功能会显著**降低您系统的安全态势**，使其容易受到包括涉及恶意DMA设备的各种攻击。这应该只在专用测试系统上进行，而不是在您的主机器上，并且在您了解风险的安全、隔离环境中进行。\n  * **建议（Linux/Thunderbolt）** ：如果使用带有Thunderbolt端口的系统，请了解并可能调整BIOS/UEFI中的**Thunderbolt安全级别**。较低的安全级别（例如，“无安全”、“用户授权”）通常是任意Thunderbolt/PCIe设备在未经明确主机批准的情况下执行DMA所必需的。\n* **PCIe插槽要求**\n  * **建议**：使用与FPGA设备要求物理匹配的兼容PCIe插槽。大多数基于Artix-7的DMA卡在PCIe Gen2 x1或x4下运行。\n  * **理由**：\n    * **物理匹配**：x1卡可以插入x1、x4、x8或x16插槽，但x4卡至少需要x4插槽。\n    * **性能**：虽然x4卡*可能*在x1插槽中工作（如果物理连接是开放式或已修改的），但它将以x1速度运行，严重限制数据传输速率。为了获得最佳性能和精确仿真捐赠设备的功能，请确保FPGA板卡安装在提供至少*仿真*链路宽度和速度的插槽中（例如，如果您要仿真Gen2 x4设备，请在主机上使用Gen2 x4插槽）。\n  * **主板BIOS设置**：一些主板允许配置PCIe插槽速度（例如，强制Gen1或Gen2）。确保这些设置不与您期望的仿真速度冲突。\n\n### **3.3 系统要求**\n\n建立一个健壮的开发环境对于高效的固件开发、综合和调试至关重要。\n\n* **主机系统**\n  * **处理器**：现代多核CPU对于运行Vivado等FPGA开发工具至关重要，这些工具在综合和实现过程中计算密集。（例如，Intel Core i5/i7/i9 或 AMD Ryzen 5/7/9 等效处理器，建议8代或更新）。\n  * **内存（RAM）** ：强烈建议最低16 GB RAM；对于复杂FPGA设计，**32 GB 或更高是理想选择**，因为Vivado会消耗大量内存，尤其是在实现阶段。\n  * **存储**：一个固态硬盘（SSD）并至少有 **200 GB 的可用空间** 至关重要。FPGA工具安装（仅Vivado就可能超过50 GB）、项目文件以及综合/实现输出会迅速占用磁盘空间。SSD的速度能显著缩短构建时间。\n  * **操作系统**：\n    * **Windows 10/11 (64位 专业版或企业版)** ：Xilinx Vivado 和许多硬件调试工具广泛支持。请记住内核DMA保护的注意事项。\n    * **兼容的Linux发行版 (64位)** ：Ubuntu LTS（长期支持）版本（例如 20.04、22.04）是Vivado常用且支持良好的系统。Linux通常为脚本编写和低级PCIe交互工具提供更灵活的环境。\n* **外围设备**\n  * **JTAG编程器**：将编译后的比特流烧录到基于FPGA的DMA卡上绝对必需。示例包括Xilinx Platform Cable USB II、Digilent JTAG-HS3 或某些开发板上集成的JTAG编程器。确保它与您的FPGA板卡和Vivado兼容。\n  * **PCIe插槽**：如第3.2节所述，确保您的主机系统有可用的兼容PCIe插槽用于DMA卡。\n  * **USB端口**：用于连接JTAG编程器，并可能用于连接FPGA板卡的UART/串行控制台以进行调试输出。\n\n---\n\n## **4. 要求**\n\n本节概述了进行PCIe设备仿真定制固件开发所必需的基本硬件和软件组件，以及推荐的环境设置。在开始之前，具备这些先决条件将简化您的开发过程。\n\n### **4.1 硬件**\n\n* **捐赠PCIe设备**\n  * **目的**：这是您打算在FPGA上仿真其配置和行为的物理硬件设备。它作为关键识别细节、寄存器值和操作特性的权威来源。\n  * **示例**：常见示例包括标准网卡（NIC）、SATA或NVMe存储控制器、USB控制器，或任何其他您可以安全地从系统中移除进行分析的通用PCIe扩展卡。强烈建议使用对系统操作非必需的设备，因为您将检查其低级配置。\n* **DMA FPGA卡**\n  * **描述**：一种基于FPGA的开发板，专门设计或改编用于通过PCIe接口执行直接内存访问（DMA）操作。这是您的定制固件将加载到的平台。\n  * **示例**：如第3.1节所述，兼容卡包括 **Squirrel (Artix-7 35T)** 、**Enigma-X1 (Artix-7 75T)** 、**ZDMA (Artix-7 100T)**  或各种基于 **Kintex-7** 的解决方案。确保您选择的卡具有PCIe金手指连接器。\n* **JTAG编程器**\n  * **目的**：这个关键工具促进了您的开发PC与DMA卡上FPGA之间的通信。它用于将编译后的比特流编程（烧录）到FPGA上，更重要的是，用于使用Vivado的硬件管理器和集成逻辑分析仪（ILA）等工具进行交互式调试。\n  * **示例**：\n    * **Xilinx Platform Cable USB II**：Xilinx FPGA传统且广泛兼容的编程器。确保您已安装必要的驱动程序。\n    * **Digilent JTAG-HS3 / JTAG-HS2**：流行且可靠的编程器，以良好的Vivado集成和支持而闻名。HS3提供更快的编程速度。\n    * **集成JTAG**：某些FPGA板可能具有板载USB转JTAG桥（例如FTDI芯片），这消除了对独立编程器的需求。请查阅您的板卡文档。\n\n### **4.2 软件**\n\n* **Xilinx Vivado Design Suite**\n  * **描述**：Xilinx（现为AMD）官方的、全面的FPGA开发环境。Vivado对于综合您的HDL代码、将设计实现到目标FPGA上、生成最终比特流以及执行硬件调试至关重要。它包括必要的IP核、编译器和实用程序。\n  * **下载**：访问Xilinx（AMD）官方下载页面：[https://www.xilinx.com/support/download.html](https://www.xilinx.com/support/download.html)。\n  * **版本说明**：虽然一些旧指南可能引用Vivado 2020.1等旧版本，但强烈建议下载与您的目标FPGA系列（Artix-7、Kintex-7）兼容的**最新稳定版本**（例如Vivado 2023.x或更高版本）。PCILeech-FPGA项目通常支持较新的Vivado版本。\n* **Visual Studio Code**\n  * **描述**：Microsoft出品的高度可定制且功能丰富的代码编辑器。它是编写和编辑Verilog/SystemVerilog HDL代码的绝佳选择，因为它拥有广泛的扩展生态系统，提供语法高亮、代码检查、自动补全和版本控制集成等功能。\n  * **下载**：[https://code.visualstudio.com/](https://code.visualstudio.com/)\n* **PCILeech-FPGA**\n  * **描述**：一个用于基于FPGA的DMA开发的开源框架和基础代码库。它提供了即插即用的PCIe IP核实例化和一个结构良好的项目，是定制固件的绝佳起点。本指南将大量利用其架构。\n  * **仓库**：[https://github.com/ufrisk/pcileech-fpga](https://github.com/ufrisk/pcileech-fpga)\n* **Arbor (MindShare)**\n  * **描述**：一款强大且用户友好的软件工具，专门设计用于深入扫描和分析PCIe设备。它提供了对连接PCIe硬件的配置空间、功能和寄存器的详细洞察，对于收集捐赠设备信息来说非常有价值。\n  * **下载**：可从MindShare网站获取：[https://www.mindshare.com/](https://www.mindshare.com/)（您可能需要导航到他们的软件部分）。\n  * **注意**：通常需要创建账户，并且可能提供限时试用。\n* **替代PCIe设备分析工具**\n  * **Telescan PE (Teledyne LeCroy)** ：\n    * **描述**：Teledyne LeCroy提供的一款免费PCIe流量分析和设备枚举工具。虽然它主要是一款与其硬件协议分析仪交互的软件工具，但它也可以在没有专用硬件的情况下提供一些基本的配置空间视图。\n    * **下载**：[https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software](https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software)\n    * **注意**：需要手动注册和批准才能下载。\n  * **OS原生工具（用于基本检查）** ：\n    * **Windows设备管理器**：在设备属性的“详细信息”选项卡下提供基本的厂商ID、设备ID、子系统ID和类别代码信息。\n    * **Linux **​**​`lspci`​**​ ** 工具**：一个强大的命令行工具，用于检查PCIe设备。使用`lspci -nn`查看厂商/设备ID，`lspci -vvv`查看包括BAR和功能在内的详细信息，`lspci -s <BUS:DEV.FUN> -xxxx`用于原始配置空间转储。\n\n### **4.3 环境设置**\n\n一个干净且正确配置的开发环境对于避免常见陷阱并确保流畅的工作流程至关重要。\n\n#### **4.3.1 安装Xilinx Vivado设计套件**\n\n**步骤**：\n\n1. **访问Xilinx (AMD) Vivado下载页面**：[https://www.xilinx.com/support/download.html](https://www.xilinx.com/support/download.html)。\n2. **下载适当版本**：选择与您的操作系统兼容的最新稳定版Vivado，更重要的是，它必须与您的特定FPGA设备（例如Artix-7、Kintex-7）兼容。查阅Vivado发行说明以了解设备支持情况。\n3. **运行安装程序**：执行下载的安装程序并仔细遵循屏幕上的说明。\n4. **选择必要组件**：在安装过程中，系统会提示您选择要安装的设备家族。**至关重要的是，选择与您的FPGA板卡对应的设备家族（例如，Artix-7/Kintex-7的“7 Series”）** 。这与安装所有家族相比，能节省大量磁盘空间。确保您选择“设计工具”（综合、实现）和“编程与调试”组件。\n5. **启动Vivado**：安装完成后，启动Vivado以确认它能无错误打开，并且许可证（如果适用）已正确配置。\n\n#### **4.3.2 安装Visual Studio Code**\n\n**步骤**：\n\n1. **访问Visual Studio Code下载页面**：[https://code.visualstudio.com/](https://code.visualstudio.com/)。\n2. **下载并安装**：下载适用于您操作系统的安装程序，并遵循标准安装提示。\n3. **安装HDL支持扩展**：安装VS Code后，打开它并导航到扩展视图（Ctrl+Shift+X或Cmd+Shift+X）。搜索并安装适用于Verilog/SystemVerilog的相关扩展，例如：\n   * **Verilog-HDL/SystemVerilog** (由mshr-h提供)\n   * **VHDL** (如果您也使用VHDL)\n     这些扩展提供了语法高亮、代码检查和其他有用的功能。\n\n#### **4.3.3 克隆PCILeech-FPGA仓库**\n\n此仓库包含您将要修改的基础固件结构和脚本。\n\n**步骤**：\n\n1. **打开终端或命令提示符**：（例如，Windows上的Git Bash，Linux上的Terminal）。\n2. **导航到您想要的目录**：选择一个您想存储项目的位置。\n   ```bash\n   cd ~/Projects/ # 在Linux/macOS上\n   cd C:\\Users\\YourUsername\\Documents\\Projects\\ # 在Windows上\n   ```\n3. **克隆仓库**：\n   ```bash\n   git clone https://github.com/ufrisk/pcileech-fpga.git\n   ```\n4. **导航到克隆的目录**：\n   ```bash\n   cd pcileech-fpga\n   ```\n\n   这将是您的主项目目录。PCILeech-FPGA项目通常包含不同板卡变体的子目录（例如`pcileech-artix-7-50t`、`pcileech-squirrel-35t`）。您将根据您的特定硬件导航到相关的板卡特定目录。\n\n#### **4.3.4 设置一个干净的开发环境**\n\n**建议**：始终在隔离或专用的环境中工作，尤其是在处理低级硬件和潜在的安全隐患时。\n\n**步骤**：\n\n1. **使用专用开发机或虚拟机**：\n   * **物理机**：如果可能，使用一台单独的物理计算机进行FPGA开发和测试。这可以防止在您的主机器上发生意外的系统不稳定或安全风险。\n   * **虚拟机（VM）** ：虚拟机可以是隔离开发环境的好选择。然而，通常需要向虚拟机进行直接PCIe直通（PCIe热插拔或VT-d直通），FPGA卡才能被正确检测和操作，这可能配置复杂，并且如果操作不当，仍然可能暴露主机。对于初始工具安装和代码编辑，虚拟机完全没问题。\n2. **最小化后台应用程序**：确保没有其他资源密集型应用程序正在运行，这些应用程序可能会干扰Vivado在综合和实现过程中的性能。\n3. **禁用冲突软件**：在开发和测试期间，暂时禁用任何可能干扰低级硬件访问或JTAG通信的防病毒、防火墙或安全软件。完成工作后请记得重新启用它们。\n\n---\n\n## **5. 收集捐赠设备信息**\n\n精确的设备仿真取决于精细地提取和复制捐赠设备的关键信息。这种全面的数据收集使您的FPGA能够忠实地模仿目标硬件的PCIe配置和行为，确保与主机系统接口时的兼容性和功能性。\n\n### **5.1 使用Arbor进行PCIe设备扫描**\n\n**Arbor** 是一款强大且用户友好的工具，专为深入扫描PCIe设备而设计。它提供了对连接硬件配置空间的详细洞察，使其成为提取设备仿真所需信息的宝贵资源。\n\n#### **5.1.1 安装Arbor**\n\n要开始使用Arbor进行设备扫描，您必须首先在系统上安装该软件。\n\n**步骤：**\n\n1. **访问Arbor下载页面：**\n   * 使用您偏好的网页浏览器导航到MindShare官方网站（[https://www.mindshare.com/](https://www.mindshare.com/)）。您需要找到他们的“Software”或“Downloads”部分来定位Arbor。\n   * 确保您直接访问该网站，以避免任何恶意重定向。\n2. **创建账户（如果需要）：**\n   * Arbor可能要求您创建用户账户才能访问下载链接。\n   * 提供必要的信息，例如您的姓名、电子邮件地址和组织。\n   * 如果出现提示，请验证您的电子邮件以激活您的账户。\n3. **下载Arbor：**\n   * 登录后，找到Arbor的下载部分。\n   * 选择与您的操作系统兼容的版本（例如，Windows 10/11 64位）。\n   * 点击 **Download** 按钮并将安装程序保存到计算机上已知的位置。\n4. **安装Arbor：**\n   * 找到下载的安装程序文件（例如，`ArborSetup.exe`）。\n   * 右键单击安装程序并选择 **以管理员身份运行** 以确保它具有必要的权限。\n   * 按照屏幕上的说明完成安装过程。\n     * 接受许可协议。\n     * 选择安装目录。\n     * 如果需要，选择创建桌面快捷方式。\n5. **验证安装：**\n   * 安装完成后，确保Arbor列在您的“开始”菜单或桌面上。\n   * 启动Arbor以确认它能无错误打开。\n\n#### **5.1.2 扫描PCIe设备**\n\n安装Arbor后，您可以继续扫描系统中的PCIe设备。\n\n**步骤：**\n\n1. **启动Arbor：**\n   * 双击桌面上的Arbor图标或通过“开始”菜单找到它。\n   * 如果用户账户控制（UAC）提示，允许应用程序对设备进行更改。\n2. **导航到本地系统选项卡：**\n   * 在Arbor界面中，找到导航窗格或选项卡。\n   * 单击 **Local System** 以访问扫描本地机器的工具。\n3. **扫描PCIe设备：**\n   * 查找 **Scan** 或 **Rescan** 按钮，通常位于界面的顶部或底部。\n   * 点击 **Scan/Rescan** 以启动检测过程。\n   * 等待扫描过程完成；这可能需要几分钟，具体取决于连接的设备数量。\n4. **审查检测到的设备：**\n   * 扫描完成后，Arbor将显示所有检测到的PCIe设备的列表。\n   * 设备通常会列出其名称、设备ID和其他识别信息。\n\n#### **5.1.3 识别捐赠设备**\n\n识别正确的捐赠设备对于精确仿真至关重要。\n\n**步骤：**\n\n1. **在列表中找到您的捐赠设备：**\n   * 滚动浏览Arbor检测到的设备列表。\n   * 查找与您的捐赠硬件的品牌和型号匹配的设备。\n   * 设备可能按其厂商名称、设备类型或功能列出。\n2. **验证设备详细信息：**\n   * 单击设备以选中它。\n   * 确认 **Device ID** 和 **Vendor ID** 与您的捐赠设备匹配。\n     * **提示：**  这些ID通常可以在设备文档或制造商网站上找到。对于常见设备，快速在网上搜索“\\[设备名称] Vendor ID Device ID”通常能得到结果。\n3. **查看详细配置：**\n   * 选中设备后，找到并单击类似 **View Details** 或 **Properties** 的选项。\n   * 这将打开一个详细视图，显示设备的配置空间和功能。\n4. **与物理硬件交叉引用：**\n   * 如果列出了多个类似设备，请将 **Slot Number** 或 **Bus Address** 与安装捐赠设备的物理插槽交叉引用。这有助于确认您正在分析正确的硬件。\n\n#### **5.1.4 捕获设备数据**\n\n从捐赠设备中提取详细信息对于精确仿真至关重要。\n\n**要提取的信息：**\n\n* **设备ID (0xXXXX)：**  唯一标识设备型号的16位标识符。\n* **厂商ID (0xYYYY)：**  分配给制造商的16位标识符。\n* **子系统ID (0xZZZZ)：**  标识特定子系统或变体（例如，产品线中的特定型号）。\n* **子系统厂商ID (0xWWWW)：**  标识子系统的厂商（通常与主厂商ID相同，但对于OEM版本可能会有所不同）。\n* **修订ID (0xRR)：**  指示设备的硬件修订级别。\n* **类别代码 (0xCCCCCC)：**  一个24位代码，定义设备的主要功能/类型（例如，`0x020000`用于以太网控制器，`0x010802`用于NVMe控制器）。这有助于操作系统加载通用驱动程序。\n* **基地址寄存器 (BARs)：**\n  * 定义设备使用的内存或I/O地址区域的寄存器。\n  * 包括BAR0到BAR5，每个都可能是32位或64位。对于每个BAR，请记录其 **类型（内存或I/O）** 、**位宽（32位或64位）** 、**大小（例如，256 MB，4KB）**  和 **可预取状态（是/否）** 。这对于内存映射至关重要。\n* **功能：**  列出支持的功能及其配置，通常在配置空间中的链表结构中找到。示例包括：\n  * **PCIe功能结构**：PCIe链路速度（例如，Gen2，Gen3），链路宽度（例如，x1，x4），最大载荷大小，最大读取请求大小。\n  * **MSI/MSI-X功能结构**：消息信号中断信息，包括支持的向量数量。\n  * **电源管理功能结构**：支持的电源状态（D0，D1，D2，D3hot，D3cold）。\n* **设备序列号 (DSN)：**  一个64位唯一标识符，如果设备支持（在“设备序列号”扩展功能中找到）。并非所有设备都实现了此功能。\n\n**步骤：**\n\n1. **导航到PCI配置选项卡：**\n   * 在设备详细视图中，找到并选择 **PCI Config** 或 **Configuration Space** 选项卡。这通常会以解码视图显示原始配置空间寄存器。\n2. **记录相关详细信息：**\n   * 仔细记录上面列出的每个所需字段。\n   * 使用截图或将值复制到文本文件、专用电子表格或结构化文档格式中以确保准确性。\n   * 确保十六进制值正确记录，包括是否使用`0x`前缀。\n3. **展开功能列表：**\n   * 查找标记为 **Capabilities** 或 **Advanced Features** 的部分。这些通常是可点击或可展开以显示子部分的。\n   * 记录存在的每个功能及其相关参数（例如，MSI消息控制，电源状态标志，当前/最大PCIe链路设置）。\n4. **详细检查BAR：**\n   * 在配置空间中，找到BAR0到BAR5的条目。\n   * 对于每个活动的BAR，记录其分配的大小、是内存映射还是I/O、其位宽（32位或64位）以及是否可预取。这些信息通常在Arbor的GUI中清晰显示。\n5. **保存数据以备参考：**\n   * 将所有提取的信息编译成一个组织良好的文档（例如，Markdown文件、`.txt`文件或Excel电子表格）。\n   * 为每个部分清晰标记，以便在固件定制期间轻松参考。\n\n### **5.2 提取和记录设备属性**\n\n捕获数据后，理解每个属性的重要性并确保其准确记录对于成功仿真至关重要。\n\n**确保您已准确记录以下内容：**\n\n1. **设备ID：**\n   * **目的：**  唯一标识PCIe设备的特定型号。\n   * **仿真用法：**  对于主机操作系统（OS）正确识别仿真设备至关重要，更重要的是，它能尝试加载适当的设备驱动程序。\n2. **厂商ID：**\n   * **目的：**  标识PCIe设备的制造商。\n   * **仿真用法：**  与设备ID结合使用，形成主机操作系统用于将设备与相应驱动程序匹配的唯一标识符（`VendorID:DeviceID`）。\n3. **子系统ID和子系统厂商ID：**\n   * **目的：**  这些可选ID允许区分同一厂商设备的变体，或区分主厂商/设备ID可能为通用的OEM特定版本。\n   * **仿真用法：**  对于仿真具有多种配置的设备或OEM提供的设备很重要，因为驱动程序可能会专门查找这些值。\n4. **修订ID：**\n   * **目的：**  指示设备的硬件修订级别。\n   * **仿真用法：**  有助于识别可能需要不同驱动程序、固件或具有细微行为差异的特定硬件版本。\n5. **类别代码：**\n   * **目的：**  一个24位代码，用于对设备的通用功能进行分类（例如，`0x020000`用于以太网控制器，`0x010802`用于NVMe控制器，`0x0C0300`用于USB主机控制器）。它由基本类别、子类别和编程接口组成。\n   * **仿真用法：**  允许操作系统理解设备的通用功能，并在找不到特定厂商驱动程序时加载通用类别驱动程序。这对于初始设备识别至关重要。\n6. **基地址寄存器（BARs）：**\n   * **目的：**  定义设备用于寄存器、内部缓冲区或配置空间扩展的内存映射或I/O端口地址区域。主机操作系统在枚举期间将物理地址分配给这些BAR。\n   * **仿真用法：**  对于将仿真设备的内部内存和寄存器映射到主机系统的地址空间至关重要。每个BAR的大小、类型（内存/I/O，32/64位）和可预取状态必须与捐赠设备精确匹配。\n7. **功能：**\n   * **目的：**  列出设备支持的高级功能，如高级错误报告、电源管理、MSI/MSI-X、PCIe高级功能（如AER、VC/PF）等。每个功能由一个具有其自身寄存器的结构定义。\n   * **仿真用法：**  对于准确复制捐赠设备如何宣传其功能以及主机系统如何与这些功能交互（例如，中断传递机制、电源状态转换、错误报告）至关重要。\n8. **设备序列号（DSN）：**\n   * **目的：**  设备的唯一64位标识符，通常是可选的扩展功能。\n   * **仿真用法：**  虽然可选，但某些驱动程序或管理应用程序可能会专门查询并依赖DSN进行识别、许可或安全检查。准确仿真此功能可以防止您的设备被检测为通用或修改的外设。\n\n**数据收集的最佳实践：**\n\n* **组织数据：**  创建一个结构化的文档或电子表格。为每个属性使用清晰的标题和子标题。模板会很有益。\n* **包含单位和格式：**  始终注明大小的单位（例如，MB、KB），并为十六进制值使用一致的格式（例如，`0x1234`、`16'h1234`）。\n* **与规范交叉引用（如果可能）：**  如果可用，查阅捐赠设备的数据手册或公开可用的规范以验证值。这有助于识别原始扫描中不明显或不寻常的配置。\n* **保护数据：**  安全存储收集到的信息。请注意，这些数据可能包含专有或敏感信息。\n* **理解“缺少什么”：**  像Arbor这样的专业工具非常出色，但它们可能无法捕捉复杂、高度专有设备的每一个细微之处（例如，标准配置空间之外的特定厂商定义寄存器）。对于高级仿真，您可能需要将此信息与捐赠设备驱动程序的逆向工程结合起来。\n\n---\n\n## **6. 初始固件定制**\n\n在细致地记录了捐赠设备的信息之后，下一个关键阶段是定制您的FPGA固件，以准确仿真捐赠设备。这个过程首先要修改PCIe配置空间中的关键识别寄存器，并确保设备序列号等特定标识符被正确集成。\n\n### **6.1 修改配置空间**\n\nPCIe配置空间是定义设备如何被识别并与主机系统在枚举期间交互的基本组件。精确定制此空间以匹配捐赠设备的配置文件对于成功仿真绝对至关重要，它能让主机操作系统加载正确的驱动程序并按预期交互。\n\n#### **6.1.1 导航到配置文件**\n\nPCIe配置空间参数通常在PCILeech-FPGA项目中的特定SystemVerilog（`.sv`）文件中定义。此文件将综合成配置PCIe IP核并向主机公开设备身份的逻辑。\n\n**PCILeech-FPGA（基于Artix-7的板卡，如Squirrel）的常见路径：** \n找到负责为您特定板卡配置PCIe参数的文件。对于许多Artix-7 PCILeech变体，这将是：\n\n```\npcileech-fpga/<your_board_variant>/src/pcileech_pcie_cfg_a7.sv\n```\n\n* **示例（对于Squirrel 35T）** ：\n  ```\n  pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv\n  ```\n\n  *注意：实际的文件夹名称，如*​*​`pcileech-squirrel-35t`​*​ *，可能会根据您克隆的PCILeech-FPGA的具体版本或分支略有不同。克隆主仓库后，请始终导航到相关的板卡特定子目录。*\n\n#### **6.1.2 在Visual Studio Code中打开文件**\n\n编辑配置文件需要一个合适的代码编辑器，该编辑器支持SystemVerilog（或Verilog）的语法高亮，使代码更易于阅读和修改。\n\n**步骤：**\n\n1. **启动Visual Studio Code：**\n   * 点击VS Code图标或通过“开始”菜单找到它。\n2. **打开文件：**\n   * 使用 **文件 &gt; 打开文件** 或按下 `Ctrl + O`（macOS上为 `Cmd + O`）。\n   * 导航到第6.1.1节中确定的配置文件路径（例如，`pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv`）。\n   * 选择文件并点击 **打开**。\n3. **验证语法高亮：**\n   * 确保编辑器识别 `.sv` 文件扩展名并应用正确的SystemVerilog语法高亮。如果不行，请返回第4.3.2节，确保您已安装推荐的Verilog/SystemVerilog扩展程序。\n4. **熟悉文件结构：**\n   * 滚动浏览文件。您通常会发现使用`localparam`或`reg`赋值定义的参数，通常附有解释其目的的注释。查找定义和赋值标准PCIe配置寄存器（厂商ID、设备ID等）的部分。\n\n#### **6.1.3 修改设备ID和厂商ID**\n\n更新这些基本标识符是主机系统正确将仿真设备识别为您的捐赠设备的最关键步骤。操作系统严重依赖 `Vendor ID` 和 `Device ID` 对来识别连接的硬件并加载适当的设备驱动程序。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_deviceid`​**​ **：**\n   * 在VS Code中使用搜索功能（`Ctrl + F`或`Cmd + F`）。\n   * 找到定义`cfg_deviceid`的行。它通常看起来像这样：\n     ```verilog\n     reg [15:0] cfg_deviceid = 16'hAAAA; // 默认或占位符设备ID\n     ```\n2. **更新设备ID：**\n   * 将`AAAA`替换为您使用Arbor从捐赠设备中提取的16位十六进制设备ID（例如，`0x1234`）。\n   * **示例：** \n     如果捐赠设备的设备ID是`0x1234`，则将该行更新为：\n     ```verilog\n     reg [15:0] cfg_deviceid = 16'h1234; // 更新为捐赠设备的设备ID（例如，来自网卡）\n     ```\n3. **搜索 **​**​`cfg_vendorid`​**​ **：**\n   * 找到定义`cfg_vendorid`的行。其格式将类似于`cfg_deviceid`：\n     ```verilog\n     reg [15:0] cfg_vendorid = 16'hBBBB; // 默认或占位符厂商ID\n     ```\n4. **更新厂商ID：**\n   * 将`BBBB`替换为您从捐赠设备中提取的16位十六进制厂商ID（例如，`0xABCD`）。\n   * **示例：** \n     如果捐赠设备的厂商ID是`0xABCD`，则将该行更新为：\n     ```verilog\n     reg [15:0] cfg_vendorid = 16'hABCD; // 更新为捐赠设备的厂商ID（例如，Intel Corporation）\n     ```\n5. **确保格式正确：**\n   * 验证十六进制值是否正确以`16'h`为前缀（表示一个16位十六进制数）。\n   * 保持一致的缩进和注释风格以提高可读性。\n\n#### **6.1.4 修改子系统ID和修订ID**\n\n这些标识符提供了关于设备变体、特定产品型号或硬件修订的额外详细信息。虽然通常是可选的，但匹配它们能增强仿真的真实性，并且对于执行细粒度检查的驱动程序可能至关重要。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_subsysid`​**​ **：**\n   * 找到定义`cfg_subsysid`的行。\n\n   ```verilog\n   reg [15:0] cfg_subsysid = 16'hCCCC; // 占位符子系统ID\n   ```\n2. **更新子系统ID：**\n   * 将`CCCC`替换为您捐赠设备的16位十六进制子系统ID（例如，`0x5678`）。\n   * **示例：**\n     ```verilog\n     reg [15:0] cfg_subsysid = 16'h5678; // 设置为捐赠设备的子系统ID\n     ```\n3. **搜索 **​**​`cfg_subsysvendorid`​**​ **：**\n   * 找到定义`cfg_subsysvendorid`的行。\n\n   ```verilog\n   reg [15:0] cfg_subsysvendorid = 16'hDDDD; // 占位符子系统厂商ID\n   ```\n4. **更新子系统厂商ID（如果适用）：**\n   * 将`DDDD`替换为您捐赠设备的16位十六进制子系统厂商ID（例如，`0x9ABC`）。如果您的捐赠设备没有唯一的子系统厂商ID（即与主厂商ID相同），您仍应将其设置为该值。\n   * **示例：**\n     ```verilog\n     reg [15:0] cfg_subsysvendorid = 16'h9ABC; // 设置为捐赠设备的子系统厂商ID\n     ```\n5. **搜索 **​**​`cfg_revisionid`​**​ **：**\n   * 找到定义`cfg_revisionid`的行。\n\n   ```verilog\n   reg [7:0] cfg_revisionid = 8'hEE; // 占位符修订ID\n   ```\n6. **更新修订ID：**\n   * 将`EE`替换为您捐赠设备的8位十六进制修订ID（例如，`0x01`）。\n   * **示例：**\n     ```verilog\n     reg [7:0] cfg_revisionid = 8'h01; // 设置为捐赠设备的修订ID\n     ```\n\n#### **6.1.5 更新类别代码**\n\n类别代码通知主机操作系统设备的通用类型和功能（例如，网络控制器、存储设备）。这对于操作系统加载通用类别驱动程序至关重要，即使没有安装特定厂商驱动程序。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_classcode`​**​ **：**\n   * 找到定义`cfg_classcode`的行。\n\n   ```verilog\n   reg [23:0] cfg_classcode = 24'hFFFFFF; // 默认或占位符类别代码\n   ```\n2. **更新类别代码：**\n   * 将`FFFFFF`替换为您从捐赠设备中提取的24位十六进制类别代码（例如，`0x020000`用于以太网控制器）。请记住格式：基本类别、子类别、编程接口。\n   * **示例：** \n     如果捐赠设备的类别代码是`0x020000`（表示基本类别：0x02 - 网络控制器，子类别：0x00 - 以太网控制器，编程接口：0x00），则更新为：\n     ```verilog\n     reg [23:0] cfg_classcode = 24'h020000; // 设置为捐赠设备的类别代码（例如，以太网控制器）\n     ```\n3. **验证正确的位宽：**\n   * 确保类别代码使用`24'h`前缀正确表示为24位十六进制值。\n\n#### **6.1.6 保存更改**\n\n在对配置参数进行所有修改后，保存和审查更改至关重要。\n\n**步骤：**\n\n1. **保存文件：**\n   * 在VS Code中点击 **文件 &gt; 保存**，或按下 `Ctrl + S`（macOS上为 `Cmd + S`）。\n2. **审查更改：**\n   * 在关闭之前，快速重新阅读修改过的行，以根据您的捐赠设备信息文档确认其准确性。\n   * 检查是否有任何明显的语法错误或拼写错误（VS Code的扩展可能会高亮显示这些）。\n3. **可选 - 使用版本控制：**\n   * 如果您正在使用Git（强烈推荐用于任何代码项目，尤其是固件），请以清晰且有意义的消息提交您的更改。这将创建您的修改历史记录。\n   * **示例Git命令：**\n     ```bash\n     git add pcileech_pcie_cfg_a7.sv\n     git commit -m \"更新PCIe配置寄存器（VID, DID, SubIDs, Revision, Class Code）以匹配捐赠设备：[捐赠设备名称]\"\n     ```\n\n### **6.2 插入设备序列号（DSN）**\n\n设备序列号（DSN）是一些PCIe设备（特别是那些具有高级功能或特定驱动程序的设备）可能使用的独特64位标识符。包含它能增强仿真的真实性，并有助于绕过明确查询此值的驱动程序中的检查。\n\n#### **6.2.1 定位DSN字段**\n\nDSN（如果由捐赠设备实现）是PCIe扩展能力的一部分。在PCILeech-FPGA框架中，DSN字段通常作为您一直在编辑的同一配置文件中的可配置参数公开。\n\n**步骤：**\n\n1. **搜索 **​**​`cfg_dsn`​**​ **：**\n   * 在 `pcileech_pcie_cfg_a7.sv`（或您的板卡等效配置文件）中，使用搜索功能（`Ctrl + F` 或 `Cmd + F`）查找 `cfg_dsn`。\n2. **理解现有赋值：**\n   * DSN可能被设置为默认值（通常是全零）或被注释掉。它通常看起来像这样：\n     ```verilog\n     reg [63:0] cfg_dsn = 64'h0000000000000000; // 默认DSN（如果未使用，通常为0）\n     ```\n\n#### **6.2.2 插入DSN**\n\n更新DSN涉及将其设置为从捐赠设备捕获的精确64位十六进制值。\n\n**步骤：**\n\n1. **更新 **​**​`cfg_dsn`​**​ **：**\n   * 将现有的十六进制值替换为您使用Arbor从捐赠设备中提取的64位DSN。\n   * **示例：** \n     如果捐赠设备的DSN是`0x0011223344556677`，则更新为：\n     ```verilog\n     reg [63:0] cfg_dsn = 64'h0011223344556677; // 捐赠设备序列号\n     ```\n2. **处理DSN不可用或不相关的情况：**\n   * 如果您的捐赠设备*没有*DSN，或者您已确定它不是您目标驱动程序所需的参数，您可以简单地将其保留为零：\n     ```verilog\n     reg [63:0] cfg_dsn = 64'h0000000000000000; // 捐赠设备没有特定DSN，保留为默认0\n     ```\n   * **注意**：对于关键仿真，如果捐赠设备有DSN，最好准确仿真它。\n3. **确保格式正确：**\n   * DSN是64位值；确保它以`64'h`前缀正确格式化为十六进制值。\n\n#### **6.2.3 保存更改**\n\n通过保存和审查文件来完成DSN修改。\n\n**步骤：**\n\n1. **保存文件：**\n   * 在VS Code中点击 **文件 &gt; 保存**，或按下 `Ctrl + S`。\n2. **验证语法：**\n   * 检查VS Code的语法检查器是否有任何红色下划线或错误指示。立即纠正任何问题。\n3. **记录更改：**\n   * 如果使用版本控制，请使用适当的消息提交更新。\n   * **示例Git命令：**\n     ```bash\n     git commit -am \"在PCIe配置中插入捐赠设备序列号（DSN）\"\n     ```\n\n---\n\n## **7. Vivado项目设置与定制**\n\n在固件文件更新以反映捐赠设备的关键识别和配置数据后，下一个关键步骤是将这些更改集成到Vivado项目中。这包括为您的特定FPGA板卡生成项目文件，定制嵌入式PCIe IP核，并准备整个设计以进行综合和实现阶段。\n\n### **7.1 生成Vivado项目文件**\n\nVivado是Xilinx（AMD）开发套件，使用Tcl（工具命令语言）脚本来自动化项目创建、添加源文件和配置项目设置。通过运行PCILeech-FPGA框架提供的这些脚本，您可以确保您的Vivado项目已为目标FPGA板卡正确设置。\n\n#### **7.1.1 打开Vivado**\n\n启动Vivado的新会话可确保之前会话中没有残留设置或打开项目干扰当前工作。\n\n**步骤：**\n\n1. **启动Vivado：**\n   * 在“开始”菜单（Windows）或“应用程序”文件夹（Linux/macOS）中找到Vivado应用程序图标。\n   * 点击打开。\n2. **选择正确的版本：**\n   * 如果您安装了多个Vivado版本，请确保您启动的是与您的FPGA板卡和PCILeech-FPGA项目兼容的版本（如第4.3.1节所述，建议使用Vivado 2023.x等最新稳定版本）。\n3. **等待启动界面：**\n   * 让Vivado完全初始化并显示欢迎界面或项目仪表板，然后才能继续。\n\n#### **7.1.2 访问Tcl控制台**\n\nVivado内的Tcl控制台是您执行脚本和直接命令的主要界面。您将在此处运行项目生成脚本。\n\n**步骤：**\n\n1. **打开Tcl控制台：**\n   * 在Vivado界面中，导航到菜单栏。\n   * 单击 **Window** > **Tcl Console**。\n   * Tcl控制台窗格通常会出现在Vivado窗口的底部。\n2. **调整控制台大小（可选）：**\n   * 您可以拖动控制台的顶部边框来调整其大小，使其更高以便更好地查看命令和输出。\n3. **清除先前命令（可选但推荐）：**\n   * 如果存在任何先前的命令或消息，您可以在控制台内右键单击并选择“Clear Console”以获得一个干净的开始。\n\n#### **7.1.3 导航到项目目录**\n\n在运行Tcl脚本之前，您必须确保Tcl控制台的当前工作目录已设置为您的板卡特定PCILeech-FPGA项目脚本所在的正确位置。\n\n**对于Squirrel DMA (Artix-7 35T) 或类似板卡：**\n\n**典型路径（克隆**​**​`pcileech-fpga`​**​**并导航到您的板卡变体后）：**\n\n```\nC:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel-35t/  # 在Windows上\n~/Projects/pcileech-fpga/pcileech-squirrel-35t/  # 在Linux/macOS上\n```\n\n*注意：将*​ *​`<your_board_variant>`​*​*替换为您的板卡子目录的实际名称（例如，*​*​`pcileech-squirrel-35t`​*​ *，*​*​`pcileech-artix-7-50t`​*​ *）。*\n\n**步骤：**\n\n1. **在Tcl控制台中设置工作目录：**\n   * 在Vivado Tcl控制台中，输入`cd`命令，后跟您的板卡项目目录的完整路径。\n   * **示例（Windows）：**\n     ```tcl\n     cd C:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel-35t/\n     ```\n   * **示例（Linux/macOS）：**\n     ```tcl\n     cd ~/Projects/pcileech-fpga/pcileech-squirrel-35t/\n     ```\n   * *自我纠正提示：即使在Windows上，Tcl路径也使用正斜杠（*​ *​`/`​*​ *）。*\n2. **验证目录更改：**\n   * 要确认您处于正确的目录中，请在Tcl控制台中输入`pwd`（打印工作目录）。\n   * 控制台应显示您刚刚设置的完整路径，确认更改。\n\n#### **7.1.4 生成Vivado项目**\n\n运行适用于您的FPGA板卡的相应Tcl脚本将自动化Vivado内部的整个项目设置过程。这包括创建项目、添加所有必要的源文件（HDL、约束）以及配置核心项目设置。\n\n**步骤：**\n\n1. **运行Tcl脚本：**\n   * 输入`source`命令，后跟您的板卡的项​​目生成脚本的名称。PCILeech-FPGA项目通常在主板卡目录中提供这些脚本。\n   * **对于Squirrel (Artix-7 35T)（以及类似的Artix-7板卡）：**\n     ```tcl\n     source vivado_generate_project_squirrel.tcl -notrace\n     ```\n   * **对于Enigma-X1 (Artix-7 75T)：**\n     ```tcl\n     source vivado_generate_project_enigma_x1.tcl -notrace\n     ```\n   * **对于ZDMA (Artix-7 100T)：**\n     ```tcl\n     source vivado_generate_project_100t.tcl -notrace\n     ```\n   * `-notrace`选项可防止每个Tcl命令的详细输出，使控制台更整洁。\n2. **等待脚本完成：**\n   * 脚本将按顺序执行许多命令。此过程可能需要几分钟，具体取决于您的系统性能和项目的复杂性。\n   * 监控Tcl控制台的进度消息。脚本将：\n     * 在当前目录中创建一个新的Vivado项目（`.xpr`文件）。\n     * 添加所有SystemVerilog/Verilog源文件（`.sv`，`.v`）。\n     * 添加Xilinx IP核配置（`.xci`）。\n     * 添加XDC（Xilinx设计约束）文件。\n     * 可能配置各种项目设置。\n   * **处理任何错误**：如果发生任何错误（例如，“文件未找到”、“无效命令”），脚本通常会停止。检查错误消息，纠正底层问题（例如，路径不正确、文件丢失），然后重新运行脚本。\n3. **确认项目生成：**\n   * 成功完成后，Tcl控制台通常会指示项目已创建，并且您应该在项目目录中看到新生成的项目文件（例如，`pcileech_squirrel_top.xpr`）和相关目录（例如，`pcileech_squirrel_top.runs`，`pcileech_squirrel_top.ip`）。\n\n#### **7.1.5 打开生成的项目**\n\n现在Vivado项目文件已成功由Tcl脚本生成，您可以在Vivado GUI中打开该项目以进行进一步检查和定制。\n\n**步骤：**\n\n1. **打开项目：**\n   * 在Vivado中，点击 **文件** > **打开项目**。\n   * 导航到您的项目目录（与您在第7.1.3节中在Tcl控制台中设置的目录相同）。\n2. **选择项目文件：**\n   * 找到并选择与您的板卡对应的Vivado项目文件（`.xpr`扩展名）。\n   * **对于Squirrel：**  文件名通常为 `pcileech_squirrel_top.xpr`。\n   * 点击 `.xpr` 文件以选择它。\n3. **点击打开：**\n   * Vivado将加载项目，显示设计层次结构、源文件、IP集成器块设计（如果使用）和各种设计视图。这可能需要一些时间。\n4. **验证项目内容：**\n   * 在 **项目管理器** 窗口（通常在左侧）中，展开 **源文件** 窗格。\n   * 确保所有预期的源文件（Verilog/SystemVerilog、XDC、IP核）都已列出，并且设计层次结构看起来正确。\n   * 检查 **消息** 窗格（底部）中打开项目时出现的任何警告或严重警告，因为这些可能表明潜在问题。\n\n### **7.2 修改IP核**\n\nPCIe IP核是设备PCIe接口的核心。它是一个经过Xilinx（AMD）预验证、可配置的模块，用于处理复杂的PCIe协议层。尽管某些配置空间值在SystemVerilog文件中处理（第6.1节），但其他核心PCIe参数，特别是与链路能力和BAR结构相关的参数，是在Vivado中直接通过PCIe IP核的定制设置进行配置的。定制IP核可确保您的FPGA在PCIe协议级别上与捐赠硬件的行为完全一致。\n\n#### **7.2.1 访问PCIe IP核**\n\nPCIe IP核在您的Vivado项目中被实例化为一个IP块。您需要打开其定制GUI来修改其参数。\n\n**步骤：**\n\n1. **定位PCIe IP核：**\n   * 在 **Sources**（源文件）窗格（位于 **Project Manager**（项目管理器）窗口内）中，确保已选择 **Hierarchy**（层次结构）选项卡。\n   * 展开设计层次结构，直到找到PCIe IP核的实例。\n   * 对于7系列FPGA（如Squirrel中使用的Artix-7），它通常被命名为 `pcie_7x_0.xci` 或类似名称，通常位于项目源文件的 `ip` 子目录中。\n2. **打开IP定制窗口：**\n   * **右键单击** `pcie_7x_0.xci` 文件。\n   * 从上下文菜单中选择 **Customize IP**（定制IP）。\n   * 将打开 **IP Configuration**（IP配置）窗口（或类似名称，如“Customize IP”或“Re-customize IP”），显示带有各种选项卡和选项的图形界面，用于配置PCIe核。\n3. **等待IP设置加载：**\n   * IP定制界面可能需要几分钟才能初始化并填充所有设置。在您开始进行更改之前，请确保所有选项和选项卡都已完全加载并响应。\n\n#### **7.2.2 在IP核内部定制设备ID和BAR**\n\n尽管某些设备标识符在`pcileech_pcie_cfg_a7.sv`中设置，但PCIe IP核本身也包含设备ID、厂商ID以及至关重要的基地址寄存器（BARs）的定义参数。您必须确保这些参数保持一致。`.sv`文件中的某些值可能会覆盖或输入到IP核中，但在此处也确保一致性是一个好习惯。IP核中的BAR设置尤其重要，因为它们决定了内存映射的硬件实现。\n\n**步骤：**\n\n1. **导航到基本/识别参数：**\n   * 在IP定制窗口中，查找与 **基本**、**设备和厂商标识符**、**通用** 或 **PCIe能力** 相关的选项卡或部分。这是定义基本ID和初始链路设置的地方。\n2. **验证/输入设备ID、厂商ID、子系统ID、修订ID、类别代码：**\n   * **至关重要：请确认这些值与您在**​**​`pcileech_pcie_cfg_a7.sv`​**​**中设置的以及从捐赠设备中获取的值相匹配。**\n   * 查找以下字段：\n     * **设备ID**：输入`0xXXXX`（例如，`0x1234`）。\n     * **厂商ID**：输入`0xYYYY`（例如，`0xABCD`）。\n     * **子系统ID**：输入`0xZZZZ`（例如，`0x5678`）。\n     * **子系统厂商ID**：输入`0xWWWW`（例如，`0x9ABC`）。\n     * **修订ID**：输入`0xRR`（例如，`0x01`）。\n     * **类别代码**：输入`0xCCCCCC`（例如，`0x020000`）。\n   * **重要提示**：某些IP核版本或特定配置可能会直接从用户逻辑（如`pcileech_pcie_cfg_a7.sv`）拉取这些值，或者可能允许直接在此处设置它们。最可靠的方法是，如果IP GUI中提供此选项，则在两个位置都保持一致设置。\n3. **导航到基地址寄存器（BARs）选项卡：**\n   * 在IP定制窗口中，找到并选择 **BARs** 选项卡或部分。这是您定义PCIe设备暴露的内存区域的地方。\n4. **配置每个BAR：**\n   * 对于您的捐赠设备使用的每个BAR（BAR0到BAR5），根据您使用Arbor提取的信息，仔细配置以下参数：\n     * **启用BAR**：仅当捐赠设备使用此特定BAR时才选中此框。禁用（取消选中）捐赠设备不使用的任何BAR。\n     * **BAR大小**：从下拉列表中选择精确的大小（例如，**256 MB**，**64 KB**，**4 KB**）。这对于主机操作系统分配正确数量的内存至关重要。\n     * **BAR类型**：选择适当的类型：\n       * **Memory (32-bit Addressing)** （内存（32位寻址））: 用于32位地址可访问的内存映射区域。\n       * **Memory (64-bit Addressing)** （内存（64位寻址））: 用于可以驻留在64位地址空间中任何位置的内存映射区域（对于大内存区域或如果捐赠设备使用它，则需要）。\n       * **I/O**: 用于传统I/O端口区域（在现代PCIe中较不常见，但仍然可能）。\n     * **可预取**：如果捐赠设备的BAR被标记为可预取，则选中此框。此属性允许主机系统从此区域缓存或预取数据以提高性能。\n   * **示例配置（基于您的捐赠设备）：**\n     * **BAR0**：\n       * 启用：是\n       * 大小：**256 MB**\n       * 类型：**Memory (64-bit Addressing)**\n       * 可预取：是\n     * **BAR1**：\n       * 启用：否（如果捐赠设备不使用BAR1）\n     * *继续配置BAR2-BAR5，镜像捐赠设备的配置。*\n5. **确保对齐和非重叠空间**：\n   * Vivado IP核通常会根据您选择的大小自动处理对齐。但是，请注意PCIe规范要求BAR大小是2的幂，并且BAR必须对其大小进行对齐。\n   * 确保所有活动BAR映射的总内存不超过FPGA可用的块RAM（BRAM）或外部内存容量。\n\n#### **7.2.3 完成IP定制**\n\n在IP核定制窗口中配置所有必要的设置后，您必须应用这些更改，使其在Vivado项目中生效。\n\n**步骤：**\n\n1. **审查所有设置：**\n   * 在应用之前，花点时间快速最后一次审查IP定制窗口中的每个选项卡。\n   * 确认所有条目都与您捐赠设备的文档规范精确匹配。这里的一个小错误可能导致设备检测或功能问题。\n2. **应用更改：**\n   * 点击IP定制窗口底部的 **OK** 或 **Generate** 按钮（标签可能不同）。\n   * 如果Vivado提示您确认是否继续更改并重新生成IP输出产品，请点击 **Yes** 确认。\n3. **重新生成IP核：**\n   * Vivado现在将重新生成IP核的输出产品（例如，网表、仿真模型、新的`.xci`配置文件），以反映您的新配置。\n   * 监控 **消息** 窗格（Vivado窗口底部），查看在此重新生成过程中可能出现的任何错误、警告或严重警告。立即解决任何严重警告。\n4. **更新项目中的IP：**\n   * 在IP核重新生成后，Vivado可能会自动更新或提示您更新项目中的任何IP依赖项。允许它这样做，以确保在整个设计中使用最新的配置。\n\n#### **7.2.4 锁定IP核**\n\n锁定IP核是Vivado中推荐的最佳实践，可防止在后续综合和实现运行期间意外修改或重新定制，这可能会潜在地恢复您精心配置的设置。\n\n**锁定的目的：**\n\n* **防止覆盖：**  确保您在IP核GUI中进行的手动配置得以保留，不会因Vivado自动化或IP因细微项目更改而被检测为“过时”而意外覆盖。\n* **保持一致性：**  在整个构建过程中保持IP核处于已知、稳定的状态，这对于PCIe接口等关键组件尤其重要。\n\n**步骤：**\n\n1. **打开Tcl控制台：**\n   * 在Vivado中，如果Tcl控制台尚未打开，请转到 **Window** > **Tcl Console**。\n2. **执行锁定命令：**\n   * 在Tcl控制台中，精确输入以下命令。此命令将PCIe IP核实例（`pcie_7x_0`）的`IP_LOCKED`属性设置为`true`。\n\n   ```tcl\n   set_property -name {IP_LOCKED} -value true -objects [get_ips pcie_7x_0]\n   ```\n\n   * 按 **Enter** 执行命令。\n3. **验证锁定：**\n   * 检查 **消息** 窗格。您应该会看到一条确认属性已设置的消息。\n   * 您还可以右键单击源文件窗格中的 `pcie_7x_0.xci`，选择“IP Properties”（IP属性），并验证 `IP_LOCKED` 是否设置为 `true`。您可能还会注意到“Customize IP”（定制IP）选项现在已灰显，或者只允许“Re-customize IP”（重新定制IP），然后会警告您关于锁定。\n4. **解锁（如果需要）：**\n   * 如果您将来需要对PCIe IP核的设置进行进一步修改，则必须先将其解锁。使用以下Tcl命令：\n\n   ```tcl\n   set_property -name {IP_LOCKED} -value false -objects [get_ips pcie_7x_0]\n   ```\n\n   * 请记住在进行和应用更改后重新锁定它。\n5. **记录操作：**\n   * 在您的项目文档（例如，README文件、项目说明）中注明PCIe IP核已锁定是一个好习惯。这有助于项目中其他人理解其配置状态并避免混淆。\n\n---\n\n## **第二部分：中级概念与实现**\n\n---\n\n## **8. 高级固件定制**\n\n为了实现对捐赠设备精确且令人信服的仿真，除了基本识别之外，还需要对FPGA固件进行更深入的定制。这包括调整PCIe参数（例如链路速度和事务大小），细致地调整基地址寄存器（BARs）及其相关的内存映射，以及准确仿真电源管理和中断机制。这些步骤确保仿真设备不仅在主机系统看来与原始硬件相同，而且在协议和功能级别上行为也完全一致。\n\n### **8.1 配置PCIe参数以进行仿真**\n\n精确仿真要求您的FPGA设备的PCIe操作参数经过细致配置，以匹配捐赠设备的参数。这包括PCIe链路速度、链路宽度、能力指针和最大有效载荷大小等设置。正确的配置可确保与主机系统的兼容性、驱动程序和应用程序与设备交互的正确操作以及数据传输的最佳性能。\n\n#### **8.1.1 匹配PCIe链路速度和宽度**\n\nPCIe链路速度（例如，Gen1、Gen2、Gen3）和链路宽度（例如，x1、x4、x8）是决定设备最大理论数据吞吐量和性能的关键参数。将这些设置与捐赠设备匹配对于精确仿真至关重要，因为驱动程序或系统组件可能期望特定的链路能力。\n\n**步骤：**\n\n1. **访问PCIe IP核设置：**\n\n   * **打开您的Vivado项目：**  启动Vivado并打开您之前创建或修改的项目（例如，`pcileech_squirrel_top.xpr`）。确保所有源文件都已正确添加到项目中。\n   * **定位PCIe IP核：**  在 **Sources**（源文件）窗格（通常在左侧）中，展开设计层次结构以找到PCIe IP核实例。对于Xilinx 7系列设计（如Squirrel中使用的Artix-7），这通常被命名为 `pcie_7x_0.xci`。\n   * **定制IP核：**  右键单击 `pcie_7x_0.xci` 并选择 **Customize IP**（定制IP）。IP定制窗口将打开，显示多个选项卡中的各种配置选项。\n2. **设置最大链路速度：**\n\n   * **导航到链路参数：**  在IP定制窗口中，点击 **PCIe Capabilities**（PCIe功能）选项卡（有时是“PCIe Configuration”或“General”）。在此选项卡内，查找与 **Link Parameters**（链路参数）或 **Link Capability Register**（链路能力寄存器）相关的部分。\n   * **配置最大链路速度：**  找到标有 **Maximum Link Speed**（最大链路速度）的选项（或“Target Link Speed”）。\n   * 将其设置为与您的捐赠设备支持和广告的最大链路速度相匹配。\n     * **示例：**\n       * 如果捐赠设备在 **PCIe Gen2 (5.0 GT/s)**  下运行，选择 **5.0 GT/s**。\n       * 如果它在 **PCIe Gen1 (2.5 GT/s)**  或 **PCIe Gen3 (8.0 GT/s)**  下运行，请选择相应的选项。\n   * **注意**：确保您的FPGA的收发器和物理硬件（主板PCIe插槽）支持所选的链路速度。FPGA只会协商到其配置的最大速度。\n3. **设置链路宽度：**\n\n   * **配置链路宽度：**  在相同的 **Link Parameters**（链路参数）部分中，找到 **Link Width**（链路宽度）设置（或“PCIe Link Width”、“Target Link Width”）。\n   * 将其设置为与您的捐赠设备广告的最大链路宽度相匹配。\n     * **示例：**\n       * 如果捐赠设备使用 **x4** 链路，将 **Link Width** 设置为 **4**。\n       * 选项通常包括 **1**、**2**、**4**、**8**、**16** 通道。\n   * **注意**：物理PCIe插槽和FPGA的封装必须支持所选的链路宽度。尝试配置大于物理连接的宽度将导致链路协商问题。\n4. **保存并重新生成：**\n\n   * **应用更改：**  配置链路速度和宽度后，点击 **OK** 以在IP定制窗口中应用更改。\n   * **重新生成IP输出产品：**  Vivado很可能会提示您由于所做的更改而重新生成IP核的输出产品。确认并允许重新生成过程完成。这可能需要一些时间。\n   * **验证设置：**  一旦重新生成完成，您可以选择性地重新访问IP核设置，以确保配置已正确应用。检查Vivado中 **Messages**（消息）窗口中是否有任何警告或错误。\n\n#### **8.1.2 设置能力指针**\n\nPCIe配置空间中的能力指针是8位寄存器，它们形成一个链表，指向各种能力结构（例如，电源管理、MSI/MSI-X、PCIe Express能力）。正确设置这些指针可确保主机系统能够遍历能力列表并定位和利用设备广告的功能。\n\n**步骤：**\n\n1. **在固件中定位能力指针：**\n\n   * **打开配置文件：**  在Visual Studio Code中，打开您的板卡的主配置文件，通常是`pcileech_pcie_cfg_a7.sv`，位于`pcileech-fpga/<your_board_variant>/src/pcileech_pcie_cfg_a7.sv`。\n   * **理解能力指针：**  此文件中的能力指针（`cfg_cap_pointer`）指向PCIe配置空间中的*第一个*能力结构，通常从标准64字节配置头之后开始。后续的能力通过其“下一个能力指针”字段链接起来。\n2. **设置能力指针值：**\n\n   * **找到**​**​`cfg_cap_pointer`​**​**的赋值：**  在代码中搜索定义`cfg_cap_pointer`的行。\n     ```verilog\n     reg [7:0] cfg_cap_pointer = 8'hXX; // 当前值（例如，默认的8'h40）\n     ```\n   * **更新能力指针：**  将`XX`替换为您使用Arbor从捐赠设备观察到的8位十六进制能力指针值。此值通常指向设备特定配置空间（通常在偏移量`0x3F`结束）之后第一个能力结构的偏移量。能力常见的起始点是`0x40`或`0x60`。\n     * **示例：**\n       * 如果捐赠设备的第一个能力指针是`0x60`（表示其第一个能力结构在配置空间中从偏移量`0x60`开始），将该行更新为：\n         ```verilog\n         reg [7:0] cfg_cap_pointer = 8'h60; // 更新以匹配捐赠设备的第一个能力偏移量\n         ```\n   * **确保正确对齐：**  能力结构必须对齐到4字节边界。能力指针应始终指向配置空间中有效的4字节对齐偏移量。\n3. **保存更改：**\n\n   * **保存配置文件：**  进行更改后，点击 **文件 &gt; 保存** 或按下 `Ctrl + S` 保存文件。\n   * **验证语法：**  确保更改未引入任何语法错误（VS Code通常会高亮显示这些错误）。\n   * **添加注释以清晰说明：**  添加注释解释更改，以便将来参考和维护。\n     ```verilog\n     reg [7:0] cfg_cap_pointer = 8'h60; // 设置为捐赠设备的能力指针（例如，PCIe能力位于0x60）\n     ```\n\n#### **8.1.3 调整最大载荷和读取请求大小**\n\n这些参数定义了单个PCIe事务层数据包（TLP）中可以传输的最大数据量，以及非posted内存读取请求TLP的最大大小。将这些设置与捐赠设备匹配可确保兼容性并优化数据传输操作的性能。不匹配可能导致吞吐量降低或通信错误。\n\n**步骤：**\n\n1. **设置支持的最大载荷大小（IP核）：**\n\n   * **访问设备功能：**  在PCIe IP核定制窗口（Vivado中的`pcie_7x_0.xci`）中，导航到 **PCIe Capabilities**（PCIe功能）选项卡。\n   * **配置支持的最大载荷大小：**  找到标有 **Max Payload Size Supported**（支持的最大载荷大小）的设置（或类似名称）。\n   * 将其设置为与您的捐赠设备支持和广告的值相匹配（例如，128字节、256字节、512字节、1024字节、2048字节、4096字节）。\n     * **示例：**  如果捐赠设备支持的最大载荷大小为 **256字节**，请从下拉列表中选择 **256字节**。\n2. **设置支持的最大读取请求大小（IP核）：**\n\n   * **配置支持的最大读取请求大小：**  在同一选项卡中，找到 **Max Read Request Size Supported**（支持的最大读取请求大小）设置。\n   * 将其设置为与捐赠设备的能力相匹配。这指定了设备在单个读取事务中可以请求的最大数据量。\n     * **示例：**  如果捐赠设备支持的最大读取请求大小为 **512字节**，请选择 **512字节**。\n3. **调整固件参数（匹配IP核）：**\n\n   * **打开 **​**​`pcileech_pcie_cfg_a7.sv`​**​ **：**  确保配置文件在Visual Studio Code中打开。\n   * **更新固件常量：**  找到定义`max_payload_size_supported`和`max_read_request_size_supported`的行。这些通常是与您在IP核中选择的字节大小对应的位编码值。\n     ```verilog\n     reg [2:0] max_payload_size_supported = 3'bZZZ;   // 当前值\n     reg [2:0] max_read_request_size_supported = 3'bWWW; // 当前值\n     ```\n   * **设置适当的值：**  将`ZZZ`和`WWW`替换为与所选大小对应的3位二进制表示。\n     * **映射（根据PCIe规范）：**\n       * **128字节**：`3'b000`\n       * **256字节**：`3'b001`\n       * **512字节**：`3'b010`\n       * **1024字节**：`3'b011`\n       * **2048字节**：`3'b100`\n       * **4096字节**：`3'b101`\n     * **示例：**\n       * 对于 **256字节** 载荷大小：\n         ```verilog\n         reg [2:0] max_payload_size_supported = 3'b001; // 支持最大256字节 (0x100)\n         ```\n       * 对于 **512字节** 读取请求大小：\n         ```verilog\n         reg [2:0] max_read_request_size_supported = 3'b010; // 支持最大512字节 (0x200)\n         ```\n   * **原因**：这些固件参数通常决定了与PCIe核接口的用户逻辑的行为，确保您的逻辑遵循配置的最大值。\n4. **保存更改：**\n\n   * **保存文件：**  更新`pcileech_pcie_cfg_a7.sv`中的值后，保存文件。\n   * **验证一致性：**  Vivado PCIe IP核GUI中配置的值*必须*与您的HDL配置文件中设置的值*匹配*。任何不匹配都可能导致意外行为或链路训练问题。\n   * **添加注释：**  在您的代码中清晰地记录这些更改，以便将来参考。\n\n### **8.2 调整BARs和内存映射**\n\n基地址寄存器（BARs）是PCIe设备向主机系统公开其内部内存和寄存器的基本方式。正确配置BARs并在FPGA的BRAMs（块RAMs）和逻辑中定义它们的内存映射对于精确仿真和主机端设备驱动程序的正常运行至关重要。\n\n#### **8.2.1 设置BAR大小和类型（IP核和BRAM）**\n\n配置BAR大小和类型可确保您的仿真设备在枚举期间向主机请求正确的地址空间量，并且主机适当地分配和映射这些区域。这还涉及将这些地址区域与FPGA内的物理内存块关联起来。\n\n**步骤：**\n\n1. **访问BAR配置（PCIe IP核）：**\n\n   * **定制PCIe IP核：**  在Vivado中，右键单击 `pcie_7x_0.xci` 并选择 **Customize IP**（定制IP）以打开其配置GUI。\n   * **导航到BARs选项卡：**  在IP定制窗口中，点击 **Base Address Registers (BARs)** （基地址寄存器（BARs））选项卡。\n2. **配置每个BAR（IP核）：**\n\n   * **匹配捐赠设备的BARs：**  对于每个BAR（BAR0到BAR5），根据您使用Arbor从捐赠设备中提取的信息，细致地设置大小、类型和可预取状态。\n   * **启用/禁用BARs：**  确保只启用捐赠设备实际使用的BARs。禁用（取消选中）任何未使用的BARs。\n   * **设置BAR大小：**  为每个*已启用*的BAR从下拉列表中选择适当的大小。这将是2的幂次（例如，4KB、8KB、64KB、1MB、256MB、1GB）。\n     * **示例：**\n       * 如果 **BAR0** 是 **64 KB**，将 **BAR0 Size** 设置为 **64 KB**。\n       * 如果 **BAR1** 是 **128 MB**，将 **BAR1 Size** 设置为 **128 MB**。\n   * **设置BAR类型：**\n     * 如果BAR是内存映射的，选择 **Memory (32-bit Addressing)** （内存（32位寻址））或 **Memory (64-bit Addressing)** （内存（64位寻址））。如果捐赠设备的BAR是64位或您需要访问4GB以上的地址，请选择 **64-bit Addressing**。\n     * 如果BAR用于I/O端口空间（现代PCIe设备较少见），选择 **I/O**。\n   * **设置可预取状态**：如果捐赠设备的BAR被识别为可预取，请选中“Prefetchable”（可预取）框。此位允许主机预取该区域的数据，可能提高性能。\n3. **更新BRAM配置（如果适用）：**\n\n   * 许多PCILeech-FPGA项目使用Xilinx块RAM（BRAM）IP核来表示BARs暴露的内存区域。这些BRAM提供仿真设备内存的物理存储。\n   * **定位BRAM IP核：**  在您的Vivado项目 **Sources**（源文件）窗格中，在`ip`子目录（或类似目录）中，您可能会找到BRAM的`.xci`文件，名称可能类似：\n     ```\n     pcileech-fpga/<your_board_variant>/ip/bram_bar_zero4k.xci\n     pcileech-fpga/<your_board_variant>/ip/bram_pcie_cfgspace.xci\n     # 可能还有BAR1、BAR2等的其他文件\n     ```\n   * **修改BRAM大小：**  对于与*已启用*BAR关联的每个BRAM IP核，您可能需要 **Customize IP**（定制IP）（右键单击`.xci`文件）并调整其内存大小配置，以精确匹配相应的BAR大小。\n     * **示例：**  如果BAR0是256MB，请确保连接到BAR0的BRAM大小为256MB。\n     * **注意**：确保所有活动BAR所需的总内存不超过您的FPGA设备的物理BRAM容量。超出容量将导致实现失败。\n4. **保存并重新生成：**\n\n   * **应用更改（IP核）：**  在PCIe IP核中配置BAR后，点击IP定制窗口中的 **OK**。\n   * **重新生成IP核：**  Vivado将提示您由于所做的更改而重新生成PCIe IP核和任何相关的BRAM IP核。允许重新生成完成。这可确保硬件网表反映您的新BAR定义。\n   * **检查错误：**  检查 **Messages**（消息）窗口中是否有与BAR配置或BRAM实例化相关的任何警告或错误。\n\n#### **8.2.2 在固件中定义BAR地址空间**\n\n尽管PCIe IP核配置了BAR的*硬件*方面，但您的定制固件（SystemVerilog代码）需要定义当主机CPU对这些BAR区域内的地址执行读写操作时，仿真设备如何响应的*逻辑*。这涉及地址解码和实现寄存器/内存访问逻辑。\n\n**步骤：**\n\n1. **打开BAR控制器文件：**\n\n   * 在Visual Studio Code中，打开负责处理BAR访问的SystemVerilog文件。对于PCILeech-FPGA，这通常是：\n     ```\n     pcileech-fpga/<your_board_variant>/src/pcileech_tlps128_bar_controller.sv\n     ```\n\n     此模块通常接收PCIe内存读/写TLP，并解码地址以确定正在访问哪个BAR（以及该BAR内的哪个偏移量）。\n2. **实现地址解码逻辑：**\n\n   * 在`pcileech_tlps128_bar_controller.sv`模块中，您会找到确定传入事务目标是哪个BAR的逻辑。这通常涉及根据配置的BAR大小检查地址位。\n   * 您需要定义传入地址`req_addr`（来自TLP）如何映射到您的特定BAR内的偏移量。\n   * **概念示例：**\n     ```verilog\n     // 示例：BAR0的逻辑（假设它是一个256MB的64位内存BAR，用于寄存器/数据）\n     // 'bar_hit[0]'是一个指示命中BAR0的输入信号，通常来自PCIe核。\n     // 'req_addr'是传入的PCIe地址。\n     // 'req_be'是来自TLP的字节使能。\n     // 'req_data'是传入的写入数据。\n     // 'rsp_data'是传出的读取数据。\n\n     // 假设BAR0是256MB (2^28字节)，地址位 [27:0] 在BAR范围内。\n     localparam BAR0_SIZE_BITS = 28; // 2^28 = 256MB\n\n     reg [31:0] internal_register_0; // BAR0内的示例寄存器\n     reg [31:0] internal_register_1; // 另一个示例寄存器\n\n     assign bar0_offset = req_addr[BAR0_SIZE_BITS-1:0]; // 提取BAR0内的偏移量\n\n     always_comb begin\n         // 默认响应\n         rsp_data = 32'hFFFFFFFF; // 默认值为全F或类似值，表示未映射区域\n\n         if (bar_hit[0]) begin // 如果事务目标是BAR0\n             if (req_write) begin // 这是写入操作\n                 case (bar0_offset)\n                     // 示例：将偏移量0x0映射到internal_register_0\n                     32'h0000_0000: begin\n                         if (req_be[3]) internal_register_0[31:24] = req_data[31:24];\n                         if (req_be[2]) internal_register_0[23:16] = req_data[23:16];\n                         if (req_be[1]) internal_register_0[15:8]  = req_data[15:8];\n                         if (req_be[0]) internal_register_0[7:0]   = req_data[7:0];\n                     end\n                     // 示例：将偏移量0x4映射到internal_register_1\n                     32'h0000_0004: begin\n                         if (req_be[3]) internal_register_1[31:24] = req_data[31:24];\n                         if (req_be[2]) internal_register_1[23:16] = req_data[23:16];\n                         if (req_be[1]) internal_register_1[15:8]  = req_data[15:8];\n                         if (req_be[0]) internal_register_1[7:0]   = req_data[7:0];\n                     end\n                     // 添加更多寄存器映射或内存访问（例如，BRAM访问）\n                     default: begin\n                         // 处理BAR0内未映射的写入，例如，忽略或记录\n                     end\n                 endcase\n             end else if (req_read) begin // 这是读取操作\n                 case (bar0_offset)\n                     // 示例：从internal_register_0读取\n                     32'h0000_0000: rsp_data = internal_register_0;\n                     // 示例：从internal_register_1读取\n                     32'h0000_0004: rsp_data = internal_register_1;\n                     // 添加更多寄存器映射或内存访问（例如，BRAM访问）\n                     default: begin\n                         rsp_data = 32'h0; // 对于未映射的读取返回0或特定错误值\n                     end\n                 endcase\n             end\n         end\n     end\n     ```\n   * **处理数据传输：**  `always_comb`块（或`always_ff`用于时序逻辑）应定义如何为读取生成`rsp_data`，以及如何根据`bar0_offset`和字节使能（`req_be`）更新内部寄存器/内存。\n3. **实现BRAM访问（如果BAR映射到BRAM）：**\n\n   * 如果BAR映射到大块内存（例如，256MB），您通常会实例化一个BRAM IP核（如8.2.1所述）并将其`bar_controller`逻辑与它连接。`bar_controller`将向BRAM提供地址和控制信号。\n   * **概念性BRAM集成（简化）：**\n     ```verilog\n     // 在pcileech_tlps128_bar_controller.sv或子模块中\n     // BRAM接口\n     wire [BAR0_SIZE_BITS-1:0] bram_addr;\n     wire [31:0] bram_wr_data;\n     wire [3:0] bram_wr_en; // BRAM的字节使能\n     wire bram_wr_ce;\n     wire bram_rd_ce;\n     wire [31:0] bram_rd_data;\n\n     // 将TLP信号映射到BRAM接口\n     assign bram_addr = bar0_offset;\n     assign bram_wr_data = req_data;\n     assign bram_wr_en = req_be;\n     assign bram_wr_ce = bar_hit[0] && req_write;\n     assign bram_rd_ce = bar_hit[0] && req_read;\n\n     // 实例化BRAM IP核\n     bram_bar_zero bram_inst ( // 假设'bram_bar_zero'是您的BRAM IP模块\n         .clka(clk),\n         .ena(1'b1),\n         .wea(bram_wr_en),\n         .addra(bram_addr),\n         .dina(bram_wr_data),\n         .douta(bram_rd_data)\n     );\n\n     // 对于从BAR0的读取，输出BRAM的数据\n     if (bar_hit[0] && req_read) begin\n         rsp_data = bram_rd_data;\n     end\n     ```\n4. **保存更改：**\n\n   * 实现每个BAR的逻辑后，保存`pcileech_tlps128_bar_controller.sv`文件。\n   * **验证功能：**  此逻辑很复杂。彻底的仿真（使用测试平台）和后续的硬件测试对于确保正确行为至关重要。\n\n#### **8.2.3 处理多个BAR**\n\n正确管理多个BAR对于暴露多个独立内存或I/O区域的设备至关重要。`bar_controller`模块通常处理所有BAR。\n\n**步骤：**\n\n1. **实现每个BAR的逻辑：**\n\n   * 在`pcileech_tlps128_bar_controller.sv`内部，扩展逻辑以处理您的捐赠设备使用的所有已启用BAR（BAR0、BAR1、BAR2等）。\n   * **独立逻辑块：**  为清晰和可维护性，创建独立的`if/else if`块或`case`语句，根据哪个`bar_hit`信号被断言而激活。\n     ```verilog\n     // BAR0处理\n     if (bar_hit[0]) begin\n         // BAR0特定读/写逻辑，用于其寄存器/内存\n     end else if (bar_hit[1]) begin\n         // BAR1特定读/写逻辑，用于其寄存器/内存\n     end else if (bar_hit[2]) begin\n         // BAR2特定逻辑\n     end\n     // ... 继续其他BAR\n     ```\n   * **定义寄存器和内存：**  根据需要为每个BAR分配独立的寄存器集或连接不同的BRAM实例。\n2. **确保非重叠地址空间：**\n\n   * 虽然PCIe IP核处理与主机操作系统的每个BAR的不同地址空间的协商，但您的内部固件逻辑*必须*假定这些空间是独立的且不重叠的。\n   * **验证地址范围**：仔细检查PCIe IP核中的BAR大小配置，以确保它们是独立的，并且根据PCIe规范正确地对齐到2的幂次方边界。\n   * **更新地址解码**：您的`bar_controller`逻辑依赖于PCIe IP核生成的`bar_hit`信号。确保这些信号被正确解释并导致每个BAR的独特处理逻辑。\n3. **测试BAR访问：**\n\n   * **仿真测试：**  在硬件部署之前，使用仿真工具（例如Vivado仿真器）和全面的测试平台来验证对每个BAR的所有读写操作。\n     * 向每个BAR内的特定偏移量发送内存写入TLP。\n     * 向每个BAR内的特定偏移量发送内存读取TLP并验证返回的数据。\n   * **硬件测试：**  编程FPGA后，使用主机端软件工具（如PCILeech客户端软件或定制C/Python脚本）访问和验证每个BAR。\n     * **Linux**：使用`lspci -vvv`检查BAR映射（`Memory at XXXX (64-bit, prefetchable) [size=YYYY]`）。然后可以使用`devmem2`或自定义内核模块来读/写这些映射地址。\n     * **Windows**：使用“RW-Everything”等工具或自定义用户模式应用程序来检查和与映射的内存区域交互。\n     * 执行各种读/写模式以确保所有BAR之间的数据完整性和正确寻址。\n\n---\n\n### **8.3 仿真设备电源管理和中断**\n\n实现电源管理功能和中断对于需要与主机操作系统的电源管理和中断处理机制密切高效交互的设备至关重要。没有这些，仿真设备可能无法完全正常工作，或者性能可能不理想。\n\n#### **8.3.1 电源管理配置**\n\n实现电源管理允许仿真设备支持各种电源状态（例如D0、D3hot），有助于系统范围的电源效率并符合操作系统的预期。主机操作系统将查询设备的功能并发送命令以在这些状态之间转换。\n\n**步骤：**\n\n1. **在PCIe IP核中启用电源管理：**\n\n   * **访问功能：**  在PCIe IP核定制窗口（`pcie_7x_0.xci`）中，导航到 **PCIe Capabilities**（PCIe功能）选项卡。\n   * **启用电源管理：**  查找与 **Power Management Capability**（电源管理功能）相关的部分或选项。确保已选中或启用此选项，以便在设备的配置空间中包含电源管理（PM）功能结构。\n2. **设置支持的电源状态：**\n\n   * **配置支持的状态：**  在IP核的电源管理功能部分，指定设备支持的电源状态。这些通常是复选框或下拉菜单。将这些设置与您通过Arbor观察到的捐赠设备的能力相匹配。\n     * **D0（完全开启/运行）** ：始终支持。\n     * **D1、D2（中间状态）** ：可选，用于低功耗空闲状态。\n     * **D3hot（断电，辅助电源存在）** ：设备逻辑关闭，但可以响应PM事件。\n     * **D3cold（完全断电）** ：设备没有电源。\n   * **示例**：如果捐赠设备仅支持D0和D3hot，则只启用它们。\n3. **在固件中实现电源状态逻辑：**\n\n   * **打开 **​**​`pcileech_pcie_cfg_a7.sv`​**​ **（或相关控制模块）：**  您通常需要修改固件以反映并可能响应主机命令的电源状态转换。PCIe核本身处理大部分协议，但您的用户逻辑需要知道当前状态。\n   * **处理电源管理控制和状态寄存器（PMCSR）写入：**  主机操作系统通过写入PMCSR中的特定位来改变设备的电源状态，PMCSR是PM能力结构的一部分。您的固件理想情况下应有逻辑来读取这些位并调整设备行为（例如，暂停/恢复操作，启用/禁用时钟）。\n     ```verilog\n     // 示例：pcileech_pcie_cfg_a7.sv或专用PM模块的一部分\n     // 假设'cfg_write'在配置写入时被断言，'cfg_address'是偏移量，'cfg_writedata'是数据。\n     // D状态位位于PM能力结构中偏移量0x04处，位[1:0]。\n\n     // PMCSR寄存器（内部表示）\n     reg [15:0] pmcsr_reg = 16'h0000; // 初始化为D0\n\n     // 用户逻辑信号，指示当前电源状态\n     reg [1:0] current_d_state = 2'b00; // 00 = D0, 01 = D1, 10 = D2, 11 = D3hot\n\n     always @(posedge clk) begin\n         if (reset) begin\n             pmcsr_reg <= 16'h0000;\n             current_d_state <= 2'b00; // 重置为D0\n         end else begin\n             // 示例：捕获对PMCSR的写入（如果直接在用户逻辑中处理）\n             // 注意：PCIe IP核管理大部分内容，但您的用户逻辑可能需要从中读取值。\n             // 假设PCIe核提供一个反映当前D状态的输出：\n             // assign current_d_state = pcie_core_d_state_output;\n\n             // 如果用户逻辑*需要*写入PMCSR（较少见，通常是只读状态）\n             // 或者它需要处理命令\n             // if (cfg_write && (cfg_address == PM_CAP_OFFSET + 2'h04)) begin // PMCSR在PM Cap基础地址+0x04\n             //     pmcsr_reg[1:0] <= cfg_writedata[1:0]; // 捕获新D状态\n             //     // current_d_state <= cfg_writedata[1:0]; // 更新内部状态\n             // end\n\n             // 在PCILeech中，PCIe核管理PMCSR。您可能会从核读取信号。\n             // 为了演示，假设'pcie_d_state'是来自IP核的输入。\n             current_d_state <= pcie_d_state; // 根据PCIe核的状态更新\n         end\n     end\n\n     // 示例：响应D状态变化的逻辑\n     always @(*) begin\n         if (current_d_state == 2'b11) begin // D3hot状态\n             // 禁用非必要模块的电源，暂停操作，\n             // 断言信号给主DMA逻辑以停止活动。\n             // 例如：dma_engine_enable = 1'b0;\n         end else if (current_d_state == 2'b00) begin // D0状态\n             // 启用全部功能\n             // 例如：dma_engine_enable = 1'b1;\n         end\n     end\n     ```\n   * **管理电源状态效果：**  实现逻辑以根据`current_d_state`更改设备的内部行为（例如，启用/禁用时钟，将子模块置于低功耗模式）。这对于精确的功耗仿真以及确保设备正确响应操作系统命令至关重要。\n4. **保存更改：**\n\n   * 保存任何修改过的固件文件。\n   * 通过仿真或硬件测试（例如，Windows“睡眠”或“休眠”功能，或Linux `poweroff`命令）彻底测试电源管理功能，以查看设备是否正确转换。\n\n#### **8.3.2 MSI/MSI-X配置**\n\n实现消息信号中断（MSI）或其扩展版本（MSI-X）允许仿真设备使用基于消息的中断。这些中断比传统的引脚中断（INTx）效率更高、可扩展性更强，是现代PCIe设备的优选方法。MSI/MSI-X允许设备通过向特定内存地址写入特殊TLP来通知CPU。\n\n**步骤：**\n\n1. **在PCIe IP核中启用MSI/MSI-X：**\n\n   * **访问中断配置：**  在PCIe IP核定制窗口（`pcie_7x_0.xci`）中，导航到 **Interrupts**（中断）选项卡或专门标记为 **MSI/MSI-X Capabilities**（MSI/MSI-X功能）的部分。\n   * **选择中断类型：**  根据捐赠设备的功能，选择 **MSI** 或 **MSI-X**。MSI-X通常因其灵活性（更多向量，每个向量可屏蔽）而受到青睐。\n   * **配置支持的向量数量：**  设置设备将支持的中断向量（消息）数量。这应与捐赠设备匹配。\n     * **MSI** 支持最多32个向量（通常是1、2、4、8、16或32）。\n     * **MSI-X** 支持最多2048个向量，允许更细粒度的中断源。\n   * **启用功能：**  确保MSI或MSI-X功能结构已明确启用，以便包含在设备的配置空间中。这是主机操作系统发现设备中断能力的方式。\n2. **在固件中实现中断逻辑：**\n\n   * **打开 **​**​`pcileech_pcie_tlp_a7.sv`​**​ **（或用户逻辑模块）：**  此文件通常负责用户定义的TLP生成，并且可能是启动MSI/MSI-X消息的合适位置。但是，中断的*触发*将来自您的自定义逻辑。\n   * **定义中断信号：**  声明内部信号，指示何时需要生成中断。\n     ```verilog\n     // 在自定义模块中（例如，'my_device_logic.sv'），该模块与TLP生成逻辑接口\n     reg msi_trigger_signal; // 当发生中断条件时断言此信号\n     ```\n   * **实现中断生成逻辑：**  定义应该触发中断的条件。这通常涉及在仿真设备的逻辑中检测事件。\n     ```verilog\n     // 在'my_device_logic.sv'内部\n     input wire clk;\n     input wire reset;\n     input wire event_data_ready; // 示例：当数据就绪时来自您的逻辑的输入\n\n     always @(posedge clk or posedge reset) begin\n         if (reset) begin\n             msi_trigger_signal <= 1'b0;\n         end else if (event_data_ready) begin // 当特定事件发生时\n             msi_trigger_signal <= 1'b1; // 触发MSI\n         end else begin\n             msi_trigger_signal <= 1'b0; // 一个周期后或被确认后清除\n         end\n     end\n     ```\n   * **连接到PCIe核的MSI接口：**  `msi_trigger_signal`（或您的自定义逻辑的类似输出）需要连接到PCIe IP核的适当输入（例如，如果使用AXI-Stream接口进行MSI TLP，则连接到`s_axis_tdata_tready`、`s_axis_tdata_tvalid`、`s_axis_tdata_tlast`；或者连接到IP核提供的专用MSI请求端口）。然后PCIe核会形成并发送实际的MSI/MSI-X TLP。有关精确的接口详细信息，请查阅Xilinx PCIe IP核文档。\n3. **保存更改：**\n\n   * 实现中断逻辑后，保存所有修改过的固件文件。\n   * **检查时序约束：**  新逻辑，特别是中断路径，可能对时序很敏感。确保综合和实现工具不会报告与您的中断生成逻辑相关的任何时序违规。\n\n#### **8.3.3 实现中断处理逻辑（设备端）**\n\n除了启用功能之外，定义仿真设备何时以及如何生成中断对于其与主机中断处理机制和驱动程序行为的正确交互至关重要。这涉及创建断言中断请求的内部逻辑。\n\n**步骤：**\n\n1. **定义中断条件：**\n\n   * **识别触发事件：**  根据您的捐赠设备的行为，确定哪些特定的内部事件应导致您的仿真设备生成中断。\n     * **示例**：数据传输完成、接收缓冲区中有新数据、内部错误条件、特定命令完成、链路状态更改。\n   * **实现条件逻辑：**  在您的自定义SystemVerilog模块中使用组合逻辑或时序逻辑，精确检测这些事件并生成一个短脉冲或电平信号，指示中断请求。\n2. **创建中断生成模块（模块化设计）：**\n\n   * 将中断生成逻辑封装到一个单独的专用模块中是一个好习惯，这样可以提高清晰度、可重用性并方便调试。此模块将内部事件作为输入，并产生一个连接到PCIe核的`msi_req`（或类似）输出。\n     ```verilog\n     // 文件：interrupt_generator.sv\n     module interrupt_generator (\n         input wire clk,\n         input wire reset,\n         input wire event_trigger,        // 来自您的自定义逻辑的输入信号（例如，data_ready, error_flag）\n         output reg msi_req_o            // 输出：断言此信号以请求MSI/MSI-X\n     );\n\n     // MSI的简单脉冲发生器（一次性中断）\n     reg event_trigger_d1;\n\n     always @(posedge clk or posedge reset) begin\n         if (reset) begin\n             msi_req_o <= 1'b0;\n             event_trigger_d1 <= 1'b0;\n         end else begin\n             event_trigger_d1 <= event_trigger;\n             // 当event_trigger从低到高跳变时，生成一个单周期脉冲\n             if (event_trigger && !event_trigger_d1) begin\n                 msi_req_o <= 1'b1; // 断言MSI请求\n             end else begin\n                 msi_req_o <= 1'b0; // 一个周期后取消断言\n             end\n         end\n     end\n\n     endmodule // interrupt_generator\n     ```\n   * **与主固件集成：**  在您的顶层用户逻辑中（例如，在`pcileech_squirrel_top.sv`或其实例化的模块中）实例化此`interrupt_generator`模块，并将其`msi_req_o`输出连接到PCIe IP核的MSI输入。\n3. **确保正确的时序和序列：**\n\n   * **遵守PCIe规范：**  MSI/MSI-X消息是TLP。确保这些消息的生成符合PCIe TLP格式、流控制和时序要求。PCIe IP核处理大部分内容，但您提供给它的输入信号必须稳定且时序正确。\n   * **管理中断延迟：**  优化您的逻辑，以最大限度地减少内部事件发生与`msi_req_o`信号断言之间的任何不必要延迟。\n4. **测试中断传递：**\n\n   * **仿真：**  使用全面的测试平台模拟应生成中断的场景。验证您的`msi_req_o`信号是否按预期工作，以及PCIe核是否生成正确的MSI/MSI-X TLP。\n   * **硬件测试：**\n     * 用更新的固件编程FPGA。\n     * 使用主机端软件触发应引起中断的事件（例如，启动完成的DMA传输）。\n     * 确认主机操作系统接收到中断。在Linux上，`dmesg`可以显示中断消息。在Windows上，您可以使用特定的驱动程序调试工具或事件查看器。\n     * **调试工具：**  利用Vivado的集成逻辑分析仪（ILA）核（如第12节所述）实时监控`event_trigger`、`msi_req_o`和PCIe核的TLP输出信号，以验证正确的中断生成。\n5. **保存更改：**\n\n   * 完成所有代码修改并保存相关固件文件。\n   * 根据测试结果审查并改进您的中断逻辑，以确保可靠性。\n\n---\n\n## **9. 仿真设备特定功能**\n\n除了标准的PCIe配置空间和通用DMA功能之外，许多捐赠设备还具有独特的功能、自定义寄存器或厂商特定功能，这些对于其完整功能或与其专有驱动程序交互至关重要。精确的仿真需要理解和复制这些细微之处。本节将深入探讨如何实现这些高级功能，从而实现更忠实和功能更全面的仿真。\n\n### **9.1 实现高级PCIe功能**\n\nPCIe规范包含除了基本配置空间之外的各种*扩展功能*。这些功能提供了高级错误报告、电源管理、虚拟化等特性。实现这些功能有助于您的仿真设备显得更合法，并与现代主机系统正确交互。\n\n**步骤：**\n\n1. **识别所需的扩展功能：**\n\n   * 在使用Arbor等工具收集捐赠设备信息时，请仔细查找并记录捐赠设备配置空间中存在的任何扩展功能。这些通常在标准配置空间的初始256字节之外找到。\n   * **常见示例：**\n     * **高级错误报告（AER）** ：为PCIe链路提供强大的错误检测、日志记录和报告机制。\n     * **设备序列号（DSN）** ：（已在第6.2节中介绍）。\n     * **电源管理（PM）** ：（已在第8.3.1节中介绍）。\n     * **PCI Express（PCIe）功能结构**：（已在第8.1节中介绍链路速度/宽度、最大载荷/读取请求，但也包括其他字段，如设备控制/状态、链路控制/状态）。\n     * **虚拟通道（VC）/多功能虚拟通道（MFVC）** ：用于服务质量（QoS）和流量管理。\n     * **精确时间测量（PTM）** ：用于设备之间的时间同步。\n     * **延迟容忍报告（LTR）** ：基于延迟要求进行电源管理。\n     * **可重置FPC（功能级重置）** ：用于更细粒度的重置。\n2. **在Vivado PCIe IP核中启用功能：**\n\n   * 访问Vivado中的PCIe IP核定制窗口（`pcie_7x_0.xci`）。\n   * 导航到各个选项卡（例如，“PCIe Capabilities”、“Extended Capabilities”、“Advanced Options”）。\n   * 查找复选框或下拉菜单，以启用和配置从捐赠设备中识别出的特定扩展功能。\n   * **示例（AER）：**  您会找到一个“高级错误报告”部分，您可以在其中启用它并配置其寄存器（例如，严重性掩码）。\n   * **注意：**  Xilinx PCIe IP核为许多标准和扩展功能提供了高度可配置性。通常只需在GUI中启用正确的选项即可。\n3. **实现功能寄存器的固件逻辑（如果需要）：**\n\n   * 虽然PCIe IP核处理这些功能的*存在*和大部分*协议*，但某些功能会暴露您的自定义固件可能需要读写或其值需要固件响应的寄存器。\n   * **示例（AER）：**  如果您的仿真设备检测到应通过AER报告的内部错误，您的固件需要写入特定的AER错误状态寄存器（这些寄存器可能作为BAR的一部分暴露，或由PCIe核内部处理，然后反映到用户逻辑）。然后您的用户逻辑将向PCIe核断言错误输入。\n   * **示例（电源管理）：**  如8.3.1节所述，您的固件需要响应PCIe核发出的D状态变化。\n   * **流程：**\n     * 识别您的捐赠设备驱动程序交互的每个已启用功能结构中的特定寄存器。\n     * 在PCILeech-FPGA框架中找到与这些寄存器接口的相应信号或逻辑（通常在`pcileech_pcie_cfg_a7.sv`或`bar_controller`中）。\n     * 实现这些寄存器的读写逻辑，确保您的仿真设备的内部状态准确反映驱动程序期望的值。\n\n### **9.2 仿真厂商特定功能**\n\n这是真正的“全设备仿真”变得高度专业化的部分。许多实际设备具有独特的寄存器、未文档化的命令、自定义数据格式或专有控制流程，这些都使其与众不同。复制这些需要更深入的分析和定制HDL开发。\n\n**步骤：**\n\n1. **逆向工程厂商特定行为：**\n\n   * 这通常是最具挑战性的部分。\n   * **静态分析（驱动程序/固件）：**  反汇编捐赠设备的官方驱动程序（Windows `.sys`，Linux `.ko`）或设备的原始固件（如果可用）。查找独特的I/O或MMIO访问模式、魔术值或寄存器写入序列。Ghidra、IDA Pro或objdump等工具会非常有价值。\n   * **动态分析（驱动程序执行）：**  运行捐赠设备及其驱动程序，并使用**PCIe协议分析仪**（例如，Teledyne LeCroy，Keysight，如第12.2节所述）监控PCIe流量。这是理解实际TLP交换，包括厂商定义消息和寄存器访问序列的黄金标准。请注意：\n     * BARs中访问的特定内存地址。\n     * 对这些地址的读/写模式。\n     * 写入或读取特定寄存器的值。\n     * 命令和响应之间的时序关系。\n   * **系统调用/API监控**：在主机上，使用Procmon（Windows）或`strace`（Linux）等工具查看驱动程序如何与操作系统交互以及它使用了哪些特定的设备I/O控制（IOCTL）代码，这些代码可能对应于特定的硬件操作。\n   * **硬件嗅探**：如果可能，使用硬件嗅探器（如Saleae逻辑分析仪）捕获设备内部总线（例如SPI，I2C）上的信号，如果它有外部闪存或组件。\n2. **在BARs中实现自定义寄存器和逻辑：**\n\n   * 一旦您识别出厂商特定的寄存器或命令协议，您将需要将这些定义到您的FPGA固件中，通常作为可通过您的某个BAR访问的内存映射寄存器。\n   * **创建内部寄存器：**  在您的SystemVerilog代码中声明`reg`变量来表示这些自定义寄存器。\n     ```verilog\n     // 在pcileech_tlps128_bar_controller.sv或子模块中\n     reg [31:0] custom_control_reg;\n     reg [31:0] custom_status_reg;\n     reg [31:0] custom_data_reg;\n\n     // 示例：将它们映射到BAR0中的特定偏移量（假设BAR0足够大）\n     // 调整'bar0_offset' case语句（来自第8.2.2节）\n     // ...\n     if (bar_hit[0]) begin\n         if (req_write) begin\n             case (bar0_offset)\n                 32'h0000_1000: custom_control_reg <= req_data; // 自定义控制寄存器\n                 32'h0000_1004: custom_data_reg <= req_data;    // 自定义数据写入寄存器\n                 // ... 其他映射\n             endcase\n         end else if (req_read) begin\n             case (bar0_offset)\n                 32'h0000_1000: rsp_data = custom_control_reg; // 读取控制寄存器\n                 32'h0000_1008: rsp_data = custom_status_reg;  // 自定义状态寄存器\n                 // ... 其他映射\n             endcase\n         end\n     end\n     // ...\n     ```\n   * **实现行为逻辑：**  创建SystemVerilog逻辑（状态机、组合逻辑），用于：\n     * 响应对`custom_control_reg`的写入。例如，此寄存器中的某个特定位可能触发DMA传输、清除状态标志或启动内部操作。\n     * 根据仿真设备的内部状态更新`custom_status_reg`（例如，“操作完成”、“发生错误”、“数据可用”）。\n     * 处理写入`custom_data_reg`的数据，或在读取时从中提供数据，模仿捐赠设备的数据路径。\n3. **仿真厂商特定消息（如果适用）：**\n\n   * 一些复杂设备可能通过PCIe使用“厂商定义消息”（VDM）进行特定控制或通信。如果您的分析揭示了此类消息，您将需要：\n     * 在PCIe IP核中启用VDM支持（如果可用）。\n     * 实现TLP生成逻辑（如第10节所述）来制作和发送这些VDM。\n     * 实现TLP接收和解析逻辑来解释来自主机的传入VDM。\n4. **验证仿真行为：**\n\n   * **迭代测试：**  这是一个高度迭代的过程。进行小修改，编译，烧录，然后测试。\n   * **驱动程序加载：**  捐赠设备的驱动程序是否正确加载而没有错误？\n   * **功能测试：**  驱动程序能否启动基本操作？它是否从您的仿真寄存器获得预期的响应？\n   * **应用程序测试：**  依赖捐赠设备的应用程序能否在您的仿真版本下正常运行？\n   * **调试：**  广泛使用ILA和PCIe协议分析仪来比较您的仿真设备的行为与真实捐赠设备捕获的行为。寻找TLP时序、寄存器值和总体协议流中的差异。\n\n---\n\n## **10. 事务层数据包（TLP）仿真**\n\n事务层数据包（TLP）是PCIe架构中通信的基本单位。主机系统与PCIe设备之间的每一次交互，从配置读取到数据传输，都被封装在一个或多个TLP中。精确的TLP仿真不仅重要；它对于您的仿真设备与主机系统正确交互，确保驱动程序正常运行和数据按预期移动，是*至关重要*的。\n\n### **10.1 理解和捕获TLP**\n\n在您能够制作自定义TLP之前，您必须深入理解它们的结构和常见类型。从您的捐赠设备捕获真实世界的TLP可提供最精确的蓝图。\n\n* **TLP结构的学习**：\n  TLP通常由报头、可选数据载荷和可选的端到端CRC（ECRC）组成。报头至关重要，它定义了TLP的类型、事务细节和路由信息。\n\n  * **TLP的组成部分**：\n    * **报头（Header）** ：最重要的部分，通常是3或4个双字（Dword = 4字节）。它包含定义TLP目的和处理方式的关键字段：\n      * **Fmt（格式）和 Type（类型）** ：定义TLP的格式（3DW/4DW，带/不带数据）及其特定目的（例如，内存读取请求、内存写入、完成、配置读取/写入）。\n      * **Length（长度）** ：指定数据载荷的长度（以双字为单位）。\n      * **Requester ID（总线、设备、功能）** ：标识发起请求的PCIe功能。对于将完成数据路由回正确的源头至关重要。\n      * **Tag（标签）** ：由请求者分配给事务的唯一标识符，允许完成者将完成TLP与其原始请求TLP匹配。\n      * **Address（地址）** ：对于内存/IO事务，这是目标内存或I/O地址。\n      * **First DW Byte Enable (FBE)**  和 **Last DW Byte Enable (LBE)** ：指定数据载荷的第一个和最后一个双字中哪些字节对于写入操作有效，或哪些字节正在请求读取完成。\n      * **Traffic Class (TC)**  和 **Transaction ID (TID)** ：用于QoS和排序规则。\n    * **数据载荷（可选）** ：存在于内存写入、配置写入和读取完成等TLP中。它包含实际传输的数据。\n    * **端到端CRC (ECRC)（可选）** ：一个32位CRC，覆盖整个TLP，确保从源到目的地的数据完整性，通常由软件生成/检查。\n* **理解常见的TLP类型**：您的固件将主要处理这些类型：\n\n  * **Memory Read Request (MRd)** ：由请求者（例如，主机CPU，或您的FPGA作为DMA主设备）发送的TLP，用于从特定内存地址读取数据。\n  * **Memory Read Completion (CplD)** ：由完成者（例如，您的FPGA响应主机MRd）发送的TLP，携带请求的数据。\n  * **Memory Write (MWr)** ：由请求者（例如，主机CPU，或您的FPGA）发送的TLP，用于向特定内存地址写入数据。\n  * **Completion Without Data (Cpl)** ：由完成者发送的TLP，用于确认不返回数据的请求（例如，成功的MWr）。\n  * **Configuration Read Request (CfgRd)** ：来自主机的TLP，用于读取设备配置空间中的寄存器。\n  * **Configuration Read Completion (CplD)** ：来自设备返回CfgRd数据数据的TLP。\n  * **Configuration Write Request (CfgWr)** ：来自主机的TLP，用于写入设备配置空间中的寄存器。\n  * **Vendor-Defined Messages (VDM)** ：特定厂商用于专有通信的自定义TLP。\n\n#### **10.1.2 从捐赠设备捕获TLP**\n\n从您的捐赠设备捕获真实的PCIe流量是无价的。它提供了TLP结构、序列和时序的具体示例，使您能够精确地复制它们。\n\n* **步骤**：\n  1. **设置PCIe协议分析仪**：\n     * 最有效的方法是使用专用的硬件工具，通常称为“PCIe协议分析仪”。这些设备位于主机和捐赠PCIe卡之间，被动捕获所有流量。\n     * **示例**：\n       * **Teledyne LeCroy PCIe 分析仪**：行业标准，功能强大，但投资巨大。\n       * **Keysight PCIe 分析仪**：另一个领先的供应商。\n       * （对于基本调试，一些带PCIe解码器的高端逻辑分析仪可能提供有限的TLP查看功能，但真正的协议分析仪更优越）。\n  2. **捕获事务**：\n     * 在连接了协议分析仪的测试系统中安装捐赠设备。\n     * 运行捐赠设备的驱动程序和任何相关应用程序。\n     * 在正常操作期间，尤其是关键阶段，监控和记录PCIe事务，例如：\n       * 设备枚举（操作系统首次检测到它时）。\n       * 驱动程序加载和初始化。\n       * 典型数据传输操作（例如，存储设备的大文件复制，网卡的网络流量）。\n       * 设备特定命令或诊断。\n  3. **分析捕获的TLP**：\n     * 使用协议分析仪的先进软件解剖捕获的TLP。软件将解码字段，提供时间顺序视图，并允许过滤和搜索。\n     * 密切关注：\n       * 精确的`Fmt`和`Type`字段。\n       * `Requester ID`和`Tag`值（特别是对于完成）。\n       * 内存事务的`Address`和`Length`。\n       * 写入和读取完成的`Data Payload`内容。\n       * 任何厂商特定字段或自定义TLP。\n\n#### **10.1.3 记录关键TLP事务**\n\n对捕获的TLP进行结构化文档创建了一个用于您的仿真的蓝图。\n\n* **步骤**：\n  1. **识别关键事务**：\n     * 重点关注对设备核心功能至关重要的TLP。这包括：\n       * **初始化序列**：操作系统在枚举期间执行的一系列配置读/写。\n       * **驱动程序初始化**：驱动程序启动时交换的命令和数据。\n       * **主要数据传输**：`MWr`和`MRd` TLP如何为设备的主要功能构建和完成。\n       * **错误处理**：设备如何报告错误（例如，带有Completer Abort (CA)、Unsupported Request (UR)的Completion）。\n       * **电源管理转换**：与D状态变化相关的TLP。\n       * **中断生成**：MSI/MSI-X消息如何发送。\n     * 协议分析仪的截图在这里会非常有帮助。\n  2. **创建详细文档**：\n     * 对于每个关键TLP序列，记录：\n       * **TLP类型**（例如，MWr、MRd、CplD）。\n       * 其**报头字段**（Fmt、Type、Requester ID、Tag、Length、Address、Byte Enables）。\n       * **数据载荷**（如果适用）。\n       * 事务中的**序列号**或顺序。\n       * 发送它的**条件**（例如，“主机在驱动程序初始化时发送”，“设备在DMA完成时发送”）。\n       * 任何**预期的响应**或后续TLP。\n     * 协议分析仪的截图在这里会非常有帮助。\n  3. **理解时序和序列**：\n     * 除了TLP内容，TLP的*时序*和*序列*至关重要。PCIe有严格的排序规则和流控制机制。注意：\n       * **请求和完成之间的延迟**：真实设备响应的速度。\n       * **流控制信用**：设备如何管理其传入/传出TLP的缓冲区空间。虽然Xilinx PCIe IP核处理基本的流控制，但对于高级仿真，了解捐赠设备的典型信用使用情况会有所帮助。\n       * **事务层数据包排序**：理解posted（写入）和non-posted（读取、完成）事务如何排序。\n\n### **10.2 制作用于特定操作的定制TLP**\n\n一旦您理解了蓝图，您就可以将这些知识转化为您的FPGA固件（SystemVerilog），以主动生成和响应TLP。PCILeech-FPGA框架提供了抽象层，但对于深度仿真，您可能需要直接与TLP生成/解析逻辑交互。\n\n#### **10.2.1 在固件中实现TLP处理**\n\n您的固件需要逻辑来发送和接收TLP。PCIe IP核处理物理层和数据链路层，向您的用户逻辑暴露一个事务层接口（通常是AXI-Stream）。\n\n* **要修改的文件（主要）** ：\n\n  * `pcileech-fpga/<your_board_variant>/src/pcileech_pcie_tlp_a7.sv`（或类似文件，取决于板卡变体）\n    * 此文件通常包含将用户请求转换为出站TLP并将传入TLP解析为用户逻辑信号的核心逻辑。\n  * `pcileech-fpga/<your_board_variant>/src/pcileech_tlps128_bar_controller.sv`\n    * 此模块专门处理解析目标为设备BAR的传入内存读/写TLP，并生成相应的完成TLP。\n* **步骤**：\n\n  1. **理解PCIe IP核接口**：\n\n     * 在编写TLP逻辑之前，请彻底阅读Xilinx PCIe IP核用户指南（特别是关于用户应用接口或AXI4-Stream接口的部分）。这定义了您的SystemVerilog逻辑如何连接到PCIe核以发送和接收TLP。您通常会与`s_axis_rx_tdata`（接收到的TLP数据）、`s_axis_rx_tvalid`（接收到有效TLP）、`m_axis_tx_tdata`（传出TLP数据）、`m_axis_tx_tready`（核已准备好接受TLP）等进行交互。\n  2. **创建TLP生成函数（用于出站TLP）** ：\n\n     * 在`pcileech_pcie_tlp_a7.sv`（或与`m_axis_tx_*`接口的模块）中，您将编写逻辑来组装具有所需报头和载荷的TLP。这通常涉及将各种字段组合成一个`[127:0]`（对于128位接口）或`[63:0]`（对于64位接口）总线，该总线馈送PCIe核。\n     * **示例（概念性，简化函数，用于3DW TLP报头）：**\n       ```verilog\n       // 这是一个概念性辅助函数。实际上，您将构建一个状态机\n       // 通过AXI-Stream接口发送TLP，可能使用FIFO。\n       function automatic [95:0] create_3dw_tlp_header; // 假设3个双字 = 96位\n           input logic [7:0] tlp_type_fmt;   // 格式和类型字段\n           input logic [15:0] requester_id;  // BDF\n           input logic [7:0] tag;\n           input logic [7:0] lower_address_bits; // 或更复杂的地址\n           input logic [7:0] byte_enables;   // 第一个双字字节使能\n\n           begin\n               create_3dw_tlp_header = {\n                   tlp_type_fmt,                     // Fmt[6:4], Type[3:0]\n                   8'b0,                             // 保留\n                   4'b0,                             // TC[3:0] (流量类别)\n                   3'b0,                             // Attr[2:0]\n                   1'b0,                             // TH (TLP提示)\n                   2'b0,                             // D(igest) (ECRC存在)\n                   1'b0,                             // EP (Poisoned)\n                   1'b0,                             // TD (类型依赖)\n                   // DW0: Fmt, Type, TC, Attr, TH, D, EP, TD, Length (不在3DW中, 4DW有)\n\n                   requester_id,                     // 请求者ID (Bus[7:0], Device[4:0], Function[2:0])\n                   tag,                              // 标签\n                   lower_address_bits,               // 示例：地址的低位或数据的一部分\n                   byte_enables,                     // 第一个双字字节使能\n                   4'b0,                             // 保留\n                   4'b0                              // 最后一个双字字节使能 (通常用于MWr)\n                   // DW1, DW2... 字段\n               };\n           end\n       endfunction\n\n       // 示例：在状态机中生成带数据的完成（CplD）\n       // 这只是一个片段，不是完整实现\n       localparam  CPLD_3DW_FMT = 8'h4A; // Fmt=100 (4DW, 带数据), Type=1010 (Cpl)\n       localparam  CPL_D_FMT_TYPE_LEN = 8'h4A; // 根据PCIe规范调整。(带数据的4DW报头)\n\n       // ... 发送TLP的状态机\n       // 在准备发送CplD的状态下\n       if (tx_ready_from_pcie_core) begin\n           // 构建报头和载荷\n           // 对于CplD，您需要Compliter ID, Status, Byte Count, Requester ID, Tag, Completion ID, Lower Address\n           // 然后是实际的读取数据载荷\n           m_axis_tx_tdata_reg = {\n               CPL_D_FMT_TYPE_LEN,         // 字节0: Fmt/Type\n               tlp_length_dw_minus_one,    // 字节1: TLP长度 (以双字为单位) - 1\n               status_completion_bits,     // 字节2: Cpl Status, BCM, Rsvd\n               byte_count_dws_upper,       // 字节3: 字节计数 (高位)\n               requester_id,               // 字节4-5: 请求者ID (来自原始MRd)\n               tag,                        // 字节6: 标签 (来自原始MRd)\n               byte_count_dws_lower,       // 字节7: 字节计数 (低位)\n               completion_id,              // 字节8-9: 完成ID (您的BDF)\n               lower_address_from_request  // 字节10-11: 请求的低位地址\n               // ... 接着是实际的数据载荷\n           };\n           m_axis_tx_tvalid_reg = 1'b1;\n           m_axis_tx_tlast_reg = 1'b1; // 最后一个TLP片段\n           // ... 状态转换以等待tready\n       end\n       ```\n     * **注意**：实际实现涉及状态机、FIFO，以及遵循PCIe IP核的AXI-Stream协议。PCILeech-FPGA框架已经为此提供了良好的基础，但您可能需要为非常特定的TLP行为进行扩展或修改。\n  3. **处理TLP接收（用于入站TLP）** ：\n\n     * 实现逻辑以解析来自PCIe核接收接口的传入TLP（例如，`s_axis_rx_tdata`、`s_axis_rx_tvalid`）。\n     * 此解析包括：\n       * 检查`s_axis_rx_tvalid`以判断是否存在TLP。\n       * 从TLP报头中读取`Fmt`和`Type`字段以确定其目的。\n       * 提取`Requester ID`、`Tag`、`Address`、`Length`和`Data Payload`等相关字段。\n     * 使用`case`语句或`if/else if`块，根据TLP类型将信息路由到适当的内部逻辑（例如，用于内存写入的`bar_controller`，用于配置写入的配置模块）。\n     * **示例（概念性，简化解析）：**\n       ```verilog\n       // 在pcileech_pcie_tlp_a7.sv或TLP解析模块中\n       input wire [127:0] s_axis_rx_tdata;\n       input wire s_axis_rx_tvalid;\n       output wire s_axis_rx_tready; // 需要断言此信号以接受更多数据\n\n       reg [7:0] received_tlp_fmt_type;\n       reg [15:0] received_requester_id;\n       // ... 声明其他已解析的字段\n\n       assign s_axis_rx_tready = 1'b1; // 为简化起见始终准备好接收，在实际设计中管理反压\n\n       always @(posedge clk) begin\n           if (s_axis_rx_tvalid) begin\n               received_tlp_fmt_type = s_axis_rx_tdata[127:120]; // 假设最高位\n               received_requester_id = s_axis_rx_tdata[111:96]; // 示例偏移量\n\n               // 根据TLP类型解码\n               case (received_tlp_fmt_type[3:0]) // 仅TLP类型位\n                   4'h0: // 内存写入 (3DW或4DW取决于Fmt)\n                       // 提取地址、长度、载荷并传递给BAR控制器\n                       begin\n                           // 传递给BAR控制器，用于写入仿真内存\n                           // bar_write_enable = 1'b1;\n                           // bar_write_address = s_axis_rx_tdata[...];\n                           // bar_write_data = s_axis_rx_tdata[...];\n                       end\n                   4'h1: // 内存读取\n                       // 提取地址、长度，并传递给BAR控制器进行读取\n                       begin\n                           // bar_read_enable = 1'b1;\n                           // bar_read_address = s_axis_rx_tdata[...];\n                           // (完成将由BAR控制器生成)\n                       end\n                   // ... 其他TLP类型\n                   default: begin\n                       // 处理不支持或保留的TLP类型（例如，日志记录、错误）\n                   end\n               endcase\n           end\n       end\n       ```\n  4. **确保符合性**：\n\n     * 严格验证您生成和解析的TLP是否符合PCIe规范的格式、字段定义和时序。偏差将导致通信失败。\n  5. **实现完成处理**：\n\n     * 对于从主机接收到的内存读取请求（MRd）和配置读取请求（CfgRd），您的设备必须在指定的时间内返回适当的完成TLP（CplD表示数据，Cpl表示无数据）。`bar_controller`模块（第8.2.2节）是此BAR读取逻辑所在的位置。\n  6. **保存更改**：\n\n     * 保存文件（`pcileech_pcie_tlp_a7.sv`、`pcileech_tlps128_bar_controller.sv`或任何自定义模块）后，实现更改。\n\n#### **10.2.2 处理不同TLP类型**\n\n每种TLP类型都有特定的报头格式和行为。您的固件必须擅长处理与您的捐赠设备相关的那些类型。\n\n* **内存读取请求（MRd）** ：\n\n  * **实现**：\n    * 当接收到MRd TLP（由`pcileech_pcie_tlp_a7.sv`解析并路由到`bar_controller`）时，`bar_controller`需要：\n      * 解析请求的地址和长度。\n      * 从适当的内部内存位置（例如，连接到BAR的BRAM）或内部寄存器中获取数据。\n      * 组装一个**带数据的完成（CplD）**  TLP。关键是，此TLP必须包含来自MRd请求的原始`Requester ID`、`Tag`和`Completion ID`（您的设备BDF），以及获取的数据载荷。\n      * 通过PCIe IP核的传输接口将CplD TLP发送回主机。\n* **内存写入请求（MWr）** ：\n\n  * **实现**：\n    * 当接收到MWr TLP时，`bar_controller`需要：\n      * 解析目标地址、长度和`Byte Enables`（FBE/LBE）。\n      * 提取`数据载荷`。\n      * 将数据写入仿真设备内的指定内存位置（例如，BRAM或内部寄存器），并遵循字节使能。\n    * 内存写入是“posted事务”，这意味着它们不需要完成TLP进行确认，除非发生错误。\n* **配置读/写请求（CfgRd/CfgWr）** ：\n\n  * **实现**：\n    * 这些TLP针对设备的配置空间（厂商ID、设备ID、BAR、功能等）。Xilinx PCIe IP核根据其配置自动处理大部分标准配置空间访问。\n    * 但是，如果您的配置空间中存在非标准的自定义寄存器或扩展功能，您可能需要特定的逻辑来：\n      * 对于CfgRd：从您的内部`cfg_`寄存器返回请求的数据。\n      * 对于CfgWr：更新您的内部`cfg_`寄存器或根据写入的数据触发操作。\n    * 配置读取需要**带数据的完成（CplD）** ，而配置写入需要**不带数据的完成（Cpl）** 。\n* **厂商定义消息（VDM）** ：\n\n  * **实现**：\n    * 如果您的捐赠设备使用VDM，这将需要专门的解析和响应逻辑。\n    * **解析传入VDM**：根据其`Fmt`和`Type`字段识别VDM。提取厂商特定数据并根据您的逆向工程发现进行解释。\n    * **制作出站VDM**：当您的仿真设备需要发送VDM时，创建逻辑来组装具有精确厂商特定报头和载荷格式的VDM。\n\n#### **10.2.3 验证TLP时序和序列**\n\n即使TLP格式完美，不正确的时序或序列也会导致设备故障或被检测为不兼容。\n\n* **步骤**：\n\n  1. **使用仿真工具**：\n\n     * **测试平台**：为您的TLP生成和解析模块开发全面的SystemVerilog测试平台。\n     * 模拟各种场景（例如，主机发送MRd，您的设备发送CplD；主机发送MWr；主机枚举设备），以验证TLP是否正确形成、传输、接收和处理。\n     * 验证TLP的序列，并确保在合理的时间内发送完成。\n  2. **使用ILA监控（集成逻辑分析仪）** ：\n\n     * 如第12.1节所述，在您的Vivado设计中插入一个ILA核。\n     * 将ILA探头连接到PCIe IP核的AXI-Stream接口（例如，`s_axis_rx_tdata`、`s_axis_rx_tvalid`、`m_axis_tx_tdata`、`m_axis_tx_tready`）。\n     * 设置触发器以捕获特定TLP（例如，在`m_axis_tx_tvalid`上针对某种TLP类型触发）。\n     * 这使您可以在硬件操作期间实时查看FPGA上的实际TLP位，验证您的固件是否向/从PCIe IP核发送/接收正确的数据和控制信号。\n  3. **检查时序约束**：\n\n     * PCIe IP核对其AXI-Stream接口有严格的时序要求。确保您的用户逻辑向`m_axis_tx_tdata`提供数据和处理`s_axis_rx_tdata`满足这些时序约束。\n     * Vivado的时序分析报告（综合和实现后）将标记任何违规。通过优化您的逻辑或在可能的情况下调整时钟来解决这些问题。\n  4. **符合性测试（高级）** ：\n\n     * 对于高保真仿真，请考虑使用专用的PCIe符合性测试套件（通常与高端协议分析仪集成）。这些测试系统地检查是否符合PCIe规范，揭示细微的协议违规。\n  5. **保存更改**：\n\n     * 在彻底测试和验证后保存所有修改过的文件。迭代是TLP级调试的关键。\n\n---\n\n## **第三部分：高级技术与优化**\n\n---\n\n## **11. 构建、烧录与测试**\n\n完成所有定制后，就到了验证的时刻：构建固件，将其编程到您的FPGA上，并严格测试其功能，以确保它与捐赠设备的行为完全一致。此阶段将您的设计从代码转换为可工作的硬件仿真。\n\n### **11.1 综合与实现**\n\n这是FPGA设计流程中的核心步骤，您的SystemVerilog高级代码将被转换为可以加载到FPGA上的低级硬件配置。\n\n#### **11.1.1 运行综合**\n\n综合是Vivado将您的HDL代码转换为门级网表（逻辑门及其互连的描述）的过程。它还执行初步的时序分析和资源估算。\n\n* **步骤**：\n  1. **开始综合**：\n     * 在Vivado GUI中，在 **Flow Navigator**（流程导航器）窗格（通常在左侧）中，在“Synthesis”（综合）下，点击 **Run Synthesis**（运行综合）。\n  2. **监控进度**：\n     * Vivado将打开一个“Launch Runs”（启动运行）对话框。您通常只需点击“OK”。\n     * 监控Vivado窗口底部的 **Messages**（消息）选项卡。它将显示综合运行的进度。\n     * **常见警告/错误关注点**：\n       *  **​`[Synth 8-327]`​**​ ** Unconnected Ports / Unused Inputs（未连接端口/未使用的输入）** ：这表明您设计中的信号或端口未连接到任何东西。虽然有时是故意的（例如，FPGA上未使用的引脚），但它们也可能指向端口名称中的拼写错误或遗忘的连接。检查每个警告以确保这不是功能问题。\n       *  **​`[Synth 8-256]`​**​ ** Registers/Wires Not Optimized（寄存器/线未优化）** ：这可能表明逻辑推断不正确，或者您有冗余逻辑可以优化。\n       * **Syntax Errors（语法错误）** ：如果您的SystemVerilog代码中有致命的语法错误，综合将立即失败。请在Visual Studio Code中修复这些错误。\n  3. **审查综合报告**：\n     * 成功完成后，Vivado将询问您下一步要做什么。选择 **Open Synthesized Design**（打开综合设计）或 **Open Report**（打开报告）。\n     * 最重要的是，查看综合报告中的 **Utilization Summary**（资源利用率摘要）。这显示了您的设计消耗了FPGA多少资源（LUT、触发器、BRAM、DSP）。确保设计适合您的目标FPGA的容量（例如，对于Artix-7 35T，您应该在其限制内）。\n\n#### **11.1.2 运行实现**\n\n实现是最耗时的一步。它接收综合后的网表并将其物理映射到FPGA的资源上（放置逻辑块，布线连接），然后执行详细的时序分析，以确保设计能够以指定的时钟频率运行。\n\n* **步骤**：\n  1. **开始实现**：\n     * 成功综合后，在 **Flow Navigator**（流程导航器）中，在“Implementation”（实现）下，点击 **Run Implementation**（运行实现）。\n     * 确认“Launch Runs”（启动运行）对话框。\n  2. **监控进度**：\n     * 实现包括几个阶段：Opt Design（优化设计）、Power Opt Design（功耗优化设计）、Place Design（放置设计）、Post-Placement Phys Opt Design（后放置物理优化设计）、Route Design（布线设计）、Post-Route Phys Opt Design（后布线物理优化设计）。每个阶段都可能需要大量时间。\n     * 监控 **Messages**（消息）选项卡以了解进度和潜在问题。\n  3. **分析时序报告**：\n     * 这是实现后*最关键的步骤*。完成后，Vivado会再次询问下一步做什么。选择 **Open Implemented Design**（打开已实现设计），或者更重要的是，选择 **Open Report**（打开报告），然后选择 **Report Timing Summary**（报告时序摘要）。\n     * **确保所有时序约束都得到满足。**  查找“WNS (Worst Negative Slack)”值。\n       * **正WNS**：表示所有时序路径都满足其要求（有余量）。这是您想要的结果。\n       * **负WNS**：表示**时序违规**，这意味着您的设计无法在所需的时钟频率下运行，或者数据可能不稳定。**这是一个必须解决的关键问题。**\n     * **解决违规**：\n       * 如果您有负余量，请调查失败的具体路径。Vivado的时序报告将显示失败路径的源、目标和组件。\n       * 解决方案可以包括：\n         * 优化HDL代码以减少逻辑深度或关键路径延迟。\n         * 添加流水线级（寄存器）以打断长组合路径。\n         * 改进XDC（约束）文件，确保所有时钟都正确定义和传播。\n         * 调整时钟频率（如果应用程序允许）。\n         * 在Vivado中使用更快的时序收敛策略。\n         * 确保您的自定义逻辑与PCIe核的AXI-Stream接口时序要求正确接口。\n  4. **验证布局（可选）** ：\n     * 在已实现的设计中，您可以打开“Device”（器件）视图，查看您的逻辑如何在FPGA上布局。这通常适用于高级用户，以确认关键组件是否最佳布局（例如，靠近PCIe收发器）。\n\n#### **11.1.3 生成比特流**\n\n比特流是最终的二进制配置文件（`.bit`扩展名），将被加载到您的FPGA上。它是综合和实现的成果。\n\n* **步骤**：\n  1. **生成比特流**：\n     * 成功实现后（没有严重的时序违规），在 **Flow Navigator**（流程导航器）中，在“Program and Debug”（编程和调试）下，点击 **Generate Bitstream**（生成比特流）。\n  2. **等待完成**：\n     * 此过程通常比实现花费的时间少，但仍可能因设计复杂性而异。\n  3. **审查比特流生成日志**：\n     * 完成后，Vivado会指示成功。审查日志中是否有任何警告，但通常如果实现顺利通过，比特流生成也会顺利通过。\n     * `.bit`文件将生成在您的项目目录`pcileech_squirrel_top.runs/impl_1/`（或您的板卡类似路径）中。\n\n### **11.2 烧录比特流**\n\n编程（烧录）比特流会将您编译的设计加载到FPGA上，使您的仿真设备激活。\n\n#### **11.2.1 连接FPGA设备**\n\n* **步骤**：\n  1. **准备硬件**：\n     * 确保您的基于FPGA的DMA板卡已正确插入主机系统的兼容PCIe插槽。\n     * 将JTAG编程器（例如，Digilent HS3，Xilinx Platform Cable）连接到FPGA板卡上的JTAG接口和开发PC的USB端口。\n     * 打开主机系统电源。\n     * 请参阅您的特定FPGA板卡手册，了解精确的电源、JTAG和PCIe连接说明。\n  2. **打开硬件管理器**：\n     * 在Vivado中，导航到 **Flow Navigator &gt; Program and Debug &gt; Open Hardware Manager**（流程导航器 > 编程和调试 > 打开硬件管理器）。\n     * 如果Vivado未运行，您可以作为独立应用程序启动硬件管理器。\n\n#### **11.2.2 编程FPGA**\n\n* **步骤**：\n  1. **连接到目标**：\n     * 在硬件管理器窗口中，点击 **Open Target**（打开目标）（通常是一个大按钮或链接），然后选择 **Auto Connect**（自动连接）。\n     * Vivado应该自动检测到您的JTAG编程器，然后检测到JTAG链上连接的FPGA设备。如果检测失败，请检查JTAG电缆连接、板卡电源以及PC上的JTAG驱动程序。\n  2. **编程设备**：\n     * 一旦您的FPGA设备在硬件窗口中被检测并显示，**右键单击** 您的FPGA设备（例如，`xc7a35t_0`）并选择 **Program Device**（编程设备）。\n     * 将出现一个对话框。点击“Bitstream file”（比特流文件）字段旁边的“...”按钮，导航到您生成的比特流文件（例如，`pcileech_squirrel_top.runs/impl_1/pcileech_squirrel_top.bit`）。\n     * 点击 **Program**（编程）开始将固件烧录到FPGA上。\n     * 等待编程过程完成。您将看到一个进度条。\n\n#### **11.2.3 验证编程**\n\n* **步骤**：\n  1. **检查状态**：\n     * 确保编程在Vivado的硬件管理器中无错误地完成。Vivado将在完成后显示“Program Device”成功消息。\n  2. **观察LED或指示灯**：\n     * 许多FPGA板卡都有状态LED。成功的编程操作通常会导致特定LED亮起或改变状态（例如，“DONE”LED）。这是一个快速的视觉确认。\n  3. **主机系统重启（有时需要）** ：\n     * 为了让主机操作系统正确识别新编程的PCIe设备，通常需要系统重启，尤其是在Windows上，以触发完整的PCIe枚举过程。\n\n### **11.3 测试与验证**\n\n编程完成后，关键一步是验证您的仿真设备是否被主机正确检测，并且其功能是否按预期工作，模仿捐赠设备。\n\n#### **11.3.1 验证设备枚举**\n\n这证实主机操作系统根据您编程的ID将您的FPGA识别为捐赠设备。\n\n* **Windows**：\n  * **步骤**：\n    1. **打开设备管理器**：按下 `Win + X` 并从快速链接菜单中选择 **Device Manager**（设备管理器）。\n    2. **检查设备属性**：\n       * 在适当的设备类别下查找（例如，**Network Adapters**（网络适配器）、**Storage Controllers**（存储控制器）、**System devices**（系统设备））。\n       * 找到您的仿真设备。它现在应该显示为*捐赠设备的名称*（例如，“Intel(R) Ethernet Connection...”）。\n       * 右键单击该设备，选择 **Properties**（属性），然后转到 **Details**（详细信息）选项卡。\n       * 在“Property”（属性）下拉菜单中，选择“Hardware Ids”（硬件ID）。确认 **设备ID（DID）**  和 **厂商ID（VID）** （例如，`PCI\\VEN_ABCD&DEV_1234`）与您编程到固件中的值匹配。\n       * 还应检查“Class Code”（类别代码）和“Subsystem ID”（子系统ID）以进行进一步验证。\n* **Linux**：\n  * **步骤**：\n    1. **使用 **​**​`lspci`​**：打开终端并使用`lspci`命令。\n       ```bash\n       lspci -nn # 显示厂商ID:设备ID\n       lspci -vvv # 显示包括BAR、功能等详细信息\n       ```\n    2. **验证设备列表**：\n       * 检查仿真设备是否在`lspci`输出中显示了正确的厂商ID、设备ID和类别代码。\n       * **示例输出（仿真Intel NIC）** ：\n         ```\n         03:00.0 Network controller [0280]: Intel Corporation Ethernet Connection I219-V [8086:1570] (rev 21)\n         ```\n\n         （`8086`是Intel的厂商ID，`1570`是I219-V的设备ID，`0280`是网络控制器类别代码）。\n       * 使用`lspci -vvv`确认BAR是否以正确的大小和类型枚举，与您的捐赠设备配置匹配。\n\n#### **11.3.2 测试设备功能**\n\n一旦设备被枚举，最终的测试是它是否像原始设备一样工作。\n\n* **步骤**：\n  1. **安装必要的驱动程序**：\n     * 如果主机操作系统未自动加载合适的驱动程序，您将需要手动安装捐赠设备的官方驱动程序。从制造商网站下载它们。\n     * 按照制造商的说明进行安装。如果仿真成功，驱动程序应该安装并识别您的FPGA为真实硬件。\n  2. **执行功能测试**：\n     * 运行通常与捐赠设备交互的应用程序或实用程序。\n     * **示例**：\n       * **网卡**：执行ping测试、浏览网页或启动大文件传输以测试吞吐量。\n       * **存储控制器**：尝试格式化模拟驱动器（如果您的仿真包括存储功能），执行读/写操作，或运行磁盘基准测试。\n       * **USB控制器**：连接USB设备（如果您的仿真包括USB主机功能）并测试它们的检测和操作。\n     * 监控主机系统以获取预期的行为和性能特征。\n  3. **监控系统行为**：\n     * 检查系统稳定性（Windows上没有蓝屏，Linux上没有内核崩溃）。\n     * 在系统日志中查找设备特定错误（Windows上的事件查看器，Linux上的`dmesg`或`journalctl`）。\n     * 确保仿真设备在各种工作负载下（包括大数据传输或压力测试）按预期运行。\n\n#### **11.3.3 监控错误**\n\n主动的错误监控对于识别可能不会立即导致崩溃的细微仿真问题至关重要。\n\n* **Windows**：\n  * **步骤**：\n    1. **检查事件查看器**：按下 `Win + X` 并选择 **Event Viewer**（事件查看器）。\n    2. **查找与PCIe相关的错误**：导航到 **Windows Logs &gt; System**（Windows 日志 > 系统）。筛选或搜索与“PCIe”、“PCI Express”相关的警告、错误或关键事件，或源自特定设备驱动程序的事件（查找与您的仿真设备驱动程序匹配的源名称）。\n       * 常见错误包括资源冲突、驱动程序初始化失败或意外的设备响应。\n* **Linux**：\n  * **步骤**：\n    1. **检查 **​**​`dmesg`​**​ ** 日志**：打开终端并输入：\n       ```bash\n       dmesg | grep -i pci # 不区分大小写地搜索pci消息\n       dmesg | grep -i <VendorID> # 过滤您的设备的厂商ID\n       ```\n    2. **识别问题**：查找指示PCIe链路训练问题、设备初始化问题、内存分配失败或意外DMA活动的消息。Linux内核的PCIe子系统非常详细。\n  * **Systemd Journal (现代Linux)** ：\n    ```bash\n    journalctl -b | grep -i pci # 当前引导日志\n    ```\n\n---\n\n## **12. 高级调试技术**\n\n当问题出现时，特别是在复杂的PCIe设备仿真中，基本的故障排除可能不足以解决问题。高级调试工具和技术提供对FPGA内部逻辑和PCIe总线的深入可见性，使您能够高效地识别和解决问题。\n\n### **12.1 使用Vivado的集成逻辑分析仪（ILA）**\n\n集成逻辑分析仪（ILA）是Xilinx提供的一种强大、可配置的调试IP核，您可以直接将其嵌入到FPGA设计中。它允许您监控内部FPGA信号（线和寄存器）的实时行为，而无需外部探测硬件，其功能类似于一个强大的内部示波器或逻辑分析仪。\n\n#### **12.1.1 插入ILA核**\n\n* **步骤**：\n  1. **规划您的探头**：确定您需要观察的关键信号。对于PCIe仿真，这些信号通常包括：\n     * PCIe IP核的AXI-Stream接口（例如，`s_axis_rx_tdata`、`s_axis_rx_tvalid`、`m_axis_tx_tdata`、`m_axis_tx_tready`）。\n     * 内部状态机信号（`current_state`、`next_state`）。\n     * BAR地址解码输出（`bar_hit[0]`、`bar_hit[1]`）。\n     * 自定义寄存器值（`custom_control_reg`、`custom_status_reg`）。\n     * 中断请求信号（`msi_trigger_signal`）。\n  2. **添加ILA IP核**：\n     * 在Vivado中，打开 **IP Catalog**（IP目录）（通常在 **Flow Navigator**（流程导航器）窗格中）。\n     * 搜索“ILA”（Integrated Logic Analyzer）。\n     * 双击“Debug Bridge”（用于基本ILA）或“Integrated Logic Analyzer (ILA)”以打开其定制GUI。\n     * 配置ILA：\n       * 设置您需要的**捕获数据端口数量**（探头）。\n       * 设置每个探头的**宽度**以匹配您计划连接的信号。\n       * 配置**采样深度**（在触发前/后存储多少个样本）。更深的深度会消耗更多BRAM。\n       * 点击“OK”并让Vivado生成IP。\n  3. **实例化并连接信号**：\n     * Vivado将生成ILA的`.xci`文件。您可以将其直接实例化在您的顶层SystemVerilog文件（例如，`pcileech_squirrel_top.sv`）中，或在可用信号的模块中。\n     * **示例（在**​**​`pcileech_squirrel_top.sv`​**​**或子模块中）：**\n       ```verilog\n       // 假设您已从IP Catalog生成了ila_0\n       // 连接到您设计的时钟和感兴趣的信号\n       ila_0 your_ila_instance (\n           .clk(clk_125mhz), // 连接到您设计中稳定的时钟，通常是PCIe用户时钟\n           .probe0(pcie_s_axis_rx_tdata),    // 示例：PCIe入站TLP数据\n           .probe1(pcie_s_axis_rx_tvalid),   // 示例：PCIe入站TLP有效\n           .probe2(pcie_m_axis_tx_tdata),    // 示例：PCIe出站TLP数据\n           .probe3(my_bar_controller_state), // 示例：您的BAR逻辑状态\n           .probe4(my_custom_register),      // 示例：自定义寄存器的值\n           // 根据需要添加更多探头\n           .probeN(signal_to_monitor_N)\n       );\n       ```\n     * **替代方法（标记用于调试）：**  对于更简单的信号，有时可以直接在HDL代码中标记它们用于调试。使用`(* mark_debug = \"true\" *) wire my_signal;` 或 `(* mark_debug = \"true\" *) reg my_register;`。Vivado随后会自动建议将它们添加到ILA中。\n\n#### **12.1.2 配置触发条件**\n\n当您配置智能触发条件以精确地在感兴趣的事件发生时（例如，错误、特定TLP类型、状态转换）捕获数据时，ILA最强大。\n\n* **步骤**：\n  1. **生成带有ILA的比特流**：插入并连接ILA后，您必须运行综合、实现并生成新的比特流。ILA核消耗FPGA资源，并将嵌入到您的设计中。\n  2. **打开硬件管理器**：使用支持ILA的比特流编程您的FPGA（第11.2节）。然后，在Vivado中，打开硬件管理器并连接到您的目标。\n  3. **访问ILA仪表板**：在硬件管理器中，选择您的ILA实例（例如，`hw_ila_1`）。这将打开ILA仪表板。\n  4. **定义触发器**：\n     * 选择要用作触发输入的探头。\n     * 设置特定的**触发模式**（例如，`pcie_s_axis_rx_tdata`为`0x4A`以触发完成TLP）。\n     * 配置**触发条件**（例如，“等于”、“不等于”、“上升沿”、“下降沿”）。\n     * 设置**触发位置**（在触发事件*之前*捕获多少样本，用于预触发可见性）。\n     * 您可以设置多个触发序列以检测复杂事件。\n     * **触发器示例场景**：\n       * 在收到的TLP中触发特定的`Fmt/Type`以分析传入命令。\n       * 当特定寄存器（`my_custom_register`）达到某个值时触发。\n       * 在`pcie_m_axis_tx_tvalid`断言 AND `pcie_m_axis_tx_tdata[3:0]` == `4'hC`（用于内存写入TLP）时触发，以分析出站写入。\n       * 在错误信号断言时触发。\n\n#### **12.1.3 捕获和分析数据**\n\n* **步骤**：\n  1. **运行设计**：让您的主机系统与已编程的FPGA交互，从而引发您要调试的事件。\n  2. **布防ILA**：在ILA仪表板中，点击 **Run Trigger**（运行触发器）按钮（通常是绿色的“播放”图标）。ILA将等待定义的触发条件。\n  3. **捕获数据**：一旦满足触发条件，ILA将把信号快照捕获到其内部内存缓冲区中。\n  4. **分析波形**：\n     * 捕获的数据将出现在波形查看器中。\n     * 检查信号随时间的变化行为。放大、添加光标并解码值。\n     * 寻找：\n       * **意外的跳变**：信号在错误的时间改变。\n       * **不正确的值**：寄存器中保存了错误的数据。\n       * **协议违规**：您的逻辑在PCIe接口上发送了不正确的数据。\n       * **时序问题**：如果信号在预期时不稳定（尽管完整的时序分析在实现中完成，但ILA显示运行时行为）。\n     * 将捕获到的行为与您的预期设计逻辑和捐赠设备的观察行为（如果您使用协议分析仪捕获了它）进行比较。\n\n### **12.2 PCIe流量分析工具**\n\n虽然ILA提供了FPGA内部可见性，但外部PCIe流量分析工具提供了对您的仿真设备和主机之间PCIe总线上实际通信的无与伦比的视图。这对于验证协议符合性和调试链路级问题至关重要。\n\n#### **12.2.1 PCIe协议分析仪（硬件）**\n\n* **示例**：\n  * **Teledyne LeCroy PCIe 分析仪**：深度分析的黄金标准，完整的协议解码，高级触发，以及错误注入功能。\n  * **Keysight PCIe 分析仪**：另一个领先的供应商，具有类似的高端功能。\n* **步骤**：\n  1. **设置分析仪**：将硬件分析仪串联连接在主机系统的PCIe插槽和您的基于FPGA的DMA设备之间。这通常涉及一个特殊的中间卡。\n  2. **配置捕获设置**：使用分析仪的软件定义要捕获的流量。您可以按TLP类型、地址、请求者ID、错误条件等进行过滤，以关注相关事件。\n  3. **捕获流量**：在主机上运行您的仿真设备。分析仪将被动记录所有PCIe事务。\n  4. **分析结果**：\n     * 使用分析仪强大的软件查看解码的TLP、事务列表和波形视图。\n     * **检查TLP的符合性和正确性**：所有字段都正确吗？序列是否正确？\n     * **识别任何协议违规或意外行为**：这是您发现驱动程序可能失败的原因（例如，您的设备发送了带数据的完成，而规范要求不带数据的完成，或者响应太慢）。\n     * **与捐赠设备捕获进行比较**：直接比较您的仿真设备捕获的流量与您从真实捐赠设备捕获的流量。这是仿真准确性的最终测试。\n\n#### **12.2.2 基于软件的工具**\n\n对于基本的PCIe总线检查，或者在没有专用硬件分析仪的情况下，一些软件工具可以提供有限的洞察。\n\n* **示例**：\n  * **Wireshark with PCIe Plugins**：虽然Wireshark主要用于网络流量，但通过专用硬件（例如，将PCIe跟踪暴露给操作系统的网卡，或特定的捕获硬件/驱动程序），它有时可以捕获和解码PCIe数据包。这高度依赖于系统。\n  * **ChipScope Pro（传统Xilinx，现已集成到Vivado中）** ：Integrated Logic Analyzer (ILA) 是现代的等效工具，但ChipScope曾是一个独立工具。\n  * **​`lspci`​**​ ** (Linux)** ：如第11.3.1节所述，`lspci -vvv`提供了广泛的静态配置空间信息。您可以将其与`watch`或脚本结合使用来监控随时间的变化。\n  * **​`pcileech`​**​**客户端（来自PCILeech框架）** ：`pcileech`客户端软件本身可以通过您的FPGA执行内存和配置空间的读写操作，并可用于测试基本的DMA功能。虽然不是“流量分析仪”，但它对于测试功能接口至关重要。\n* **步骤**：\n  1. **安装必要的工具/插件**：确保工具已安装并配置了任何所需的驱动程序或插件。\n  2. **监控PCIe总线**：运行软件工具以捕获和显示PCIe相关信息。\n  3. **分析通信**：\n     * 查找设备配置中的差异。\n     * 如果工具支持，分析捕获数据包的结构是否存在异常或错误。\n     * 验证您的仿真设备是否正确响应了配置请求。\n\n---\n\n## **13. 故障排除**\n\n本节提供了在PCIe设备仿真定制固件开发、比特流编程和硬件测试过程中可能遇到的常见问题的解决方案。固件调试可能具有挑战性，因此采用系统方法是关键。\n\n### **13.1 设备检测问题**\n\n**问题**：您的基于FPGA的DMA设备在编程后未被主机系统识别，或者在设备管理器/lspci中显示为不正确的ID（例如，“未知设备”）或错误符号。\n\n#### **可能原因及解决方案**：\n\n1. **设备ID、厂商ID、子系统ID或类别代码不正确**：\n\n   * **原因**：最常见的原因。您编程到FPGA固件中的识别值与主机操作系统预期或您打算仿真的值不匹配。\n   * **解决方案**：\n     * **验证**：仔细检查`pcileech_pcie_cfg_a7.sv`（或等效文件）中的所有`cfg_deviceid`、`cfg_vendorid`、`cfg_subsysid`、`cfg_subsysvendorid`、`cfg_revisionid`和`cfg_classcode`参数，与您精心记录的捐赠设备信息（来自第5节）进行比对。\n     * **一致性**：确保这些值在Vivado PCIe IP核定制GUI（第7.2.2节）中也保持一致设置。\n     * **重新构建并重新烧录**：进行任何更改后，始终重新综合、重新实现、生成新的比特流并重新烧录FPGA（第11.1、11.2节）。\n     * **重启主机**：烧录后务必重启主机系统，因为Windows通常需要完全重启才能正确重新枚举PCIe设备。\n2. **PCIe链路训练失败**：\n\n   * **原因**：主机根联合体与您的FPGA卡之间的基本PCIe链路未能建立。这发生在任何配置空间读取之前。症状包括设备完全不出现（`lspci`在该总线/插槽上没有任何显示，或设备管理器显示“PCI Express Root Port”错误）。\n   * **解决方案**：\n     * **物理连接**：确保FPGA板卡牢固地插入PCIe插槽，并且所有电源连接都牢固。如果可能，尝试不同的PCIe插槽。\n     * **电源**：验证FPGA板卡是否获得足够的电源。某些板卡需要辅助PCIe电源连接器。\n     * **链路速度/宽度**：\n       * 检查Vivado PCIe IP核中的`Max Link Speed`和`Link Width`设置（第8.1.1节）。\n       * 尝试将链路速度设置为较低的代数（例如，Gen1 / 2.5 GT/s）并将宽度设置为x1，即使您的板卡支持更高。有时，在较高速度下与特定主板会产生兼容性问题。\n       * 检查主板BIOS设置中的PCIe插槽速度选项。\n     * **复位**：确保FPGA的复位逻辑正确实现（例如，与PCIe参考时钟同步），并在上电/重启时正确断言/去断言。\n     * **PCIe IP核**：确保PCIe IP核正确实例化，并且其时钟和复位在您的顶层设计中正确连接。\n3. **电源问题（电源不足或不稳定）** ：\n\n   * **原因**：FPGA板卡未获得足够的稳定电源，或电源供应不稳定，导致操作不可靠。\n   * **解决方案**：\n     * **验证连接**：仔细检查所有电源线（主PCIe插槽电源、辅助PCIe电源、如果使用则包括外部直流插孔）。\n     * **电源供应**：确保您的主机系统电源（PSU）具有足够的瓦数和稳定的12V电压轨。对于高功耗FPGA，弱电源可能导致问题。\n     * **外部电源**：如果板卡有外部电源插孔，请确保使用正确电压和电流额定值的电源。\n4. **固件错误（早期阶段）** ：\n\n   * **原因**：SystemVerilog代码中的逻辑错误，特别是顶层模块或PCIe核的包装器中，导致PCIe核无法初始化或正确呈现自身。\n   * **解决方案**：\n     * **Vivado消息**：仔细检查Vivado的综合和实现日志中与PCIe IP核相关的**严重警告**或**错误**。这些通常是配置错误或连接不当的指示。\n     * **ILA调试**：如果链路尝试训练但失败，请使用连接到PCIe IP核的状态信号（例如，`link_up`、`link_speed`、`link_width`）和AXI-Stream接口的ILA（第12.1节），以查看链路协商在哪个点失败，或者核是否生成了意外流量。\n\n### **13.2 内存映射和BAR配置错误**\n\n**问题**：仿真设备已检测到，但当主机操作系统或驱动程序尝试通过BAR访问其内存映射寄存器或缓冲区时，系统崩溃、冻结或报告错误。\n\n#### **可能原因及解决方案**：\n\n1. **BAR大小或类型不正确（IP核和固件）** ：\n\n   * **原因**：您在Vivado PCIe IP核（第7.2.2节）中配置的BAR大小或类型（32位/64位、内存/I/O、可预取/不可预取）和/或在`pcileech_tlps128_bar_controller.sv`中处理的值与捐赠设备实际提供的值不匹配。这可能导致主机分配不正确的地址空间或尝试不支持的访问。\n   * **解决方案**：\n     * **交叉验证**：返回到您的Arbor/协议分析仪数据（第5节），重新验证每个BAR配置（大小、类型、可预取）。\n     * **一致性**：确保这些值在PCIe IP核定制中完全匹配，并且您的`bar_controller`逻辑正确处理每个BAR的大小（地址解码范围）和类型。\n     * **BRAM大小**：如果您的BAR映射到BRAM，请确认BRAM IP核的大小（第8.2.1节）与BAR大小完全匹配。\n2. **固件中的地址解码错误**：\n\n   * **原因**：您的`pcileech_tlps128_bar_controller.sv`（或自定义BAR逻辑）错误地解释了传入的PCIe地址，导致访问了不正确的内部寄存器或内存位置。\n   * **解决方案**：\n     * **审查逻辑**：仔细审查`bar_controller`中的`case`语句和地址计算。\n     * **仿真**：在您的SystemVerilog测试平台中开发特定的测试用例，模拟主机对每个BAR中不同偏移量的读写访问。验证内部`bar_hit`信号是否正确，以及数据是否正确路由到/从正确的内部寄存器/BRAM。\n     * **ILA调试**：在`req_addr`、`req_write`、`req_read`、`req_data`、`rsp_data`以及`bar_controller`中与您的地址解码和寄存器访问相关的内部信号上放置ILA探头。实时观察地址如何解码以及正在读/写的数据。\n3. **内部地址空间重叠**：\n\n   * **原因**：虽然PCIe标准确保不同设备的BAR在主机的内存映射中不重叠，但在FPGA*内部*，您可能会意外地将不同的逻辑组件映射到单个BAR中的相同物理地址空间。\n   * **解决方案**：\n     * **仔细映射**：在BAR中定义内部寄存器和内存块时，显式为每个寄存器和内存块分配唯一的、不重叠的偏移量。使用`localparam`来定义这些偏移量以防止错误。\n     * **设计审查**：需要对您的`bar_controller`进行彻底的设计审查，以确保每个地址范围都得到唯一处理。\n4. **BRAM访问问题**：\n\n   * **原因**：您的逻辑与BRAM IP核接口存在问题（例如，不正确的BRAM时钟、异步复位、错误的字节使能或不正确的写入使能逻辑）。\n   * **解决方案**：\n     * **BRAM文档**：查阅Xilinx BRAM IP核文档，了解正确的实例化和接口信号。\n     * **ILA**：在BRAM接口信号（地址、写入使能、数据输入、数据输出）上放置ILA探头，以验证您的逻辑是否向BRAM发送了正确的控制信号。\n\n### **13.3 DMA性能和TLP错误**\n\n**问题**：设备已检测到并功能上看起来正常，但在大型DMA操作期间，数据传输速率缓慢，或者系统间歇性崩溃、挂起或报错。PCIe协议分析仪报告TLP格式错误或流控制问题。\n\n#### **可能原因及解决方案**：\n\n1. **TLP格式错误（报头/载荷）** ：\n\n   * **原因**：您的固件生成的TLP（特别是您的FPGA作为DMA主设备时发送的完成或出站内存写入）具有不正确的报头、长度、字节使能或载荷。主机系统的PCIe核或驱动程序将其检测为违规。\n   * **解决方案**：\n     * **PCIe协议分析仪**：这是最好的工具（第12.2.1节）。捕获流量并仔细比较您生成的TLP与PCIe规范，更重要的是，与您*真实捐赠设备*的捕获进行比较。\n     * **TLP生成逻辑**：审查您的TLP组装代码（`pcileech_pcie_tlp_a7.sv`及相关模块）。确保所有字段（Fmt、Type、Requester ID、Tag、Completion ID、Length、Byte Enables、Address）都正确派生并打包到TLP结构中。\n     * **错误检查**：在固件中实现基本的错误检查（例如，检查是否存在意外的`req_valid`而没有`req_ready`，反之亦然）。\n2. **流控制问题**：\n\n   * **原因**：PCIe使用基于信用的流控制机制。如果您的固件（或PCIe IP核与其的交互）错误地管理信用，可能导致死锁、超时或丢包。症状包括PCIe链路“停滞”、超时或低吞吐量。\n   * **解决方案**：\n     * **PCIe IP核配置**：确保Vivado PCIe IP核定制中的流控制设置适用于您预期的流量模式。默认设置通常是健壮的。\n     * **用户逻辑反压**：您的用户逻辑向PCIe IP核发送TLP（`m_axis_tx_*`接口）*必须*遵守来自IP核的`m_axis_tx_tready`信号。如果`tready`被去断言，您*必须*暂停发送数据。否则将导致核的缓冲区溢出。\n     * **ILA调试**：将ILA探头连接到PCIe IP核的流控制接口信号和您的用户逻辑，以观察`tvalid`/`tready`握手是否正常工作。\n3. **DMA逻辑效率低下/缓冲问题**：\n\n   * **原因**：FPGA内部的DMA引擎实现（读取/写入主机内存数据的部分）未优化，导致瓶颈。这可能涉及：\n     * 缺少流水线。\n     * BRAM使用效率低下。\n     * 外部内存访问延迟导致的停滞。\n     * 突发大小过小。\n   * **解决方案**：\n     * **流水线**：将长组合路径分解为更小、更连续的阶段，使用寄存器。这允许更高的时钟频率和更好的吞吐量。\n     * **缓冲**：使用FIFO（先进先出缓冲区）来解耦发送方和接收方逻辑，平滑数据流并防止停滞。\n     * **突发传输**：利用PCIe执行突发读/写的能力以提高效率。确保您的DMA逻辑以适当的突发大小请求和处理数据。\n     * **内存带宽**：确保您的BRAM或外部DDR内存接口能够足够快地提供/消耗数据，以满足您所需的DMA速率。\n     * **ILA**：监控您的DMA引擎的内部状态、读写指针和数据路径信号，以识别瓶颈。\n4. **完成超时/不支持的请求**：\n\n   * **原因**：主机发送请求（例如MRd、CfgRd），但您的FPGA设备未在允许的超时时间内响应完成TLP，或者它以错误状态（例如，带有Unsupported Request (UR) 或 Completer Abort (CA) 的完成）进行响应。\n   * **解决方案**：\n     * **响应逻辑**：验证您的`bar_controller`（用于MRd）和`pcileech_pcie_cfg_a7.sv`（用于自定义配置空间的CfgRd）是否正确识别请求并生成适当的完成。\n     * **超时值**：审查您的捐赠设备预期的完成延迟。虽然PCIe定义了默认超时，但某些驱动程序可能对此敏感。\n     * **ILA/协议分析仪**：对于查明*为什么*未发送完成或完成格式错误至关重要。请求TLP是否甚至到达了您的用户逻辑？您的逻辑是否生成了响应？PCIe核是否成功发送了响应？\n\n---\n\n## **14. 仿真精度与优化**\n\n实现真正令人信服的仿真意味着让您的基于FPGA的设备与捐赠设备难以区分，不仅在ID上，而且在行为上。这需要对时序、响应速度和微妙的操作细节进行细致的关注。\n\n### **14.1 精确定时仿真技术**\n\n精确的时序在硬件中至关重要，特别是对于PCIe这样的高速接口。不匹配可能导致驱动程序超时、数据解释不正确或系统不稳定。\n\n* **实现时序约束（XDC文件）** ：\n\n  * **目的**：时序约束是 Vivado 综合和实现工具的指令，告诉它们您的设计需要运行多快。它们定义了时钟周期、输入/输出延迟和路径延迟。\n  * **用法**：PCILeech-FPGA项目包含 XDC 文件（例如，`pcileech_squirrel_top.xdc`），它们定义了主时钟（例如，`create_clock -name sys_clk_p -period 8.0 [get_ports sys_clk_p]`）。\n  * **优化**：如果您的仿真需要非常特定的内部时序或对时间敏感的命令做出反应，您可能需要在自定义逻辑中添加进一步的约束（`set_max_delay`、`set_input_delay`、`set_output_delay`）到关键路径。\n  * **目标**：确保 Vivado 在实现后报告所有路径的 **正 WNS（最差负余量）** ，表明设计满足其时序要求。\n* **使用时钟域交叉（CDC）技术**：\n\n  * **目的**：PCIe设计通常涉及多个时钟域（例如，125MHz PCIe用户时钟，自定义逻辑的单独时钟）。在这些域之间异步移动信号（没有适当的同步）可能导致**亚稳态**，从而导致不可靠的行为。\n  * **实现**：对于跨时钟域的信号，始终使用适当的CDC电路：\n    * **双触发器同步器**：用于单比特控制信号。\n    * **异步FIFO（先进先出）** ：用于多比特数据路径，提供时钟域之间的数据缓冲和流控制。\n    * **格雷码编码器/解码器**：用于跨域的计数器或地址，以确保每次只有一个比特发生变化。\n  * **Vivado 工具**：Vivado 包含 CDC 分析工具（例如，`report_cdc`），可以识别潜在的亚稳态问题。\n* **使用时间精确模型仿真设备行为**：\n\n  * **高级测试平台**：使用 SystemVerilog 测试平台，其中包含真实的定时延迟，甚至提供时间精确的 PCIe 总线功能模型（BFM）。\n  * **验证**：这使您可以观察您的仿真设备的内部状态以及外部 TLP 生成/响应时序在各种条件下如何表现，确保它们与您捕获的捐赠设备行为相匹配。\n\n### **14.2 对系统调用的动态响应**\n\n真正精确的仿真不仅能呈现正确的ID；它还能智能且动态地响应主机系统的命令和查询，模仿真实、活动设备的行为。\n\n* **实现设备控制的状态机**：\n\n  * **目的**：设计健壮的 SystemVerilog 状态机来管理设备的操作模式、命令处理和数据流。\n  * **响应性**：确保状态机能够逻辑地、快速地响应传入命令（例如，写入 BAR 中的控制寄存器，特定的 TLP）。\n  * **优雅处理**：状态机应能够优雅地处理意外或无序的请求，可能返回错误 TLP 或仅仅忽略无效命令，而不是崩溃或冻结。\n* **监控和响应主机命令（超越简单的读写）** ：\n\n  * **配置写入**：除了初始枚举之外，驱动程序通常会写入配置空间寄存器以启用功能、设置阈值或清除状态位。您的固件必须处理这些写入并相应地更新内部状态。\n  * **厂商特定命令**：如第9.2节所述，如果捐赠设备具有专有命令（通过自定义寄存器或厂商定义消息访问），您的固件必须解析这些命令并触发适当的仿真行为。\n  * **电源管理命令**：通过启用/禁用内部逻辑并确认状态更改来响应主机发起的电源状态转换（D0、D1、D3hot 等）。\n  * **中断确认**：如果主机驱动程序通过写入特定寄存器来确认中断，请确保您的固件能够检测到此并清除内部中断请求。\n* **优化固件逻辑以提高响应性**：\n\n  * **降低延迟**：关键数据路径和控制路径应优化，以最小化组合逻辑深度和流水线停顿。\n  * **并行性**：利用 FPGA 固有的并行性来同时执行多个操作，提高吞吐量和响应时间。\n  * **高效内存访问**：优化对内部 BRAM 或外部 DDR 内存的访问，以确保在需要时为 DMA 传输或寄存器读取提供数据。\n  * **硬件加速**：对于捐赠设备执行的复杂计算或数据操作，请考虑在 FPGA 上实现专用的硬件加速器，而不是尝试以缓慢、类似软件的方式执行它们。\n\n---\n\n## **15. 固件开发最佳实践**\n\n在定制固件开发中遵循最佳实践对于保持代码质量、促进协作（如果团队合作）、简化调试以及确保项目的长期可维护性和可靠性至关重要。这对于安全敏感的应用尤为如此。\n\n### **15.1 持续测试与文档**\n\n* **定期、增量测试**：\n\n  * **单元测试**：使用专用测试平台隔离测试小型独立模块（例如，TLP解析器、寄存器块）。\n  * **集成测试**：验证不同模块是否协同工作。\n  * **系统测试**：烧录后，与主机系统执行端到端测试，确保整体功能。\n  * **尽早测试，经常测试**：在每次重大更改后，无论多小，都要测试固件，以便尽早发现问题，此时问题更容易调试。\n* **自动化测试（高级）** ：\n\n  * 对于复杂项目，在主机端实现自动化测试脚本（例如，使用Python和硬件抽象层）以重复验证功能和性能。\n  * 在团队环境中，考虑与持续集成（CI）工具（例如，Jenkins、GitLab CI）集成，以自动化每次代码提交的构建、测试和静态分析。\n* **维护全面的文档**：\n\n  * **设计文档**：创建并更新描述固件架构的文档，包括：\n    * **框图**：说明主要模块及其互连。\n    * **状态机图**：适用于所有有状态逻辑。\n    * **接口规范**：详细说明模块之间的输入/输出信号、时序和协议。\n    * **内存映射**：针对所有BAR，定义寄存器地址、位域及其功能。\n  * **代码注释**：在SystemVerilog代码中使用清晰、简洁的注释来解释复杂的逻辑、信号的目的以及任何不明显的设计选择。\n  * **更改日志/提交消息**：维护更改日志或使用详细的Git提交消息来跟踪所有修改、错误修复和功能添加，解释*为什么*进行更改。\n  * **用户指南**：对于您的定制固件，一个简单的用户指南，解释如何从主机端构建、烧录和与仿真设备交互，是无价的。\n\n### **15.2 管理固件版本**\n\n正确的版本控制对于跟踪更改、有效协作和管理发布至关重要。\n\n* **使用版本控制系统（VCS）** ：\n\n  * **Git**：强烈推荐。使用Git管理您的HDL源代码、约束文件和项目脚本。\n  * **组织仓库**：保持清晰的目录结构（例如，为`src`、`xdc`、`ip`、`scripts`、`doc`等设置单独的文件夹）。\n  * **分支**：使用功能分支开发新功能或进行重大更改。在彻底测试后合并回`main`或`develop`分支。\n  * **定期提交**：频繁提交，提交内容原子化，提交消息有意义。\n* **标记发布和里程碑**：\n\n  * **稳定版本**：使用Git标签（例如，`v1.0.0`、`v1.0.1_bugfix`）标记固件的稳定、经过测试的版本。这使得回溯或部署已知良好状态变得容易。\n  * **里程碑**：标记重要的开发里程碑（例如，“基本枚举工作正常”、“DMA读/写功能正常”）。\n* **备份和恢复策略**：\n\n  * **基于云的仓库**：将您的Git仓库托管在GitHub、GitLab或Bitbucket等平台上。这提供了异地备份并促进了协作。\n  * **本地备份**：即使有云仓库，也要定期对整个Vivado项目目录进行本地备份（由于生成的文件，它可能非常大）。\n\n### **15.3 安全注意事项**\n\n开发用于PCIe设备仿真（特别是能够直接内存访问的设备）的定制固件具有重要的安全影响。这项技术本质上是一种“两用”能力，意味着它既可以用于合法目的（例如，硬件测试、安全研究），也可以用于恶意目的（例如，DMA攻击、安全绕过）。**理解并负责任地管理这些风险至关重要。**\n\n* **两用性质与道德影响**：\n\n  * **道德黑客行为与恶意使用**：明确区分将这些知识用于授权安全测试（红队演练、渗透测试）和未经授权的非法活动。\n  * **负责任的披露**：如果您使用这些技术发现漏洞，请遵循负责任的披露准则。\n  * **法律和许可合规性**：了解并遵守所有与硬件逆向工程和设备修改相关的法律、法规和许可协议（例如，PCIe-SIG规范、Xilinx EULA）。\n  *  **“武器化”** ：认识到精确仿真受信任硬件的能力可以被武器化用于高级持久威胁（APTs）或复杂恶意软件。\n* **理解攻击向量（攻击视角）** ：\n\n  * **内存窃取**：恶意仿真设备可以执行DMA读取，以访问任何物理内存地址，包括内核、用户进程中的敏感数据、加密密钥或网络缓冲区。\n  * **内存注入/修改**：恶意仿真设备可以执行DMA写入以任意修改内存，从而实现：\n    * **权限提升**：修改内核数据结构（例如，进程令牌、SID）以获得管理员或系统权限。\n    * **代码注入**：将恶意代码注入正在运行的进程或内核，然后触发其执行。\n    * **安全软件绕过**：通过直接修改内存来禁用或颠覆端点检测和响应（EDR）、防病毒或防火墙软件。\n  * **模糊测试和崩溃**：发送格式错误或不符合规范的TLP/命令，以触发驱动程序漏洞，导致系统崩溃（蓝屏死机）或潜在的可利用内存损坏。\n  * **固件/BIOS操作**：在某些高级场景中，DMA设备可能能够与包含BIOS/UEFI的主机SPI闪存进行交互，可能用于持久性修改。\n* **防御措施和缓解策略（防御视角）** ：\n\n  * **IOMMU/VT-d/AMD-Vi**：如第3.2节所述，这些技术旨在通过为外设提供内存保护来缓解DMA攻击。**对于合法测试，您会禁用它们，但在生产系统中，它们应始终启用。**  它们阻止外设未经授权的内存访问。\n  * **内核DMA保护（Windows）/ Thunderbolt安全（Linux）** ：现代操作系统功能专门解决“冷启动”DMA攻击（攻击者在系统关闭或锁定时连接恶意设备）。在生产系统上保持这些功能启用。\n  * **安全启动**：虽然不是直接的DMA保护，但安全启动有助于确保只加载受信任的引导加载程序和内核模块，从而减少攻击者注入恶意内核组件以绕过DMA保护的机会。\n  * **物理安全**：最基本但最关键的防御。如果攻击者可以物理访问PCIe插槽或Thunderbolt端口，他们可以绕过许多软件保护。保护对关键系统的物理访问。\n  * **驱动程序强化**：驱动程序应以防御性方式编写，严格验证来自硬件的所有输入并在严格的内存边界内操作。\n  * **内存强化**：操作系统级的内存保护（例如KASLR、DEP、SMAP/SMEP）有助于减少内存损坏的影响，但直接DMA攻击会绕过这些保护。\n  * **监控和日志记录**：虽然在硬件层面很难，但异常的DMA活动或未知PCIe设备的枚举应在安全监控系统中触发警报。\n* **固件安全编码实践**：\n\n  * **输入验证**：如果您的固件接受任何输入（例如，通过UART调试接口，或由主机写入的内部寄存器），请严格验证它们，以防止缓冲区溢出、整数溢出或意外行为。\n  * **最小权限**：设计您的固件逻辑，使其仅执行其功能绝对必要的操作。避免授予不必要的功能。\n  * **状态管理**：实现健壮的状态机，以防止由于无效状态转换而导致的意外行为。\n  * **无硬编码秘密**：避免直接在固件中嵌入敏感信息（例如，加密密钥、硬编码凭据），如果它们可以轻易被提取。\n  * **篡改检测**：对于生产固件，考虑实现检测固件本身是否已被篡改或是否加载了未经授权配置的机制。\n\n---\n\n## **16. 其他资源**\n\n为了加深您对FPGA开发、PCIe和硬件安全等动态领域的理解并保持更新，请查阅以下资源：\n\n* **Xilinx (AMD) 文档**：您获取Vivado和Xilinx FPGA所有信息的主要来源。\n\n  * **主文档门户**：[https://docs.amd.com/](https://docs.amd.com/)（原Xilinx.com/support/documentation）。\n  * **Vivado 设计套件用户指南**：\n    * **UG900 - 入门指南**：Vivado新用户必备。\n    * **UG901 - 逻辑综合**：深入了解综合。\n    * **UG904 - 实现**：关于放置和布线的详细指南。\n    * **UG912 - Tcl 命令参考指南**：对于脚本编写价值巨大。\n    * **UG939 - 调试**：ILA和其他调试功能的综合指南。\n  * **PCI Express IP 核用户指南**：理解Xilinx PCIe IP至关重要（例如，**PG054 for 7 Series Integrated Block for PCI Express**）。在文档门户上搜索“PCI Express”。这详细介绍了核的配置、接口和限制。\n* **PCI-SIG 规范**：PCIe 标准的权威来源。\n\n  * **PCI Express Base Specification**：基础文档。虽然不公开免费，但基于它的摘要和教育材料广泛可用。您通常可以在其网站上找到信息：[https://pcisig.com/specifications](https://pcisig.com/specifications)（注意：完整规范通常需要PCI-SIG会员资格）。\n* **FPGA 教程和学习平台**：\n\n  * **FPGA4Fun**：[http://www.fpga4fun.com/](http://www.fpga4fun.com/) - 一个经典网站，提供许多实用的FPGA项目和教程。\n  * **Verilog/VHDL 教程**：\n    * **ASIC World Verilog 教程**：[https://www.asic-world.com/verilog/index.html](https://www.asic-world.com/verilog/index.html) - 很好的Verilog基础参考。\n    * **VHDLwhiz**：[https://www.vhdlwhiz.com/](https://www.vhdlwhiz.com/) - VHDL 参考和教程。\n  * **Stack Overflow (FPGA/Verilog/PCIe 标签)** ：[https://stackoverflow.com/questions/tagged/fpga](https://stackoverflow.com/questions/tagged/fpga) - 社区驱动的针对特定技术问题的问答。\n* **PCIe 协议分析工具**：\n\n  * **Teledyne LeCroy Protocol Analyzers**：[https://teledynelecroy.com/protocolanalyzer/](https://teledynelecroy.com/protocolanalyzer/) - 探索他们的高性能PCIe分析仪和软件系列。\n  * **Telescan PE Software**：[https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software](https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software) - 一款免费软件工具，提供一些PCIe分析功能（需要注册）。\n* **PCILeech 社区和资源**：\n\n  * `ufrisk/pcileech` GitHub 仓库是核心。积极关注其更新和问题。\n  * 寻找致力于PCILeech或类似开源DMA项目的社区论坛或Discord服务器。\n* **硬件安全与逆向工程**：\n\n  * 关于硬件黑客、逆向工程和低级系统利用的书籍。\n  * Black Hat、DEF CON、Recon 和 Troopers 等会议通常会举办关于 PCIe 和 DMA 攻击的讲座。\n  * 专注于硬件的安全研究人员的博客和研究论文。\n\n---\n\n## **17. 联系方式**\n\n如果您需要帮助、有疑问或希望就本指南、固件开发或硬件安全相关主题进行合作，请随时联系。我乐意提供指导、解决复杂问题或详细讨论想法。\n\n### **Discord**：\n\n* **用户**：**[VCPU](https://discord.com/users/196741541094621184)**\n* **服务器邀请链接**：**[加入硬件黑客与固件开发Discord](https://discord.gg/dS2gDUDQmV)**\n\n---\n\n## **18. 支持与贡献**\n\n您的支持有助于维护和改进本指南及相关项目。创建和更新全面的技术文档以及开源硬件项目需要大量时间和精力。\n\n### **捐赠**\n\n如果您觉得本指南有帮助并希望支持正在进行的工作，请考虑捐赠。每一笔捐款，无论大小，都有助于我们继续通过进一步的研究、开发和文档工作来创建、分享和支持社区。\n\n* **加密货币捐赠（LTC - 莱特币）** ：\n  * **地址**：`MPMyQD5zgy2b2CpDn1C1KZ31KmHpT7AwRi`\n\n**特别奖励**：如果您捐赠，请随时在Discord上（VCPU）与我联系，以获得个人感谢，并可能获得额外资源、新内容的早期访问或项目上的个性化帮助。\n\n**注意**：如果您需要我审查您实现的特定部分、解决问题或提供详细的代码反馈，请在您的代码中用`//VCPU-REVIEW//`注释标记相关部分，并提供您遇到的问题或疑问的详细说明。这有助于我集中精力并提供最有效的支持。\n\n愿上帝保佑您的灵魂。\n\n---\n\n**指南结束**\n","slug":"custom-firmware-development-guide-for-fulldevice-simulation-z17aist","published":1,"__permalink":"/post/custom-firmware-development-guide-for-fulldevice-simulation-z17aist.html","_id":"cmdxvwf1300040wsd2ns9f5k9","layout":"post","photos":[],"content":"<h1 id=\"全设备仿真的定制固件开发指南\"><a href=\"#全设备仿真的定制固件开发指南\" class=\"headerlink\" title=\"全设备仿真的定制固件开发指南\"></a>全设备仿真的定制固件开发指南</h1><h1 id=\"全设备仿真的定制固件开发指南-1\"><a href=\"#全设备仿真的定制固件开发指南-1\" class=\"headerlink\" title=\"全设备仿真的定制固件开发指南\"></a><strong>全设备仿真的定制固件开发指南</strong></h1><hr>\n<p><strong>特别鸣谢慷慨捐助的传奇人物，我将很快与您联系。如果您愿意，请DM我，我会在本文中添加鸣谢并提供更多信息！</strong></p>\n<p>正在将此指南整理到<a href=\"https://github.com/JPShag/PCILeech-DMA-Firmware/wiki/Introduction\">维基</a>中。欢迎提供帮助！</p>\n<hr>\n<p><strong>作者留言及指南状态：</strong></p>\n<p>我正在透明地分享这一切，因为最近的日子异常艰难。除了因欺诈性退款造成的巨大经济损失外，我还面临多重生活和健康困境，严重影响了我上网和投入项目的时间。坦率地说，在这些个人困难中，继续创作像本指南这样全面的资源已成为一项深刻的挣扎。</p>\n<p>这预计是主指南的最后一次重大迭代。对于已经熟悉基本硬件概念（例如，FTDI芯片的功能）的更有经验的用户，我们将提供一个简洁的精简版。</p>\n<p>如果您觉得这项工作有价值并能够提供帮助，任何形式的支持都将不胜感激。您的慷慨使我尽管面临持续的挑战，仍能继续为这个社区做出贡献。我真诚地希望本指南已经并将继续成为一份宝贵的资源。</p>\n<hr>\n<h2 id=\"纪念与献词\"><a href=\"#纪念与献词\" class=\"headerlink\" title=\"纪念与献词\"></a>纪念与献词</h2><p><img src=\"https://github.com/user-attachments/assets/de7f12fe-8992-4738-a6af-712dc48217ee\" alt=\"Ross\"></p>\n<p>本指南谨献给<br><strong>Ross Freeman (1947–1989)</strong>  的记忆</p>\n<p>作为一位富有远见的工程师、杰出的密歇根人，以及Xilinx的联合创始人，Ross Freeman被广泛认为是现场可编程门阵列（FPGA）技术之父，该技术彻底改变了计算领域。</p>\n<p>在1984年，半导体行业主要专注于固定功能芯片之时，Freeman敢于想象一种不同的范式：制造后可以重新编程的硬件。他的革命性专利（#4,870,302）和对可重构计算的不懈倡导，开启了一个四十年后仍在改变我们世界的科技范式。</p>\n<p>他的开创性创新使得在无需承担传统ASIC开发高昂成本的情况下，快速原型化和部署定制芯片解决方案成为可能，从而使硬件设计民主化，并加速了无数领域的技术进步。</p>\n<p>如今，Freeman的愿景驱动着人工智能、高性能计算、电信、汽车系统、航空航天应用以及他在世时仅是梦想的许多其他领域的尖端发展。</p>\n<p>他于2009年被追授进入国家发明家名人堂，其遗产不仅体现在硅片中，更体现在挑战我们所有人质疑既定限制并想象新可能性的技术勇气精神中。</p>\n<p> <em>“FPGA的最终目标是制造可编程逻辑器件，以取代标准数字芯片。”</em>  — Ross Freeman</p>\n<hr>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a><strong>目录</strong></h2><h3 id=\"第一部分：基础概念\"><a href=\"#第一部分：基础概念\" class=\"headerlink\" title=\"第一部分：基础概念\"></a><strong>第一部分：基础概念</strong></h3><ol>\n<li><a href=\"#1-%E5%BC%95%E8%A8%80\">引言</a><ul>\n<li><a href=\"#11-%E6%9C%AC%E6%8C%87%E5%8D%97%E7%9A%84%E7%9B%AE%E7%9A%84\">1.1 本指南的目的</a></li>\n<li><a href=\"#12-%E7%9B%AE%E6%A0%87%E8%AF%BB%E8%80%85\">1.2 目标读者</a></li>\n<li><a href=\"#13-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E6%8C%87%E5%8D%97\">1.3 如何使用本指南</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%E5%85%B3%E9%94%AE%E5%AE%9A%E4%B9%89\">关键定义</a></li>\n<li><a href=\"#3-%E8%AE%BE%E5%A4%87%E5%85%BC%E5%AE%B9%E6%80%A7\">设备兼容性</a><ul>\n<li><a href=\"#31-%E6%94%AF%E6%8C%81%E7%9A%84%E5%9F%BA%E4%BA%8Efpga%E7%9A%84%E7%A1%AC%E4%BB%B6\">3.1 支持的基于FPGA的硬件</a></li>\n<li><a href=\"#32-pcie%E7%A1%AC%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">3.2 PCIe硬件注意事项</a></li>\n<li><a href=\"#33-%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82\">3.3 系统要求</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E8%A6%81%E6%B1%82\">要求</a><ul>\n<li><a href=\"#41-%E7%A1%AC%E4%BB%B6\">4.1 硬件</a></li>\n<li><a href=\"#42-%E8%BD%AF%E4%BB%B6\">4.2 软件</a></li>\n<li><a href=\"#43-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE\">4.3 环境设置</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E6%94%B6%E9%9B%86%E6%8D%90%E8%B5%A0%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF\">收集捐赠设备信息</a><ul>\n<li><a href=\"#51-%E4%BD%BF%E7%94%A8arbor%E8%BF%9B%E8%A1%8Cpcie%E8%AE%BE%E5%A4%87%E6%89%AB%E6%8F%8F\">5.1 使用Arbor进行PCIe设备扫描</a></li>\n<li><a href=\"#52-%E6%8F%90%E5%8F%96%E5%92%8C%E8%AE%B0%E5%BD%95%E8%AE%BE%E5%A4%87%E5%B1%9E%E6%80%A7\">5.2 提取和记录设备属性</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E5%88%9D%E5%A7%8B%E5%9B%BA%E4%BB%B6%E5%AE%9A%E5%88%B6\">初始固件定制</a><ul>\n<li><a href=\"#61-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4\">6.1 修改配置空间</a></li>\n<li><a href=\"#62-%E6%8F%92%E5%85%A5%E8%AE%BE%E5%A4%87%E5%BA%8F%E5%88%97%E5%8F%B7dsn\">6.2 插入设备序列号（DSN）</a></li>\n</ul>\n</li>\n<li><a href=\"#7-vivado%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%AE%9A%E5%88%B6\">Vivado项目设置与定制</a><ul>\n<li><a href=\"#71-%E7%94%9F%E6%88%90vivado%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6\">7.1 生成Vivado项目文件</a></li>\n<li><a href=\"#72-%E4%BF%AE%E6%94%B9ip%E6%A0%B8\">7.2 修改IP核</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第二部分：中级概念与实现\"><a href=\"#第二部分：中级概念与实现\" class=\"headerlink\" title=\"第二部分：中级概念与实现\"></a><strong>第二部分：中级概念与实现</strong></h3><ol start=\"8\">\n<li><a href=\"#8-%E9%AB%98%E7%BA%A7%E5%9B%BA%E4%BB%B6%E5%AE%9A%E5%88%B6\">高级固件定制</a><ul>\n<li><a href=\"#81-%E9%85%8D%E7%BD%AEpcie%E5%8F%82%E6%95%B0%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F\">8.1 配置PCIe参数以进行仿真</a></li>\n<li><a href=\"#82-%E8%B0%83%E6%95%B4bars%E5%92%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84\">8.2 调整BARs和内存映射</a></li>\n<li><a href=\"#83-%E4%BB%BF%E7%9C%9F%E8%AE%BE%E5%A4%87%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E4%B8%AD%E6%96%AD\">8.3 仿真设备电源管理和中断</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%E4%BB%BF%E7%9C%9F%E8%AE%BE%E5%A4%87%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD\">仿真设备特定功能</a><ul>\n<li><a href=\"#91-%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7pcie%E5%8A%9F%E8%83%BD\">9.1 实现高级PCIe功能</a></li>\n<li><a href=\"#92-%E4%BB%BF%E7%9C%9F%E5%8E%82%E5%95%86%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD\">9.2 仿真厂商特定功能</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E4%BA%8B%E5%8A%A1%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85tlp%E4%BB%BF%E7%9C%9F\">事务层数据包（TLP）仿真</a><ul>\n<li><a href=\"#101-%E7%90%86%E8%A7%A3%E5%92%8C%E6%8D%95%E8%8E%B7tlp\">10.1 理解和捕获TLP</a></li>\n<li><a href=\"#102-%E5%88%B6%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9A%E5%88%B6tlp\">10.2 制作用于特定操作的定制TLP</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第三部分：高级技术与优化\"><a href=\"#第三部分：高级技术与优化\" class=\"headerlink\" title=\"第三部分：高级技术与优化\"></a><strong>第三部分：高级技术与优化</strong></h3><ol start=\"11\">\n<li><a href=\"#11-%E6%9E%84%E5%BB%BA%E7%83%A7%E5%BD%95%E4%B8%8E%E6%B5%8B%E8%AF%95\">构建、烧录与测试</a><ul>\n<li><a href=\"#111-%E7%BB%BC%E5%90%88%E4%B8%8E%E5%AE%9E%E7%8E%B0\">11.1 综合与实现</a></li>\n<li><a href=\"#112-%E7%83%A7%E5%BD%95%E6%AF%94%E7%89%B9%E6%B5%81\">11.2 烧录比特流</a></li>\n<li><a href=\"#113-%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%AA%8C%E8%AF%81\">11.3 测试与验证</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF\">高级调试技术</a><ul>\n<li><a href=\"#121-%E4%BD%BF%E7%94%A8vivado%E7%9A%84%E9%9B%86%E6%88%90%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA\">12.1 使用Vivado的集成逻辑分析仪</a></li>\n<li><a href=\"#122-pcie%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7\">12.2 PCIe流量分析工具</a></li>\n</ul>\n</li>\n<li><a href=\"#13-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4\">故障排除</a><ul>\n<li><a href=\"#131-%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B%E9%97%AE%E9%A2%98\">13.1 设备检测问题</a></li>\n<li><a href=\"#132-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%92%8Cbar%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF\">13.2 内存映射和BAR配置错误</a></li>\n<li><a href=\"#133-dma%E6%80%A7%E8%83%BD%E5%92%8Ctlp%E9%94%99%E8%AF%AF\">13.3 DMA性能和TLP错误</a></li>\n</ul>\n</li>\n<li><a href=\"#14-%E4%BB%BF%E7%9C%9F%E7%B2%BE%E5%BA%A6%E4%B8%8E%E4%BC%98%E5%8C%96\">仿真精度与优化</a><ul>\n<li><a href=\"#141-%E7%B2%BE%E7%A1%AE%E5%AE%9A%E6%97%B6%E4%BB%BF%E7%9C%9F%E6%8A%80%E6%9C%AF\">14.1 精确定时仿真技术</a></li>\n<li><a href=\"#142-%E5%AF%B9%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%93%8D%E5%BA%94\">14.2 对系统调用的动态响应</a></li>\n</ul>\n</li>\n<li><a href=\"#15-%E5%9B%BA%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">固件开发最佳实践</a><ul>\n<li><a href=\"#151-%E6%8C%81%E7%BB%AD%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%96%87%E6%A1%A3\">15.1 持续测试与文档</a></li>\n<li><a href=\"#152-%E7%AE%A1%E7%90%86%E5%9B%BA%E4%BB%B6%E7%89%88%E6%9C%AC\">15.2 管理固件版本</a></li>\n<li><a href=\"#153-%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">15.3 安全注意事项</a></li>\n</ul>\n</li>\n<li><a href=\"#16-%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90\">其他资源</a></li>\n<li><a href=\"#17-%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F\">联系方式</a></li>\n<li><a href=\"#18-%E6%94%AF%E6%8C%81%E4%B8%8E%E8%B4%A1%E7%8C%AE\">支持与贡献</a></li>\n</ol>\n<hr>\n<h2 id=\"第一部分：基础概念-1\"><a href=\"#第一部分：基础概念-1\" class=\"headerlink\" title=\"第一部分：基础概念\"></a><strong>第一部分：基础概念</strong></h2><hr>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1. 引言\"></a><strong>1. 引言</strong></h2><h3 id=\"1-1-本指南的目的\"><a href=\"#1-1-本指南的目的\" class=\"headerlink\" title=\"1.1 本指南的目的\"></a><strong>1.1 本指南的目的</strong></h3><p>本指南的总体目标是让您掌握开发基于现场可编程门阵列（FPGA）设备的定制直接内存访问（DMA）固件的知识和实践技能。这种专用固件允许您的FPGA精确地仿真其他PCIe（Peripheral Component Interconnect Express）硬件设备的身份和行为。这种仿真是一种强大的技术，在多个高级领域具有深远意义：</p>\n<p><strong>硬件安全研究</strong>：</p>\n<ul>\n<li><strong>漏洞发现</strong>：通过仿真设备，您可以创建一个受控环境，向主机驱动程序发送格式错误或意外数据，系统性地进行模糊测试，以发现可能通过硬件外设利用的漏洞（例如，缓冲区溢出、竞态条件）。</li>\n<li><strong>驱动程序分析</strong>：观察操作系统和特定驱动程序如何与硬件交互。您可以仿真具有非标准配置或未文档化功能的设备，以了解驱动程序行为、识别安全假设或逆向工程专有协议。</li>\n<li><strong>侧信道分析</strong>：虽然更复杂，但仿真设备可以通过精确控制外设操作，潜在地协助进行与通过时序或功耗分析进行信息泄漏相关的实验。</li>\n</ul>\n<p><strong>红队演练与渗透测试</strong>：</p>\n<ul>\n<li><strong>绕过安全措施</strong>：仿真一个看似良性或白名单的硬件设备（例如，一个常见的网卡或存储控制器），以获取DMA权限。一旦实现，这允许直接与系统内存交互，可能绕过在更高软件层运行的端点检测和响应（EDR）系统或反恶意软件解决方案。</li>\n<li><strong>隐蔽持久性</strong>：仿真恶意设备可以提供一种隐蔽的方式来维护对受损系统的访问，因为它可能比基于软件的植入物更难检测。</li>\n<li><strong>利用信任关系</strong>：系统通常对连接的硬件有隐式信任。定制固件可以通过模仿被授予特定权限或访问的设备来利用这一点。</li>\n</ul>\n<p><strong>系统调试与诊断</strong>：</p>\n<ul>\n<li><strong>可复现的测试平台</strong>：创建高度特定的硬件场景，以可靠地复现可能仅在特定设备状态或数据模式下发生的难以捉摸的错误。</li>\n<li><strong>故障注入</strong>：故意仿真有缺陷的设备行为（例如，错误的TLP形成、延迟响应），以测试主机系统及其驱动程序的健壮性和错误处理能力。</li>\n</ul>\n<p><strong>硬件测试与验证</strong>：</p>\n<ul>\n<li><strong>驱动程序开发</strong>：在物理原型可用之前，或为了模拟比物理可访问的更广泛的硬件变体，针对仿真硬件配置文件测试新的或修改的驱动程序。</li>\n<li><strong>合规性测试</strong>：虽然不能替代官方合规性测试，但仿真设备可以帮助预验证PCIe协议遵守的某些方面。</li>\n</ul>\n<p><strong>传统系统支持与互操作性</strong>：</p>\n<ul>\n<li>仿真老旧、停产或难以采购的PCIe设备，以保持传统系统运行或弥合不同硬件代之间的兼容性差距。</li>\n</ul>\n<p>通过学习本指南，您将熟练掌握：</p>\n<ul>\n<li>精细地从物理“捐赠”PCIe设备中提取识别属性和配置细节。</li>\n<li>修改和扩展现有开源FPGA固件框架（主要关注广泛使用的PCILeech-FPGA项目），以采用捐赠设备的身份。</li>\n<li>配置和利用以Xilinx Vivado为核心的专业FPGA开发工具链，以及Visual Studio Code等基本代码编辑工具。</li>\n<li>对PCIe架构的分层模型、DMA数据传输机制以及低级别复制硬件行为的固件开发细微之处，形成扎实的理解。</li>\n</ul>\n<h3 id=\"1-2-目标读者\"><a href=\"#1-2-目标读者\" class=\"headerlink\" title=\"1.2 目标读者\"></a><strong>1.2 目标读者</strong></h3><p>本指南专为已具备计算机系统、硬件原理和软件开发基础到中级知识的个人量身定制。内容技术性强，并假定读者具备进行详细、低级别工作的能力。具体来说，它面向以下人群：</p>\n<ul>\n<li><strong>固件开发人员</strong>：旨在为FPGA设计或改编固件的工程师，特别是涉及高速数据传输（DMA）和通过PCIe直接硬件接口操作的应用。强烈建议具备Verilog&#x2F;VHDL背景和FPGA开发工具经验。</li>\n<li><strong>硬件工程师</strong>：参与PCIe硬件设计、测试或验证的专业人员。本指南可以帮助创建复杂的测试线束或在更大的系统设计中仿真组件。预计熟悉PCIe协议和数字设计。</li>\n<li><strong>网络安全专业人员与研究人员</strong>：<ul>\n<li><strong>漏洞研究员与漏洞利用开发人员</strong>：希望探索硬件级攻击面或开发利用DMA的概念验证漏洞。操作系统内部、内存管理和驱动程序架构的理解至关重要。</li>\n<li><strong>红队成员</strong>：寻求通过直接硬件操作来获取系统访问、持久性和数据窃取的先进技术操作员。</li>\n<li><strong>数字取证与事件响应人员</strong>：虽然本指南侧重于攻击，但理解这些技术有助于识别和分析复杂的基于硬件的攻击。</li>\n</ul>\n</li>\n<li><strong>FPGA爱好者与高级业余爱好者</strong>：有FPGA项目经验，渴望应对PCIe通信和硬件仿真等复杂挑战的个人。愿意深入研究数据手册和技术规范是关键。</li>\n</ul>\n<p>学习曲线可能很陡峭，特别是如果PCIe或高级FPGA概念是新知识。然而，本指南旨在将复杂主题分解为可管理的步骤。</p>\n<h3 id=\"1-3-如何使用本指南\"><a href=\"#1-3-如何使用本指南\" class=\"headerlink\" title=\"1.3 如何使用本指南\"></a><strong>1.3 如何使用本指南</strong></h3><p>本指南分为三个逻辑递进的部分，旨在逐步构建您的知识：</p>\n<ul>\n<li><strong>第一部分：基础概念</strong>：这第一部分至关重要。它介绍了核心术语、PCIe和DMA的基本原理、必要的硬件和软件堆栈（包括Xilinx Vivado和PCILeech-FPGA框架等工具的设置说明），以及从目标“捐赠”设备获取重要信息和进行基本固件修改的初始程序。强烈建议按顺序彻底学习本部分。</li>\n<li><strong>第二部分：中级概念与实现</strong>：（后续章节）在基础知识之上，本部分将引导您进行更高级的固件定制。主题将包括微调PCIe操作参数、仿真设备特定寄存器和功能（如电源管理状态和消息信号中断 - MSI&#x2F;MSI-X），以及初步理解事务层数据包（TLP）的构建和解释。</li>\n<li><strong>第三部分：高级技术与优化</strong>：（后续章节）最后一部分将探讨复杂的调试方法（包括使用集成逻辑分析仪 - ILA和外部PCIe协议分析仪）、优化固件性能和仿真精度的技术、常见和复杂问题的全面故障排除，以及关于最佳实践的关键讨论，特别关注开发和部署仿真PCIe设备的安全影响。</li>\n</ul>\n<p><strong>学习本指南的步骤</strong>：</p>\n<ul>\n<li><strong>顺序学习</strong>：特别是对于第一部分和第二部分，请按顺序学习各节，因为后面的概念建立在前面的基础之上。</li>\n<li><strong>动手实践</strong>：这是一份实践指南。请在您自己的硬件上积极执行设置步骤、代码修改和实验。</li>\n<li><strong>适应您的环境</strong>：文件路径、特定设备ID和软件版本可能有所不同。理解指令背后的概念，以使其适应您的特定设置。</li>\n<li><strong>查阅外部资源</strong>：PCIe规范和FPGA文档是您的最终参考。本指南进行简化和引导，但深入研究通常需要查阅原始资料。</li>\n<li><strong>迭代开发</strong>：固件开发很少是线性的。预期会进行迭代、调试和改进您的设计。广泛使用故障排除部分和调试技术。</li>\n</ul>\n<p>您将使用HDL（PCILeech-FPGA中的SystemVerilog）、FPGA综合和实现工具（Vivado），并可能使用主机端编程工具和PCIe分析实用程序。</p>\n<hr>\n<h2 id=\"2-关键定义\"><a href=\"#2-关键定义\" class=\"headerlink\" title=\"2. 关键定义\"></a><strong>2. 关键定义</strong></h2><p>牢固掌握以下术语对于理解PCIe设备仿真和定制固件开发的复杂性至关重要。这些术语将在整个指南中广泛使用。</p>\n<ul>\n<li><p><strong>DMA (Direct Memory Access)</strong>  (直接内存访问)：</p>\n<ul>\n<li><strong>定义</strong>：现代计算机体系结构的一项基本功能，允许硬件外设（如网卡、GPU或您的基于FPGA的仿真设备）直接读取和写入主系统内存（RAM），而无需CPU参与每个字节的传输。</li>\n<li><strong>重要性</strong>：DMA对于高性能I&#x2F;O操作至关重要。通过将数据传输任务从CPU卸载，它使CPU能够执行其他计算，显著提高整体系统吞吐量和效率。在本指南中，您的FPGA将利用DMA与主机系统的内存进行交互，这是一种在安全研究和红队演练中经常被利用的强大功能。</li>\n</ul>\n</li>\n<li><p><strong>PCIe (Peripheral Component Interconnect Express)</strong>  (外围组件互连高速)：</p>\n<ul>\n<li><strong>定义</strong>：一种高速串行计算机扩展总线标准，旨在取代旧的总线标准，如PCI、PCI-X和AGP。它采用点对点拓扑结构，每个设备通过独立的串行链路连接到根联合体（通常是芯片组或CPU的一部分）。通信通过数据包进行。</li>\n<li><strong>重要性</strong>：PCIe是连接高性能外设到主板的主导标准。理解其协议、分层架构（物理层、数据链路层、事务层）和配置机制对于仿真任何现代硬件设备至关重要。</li>\n</ul>\n</li>\n<li><p><strong>TLP (Transaction Layer Packet)</strong>  (事务层数据包)：</p>\n<ul>\n<li><strong>定义</strong>：PCIe协议事务层的数据交换基本单位。TLP负责在PCIe设备之间传输请求（例如，内存读&#x2F;写、I&#x2F;O读&#x2F;写、配置读&#x2F;写）和完成（对请求的响应）。每个TLP由一个报头、一个可选的数据有效载荷和一个可选的端到端CRC（ECRC）组成。</li>\n<li><strong>重要性</strong>：为了精确仿真设备，您的FPGA固件必须能够正确地形成、传输、接收和解释与捐赠设备行为匹配的TLP。理解TLP类型、格式和流控制对于高级仿真至关重要。</li>\n</ul>\n</li>\n<li><p><strong>BAR (Base Address Register)</strong>  (基地址寄存器)：</p>\n<ul>\n<li><strong>定义</strong>：位于PCIe设备的配置空间内，BAR是特殊的寄存器，设备通过它们向主机系统请求地址空间资源。一个设备最多可以有六个32位BAR（或更少，或成对的32位BAR可以形成64位BAR）。这些寄存器定义了设备用于向主机CPU公开其寄存器和内部内存的内存映射I&#x2F;O（MMIO）区域或I&#x2F;O端口区域的起始地址和大小。</li>\n<li><strong>重要性</strong>：当主机系统枚举PCIe设备时，它会读取BAR以确定设备的内存和I&#x2F;O要求，然后分配并用系统中物理地址图中的实际基地址来编程这些BAR。您的仿真设备必须精确定义其BAR以匹配捐赠设备，以便主机操作系统和驱动程序能够正确地与其交互。</li>\n</ul>\n</li>\n<li><p><strong>FPGA (Field-Programmable Gate Array)</strong>  (现场可编程门阵列)：</p>\n<ul>\n<li><strong>定义</strong>：一种集成电路（IC），可以在制造后由设计者或客户进行配置——因此称为“现场可编程”。FPGA包含一个可编程逻辑块阵列和可重构互连的层次结构，允许这些块“连接”起来以实现定制数字逻辑电路。</li>\n<li><strong>重要性</strong>：FPGA是本指南中使用的核心硬件。其可重构特性使其成为仿真其他硬件设备的理想选择，因为您可以定义精确的逻辑和接口来模仿捐赠设备的PCIe存在和行为。</li>\n</ul>\n</li>\n<li><p><strong>MSI&#x2F;MSI-X (Message Signaled Interrupts &#x2F; Message Signaled Interrupts Extended)</strong>  (消息信号中断 &#x2F; 扩展消息信号中断)：</p>\n<ul>\n<li><strong>定义</strong>：允许PCIe设备通过向系统定义的内存地址写入特殊消息（TLP，特别是内存写入TLP）来向CPU传递中断的机制，而不是使用专用的物理中断线（如传统PCI）。MSI-X是MSI的增强版，提供更多的中断向量和更大的灵活性。</li>\n<li><strong>重要性</strong>：大多数现代PCIe设备使用MSI或MSI-X以实现更高效、更灵活的中断处理。精确仿真通常需要实现捐赠设备选择的中断机制，包括配置MSI&#x2F;MSI-X能力结构并正确生成中断消息。</li>\n</ul>\n</li>\n<li><p><strong>DSN (Device Serial Number)</strong>  (设备序列号)：</p>\n<ul>\n<li><strong>定义</strong>：一个64位全局唯一标识符，可由PCIe设备可选实现。如果存在，它通常位于设备配置空间内的扩展能力结构中。</li>\n<li><strong>重要性</strong>：虽然并非所有设备都具有DSN，但某些驱动程序或管理软件可能会使用它进行唯一标识、许可或跟踪。正确仿真它对于完全透明和避免检测到仿真设备可能很重要。</li>\n</ul>\n</li>\n<li><p><strong>PCIe Configuration Space</strong> (PCIe配置空间)：</p>\n<ul>\n<li><strong>定义</strong>：与每个PCIe功能（一个设备可以有多个功能）关联的标准化256字节（对于Type 0、端点设备）或4KB地址区域。此空间包含有关设备的重要信息，包括其厂商ID、设备ID、类别代码、修订ID、BAR、能力指针以及各种状态和控制寄存器。主机系统使用特殊的配置读和配置写TLP访问此空间。</li>\n<li><strong>重要性</strong>：配置空间是PCIe设备的“身份证”。设备仿真的第一步就是将捐赠设备配置空间的相关部分精确复制到您的FPGA固件中。主机系统使用此信息来识别、配置和分配资源给设备。</li>\n</ul>\n</li>\n<li><p><strong>Donor Device</strong> (捐赠设备)：</p>\n<ul>\n<li><strong>定义</strong>：您旨在在FPGA上仿真其身份和行为的物理PCIe硬件设备。该设备作为提取配置细节（厂商ID、设备ID、BAR设置、能力等）和行为模式的来源。</li>\n<li><strong>重要性</strong>：您的仿真 fidelity 直接取决于您能够多么精确和完整地收集并复制捐赠设备的特性。</li>\n</ul>\n</li>\n<li><p><strong>Root Complex (RC)</strong>  (根联合体)：</p>\n<ul>\n<li><strong>定义</strong>：PCIe层级结构中将CPU和内存子系统连接到PCIe结构的实体。它代表CPU生成PCIe事务，并处理下游PCIe设备发起的事务。它还执行初始的总线枚举和配置。</li>\n<li><strong>重要性</strong>：您的仿真设备在与主机系统通信时，将主要与根联合体（或与其连接的交换机）交互。</li>\n</ul>\n</li>\n<li><p><strong>Endpoint (EP)</strong>  (端点)：</p>\n<ul>\n<li><strong>定义</strong>：位于PCIe结构外围，消费或生产数据的一种PCIe设备。示例包括网卡、显卡、存储控制器以及您将要编程的FPGA设备。端点请求资源并向根联合体发起事务。</li>\n<li><strong>重要性</strong>：在本指南中，您的FPGA将被编程为充当一个端点设备，仿真一个特定的捐赠端点。</li>\n</ul>\n</li>\n<li><p><strong>HDL (Hardware Description Language)</strong>  (硬件描述语言)：</p>\n<ul>\n<li><strong>定义</strong>：一种专用计算机语言，用于描述电子电路的结构、设计和操作，特别是数字逻辑电路。常见的HDL包括Verilog和VHDL。</li>\n<li><strong>重要性</strong>：您将在PCILeech-FPGA项目中使用Verilog（特别是SystemVerilog，Verilog的扩展）来定义仿真设备的定制逻辑。</li>\n</ul>\n</li>\n<li><p><strong>Bitstream</strong> (比特流)：</p>\n<ul>\n<li><strong>定义</strong>：加载到FPGA上的最终配置文件，用于编程其逻辑块和互连，从而实现您的定制硬件设计。它是FPGA开发工具（如Xilinx Vivado）的编译输出。</li>\n<li><strong>重要性</strong>：生成和烧录正确的比特流是将定制固件部署到FPGA的最终步骤。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-设备兼容性\"><a href=\"#3-设备兼容性\" class=\"headerlink\" title=\"3. 设备兼容性\"></a><strong>3. 设备兼容性</strong></h2><p>成功且精确的PCIe设备仿真取决于确保您选择的基于FPGA的硬件和主机系统配置完全兼容。本节详细介绍了支持的FPGA平台、关键的PCIe硬件注意事项以及设置开发环境所需的系统要求。</p>\n<h3 id=\"3-1-支持的基于FPGA的硬件\"><a href=\"#3-1-支持的基于FPGA的硬件\" class=\"headerlink\" title=\"3.1 支持的基于FPGA的硬件\"></a><strong>3.1 支持的基于FPGA的硬件</strong></h3><p>虽然本指南提供了一种可适用于各种基于FPGA的DMA硬件的通用方法，但我们的主要示例和具体说明将侧重于 <strong>Xilinx 7系列FPGA</strong>，由于其性能和可访问性的平衡，它们在开源DMA板中很常见。<strong>Squirrel DMA (35T)</strong>  卡因其受欢迎程度以及与PCILeech-FPGA框架的良好兼容性而受到强调。</p>\n<p>定制PCIe IP核和开发硬件描述语言（HDL）逻辑的核心原则和技术广泛适用于以下FPGA系列和特定板卡：</p>\n<ul>\n<li><strong>Squirrel (Artix-7 35T)</strong><ul>\n<li><strong>描述</strong>：一种广泛可用且经济高效的基于FPGA的DMA设备，采用Xilinx Artix-7 35T FPGA。它为标准内存采集任务以及各种基本到中级设备仿真项目提供了足够的逻辑资源和内存。它是初次接触基于FPGA的DMA的优秀起点。</li>\n<li><strong>主要特点</strong>：Artix-7提供了良好的性能价格比，适用于教育和研究目的。</li>\n</ul>\n</li>\n<li><strong>Enigma-X1 (Artix-7 75T)</strong><ul>\n<li><strong>描述</strong>：与35T相比，提供增强的逻辑和内存资源的中级FPGA，通常基于Xilinx Artix-7 75T FPGA。这为更复杂的仿真场景、更大的内存映射区域或需要额外FPGA逻辑的更复杂的DMA操作提供了更大的灵活性。</li>\n<li><strong>主要特点</strong>：增加的逻辑单元和块RAM（BRAM）支持更复杂的设计。</li>\n</ul>\n</li>\n<li><strong>ZDMA (Artix-7 100T)</strong><ul>\n<li><strong>描述</strong>：基于更高性能的Artix-7 100T FPGA，针对要求更高的内存交互和大量的读&#x2F;写操作进行了优化。此板卡适用于大规模DMA解决方案、高吞吐量仿真或需要大量片上内存的项目。</li>\n<li><strong>主要特点</strong>：100T变体在资源方面提供了显著升级，是突破仿真界限的理想选择。</li>\n</ul>\n</li>\n<li><strong>Kintex-7 (K325T, K410T等)</strong><ul>\n<li><strong>描述</strong>：代表高级别，Kintex-7 FPGA（例如K325T、K410T）为高度复杂的项目、大规模DMA解决方案以及需要更高PCIe通道数或速度（例如，Gen3 x8&#x2F;x16）的应用提供了强大的功能。虽然价格更昂贵，但它们提供了更多的逻辑、DSP切片和内存，从而能够仿真高度复杂和苛刻的捐赠设备。</li>\n<li><strong>主要特点</strong>：用于更快PCIe世代的高性能收发器，丰富的逻辑和内存资源，适用于复杂设计。</li>\n</ul>\n</li>\n</ul>\n<p><strong>关于FPGA系列的重要说明</strong>：尽管原理相似，但不同的Xilinx 7系列FPGA（Artix-7、Kintex-7、Zynq-7000 PS&#x2F;PL）之间，特定的IP核配置和时钟结构可能略有不同。请始终参考特定板卡文档和您所选FPGA系列的Xilinx PCIe IP核用户指南。PCILeech-FPGA项目通常提供板卡特定的Tcl脚本和源文件以简化此过程。</p>\n<h3 id=\"3-2-PCIe硬件注意事项\"><a href=\"#3-2-PCIe硬件注意事项\" class=\"headerlink\" title=\"3.2 PCIe硬件注意事项\"></a><strong>3.2 PCIe硬件注意事项</strong></h3><p>为了确保基于FPGA的DMA设备在仿真中平稳无限制地运行，需要仔细考虑一些PCIe特定和主机系统功能，并在某些情况下进行修改。</p>\n<ul>\n<li><strong>IOMMU &#x2F; VT-d &#x2F; AMD-Vi 设置</strong><ul>\n<li><strong>建议</strong>：对于初始设置和测试，<strong>强烈建议在系统的BIOS&#x2F;UEFI设置中禁用IOMMU（Intel的定向I&#x2F;O虚拟化技术 - VT-d）或AMD的等效技术（AMD-Vi）</strong> 。</li>\n<li><strong>理由</strong>：IOMMU是为DMA功能设备提供内存管理单元的硬件组件。它们执行地址转换，类似于CPU的MMU，并且可以强制执行内存访问权限。虽然它们对于安全和虚拟化（防止恶意设备访问未经授权的内存区域）至关重要，但它们<strong>会</strong>限制DMA设备对系统内存的访问，可能干扰内存采集和设备仿真。禁用IOMMU允许DMA设备不受限制地访问内存，这对于高级仿真和安全研究目的通常是必要的。</li>\n<li><strong>位置</strong>：通常在BIOS&#x2F;UEFI中的“CPU Configuration”、“Virtualization”、“Advanced Settings”或“I&#x2F;O Virtualization”下找到。</li>\n</ul>\n</li>\n<li><strong>内核DMA保护（Windows）&#x2F; Thunderbolt安全级别（Linux）</strong><ul>\n<li><strong>建议（Windows）</strong> ：在现代Windows系统中禁用<strong>内核DMA保护</strong>功能。这包括<strong>基于虚拟化的安全性（VBS）</strong>和<strong>内存完整性（HVCI）</strong>等设置。这些功能利用IOMMU来防止通过Thunderbolt或PCIe连接的外部外设进行未经授权的DMA攻击。</li>\n<li><strong>步骤（Windows）</strong> ：<ul>\n<li>访问Windows安全设置：<strong>开始 &gt; 设置 &gt; 隐私和安全性 &gt; Windows 安全中心 &gt; 设备安全性</strong>。</li>\n<li>在“核心隔离”下，点击“核心隔离详细信息”。</li>\n<li>关闭“内存完整性”。</li>\n<li>您可能还需要在BIOS&#x2F;UEFI中禁用安全启动，因为VBS通常依赖于它。</li>\n<li><strong>注意</strong>：禁用这些功能会显著<strong>降低您系统的安全态势</strong>，使其容易受到包括涉及恶意DMA设备的各种攻击。这应该只在专用测试系统上进行，而不是在您的主机器上，并且在您了解风险的安全、隔离环境中进行。</li>\n</ul>\n</li>\n<li><strong>建议（Linux&#x2F;Thunderbolt）</strong> ：如果使用带有Thunderbolt端口的系统，请了解并可能调整BIOS&#x2F;UEFI中的<strong>Thunderbolt安全级别</strong>。较低的安全级别（例如，“无安全”、“用户授权”）通常是任意Thunderbolt&#x2F;PCIe设备在未经明确主机批准的情况下执行DMA所必需的。</li>\n</ul>\n</li>\n<li><strong>PCIe插槽要求</strong><ul>\n<li><strong>建议</strong>：使用与FPGA设备要求物理匹配的兼容PCIe插槽。大多数基于Artix-7的DMA卡在PCIe Gen2 x1或x4下运行。</li>\n<li><strong>理由</strong>：<ul>\n<li><strong>物理匹配</strong>：x1卡可以插入x1、x4、x8或x16插槽，但x4卡至少需要x4插槽。</li>\n<li><strong>性能</strong>：虽然x4卡<em>可能</em>在x1插槽中工作（如果物理连接是开放式或已修改的），但它将以x1速度运行，严重限制数据传输速率。为了获得最佳性能和精确仿真捐赠设备的功能，请确保FPGA板卡安装在提供至少<em>仿真</em>链路宽度和速度的插槽中（例如，如果您要仿真Gen2 x4设备，请在主机上使用Gen2 x4插槽）。</li>\n</ul>\n</li>\n<li><strong>主板BIOS设置</strong>：一些主板允许配置PCIe插槽速度（例如，强制Gen1或Gen2）。确保这些设置不与您期望的仿真速度冲突。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3-系统要求\"><a href=\"#3-3-系统要求\" class=\"headerlink\" title=\"3.3 系统要求\"></a><strong>3.3 系统要求</strong></h3><p>建立一个健壮的开发环境对于高效的固件开发、综合和调试至关重要。</p>\n<ul>\n<li><strong>主机系统</strong><ul>\n<li><strong>处理器</strong>：现代多核CPU对于运行Vivado等FPGA开发工具至关重要，这些工具在综合和实现过程中计算密集。（例如，Intel Core i5&#x2F;i7&#x2F;i9 或 AMD Ryzen 5&#x2F;7&#x2F;9 等效处理器，建议8代或更新）。</li>\n<li><strong>内存（RAM）</strong> ：强烈建议最低16 GB RAM；对于复杂FPGA设计，<strong>32 GB 或更高是理想选择</strong>，因为Vivado会消耗大量内存，尤其是在实现阶段。</li>\n<li><strong>存储</strong>：一个固态硬盘（SSD）并至少有 <strong>200 GB 的可用空间</strong> 至关重要。FPGA工具安装（仅Vivado就可能超过50 GB）、项目文件以及综合&#x2F;实现输出会迅速占用磁盘空间。SSD的速度能显著缩短构建时间。</li>\n<li><strong>操作系统</strong>：<ul>\n<li><strong>Windows 10&#x2F;11 (64位 专业版或企业版)</strong> ：Xilinx Vivado 和许多硬件调试工具广泛支持。请记住内核DMA保护的注意事项。</li>\n<li><strong>兼容的Linux发行版 (64位)</strong> ：Ubuntu LTS（长期支持）版本（例如 20.04、22.04）是Vivado常用且支持良好的系统。Linux通常为脚本编写和低级PCIe交互工具提供更灵活的环境。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>外围设备</strong><ul>\n<li><strong>JTAG编程器</strong>：将编译后的比特流烧录到基于FPGA的DMA卡上绝对必需。示例包括Xilinx Platform Cable USB II、Digilent JTAG-HS3 或某些开发板上集成的JTAG编程器。确保它与您的FPGA板卡和Vivado兼容。</li>\n<li><strong>PCIe插槽</strong>：如第3.2节所述，确保您的主机系统有可用的兼容PCIe插槽用于DMA卡。</li>\n<li><strong>USB端口</strong>：用于连接JTAG编程器，并可能用于连接FPGA板卡的UART&#x2F;串行控制台以进行调试输出。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-要求\"><a href=\"#4-要求\" class=\"headerlink\" title=\"4. 要求\"></a><strong>4. 要求</strong></h2><p>本节概述了进行PCIe设备仿真定制固件开发所必需的基本硬件和软件组件，以及推荐的环境设置。在开始之前，具备这些先决条件将简化您的开发过程。</p>\n<h3 id=\"4-1-硬件\"><a href=\"#4-1-硬件\" class=\"headerlink\" title=\"4.1 硬件\"></a><strong>4.1 硬件</strong></h3><ul>\n<li><strong>捐赠PCIe设备</strong><ul>\n<li><strong>目的</strong>：这是您打算在FPGA上仿真其配置和行为的物理硬件设备。它作为关键识别细节、寄存器值和操作特性的权威来源。</li>\n<li><strong>示例</strong>：常见示例包括标准网卡（NIC）、SATA或NVMe存储控制器、USB控制器，或任何其他您可以安全地从系统中移除进行分析的通用PCIe扩展卡。强烈建议使用对系统操作非必需的设备，因为您将检查其低级配置。</li>\n</ul>\n</li>\n<li><strong>DMA FPGA卡</strong><ul>\n<li><strong>描述</strong>：一种基于FPGA的开发板，专门设计或改编用于通过PCIe接口执行直接内存访问（DMA）操作。这是您的定制固件将加载到的平台。</li>\n<li><strong>示例</strong>：如第3.1节所述，兼容卡包括 <strong>Squirrel (Artix-7 35T)</strong> 、<strong>Enigma-X1 (Artix-7 75T)</strong> 、<strong>ZDMA (Artix-7 100T)</strong>  或各种基于 <strong>Kintex-7</strong> 的解决方案。确保您选择的卡具有PCIe金手指连接器。</li>\n</ul>\n</li>\n<li><strong>JTAG编程器</strong><ul>\n<li><strong>目的</strong>：这个关键工具促进了您的开发PC与DMA卡上FPGA之间的通信。它用于将编译后的比特流编程（烧录）到FPGA上，更重要的是，用于使用Vivado的硬件管理器和集成逻辑分析仪（ILA）等工具进行交互式调试。</li>\n<li><strong>示例</strong>：<ul>\n<li><strong>Xilinx Platform Cable USB II</strong>：Xilinx FPGA传统且广泛兼容的编程器。确保您已安装必要的驱动程序。</li>\n<li><strong>Digilent JTAG-HS3 &#x2F; JTAG-HS2</strong>：流行且可靠的编程器，以良好的Vivado集成和支持而闻名。HS3提供更快的编程速度。</li>\n<li><strong>集成JTAG</strong>：某些FPGA板可能具有板载USB转JTAG桥（例如FTDI芯片），这消除了对独立编程器的需求。请查阅您的板卡文档。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-软件\"><a href=\"#4-2-软件\" class=\"headerlink\" title=\"4.2 软件\"></a><strong>4.2 软件</strong></h3><ul>\n<li><strong>Xilinx Vivado Design Suite</strong><ul>\n<li><strong>描述</strong>：Xilinx（现为AMD）官方的、全面的FPGA开发环境。Vivado对于综合您的HDL代码、将设计实现到目标FPGA上、生成最终比特流以及执行硬件调试至关重要。它包括必要的IP核、编译器和实用程序。</li>\n<li><strong>下载</strong>：访问Xilinx（AMD）官方下载页面：<a href=\"https://www.xilinx.com/support/download.html\">https://www.xilinx.com/support/download.html</a>。</li>\n<li><strong>版本说明</strong>：虽然一些旧指南可能引用Vivado 2020.1等旧版本，但强烈建议下载与您的目标FPGA系列（Artix-7、Kintex-7）兼容的<strong>最新稳定版本</strong>（例如Vivado 2023.x或更高版本）。PCILeech-FPGA项目通常支持较新的Vivado版本。</li>\n</ul>\n</li>\n<li><strong>Visual Studio Code</strong><ul>\n<li><strong>描述</strong>：Microsoft出品的高度可定制且功能丰富的代码编辑器。它是编写和编辑Verilog&#x2F;SystemVerilog HDL代码的绝佳选择，因为它拥有广泛的扩展生态系统，提供语法高亮、代码检查、自动补全和版本控制集成等功能。</li>\n<li><strong>下载</strong>：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a></li>\n</ul>\n</li>\n<li><strong>PCILeech-FPGA</strong><ul>\n<li><strong>描述</strong>：一个用于基于FPGA的DMA开发的开源框架和基础代码库。它提供了即插即用的PCIe IP核实例化和一个结构良好的项目，是定制固件的绝佳起点。本指南将大量利用其架构。</li>\n<li><strong>仓库</strong>：<a href=\"https://github.com/ufrisk/pcileech-fpga\">https://github.com/ufrisk/pcileech-fpga</a></li>\n</ul>\n</li>\n<li><strong>Arbor (MindShare)</strong><ul>\n<li><strong>描述</strong>：一款强大且用户友好的软件工具，专门设计用于深入扫描和分析PCIe设备。它提供了对连接PCIe硬件的配置空间、功能和寄存器的详细洞察，对于收集捐赠设备信息来说非常有价值。</li>\n<li><strong>下载</strong>：可从MindShare网站获取：<a href=\"https://www.mindshare.com/\">https://www.mindshare.com/</a>（您可能需要导航到他们的软件部分）。</li>\n<li><strong>注意</strong>：通常需要创建账户，并且可能提供限时试用。</li>\n</ul>\n</li>\n<li><strong>替代PCIe设备分析工具</strong><ul>\n<li><strong>Telescan PE (Teledyne LeCroy)</strong> ：<ul>\n<li><strong>描述</strong>：Teledyne LeCroy提供的一款免费PCIe流量分析和设备枚举工具。虽然它主要是一款与其硬件协议分析仪交互的软件工具，但它也可以在没有专用硬件的情况下提供一些基本的配置空间视图。</li>\n<li><strong>下载</strong>：<a href=\"https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software\">https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software</a></li>\n<li><strong>注意</strong>：需要手动注册和批准才能下载。</li>\n</ul>\n</li>\n<li><strong>OS原生工具（用于基本检查）</strong> ：<ul>\n<li><strong>Windows设备管理器</strong>：在设备属性的“详细信息”选项卡下提供基本的厂商ID、设备ID、子系统ID和类别代码信息。</li>\n<li><strong>Linux <strong>​</strong>​<code>lspci</code>​</strong>​ ** 工具**：一个强大的命令行工具，用于检查PCIe设备。使用<code>lspci -nn</code>查看厂商&#x2F;设备ID，<code>lspci -vvv</code>查看包括BAR和功能在内的详细信息，<code>lspci -s &lt;BUS:DEV.FUN&gt; -xxxx</code>用于原始配置空间转储。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-3-环境设置\"><a href=\"#4-3-环境设置\" class=\"headerlink\" title=\"4.3 环境设置\"></a><strong>4.3 环境设置</strong></h3><p>一个干净且正确配置的开发环境对于避免常见陷阱并确保流畅的工作流程至关重要。</p>\n<h4 id=\"4-3-1-安装Xilinx-Vivado设计套件\"><a href=\"#4-3-1-安装Xilinx-Vivado设计套件\" class=\"headerlink\" title=\"4.3.1 安装Xilinx Vivado设计套件\"></a><strong>4.3.1 安装Xilinx Vivado设计套件</strong></h4><p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>访问Xilinx (AMD) Vivado下载页面</strong>：<a href=\"https://www.xilinx.com/support/download.html\">https://www.xilinx.com/support/download.html</a>。</li>\n<li><strong>下载适当版本</strong>：选择与您的操作系统兼容的最新稳定版Vivado，更重要的是，它必须与您的特定FPGA设备（例如Artix-7、Kintex-7）兼容。查阅Vivado发行说明以了解设备支持情况。</li>\n<li><strong>运行安装程序</strong>：执行下载的安装程序并仔细遵循屏幕上的说明。</li>\n<li><strong>选择必要组件</strong>：在安装过程中，系统会提示您选择要安装的设备家族。<strong>至关重要的是，选择与您的FPGA板卡对应的设备家族（例如，Artix-7&#x2F;Kintex-7的“7 Series”）</strong> 。这与安装所有家族相比，能节省大量磁盘空间。确保您选择“设计工具”（综合、实现）和“编程与调试”组件。</li>\n<li><strong>启动Vivado</strong>：安装完成后，启动Vivado以确认它能无错误打开，并且许可证（如果适用）已正确配置。</li>\n</ol>\n<h4 id=\"4-3-2-安装Visual-Studio-Code\"><a href=\"#4-3-2-安装Visual-Studio-Code\" class=\"headerlink\" title=\"4.3.2 安装Visual Studio Code\"></a><strong>4.3.2 安装Visual Studio Code</strong></h4><p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>访问Visual Studio Code下载页面</strong>：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a>。</li>\n<li><strong>下载并安装</strong>：下载适用于您操作系统的安装程序，并遵循标准安装提示。</li>\n<li><strong>安装HDL支持扩展</strong>：安装VS Code后，打开它并导航到扩展视图（Ctrl+Shift+X或Cmd+Shift+X）。搜索并安装适用于Verilog&#x2F;SystemVerilog的相关扩展，例如：<ul>\n<li><strong>Verilog-HDL&#x2F;SystemVerilog</strong> (由mshr-h提供)</li>\n<li><strong>VHDL</strong> (如果您也使用VHDL)<br>这些扩展提供了语法高亮、代码检查和其他有用的功能。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-3-3-克隆PCILeech-FPGA仓库\"><a href=\"#4-3-3-克隆PCILeech-FPGA仓库\" class=\"headerlink\" title=\"4.3.3 克隆PCILeech-FPGA仓库\"></a><strong>4.3.3 克隆PCILeech-FPGA仓库</strong></h4><p>此仓库包含您将要修改的基础固件结构和脚本。</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>打开终端或命令提示符</strong>：（例如，Windows上的Git Bash，Linux上的Terminal）。</li>\n<li><strong>导航到您想要的目录</strong>：选择一个您想存储项目的位置。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/Projects/ <span class=\"comment\"># 在Linux/macOS上</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> C:\\Users\\YourUsername\\Documents\\Projects\\ <span class=\"comment\"># 在Windows上</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>克隆仓库</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ufrisk/pcileech-fpga.git</span><br></pre></td></tr></table></figure></li>\n<li><strong>导航到克隆的目录</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> pcileech-fpga</span><br></pre></td></tr></table></figure>\n\n这将是您的主项目目录。PCILeech-FPGA项目通常包含不同板卡变体的子目录（例如<code>pcileech-artix-7-50t</code>、<code>pcileech-squirrel-35t</code>）。您将根据您的特定硬件导航到相关的板卡特定目录。</li>\n</ol>\n<h4 id=\"4-3-4-设置一个干净的开发环境\"><a href=\"#4-3-4-设置一个干净的开发环境\" class=\"headerlink\" title=\"4.3.4 设置一个干净的开发环境\"></a><strong>4.3.4 设置一个干净的开发环境</strong></h4><p><strong>建议</strong>：始终在隔离或专用的环境中工作，尤其是在处理低级硬件和潜在的安全隐患时。</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>使用专用开发机或虚拟机</strong>：<ul>\n<li><strong>物理机</strong>：如果可能，使用一台单独的物理计算机进行FPGA开发和测试。这可以防止在您的主机器上发生意外的系统不稳定或安全风险。</li>\n<li><strong>虚拟机（VM）</strong> ：虚拟机可以是隔离开发环境的好选择。然而，通常需要向虚拟机进行直接PCIe直通（PCIe热插拔或VT-d直通），FPGA卡才能被正确检测和操作，这可能配置复杂，并且如果操作不当，仍然可能暴露主机。对于初始工具安装和代码编辑，虚拟机完全没问题。</li>\n</ul>\n</li>\n<li><strong>最小化后台应用程序</strong>：确保没有其他资源密集型应用程序正在运行，这些应用程序可能会干扰Vivado在综合和实现过程中的性能。</li>\n<li><strong>禁用冲突软件</strong>：在开发和测试期间，暂时禁用任何可能干扰低级硬件访问或JTAG通信的防病毒、防火墙或安全软件。完成工作后请记得重新启用它们。</li>\n</ol>\n<hr>\n<h2 id=\"5-收集捐赠设备信息\"><a href=\"#5-收集捐赠设备信息\" class=\"headerlink\" title=\"5. 收集捐赠设备信息\"></a><strong>5. 收集捐赠设备信息</strong></h2><p>精确的设备仿真取决于精细地提取和复制捐赠设备的关键信息。这种全面的数据收集使您的FPGA能够忠实地模仿目标硬件的PCIe配置和行为，确保与主机系统接口时的兼容性和功能性。</p>\n<h3 id=\"5-1-使用Arbor进行PCIe设备扫描\"><a href=\"#5-1-使用Arbor进行PCIe设备扫描\" class=\"headerlink\" title=\"5.1 使用Arbor进行PCIe设备扫描\"></a><strong>5.1 使用Arbor进行PCIe设备扫描</strong></h3><p><strong>Arbor</strong> 是一款强大且用户友好的工具，专为深入扫描PCIe设备而设计。它提供了对连接硬件配置空间的详细洞察，使其成为提取设备仿真所需信息的宝贵资源。</p>\n<h4 id=\"5-1-1-安装Arbor\"><a href=\"#5-1-1-安装Arbor\" class=\"headerlink\" title=\"5.1.1 安装Arbor\"></a><strong>5.1.1 安装Arbor</strong></h4><p>要开始使用Arbor进行设备扫描，您必须首先在系统上安装该软件。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>访问Arbor下载页面：</strong><ul>\n<li>使用您偏好的网页浏览器导航到MindShare官方网站（<a href=\"https://www.mindshare.com/\">https://www.mindshare.com/</a>）。您需要找到他们的“Software”或“Downloads”部分来定位Arbor。</li>\n<li>确保您直接访问该网站，以避免任何恶意重定向。</li>\n</ul>\n</li>\n<li><strong>创建账户（如果需要）：</strong><ul>\n<li>Arbor可能要求您创建用户账户才能访问下载链接。</li>\n<li>提供必要的信息，例如您的姓名、电子邮件地址和组织。</li>\n<li>如果出现提示，请验证您的电子邮件以激活您的账户。</li>\n</ul>\n</li>\n<li><strong>下载Arbor：</strong><ul>\n<li>登录后，找到Arbor的下载部分。</li>\n<li>选择与您的操作系统兼容的版本（例如，Windows 10&#x2F;11 64位）。</li>\n<li>点击 <strong>Download</strong> 按钮并将安装程序保存到计算机上已知的位置。</li>\n</ul>\n</li>\n<li><strong>安装Arbor：</strong><ul>\n<li>找到下载的安装程序文件（例如，<code>ArborSetup.exe</code>）。</li>\n<li>右键单击安装程序并选择 <strong>以管理员身份运行</strong> 以确保它具有必要的权限。</li>\n<li>按照屏幕上的说明完成安装过程。<ul>\n<li>接受许可协议。</li>\n<li>选择安装目录。</li>\n<li>如果需要，选择创建桌面快捷方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>验证安装：</strong><ul>\n<li>安装完成后，确保Arbor列在您的“开始”菜单或桌面上。</li>\n<li>启动Arbor以确认它能无错误打开。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-2-扫描PCIe设备\"><a href=\"#5-1-2-扫描PCIe设备\" class=\"headerlink\" title=\"5.1.2 扫描PCIe设备\"></a><strong>5.1.2 扫描PCIe设备</strong></h4><p>安装Arbor后，您可以继续扫描系统中的PCIe设备。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>启动Arbor：</strong><ul>\n<li>双击桌面上的Arbor图标或通过“开始”菜单找到它。</li>\n<li>如果用户账户控制（UAC）提示，允许应用程序对设备进行更改。</li>\n</ul>\n</li>\n<li><strong>导航到本地系统选项卡：</strong><ul>\n<li>在Arbor界面中，找到导航窗格或选项卡。</li>\n<li>单击 <strong>Local System</strong> 以访问扫描本地机器的工具。</li>\n</ul>\n</li>\n<li><strong>扫描PCIe设备：</strong><ul>\n<li>查找 <strong>Scan</strong> 或 <strong>Rescan</strong> 按钮，通常位于界面的顶部或底部。</li>\n<li>点击 <strong>Scan&#x2F;Rescan</strong> 以启动检测过程。</li>\n<li>等待扫描过程完成；这可能需要几分钟，具体取决于连接的设备数量。</li>\n</ul>\n</li>\n<li><strong>审查检测到的设备：</strong><ul>\n<li>扫描完成后，Arbor将显示所有检测到的PCIe设备的列表。</li>\n<li>设备通常会列出其名称、设备ID和其他识别信息。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-3-识别捐赠设备\"><a href=\"#5-1-3-识别捐赠设备\" class=\"headerlink\" title=\"5.1.3 识别捐赠设备\"></a><strong>5.1.3 识别捐赠设备</strong></h4><p>识别正确的捐赠设备对于精确仿真至关重要。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>在列表中找到您的捐赠设备：</strong><ul>\n<li>滚动浏览Arbor检测到的设备列表。</li>\n<li>查找与您的捐赠硬件的品牌和型号匹配的设备。</li>\n<li>设备可能按其厂商名称、设备类型或功能列出。</li>\n</ul>\n</li>\n<li><strong>验证设备详细信息：</strong><ul>\n<li>单击设备以选中它。</li>\n<li>确认 <strong>Device ID</strong> 和 <strong>Vendor ID</strong> 与您的捐赠设备匹配。<ul>\n<li><strong>提示：</strong>  这些ID通常可以在设备文档或制造商网站上找到。对于常见设备，快速在网上搜索“[设备名称] Vendor ID Device ID”通常能得到结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>查看详细配置：</strong><ul>\n<li>选中设备后，找到并单击类似 <strong>View Details</strong> 或 <strong>Properties</strong> 的选项。</li>\n<li>这将打开一个详细视图，显示设备的配置空间和功能。</li>\n</ul>\n</li>\n<li><strong>与物理硬件交叉引用：</strong><ul>\n<li>如果列出了多个类似设备，请将 <strong>Slot Number</strong> 或 <strong>Bus Address</strong> 与安装捐赠设备的物理插槽交叉引用。这有助于确认您正在分析正确的硬件。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-4-捕获设备数据\"><a href=\"#5-1-4-捕获设备数据\" class=\"headerlink\" title=\"5.1.4 捕获设备数据\"></a><strong>5.1.4 捕获设备数据</strong></h4><p>从捐赠设备中提取详细信息对于精确仿真至关重要。</p>\n<p><strong>要提取的信息：</strong></p>\n<ul>\n<li><strong>设备ID (0xXXXX)：</strong>  唯一标识设备型号的16位标识符。</li>\n<li><strong>厂商ID (0xYYYY)：</strong>  分配给制造商的16位标识符。</li>\n<li><strong>子系统ID (0xZZZZ)：</strong>  标识特定子系统或变体（例如，产品线中的特定型号）。</li>\n<li><strong>子系统厂商ID (0xWWWW)：</strong>  标识子系统的厂商（通常与主厂商ID相同，但对于OEM版本可能会有所不同）。</li>\n<li><strong>修订ID (0xRR)：</strong>  指示设备的硬件修订级别。</li>\n<li><strong>类别代码 (0xCCCCCC)：</strong>  一个24位代码，定义设备的主要功能&#x2F;类型（例如，<code>0x020000</code>用于以太网控制器，<code>0x010802</code>用于NVMe控制器）。这有助于操作系统加载通用驱动程序。</li>\n<li><strong>基地址寄存器 (BARs)：</strong><ul>\n<li>定义设备使用的内存或I&#x2F;O地址区域的寄存器。</li>\n<li>包括BAR0到BAR5，每个都可能是32位或64位。对于每个BAR，请记录其 <strong>类型（内存或I&#x2F;O）</strong> 、<strong>位宽（32位或64位）</strong> 、<strong>大小（例如，256 MB，4KB）</strong>  和 <strong>可预取状态（是&#x2F;否）</strong> 。这对于内存映射至关重要。</li>\n</ul>\n</li>\n<li><strong>功能：</strong>  列出支持的功能及其配置，通常在配置空间中的链表结构中找到。示例包括：<ul>\n<li><strong>PCIe功能结构</strong>：PCIe链路速度（例如，Gen2，Gen3），链路宽度（例如，x1，x4），最大载荷大小，最大读取请求大小。</li>\n<li><strong>MSI&#x2F;MSI-X功能结构</strong>：消息信号中断信息，包括支持的向量数量。</li>\n<li><strong>电源管理功能结构</strong>：支持的电源状态（D0，D1，D2，D3hot，D3cold）。</li>\n</ul>\n</li>\n<li><strong>设备序列号 (DSN)：</strong>  一个64位唯一标识符，如果设备支持（在“设备序列号”扩展功能中找到）。并非所有设备都实现了此功能。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>导航到PCI配置选项卡：</strong><ul>\n<li>在设备详细视图中，找到并选择 <strong>PCI Config</strong> 或 <strong>Configuration Space</strong> 选项卡。这通常会以解码视图显示原始配置空间寄存器。</li>\n</ul>\n</li>\n<li><strong>记录相关详细信息：</strong><ul>\n<li>仔细记录上面列出的每个所需字段。</li>\n<li>使用截图或将值复制到文本文件、专用电子表格或结构化文档格式中以确保准确性。</li>\n<li>确保十六进制值正确记录，包括是否使用<code>0x</code>前缀。</li>\n</ul>\n</li>\n<li><strong>展开功能列表：</strong><ul>\n<li>查找标记为 <strong>Capabilities</strong> 或 <strong>Advanced Features</strong> 的部分。这些通常是可点击或可展开以显示子部分的。</li>\n<li>记录存在的每个功能及其相关参数（例如，MSI消息控制，电源状态标志，当前&#x2F;最大PCIe链路设置）。</li>\n</ul>\n</li>\n<li><strong>详细检查BAR：</strong><ul>\n<li>在配置空间中，找到BAR0到BAR5的条目。</li>\n<li>对于每个活动的BAR，记录其分配的大小、是内存映射还是I&#x2F;O、其位宽（32位或64位）以及是否可预取。这些信息通常在Arbor的GUI中清晰显示。</li>\n</ul>\n</li>\n<li><strong>保存数据以备参考：</strong><ul>\n<li>将所有提取的信息编译成一个组织良好的文档（例如，Markdown文件、<code>.txt</code>文件或Excel电子表格）。</li>\n<li>为每个部分清晰标记，以便在固件定制期间轻松参考。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-2-提取和记录设备属性\"><a href=\"#5-2-提取和记录设备属性\" class=\"headerlink\" title=\"5.2 提取和记录设备属性\"></a><strong>5.2 提取和记录设备属性</strong></h3><p>捕获数据后，理解每个属性的重要性并确保其准确记录对于成功仿真至关重要。</p>\n<p><strong>确保您已准确记录以下内容：</strong></p>\n<ol>\n<li><strong>设备ID：</strong><ul>\n<li><strong>目的：</strong>  唯一标识PCIe设备的特定型号。</li>\n<li><strong>仿真用法：</strong>  对于主机操作系统（OS）正确识别仿真设备至关重要，更重要的是，它能尝试加载适当的设备驱动程序。</li>\n</ul>\n</li>\n<li><strong>厂商ID：</strong><ul>\n<li><strong>目的：</strong>  标识PCIe设备的制造商。</li>\n<li><strong>仿真用法：</strong>  与设备ID结合使用，形成主机操作系统用于将设备与相应驱动程序匹配的唯一标识符（<code>VendorID:DeviceID</code>）。</li>\n</ul>\n</li>\n<li><strong>子系统ID和子系统厂商ID：</strong><ul>\n<li><strong>目的：</strong>  这些可选ID允许区分同一厂商设备的变体，或区分主厂商&#x2F;设备ID可能为通用的OEM特定版本。</li>\n<li><strong>仿真用法：</strong>  对于仿真具有多种配置的设备或OEM提供的设备很重要，因为驱动程序可能会专门查找这些值。</li>\n</ul>\n</li>\n<li><strong>修订ID：</strong><ul>\n<li><strong>目的：</strong>  指示设备的硬件修订级别。</li>\n<li><strong>仿真用法：</strong>  有助于识别可能需要不同驱动程序、固件或具有细微行为差异的特定硬件版本。</li>\n</ul>\n</li>\n<li><strong>类别代码：</strong><ul>\n<li><strong>目的：</strong>  一个24位代码，用于对设备的通用功能进行分类（例如，<code>0x020000</code>用于以太网控制器，<code>0x010802</code>用于NVMe控制器，<code>0x0C0300</code>用于USB主机控制器）。它由基本类别、子类别和编程接口组成。</li>\n<li><strong>仿真用法：</strong>  允许操作系统理解设备的通用功能，并在找不到特定厂商驱动程序时加载通用类别驱动程序。这对于初始设备识别至关重要。</li>\n</ul>\n</li>\n<li><strong>基地址寄存器（BARs）：</strong><ul>\n<li><strong>目的：</strong>  定义设备用于寄存器、内部缓冲区或配置空间扩展的内存映射或I&#x2F;O端口地址区域。主机操作系统在枚举期间将物理地址分配给这些BAR。</li>\n<li><strong>仿真用法：</strong>  对于将仿真设备的内部内存和寄存器映射到主机系统的地址空间至关重要。每个BAR的大小、类型（内存&#x2F;I&#x2F;O，32&#x2F;64位）和可预取状态必须与捐赠设备精确匹配。</li>\n</ul>\n</li>\n<li><strong>功能：</strong><ul>\n<li><strong>目的：</strong>  列出设备支持的高级功能，如高级错误报告、电源管理、MSI&#x2F;MSI-X、PCIe高级功能（如AER、VC&#x2F;PF）等。每个功能由一个具有其自身寄存器的结构定义。</li>\n<li><strong>仿真用法：</strong>  对于准确复制捐赠设备如何宣传其功能以及主机系统如何与这些功能交互（例如，中断传递机制、电源状态转换、错误报告）至关重要。</li>\n</ul>\n</li>\n<li><strong>设备序列号（DSN）：</strong><ul>\n<li><strong>目的：</strong>  设备的唯一64位标识符，通常是可选的扩展功能。</li>\n<li><strong>仿真用法：</strong>  虽然可选，但某些驱动程序或管理应用程序可能会专门查询并依赖DSN进行识别、许可或安全检查。准确仿真此功能可以防止您的设备被检测为通用或修改的外设。</li>\n</ul>\n</li>\n</ol>\n<p><strong>数据收集的最佳实践：</strong></p>\n<ul>\n<li><strong>组织数据：</strong>  创建一个结构化的文档或电子表格。为每个属性使用清晰的标题和子标题。模板会很有益。</li>\n<li><strong>包含单位和格式：</strong>  始终注明大小的单位（例如，MB、KB），并为十六进制值使用一致的格式（例如，<code>0x1234</code>、<code>16&#39;h1234</code>）。</li>\n<li><strong>与规范交叉引用（如果可能）：</strong>  如果可用，查阅捐赠设备的数据手册或公开可用的规范以验证值。这有助于识别原始扫描中不明显或不寻常的配置。</li>\n<li><strong>保护数据：</strong>  安全存储收集到的信息。请注意，这些数据可能包含专有或敏感信息。</li>\n<li><strong>理解“缺少什么”：</strong>  像Arbor这样的专业工具非常出色，但它们可能无法捕捉复杂、高度专有设备的每一个细微之处（例如，标准配置空间之外的特定厂商定义寄存器）。对于高级仿真，您可能需要将此信息与捐赠设备驱动程序的逆向工程结合起来。</li>\n</ul>\n<hr>\n<h2 id=\"6-初始固件定制\"><a href=\"#6-初始固件定制\" class=\"headerlink\" title=\"6. 初始固件定制\"></a><strong>6. 初始固件定制</strong></h2><p>在细致地记录了捐赠设备的信息之后，下一个关键阶段是定制您的FPGA固件，以准确仿真捐赠设备。这个过程首先要修改PCIe配置空间中的关键识别寄存器，并确保设备序列号等特定标识符被正确集成。</p>\n<h3 id=\"6-1-修改配置空间\"><a href=\"#6-1-修改配置空间\" class=\"headerlink\" title=\"6.1 修改配置空间\"></a><strong>6.1 修改配置空间</strong></h3><p>PCIe配置空间是定义设备如何被识别并与主机系统在枚举期间交互的基本组件。精确定制此空间以匹配捐赠设备的配置文件对于成功仿真绝对至关重要，它能让主机操作系统加载正确的驱动程序并按预期交互。</p>\n<h4 id=\"6-1-1-导航到配置文件\"><a href=\"#6-1-1-导航到配置文件\" class=\"headerlink\" title=\"6.1.1 导航到配置文件\"></a><strong>6.1.1 导航到配置文件</strong></h4><p>PCIe配置空间参数通常在PCILeech-FPGA项目中的特定SystemVerilog（<code>.sv</code>）文件中定义。此文件将综合成配置PCIe IP核并向主机公开设备身份的逻辑。</p>\n<p><strong>PCILeech-FPGA（基于Artix-7的板卡，如Squirrel）的常见路径：</strong><br>找到负责为您特定板卡配置PCIe参数的文件。对于许多Artix-7 PCILeech变体，这将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_pcie_cfg_a7.sv</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>示例（对于Squirrel 35T）</strong> ：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv</span><br></pre></td></tr></table></figure>\n\n<em>注意：实际的文件夹名称，如</em>​<em>​<code>pcileech-squirrel-35t</code>​</em>​ <em>，可能会根据您克隆的PCILeech-FPGA的具体版本或分支略有不同。克隆主仓库后，请始终导航到相关的板卡特定子目录。</em></li>\n</ul>\n<h4 id=\"6-1-2-在Visual-Studio-Code中打开文件\"><a href=\"#6-1-2-在Visual-Studio-Code中打开文件\" class=\"headerlink\" title=\"6.1.2 在Visual Studio Code中打开文件\"></a><strong>6.1.2 在Visual Studio Code中打开文件</strong></h4><p>编辑配置文件需要一个合适的代码编辑器，该编辑器支持SystemVerilog（或Verilog）的语法高亮，使代码更易于阅读和修改。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>启动Visual Studio Code：</strong><ul>\n<li>点击VS Code图标或通过“开始”菜单找到它。</li>\n</ul>\n</li>\n<li><strong>打开文件：</strong><ul>\n<li>使用 <strong>文件 &gt; 打开文件</strong> 或按下 <code>Ctrl + O</code>（macOS上为 <code>Cmd + O</code>）。</li>\n<li>导航到第6.1.1节中确定的配置文件路径（例如，<code>pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv</code>）。</li>\n<li>选择文件并点击 <strong>打开</strong>。</li>\n</ul>\n</li>\n<li><strong>验证语法高亮：</strong><ul>\n<li>确保编辑器识别 <code>.sv</code> 文件扩展名并应用正确的SystemVerilog语法高亮。如果不行，请返回第4.3.2节，确保您已安装推荐的Verilog&#x2F;SystemVerilog扩展程序。</li>\n</ul>\n</li>\n<li><strong>熟悉文件结构：</strong><ul>\n<li>滚动浏览文件。您通常会发现使用<code>localparam</code>或<code>reg</code>赋值定义的参数，通常附有解释其目的的注释。查找定义和赋值标准PCIe配置寄存器（厂商ID、设备ID等）的部分。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-3-修改设备ID和厂商ID\"><a href=\"#6-1-3-修改设备ID和厂商ID\" class=\"headerlink\" title=\"6.1.3 修改设备ID和厂商ID\"></a><strong>6.1.3 修改设备ID和厂商ID</strong></h4><p>更新这些基本标识符是主机系统正确将仿真设备识别为您的捐赠设备的最关键步骤。操作系统严重依赖 <code>Vendor ID</code> 和 <code>Device ID</code> 对来识别连接的硬件并加载适当的设备驱动程序。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>搜索 <strong>​</strong>​<code>cfg_deviceid</code>​</strong>​ <strong>：</strong><ul>\n<li>在VS Code中使用搜索功能（<code>Ctrl + F</code>或<code>Cmd + F</code>）。</li>\n<li>找到定义<code>cfg_deviceid</code>的行。它通常看起来像这样：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_deviceid = <span class=\"number\">16&#x27;hAAAA</span>; <span class=\"comment\">// 默认或占位符设备ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>更新设备ID：</strong><ul>\n<li>将<code>AAAA</code>替换为您使用Arbor从捐赠设备中提取的16位十六进制设备ID（例如，<code>0x1234</code>）。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的设备ID是<code>0x1234</code>，则将该行更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_deviceid = <span class=\"number\">16&#x27;h1234</span>; <span class=\"comment\">// 更新为捐赠设备的设备ID（例如，来自网卡）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>搜索 <strong>​</strong>​<code>cfg_vendorid</code>​</strong>​ <strong>：</strong><ul>\n<li>找到定义<code>cfg_vendorid</code>的行。其格式将类似于<code>cfg_deviceid</code>：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_vendorid = <span class=\"number\">16&#x27;hBBBB</span>; <span class=\"comment\">// 默认或占位符厂商ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>更新厂商ID：</strong><ul>\n<li>将<code>BBBB</code>替换为您从捐赠设备中提取的16位十六进制厂商ID（例如，<code>0xABCD</code>）。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的厂商ID是<code>0xABCD</code>，则将该行更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_vendorid = <span class=\"number\">16&#x27;hABCD</span>; <span class=\"comment\">// 更新为捐赠设备的厂商ID（例如，Intel Corporation）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>确保格式正确：</strong><ul>\n<li>验证十六进制值是否正确以<code>16&#39;h</code>为前缀（表示一个16位十六进制数）。</li>\n<li>保持一致的缩进和注释风格以提高可读性。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-4-修改子系统ID和修订ID\"><a href=\"#6-1-4-修改子系统ID和修订ID\" class=\"headerlink\" title=\"6.1.4 修改子系统ID和修订ID\"></a><strong>6.1.4 修改子系统ID和修订ID</strong></h4><p>这些标识符提供了关于设备变体、特定产品型号或硬件修订的额外详细信息。虽然通常是可选的，但匹配它们能增强仿真的真实性，并且对于执行细粒度检查的驱动程序可能至关重要。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_subsysid</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_subsysid</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysid = <span class=\"number\">16&#x27;hCCCC</span>; <span class=\"comment\">// 占位符子系统ID</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新子系统ID：</strong></p>\n<ul>\n<li>将<code>CCCC</code>替换为您捐赠设备的16位十六进制子系统ID（例如，<code>0x5678</code>）。</li>\n<li><strong>示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysid = <span class=\"number\">16&#x27;h5678</span>; <span class=\"comment\">// 设置为捐赠设备的子系统ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_subsysvendorid</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_subsysvendorid</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysvendorid = <span class=\"number\">16&#x27;hDDDD</span>; <span class=\"comment\">// 占位符子系统厂商ID</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新子系统厂商ID（如果适用）：</strong></p>\n<ul>\n<li>将<code>DDDD</code>替换为您捐赠设备的16位十六进制子系统厂商ID（例如，<code>0x9ABC</code>）。如果您的捐赠设备没有唯一的子系统厂商ID（即与主厂商ID相同），您仍应将其设置为该值。</li>\n<li><strong>示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysvendorid = <span class=\"number\">16&#x27;h9ABC</span>; <span class=\"comment\">// 设置为捐赠设备的子系统厂商ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_revisionid</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_revisionid</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_revisionid = <span class=\"number\">8&#x27;hEE</span>; <span class=\"comment\">// 占位符修订ID</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新修订ID：</strong></p>\n<ul>\n<li>将<code>EE</code>替换为您捐赠设备的8位十六进制修订ID（例如，<code>0x01</code>）。</li>\n<li><strong>示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_revisionid = <span class=\"number\">8&#x27;h01</span>; <span class=\"comment\">// 设置为捐赠设备的修订ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-5-更新类别代码\"><a href=\"#6-1-5-更新类别代码\" class=\"headerlink\" title=\"6.1.5 更新类别代码\"></a><strong>6.1.5 更新类别代码</strong></h4><p>类别代码通知主机操作系统设备的通用类型和功能（例如，网络控制器、存储设备）。这对于操作系统加载通用类别驱动程序至关重要，即使没有安装特定厂商驱动程序。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_classcode</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_classcode</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">23</span>:<span class=\"number\">0</span>] cfg_classcode = <span class=\"number\">24&#x27;hFFFFFF</span>; <span class=\"comment\">// 默认或占位符类别代码</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新类别代码：</strong></p>\n<ul>\n<li>将<code>FFFFFF</code>替换为您从捐赠设备中提取的24位十六进制类别代码（例如，<code>0x020000</code>用于以太网控制器）。请记住格式：基本类别、子类别、编程接口。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的类别代码是<code>0x020000</code>（表示基本类别：0x02 - 网络控制器，子类别：0x00 - 以太网控制器，编程接口：0x00），则更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">23</span>:<span class=\"number\">0</span>] cfg_classcode = <span class=\"number\">24&#x27;h020000</span>; <span class=\"comment\">// 设置为捐赠设备的类别代码（例如，以太网控制器）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>验证正确的位宽：</strong></p>\n<ul>\n<li>确保类别代码使用<code>24&#39;h</code>前缀正确表示为24位十六进制值。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-6-保存更改\"><a href=\"#6-1-6-保存更改\" class=\"headerlink\" title=\"6.1.6 保存更改\"></a><strong>6.1.6 保存更改</strong></h4><p>在对配置参数进行所有修改后，保存和审查更改至关重要。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>保存文件：</strong><ul>\n<li>在VS Code中点击 <strong>文件 &gt; 保存</strong>，或按下 <code>Ctrl + S</code>（macOS上为 <code>Cmd + S</code>）。</li>\n</ul>\n</li>\n<li><strong>审查更改：</strong><ul>\n<li>在关闭之前，快速重新阅读修改过的行，以根据您的捐赠设备信息文档确认其准确性。</li>\n<li>检查是否有任何明显的语法错误或拼写错误（VS Code的扩展可能会高亮显示这些）。</li>\n</ul>\n</li>\n<li><strong>可选 - 使用版本控制：</strong><ul>\n<li>如果您正在使用Git（强烈推荐用于任何代码项目，尤其是固件），请以清晰且有意义的消息提交您的更改。这将创建您的修改历史记录。</li>\n<li><strong>示例Git命令：</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add pcileech_pcie_cfg_a7.sv</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;更新PCIe配置寄存器（VID, DID, SubIDs, Revision, Class Code）以匹配捐赠设备：[捐赠设备名称]&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-2-插入设备序列号（DSN）\"><a href=\"#6-2-插入设备序列号（DSN）\" class=\"headerlink\" title=\"6.2 插入设备序列号（DSN）\"></a><strong>6.2 插入设备序列号（DSN）</strong></h3><p>设备序列号（DSN）是一些PCIe设备（特别是那些具有高级功能或特定驱动程序的设备）可能使用的独特64位标识符。包含它能增强仿真的真实性，并有助于绕过明确查询此值的驱动程序中的检查。</p>\n<h4 id=\"6-2-1-定位DSN字段\"><a href=\"#6-2-1-定位DSN字段\" class=\"headerlink\" title=\"6.2.1 定位DSN字段\"></a><strong>6.2.1 定位DSN字段</strong></h4><p>DSN（如果由捐赠设备实现）是PCIe扩展能力的一部分。在PCILeech-FPGA框架中，DSN字段通常作为您一直在编辑的同一配置文件中的可配置参数公开。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>搜索 <strong>​</strong>​<code>cfg_dsn</code>​</strong>​ <strong>：</strong><ul>\n<li>在 <code>pcileech_pcie_cfg_a7.sv</code>（或您的板卡等效配置文件）中，使用搜索功能（<code>Ctrl + F</code> 或 <code>Cmd + F</code>）查找 <code>cfg_dsn</code>。</li>\n</ul>\n</li>\n<li><strong>理解现有赋值：</strong><ul>\n<li>DSN可能被设置为默认值（通常是全零）或被注释掉。它通常看起来像这样：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">63</span>:<span class=\"number\">0</span>] cfg_dsn = <span class=\"number\">64&#x27;h0000000000000000</span>; <span class=\"comment\">// 默认DSN（如果未使用，通常为0）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-2-插入DSN\"><a href=\"#6-2-2-插入DSN\" class=\"headerlink\" title=\"6.2.2 插入DSN\"></a><strong>6.2.2 插入DSN</strong></h4><p>更新DSN涉及将其设置为从捐赠设备捕获的精确64位十六进制值。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>更新 <strong>​</strong>​<code>cfg_dsn</code>​</strong>​ <strong>：</strong><ul>\n<li>将现有的十六进制值替换为您使用Arbor从捐赠设备中提取的64位DSN。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的DSN是<code>0x0011223344556677</code>，则更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">63</span>:<span class=\"number\">0</span>] cfg_dsn = <span class=\"number\">64&#x27;h0011223344556677</span>; <span class=\"comment\">// 捐赠设备序列号</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>处理DSN不可用或不相关的情况：</strong><ul>\n<li>如果您的捐赠设备<em>没有</em>DSN，或者您已确定它不是您目标驱动程序所需的参数，您可以简单地将其保留为零：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">63</span>:<span class=\"number\">0</span>] cfg_dsn = <span class=\"number\">64&#x27;h0000000000000000</span>; <span class=\"comment\">// 捐赠设备没有特定DSN，保留为默认0</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>注意</strong>：对于关键仿真，如果捐赠设备有DSN，最好准确仿真它。</li>\n</ul>\n</li>\n<li><strong>确保格式正确：</strong><ul>\n<li>DSN是64位值；确保它以<code>64&#39;h</code>前缀正确格式化为十六进制值。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-3-保存更改\"><a href=\"#6-2-3-保存更改\" class=\"headerlink\" title=\"6.2.3 保存更改\"></a><strong>6.2.3 保存更改</strong></h4><p>通过保存和审查文件来完成DSN修改。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>保存文件：</strong><ul>\n<li>在VS Code中点击 <strong>文件 &gt; 保存</strong>，或按下 <code>Ctrl + S</code>。</li>\n</ul>\n</li>\n<li><strong>验证语法：</strong><ul>\n<li>检查VS Code的语法检查器是否有任何红色下划线或错误指示。立即纠正任何问题。</li>\n</ul>\n</li>\n<li><strong>记录更改：</strong><ul>\n<li>如果使用版本控制，请使用适当的消息提交更新。</li>\n<li><strong>示例Git命令：</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -am <span class=\"string\">&quot;在PCIe配置中插入捐赠设备序列号（DSN）&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"7-Vivado项目设置与定制\"><a href=\"#7-Vivado项目设置与定制\" class=\"headerlink\" title=\"7. Vivado项目设置与定制\"></a><strong>7. Vivado项目设置与定制</strong></h2><p>在固件文件更新以反映捐赠设备的关键识别和配置数据后，下一个关键步骤是将这些更改集成到Vivado项目中。这包括为您的特定FPGA板卡生成项目文件，定制嵌入式PCIe IP核，并准备整个设计以进行综合和实现阶段。</p>\n<h3 id=\"7-1-生成Vivado项目文件\"><a href=\"#7-1-生成Vivado项目文件\" class=\"headerlink\" title=\"7.1 生成Vivado项目文件\"></a><strong>7.1 生成Vivado项目文件</strong></h3><p>Vivado是Xilinx（AMD）开发套件，使用Tcl（工具命令语言）脚本来自动化项目创建、添加源文件和配置项目设置。通过运行PCILeech-FPGA框架提供的这些脚本，您可以确保您的Vivado项目已为目标FPGA板卡正确设置。</p>\n<h4 id=\"7-1-1-打开Vivado\"><a href=\"#7-1-1-打开Vivado\" class=\"headerlink\" title=\"7.1.1 打开Vivado\"></a><strong>7.1.1 打开Vivado</strong></h4><p>启动Vivado的新会话可确保之前会话中没有残留设置或打开项目干扰当前工作。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>启动Vivado：</strong><ul>\n<li>在“开始”菜单（Windows）或“应用程序”文件夹（Linux&#x2F;macOS）中找到Vivado应用程序图标。</li>\n<li>点击打开。</li>\n</ul>\n</li>\n<li><strong>选择正确的版本：</strong><ul>\n<li>如果您安装了多个Vivado版本，请确保您启动的是与您的FPGA板卡和PCILeech-FPGA项目兼容的版本（如第4.3.1节所述，建议使用Vivado 2023.x等最新稳定版本）。</li>\n</ul>\n</li>\n<li><strong>等待启动界面：</strong><ul>\n<li>让Vivado完全初始化并显示欢迎界面或项目仪表板，然后才能继续。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-2-访问Tcl控制台\"><a href=\"#7-1-2-访问Tcl控制台\" class=\"headerlink\" title=\"7.1.2 访问Tcl控制台\"></a><strong>7.1.2 访问Tcl控制台</strong></h4><p>Vivado内的Tcl控制台是您执行脚本和直接命令的主要界面。您将在此处运行项目生成脚本。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>打开Tcl控制台：</strong><ul>\n<li>在Vivado界面中，导航到菜单栏。</li>\n<li>单击 <strong>Window</strong> &gt; <strong>Tcl Console</strong>。</li>\n<li>Tcl控制台窗格通常会出现在Vivado窗口的底部。</li>\n</ul>\n</li>\n<li><strong>调整控制台大小（可选）：</strong><ul>\n<li>您可以拖动控制台的顶部边框来调整其大小，使其更高以便更好地查看命令和输出。</li>\n</ul>\n</li>\n<li><strong>清除先前命令（可选但推荐）：</strong><ul>\n<li>如果存在任何先前的命令或消息，您可以在控制台内右键单击并选择“Clear Console”以获得一个干净的开始。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-3-导航到项目目录\"><a href=\"#7-1-3-导航到项目目录\" class=\"headerlink\" title=\"7.1.3 导航到项目目录\"></a><strong>7.1.3 导航到项目目录</strong></h4><p>在运行Tcl脚本之前，您必须确保Tcl控制台的当前工作目录已设置为您的板卡特定PCILeech-FPGA项目脚本所在的正确位置。</p>\n<p><strong>对于Squirrel DMA (Artix-7 35T) 或类似板卡：</strong></p>\n<p><strong>典型路径（克隆</strong>​<strong>​<code>pcileech-fpga</code>​</strong>​<strong>并导航到您的板卡变体后）：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel-35t/  # 在Windows上</span><br><span class=\"line\">~/Projects/pcileech-fpga/pcileech-squirrel-35t/  # 在Linux/macOS上</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：将</em>​ <em>​<code>&lt;your_board_variant&gt;</code>​</em>​<em>替换为您的板卡子目录的实际名称（例如，</em>​<em>​<code>pcileech-squirrel-35t</code>​</em>​ <em>，</em>​<em>​<code>pcileech-artix-7-50t</code>​</em>​ <em>）。</em></p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>在Tcl控制台中设置工作目录：</strong><ul>\n<li>在Vivado Tcl控制台中，输入<code>cd</code>命令，后跟您的板卡项目目录的完整路径。</li>\n<li><strong>示例（Windows）：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cd</span> C:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel<span class=\"number\">-35</span>t/</span><br></pre></td></tr></table></figure></li>\n<li><strong>示例（Linux&#x2F;macOS）：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cd</span> ~/Projects/pcileech-fpga/pcileech-squirrel<span class=\"number\">-35</span>t/</span><br></pre></td></tr></table></figure></li>\n<li><em>自我纠正提示：即使在Windows上，Tcl路径也使用正斜杠（</em>​ <em>​<code>/</code>​</em>​ <em>）。</em></li>\n</ul>\n</li>\n<li><strong>验证目录更改：</strong><ul>\n<li>要确认您处于正确的目录中，请在Tcl控制台中输入<code>pwd</code>（打印工作目录）。</li>\n<li>控制台应显示您刚刚设置的完整路径，确认更改。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-4-生成Vivado项目\"><a href=\"#7-1-4-生成Vivado项目\" class=\"headerlink\" title=\"7.1.4 生成Vivado项目\"></a><strong>7.1.4 生成Vivado项目</strong></h4><p>运行适用于您的FPGA板卡的相应Tcl脚本将自动化Vivado内部的整个项目设置过程。这包括创建项目、添加所有必要的源文件（HDL、约束）以及配置核心项目设置。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>运行Tcl脚本：</strong><ul>\n<li>输入<code>source</code>命令，后跟您的板卡的项​​目生成脚本的名称。PCILeech-FPGA项目通常在主板卡目录中提供这些脚本。</li>\n<li><strong>对于Squirrel (Artix-7 35T)（以及类似的Artix-7板卡）：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">source</span> vivado_generate_project_squirrel.tcl -notrace</span><br></pre></td></tr></table></figure></li>\n<li><strong>对于Enigma-X1 (Artix-7 75T)：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">source</span> vivado_generate_project_enigma_x1.tcl -notrace</span><br></pre></td></tr></table></figure></li>\n<li><strong>对于ZDMA (Artix-7 100T)：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">source</span> vivado_generate_project_100t.tcl -notrace</span><br></pre></td></tr></table></figure></li>\n<li><code>-notrace</code>选项可防止每个Tcl命令的详细输出，使控制台更整洁。</li>\n</ul>\n</li>\n<li><strong>等待脚本完成：</strong><ul>\n<li>脚本将按顺序执行许多命令。此过程可能需要几分钟，具体取决于您的系统性能和项目的复杂性。</li>\n<li>监控Tcl控制台的进度消息。脚本将：<ul>\n<li>在当前目录中创建一个新的Vivado项目（<code>.xpr</code>文件）。</li>\n<li>添加所有SystemVerilog&#x2F;Verilog源文件（<code>.sv</code>，<code>.v</code>）。</li>\n<li>添加Xilinx IP核配置（<code>.xci</code>）。</li>\n<li>添加XDC（Xilinx设计约束）文件。</li>\n<li>可能配置各种项目设置。</li>\n</ul>\n</li>\n<li><strong>处理任何错误</strong>：如果发生任何错误（例如，“文件未找到”、“无效命令”），脚本通常会停止。检查错误消息，纠正底层问题（例如，路径不正确、文件丢失），然后重新运行脚本。</li>\n</ul>\n</li>\n<li><strong>确认项目生成：</strong><ul>\n<li>成功完成后，Tcl控制台通常会指示项目已创建，并且您应该在项目目录中看到新生成的项目文件（例如，<code>pcileech_squirrel_top.xpr</code>）和相关目录（例如，<code>pcileech_squirrel_top.runs</code>，<code>pcileech_squirrel_top.ip</code>）。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-5-打开生成的项目\"><a href=\"#7-1-5-打开生成的项目\" class=\"headerlink\" title=\"7.1.5 打开生成的项目\"></a><strong>7.1.5 打开生成的项目</strong></h4><p>现在Vivado项目文件已成功由Tcl脚本生成，您可以在Vivado GUI中打开该项目以进行进一步检查和定制。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>打开项目：</strong><ul>\n<li>在Vivado中，点击 <strong>文件</strong> &gt; <strong>打开项目</strong>。</li>\n<li>导航到您的项目目录（与您在第7.1.3节中在Tcl控制台中设置的目录相同）。</li>\n</ul>\n</li>\n<li><strong>选择项目文件：</strong><ul>\n<li>找到并选择与您的板卡对应的Vivado项目文件（<code>.xpr</code>扩展名）。</li>\n<li><strong>对于Squirrel：</strong>  文件名通常为 <code>pcileech_squirrel_top.xpr</code>。</li>\n<li>点击 <code>.xpr</code> 文件以选择它。</li>\n</ul>\n</li>\n<li><strong>点击打开：</strong><ul>\n<li>Vivado将加载项目，显示设计层次结构、源文件、IP集成器块设计（如果使用）和各种设计视图。这可能需要一些时间。</li>\n</ul>\n</li>\n<li><strong>验证项目内容：</strong><ul>\n<li>在 <strong>项目管理器</strong> 窗口（通常在左侧）中，展开 <strong>源文件</strong> 窗格。</li>\n<li>确保所有预期的源文件（Verilog&#x2F;SystemVerilog、XDC、IP核）都已列出，并且设计层次结构看起来正确。</li>\n<li>检查 <strong>消息</strong> 窗格（底部）中打开项目时出现的任何警告或严重警告，因为这些可能表明潜在问题。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"7-2-修改IP核\"><a href=\"#7-2-修改IP核\" class=\"headerlink\" title=\"7.2 修改IP核\"></a><strong>7.2 修改IP核</strong></h3><p>PCIe IP核是设备PCIe接口的核心。它是一个经过Xilinx（AMD）预验证、可配置的模块，用于处理复杂的PCIe协议层。尽管某些配置空间值在SystemVerilog文件中处理（第6.1节），但其他核心PCIe参数，特别是与链路能力和BAR结构相关的参数，是在Vivado中直接通过PCIe IP核的定制设置进行配置的。定制IP核可确保您的FPGA在PCIe协议级别上与捐赠硬件的行为完全一致。</p>\n<h4 id=\"7-2-1-访问PCIe-IP核\"><a href=\"#7-2-1-访问PCIe-IP核\" class=\"headerlink\" title=\"7.2.1 访问PCIe IP核\"></a><strong>7.2.1 访问PCIe IP核</strong></h4><p>PCIe IP核在您的Vivado项目中被实例化为一个IP块。您需要打开其定制GUI来修改其参数。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>定位PCIe IP核：</strong><ul>\n<li>在 <strong>Sources</strong>（源文件）窗格（位于 <strong>Project Manager</strong>（项目管理器）窗口内）中，确保已选择 <strong>Hierarchy</strong>（层次结构）选项卡。</li>\n<li>展开设计层次结构，直到找到PCIe IP核的实例。</li>\n<li>对于7系列FPGA（如Squirrel中使用的Artix-7），它通常被命名为 <code>pcie_7x_0.xci</code> 或类似名称，通常位于项目源文件的 <code>ip</code> 子目录中。</li>\n</ul>\n</li>\n<li><strong>打开IP定制窗口：</strong><ul>\n<li><strong>右键单击</strong> <code>pcie_7x_0.xci</code> 文件。</li>\n<li>从上下文菜单中选择 <strong>Customize IP</strong>（定制IP）。</li>\n<li>将打开 <strong>IP Configuration</strong>（IP配置）窗口（或类似名称，如“Customize IP”或“Re-customize IP”），显示带有各种选项卡和选项的图形界面，用于配置PCIe核。</li>\n</ul>\n</li>\n<li><strong>等待IP设置加载：</strong><ul>\n<li>IP定制界面可能需要几分钟才能初始化并填充所有设置。在您开始进行更改之前，请确保所有选项和选项卡都已完全加载并响应。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-2-在IP核内部定制设备ID和BAR\"><a href=\"#7-2-2-在IP核内部定制设备ID和BAR\" class=\"headerlink\" title=\"7.2.2 在IP核内部定制设备ID和BAR\"></a><strong>7.2.2 在IP核内部定制设备ID和BAR</strong></h4><p>尽管某些设备标识符在<code>pcileech_pcie_cfg_a7.sv</code>中设置，但PCIe IP核本身也包含设备ID、厂商ID以及至关重要的基地址寄存器（BARs）的定义参数。您必须确保这些参数保持一致。<code>.sv</code>文件中的某些值可能会覆盖或输入到IP核中，但在此处也确保一致性是一个好习惯。IP核中的BAR设置尤其重要，因为它们决定了内存映射的硬件实现。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>导航到基本&#x2F;识别参数：</strong><ul>\n<li>在IP定制窗口中，查找与 <strong>基本</strong>、<strong>设备和厂商标识符</strong>、<strong>通用</strong> 或 <strong>PCIe能力</strong> 相关的选项卡或部分。这是定义基本ID和初始链路设置的地方。</li>\n</ul>\n</li>\n<li><strong>验证&#x2F;输入设备ID、厂商ID、子系统ID、修订ID、类别代码：</strong><ul>\n<li><strong>至关重要：请确认这些值与您在</strong>​<strong>​<code>pcileech_pcie_cfg_a7.sv</code>​</strong>​<strong>中设置的以及从捐赠设备中获取的值相匹配。</strong></li>\n<li>查找以下字段：<ul>\n<li><strong>设备ID</strong>：输入<code>0xXXXX</code>（例如，<code>0x1234</code>）。</li>\n<li><strong>厂商ID</strong>：输入<code>0xYYYY</code>（例如，<code>0xABCD</code>）。</li>\n<li><strong>子系统ID</strong>：输入<code>0xZZZZ</code>（例如，<code>0x5678</code>）。</li>\n<li><strong>子系统厂商ID</strong>：输入<code>0xWWWW</code>（例如，<code>0x9ABC</code>）。</li>\n<li><strong>修订ID</strong>：输入<code>0xRR</code>（例如，<code>0x01</code>）。</li>\n<li><strong>类别代码</strong>：输入<code>0xCCCCCC</code>（例如，<code>0x020000</code>）。</li>\n</ul>\n</li>\n<li><strong>重要提示</strong>：某些IP核版本或特定配置可能会直接从用户逻辑（如<code>pcileech_pcie_cfg_a7.sv</code>）拉取这些值，或者可能允许直接在此处设置它们。最可靠的方法是，如果IP GUI中提供此选项，则在两个位置都保持一致设置。</li>\n</ul>\n</li>\n<li><strong>导航到基地址寄存器（BARs）选项卡：</strong><ul>\n<li>在IP定制窗口中，找到并选择 <strong>BARs</strong> 选项卡或部分。这是您定义PCIe设备暴露的内存区域的地方。</li>\n</ul>\n</li>\n<li><strong>配置每个BAR：</strong><ul>\n<li>对于您的捐赠设备使用的每个BAR（BAR0到BAR5），根据您使用Arbor提取的信息，仔细配置以下参数：<ul>\n<li><strong>启用BAR</strong>：仅当捐赠设备使用此特定BAR时才选中此框。禁用（取消选中）捐赠设备不使用的任何BAR。</li>\n<li><strong>BAR大小</strong>：从下拉列表中选择精确的大小（例如，<strong>256 MB</strong>，<strong>64 KB</strong>，<strong>4 KB</strong>）。这对于主机操作系统分配正确数量的内存至关重要。</li>\n<li><strong>BAR类型</strong>：选择适当的类型：<ul>\n<li><strong>Memory (32-bit Addressing)</strong> （内存（32位寻址））: 用于32位地址可访问的内存映射区域。</li>\n<li><strong>Memory (64-bit Addressing)</strong> （内存（64位寻址））: 用于可以驻留在64位地址空间中任何位置的内存映射区域（对于大内存区域或如果捐赠设备使用它，则需要）。</li>\n<li><strong>I&#x2F;O</strong>: 用于传统I&#x2F;O端口区域（在现代PCIe中较不常见，但仍然可能）。</li>\n</ul>\n</li>\n<li><strong>可预取</strong>：如果捐赠设备的BAR被标记为可预取，则选中此框。此属性允许主机系统从此区域缓存或预取数据以提高性能。</li>\n</ul>\n</li>\n<li><strong>示例配置（基于您的捐赠设备）：</strong><ul>\n<li><strong>BAR0</strong>：<ul>\n<li>启用：是</li>\n<li>大小：<strong>256 MB</strong></li>\n<li>类型：<strong>Memory (64-bit Addressing)</strong></li>\n<li>可预取：是</li>\n</ul>\n</li>\n<li><strong>BAR1</strong>：<ul>\n<li>启用：否（如果捐赠设备不使用BAR1）</li>\n</ul>\n</li>\n<li><em>继续配置BAR2-BAR5，镜像捐赠设备的配置。</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>确保对齐和非重叠空间</strong>：<ul>\n<li>Vivado IP核通常会根据您选择的大小自动处理对齐。但是，请注意PCIe规范要求BAR大小是2的幂，并且BAR必须对其大小进行对齐。</li>\n<li>确保所有活动BAR映射的总内存不超过FPGA可用的块RAM（BRAM）或外部内存容量。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-3-完成IP定制\"><a href=\"#7-2-3-完成IP定制\" class=\"headerlink\" title=\"7.2.3 完成IP定制\"></a><strong>7.2.3 完成IP定制</strong></h4><p>在IP核定制窗口中配置所有必要的设置后，您必须应用这些更改，使其在Vivado项目中生效。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>审查所有设置：</strong><ul>\n<li>在应用之前，花点时间快速最后一次审查IP定制窗口中的每个选项卡。</li>\n<li>确认所有条目都与您捐赠设备的文档规范精确匹配。这里的一个小错误可能导致设备检测或功能问题。</li>\n</ul>\n</li>\n<li><strong>应用更改：</strong><ul>\n<li>点击IP定制窗口底部的 <strong>OK</strong> 或 <strong>Generate</strong> 按钮（标签可能不同）。</li>\n<li>如果Vivado提示您确认是否继续更改并重新生成IP输出产品，请点击 <strong>Yes</strong> 确认。</li>\n</ul>\n</li>\n<li><strong>重新生成IP核：</strong><ul>\n<li>Vivado现在将重新生成IP核的输出产品（例如，网表、仿真模型、新的<code>.xci</code>配置文件），以反映您的新配置。</li>\n<li>监控 <strong>消息</strong> 窗格（Vivado窗口底部），查看在此重新生成过程中可能出现的任何错误、警告或严重警告。立即解决任何严重警告。</li>\n</ul>\n</li>\n<li><strong>更新项目中的IP：</strong><ul>\n<li>在IP核重新生成后，Vivado可能会自动更新或提示您更新项目中的任何IP依赖项。允许它这样做，以确保在整个设计中使用最新的配置。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-4-锁定IP核\"><a href=\"#7-2-4-锁定IP核\" class=\"headerlink\" title=\"7.2.4 锁定IP核\"></a><strong>7.2.4 锁定IP核</strong></h4><p>锁定IP核是Vivado中推荐的最佳实践，可防止在后续综合和实现运行期间意外修改或重新定制，这可能会潜在地恢复您精心配置的设置。</p>\n<p><strong>锁定的目的：</strong></p>\n<ul>\n<li><strong>防止覆盖：</strong>  确保您在IP核GUI中进行的手动配置得以保留，不会因Vivado自动化或IP因细微项目更改而被检测为“过时”而意外覆盖。</li>\n<li><strong>保持一致性：</strong>  在整个构建过程中保持IP核处于已知、稳定的状态，这对于PCIe接口等关键组件尤其重要。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>打开Tcl控制台：</strong></p>\n<ul>\n<li>在Vivado中，如果Tcl控制台尚未打开，请转到 <strong>Window</strong> &gt; <strong>Tcl Console</strong>。</li>\n</ul>\n</li>\n<li><p><strong>执行锁定命令：</strong></p>\n<ul>\n<li>在Tcl控制台中，精确输入以下命令。此命令将PCIe IP核实例（<code>pcie_7x_0</code>）的<code>IP_LOCKED</code>属性设置为<code>true</code>。</li>\n</ul>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set_property -name &#123;IP_LOCKED&#125; -value true -objects [get_ips pcie_7x_0]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按 <strong>Enter</strong> 执行命令。</li>\n</ul>\n</li>\n<li><p><strong>验证锁定：</strong></p>\n<ul>\n<li>检查 <strong>消息</strong> 窗格。您应该会看到一条确认属性已设置的消息。</li>\n<li>您还可以右键单击源文件窗格中的 <code>pcie_7x_0.xci</code>，选择“IP Properties”（IP属性），并验证 <code>IP_LOCKED</code> 是否设置为 <code>true</code>。您可能还会注意到“Customize IP”（定制IP）选项现在已灰显，或者只允许“Re-customize IP”（重新定制IP），然后会警告您关于锁定。</li>\n</ul>\n</li>\n<li><p><strong>解锁（如果需要）：</strong></p>\n<ul>\n<li>如果您将来需要对PCIe IP核的设置进行进一步修改，则必须先将其解锁。使用以下Tcl命令：</li>\n</ul>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set_property -name &#123;IP_LOCKED&#125; -value false -objects [get_ips pcie_7x_0]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>请记住在进行和应用更改后重新锁定它。</li>\n</ul>\n</li>\n<li><p><strong>记录操作：</strong></p>\n<ul>\n<li>在您的项目文档（例如，README文件、项目说明）中注明PCIe IP核已锁定是一个好习惯。这有助于项目中其他人理解其配置状态并避免混淆。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"第二部分：中级概念与实现-1\"><a href=\"#第二部分：中级概念与实现-1\" class=\"headerlink\" title=\"第二部分：中级概念与实现\"></a><strong>第二部分：中级概念与实现</strong></h2><hr>\n<h2 id=\"8-高级固件定制\"><a href=\"#8-高级固件定制\" class=\"headerlink\" title=\"8. 高级固件定制\"></a><strong>8. 高级固件定制</strong></h2><p>为了实现对捐赠设备精确且令人信服的仿真，除了基本识别之外，还需要对FPGA固件进行更深入的定制。这包括调整PCIe参数（例如链路速度和事务大小），细致地调整基地址寄存器（BARs）及其相关的内存映射，以及准确仿真电源管理和中断机制。这些步骤确保仿真设备不仅在主机系统看来与原始硬件相同，而且在协议和功能级别上行为也完全一致。</p>\n<h3 id=\"8-1-配置PCIe参数以进行仿真\"><a href=\"#8-1-配置PCIe参数以进行仿真\" class=\"headerlink\" title=\"8.1 配置PCIe参数以进行仿真\"></a><strong>8.1 配置PCIe参数以进行仿真</strong></h3><p>精确仿真要求您的FPGA设备的PCIe操作参数经过细致配置，以匹配捐赠设备的参数。这包括PCIe链路速度、链路宽度、能力指针和最大有效载荷大小等设置。正确的配置可确保与主机系统的兼容性、驱动程序和应用程序与设备交互的正确操作以及数据传输的最佳性能。</p>\n<h4 id=\"8-1-1-匹配PCIe链路速度和宽度\"><a href=\"#8-1-1-匹配PCIe链路速度和宽度\" class=\"headerlink\" title=\"8.1.1 匹配PCIe链路速度和宽度\"></a><strong>8.1.1 匹配PCIe链路速度和宽度</strong></h4><p>PCIe链路速度（例如，Gen1、Gen2、Gen3）和链路宽度（例如，x1、x4、x8）是决定设备最大理论数据吞吐量和性能的关键参数。将这些设置与捐赠设备匹配对于精确仿真至关重要，因为驱动程序或系统组件可能期望特定的链路能力。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>访问PCIe IP核设置：</strong></p>\n<ul>\n<li><strong>打开您的Vivado项目：</strong>  启动Vivado并打开您之前创建或修改的项目（例如，<code>pcileech_squirrel_top.xpr</code>）。确保所有源文件都已正确添加到项目中。</li>\n<li><strong>定位PCIe IP核：</strong>  在 <strong>Sources</strong>（源文件）窗格（通常在左侧）中，展开设计层次结构以找到PCIe IP核实例。对于Xilinx 7系列设计（如Squirrel中使用的Artix-7），这通常被命名为 <code>pcie_7x_0.xci</code>。</li>\n<li><strong>定制IP核：</strong>  右键单击 <code>pcie_7x_0.xci</code> 并选择 <strong>Customize IP</strong>（定制IP）。IP定制窗口将打开，显示多个选项卡中的各种配置选项。</li>\n</ul>\n</li>\n<li><p><strong>设置最大链路速度：</strong></p>\n<ul>\n<li><strong>导航到链路参数：</strong>  在IP定制窗口中，点击 <strong>PCIe Capabilities</strong>（PCIe功能）选项卡（有时是“PCIe Configuration”或“General”）。在此选项卡内，查找与 <strong>Link Parameters</strong>（链路参数）或 <strong>Link Capability Register</strong>（链路能力寄存器）相关的部分。</li>\n<li><strong>配置最大链路速度：</strong>  找到标有 <strong>Maximum Link Speed</strong>（最大链路速度）的选项（或“Target Link Speed”）。</li>\n<li>将其设置为与您的捐赠设备支持和广告的最大链路速度相匹配。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果捐赠设备在 <strong>PCIe Gen2 (5.0 GT&#x2F;s)</strong>  下运行，选择 <strong>5.0 GT&#x2F;s</strong>。</li>\n<li>如果它在 <strong>PCIe Gen1 (2.5 GT&#x2F;s)</strong>  或 <strong>PCIe Gen3 (8.0 GT&#x2F;s)</strong>  下运行，请选择相应的选项。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>注意</strong>：确保您的FPGA的收发器和物理硬件（主板PCIe插槽）支持所选的链路速度。FPGA只会协商到其配置的最大速度。</li>\n</ul>\n</li>\n<li><p><strong>设置链路宽度：</strong></p>\n<ul>\n<li><strong>配置链路宽度：</strong>  在相同的 <strong>Link Parameters</strong>（链路参数）部分中，找到 <strong>Link Width</strong>（链路宽度）设置（或“PCIe Link Width”、“Target Link Width”）。</li>\n<li>将其设置为与您的捐赠设备广告的最大链路宽度相匹配。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果捐赠设备使用 <strong>x4</strong> 链路，将 <strong>Link Width</strong> 设置为 <strong>4</strong>。</li>\n<li>选项通常包括 <strong>1</strong>、<strong>2</strong>、<strong>4</strong>、<strong>8</strong>、<strong>16</strong> 通道。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>注意</strong>：物理PCIe插槽和FPGA的封装必须支持所选的链路宽度。尝试配置大于物理连接的宽度将导致链路协商问题。</li>\n</ul>\n</li>\n<li><p><strong>保存并重新生成：</strong></p>\n<ul>\n<li><strong>应用更改：</strong>  配置链路速度和宽度后，点击 <strong>OK</strong> 以在IP定制窗口中应用更改。</li>\n<li><strong>重新生成IP输出产品：</strong>  Vivado很可能会提示您由于所做的更改而重新生成IP核的输出产品。确认并允许重新生成过程完成。这可能需要一些时间。</li>\n<li><strong>验证设置：</strong>  一旦重新生成完成，您可以选择性地重新访问IP核设置，以确保配置已正确应用。检查Vivado中 <strong>Messages</strong>（消息）窗口中是否有任何警告或错误。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-1-2-设置能力指针\"><a href=\"#8-1-2-设置能力指针\" class=\"headerlink\" title=\"8.1.2 设置能力指针\"></a><strong>8.1.2 设置能力指针</strong></h4><p>PCIe配置空间中的能力指针是8位寄存器，它们形成一个链表，指向各种能力结构（例如，电源管理、MSI&#x2F;MSI-X、PCIe Express能力）。正确设置这些指针可确保主机系统能够遍历能力列表并定位和利用设备广告的功能。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>在固件中定位能力指针：</strong></p>\n<ul>\n<li><strong>打开配置文件：</strong>  在Visual Studio Code中，打开您的板卡的主配置文件，通常是<code>pcileech_pcie_cfg_a7.sv</code>，位于<code>pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_pcie_cfg_a7.sv</code>。</li>\n<li><strong>理解能力指针：</strong>  此文件中的能力指针（<code>cfg_cap_pointer</code>）指向PCIe配置空间中的<em>第一个</em>能力结构，通常从标准64字节配置头之后开始。后续的能力通过其“下一个能力指针”字段链接起来。</li>\n</ul>\n</li>\n<li><p><strong>设置能力指针值：</strong></p>\n<ul>\n<li><strong>找到</strong>​<strong>​<code>cfg_cap_pointer</code>​</strong>​<strong>的赋值：</strong>  在代码中搜索定义<code>cfg_cap_pointer</code>的行。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_cap_pointer = <span class=\"number\">8&#x27;hXX</span>; <span class=\"comment\">// 当前值（例如，默认的8&#x27;h40）</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>更新能力指针：</strong>  将<code>XX</code>替换为您使用Arbor从捐赠设备观察到的8位十六进制能力指针值。此值通常指向设备特定配置空间（通常在偏移量<code>0x3F</code>结束）之后第一个能力结构的偏移量。能力常见的起始点是<code>0x40</code>或<code>0x60</code>。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果捐赠设备的第一个能力指针是<code>0x60</code>（表示其第一个能力结构在配置空间中从偏移量<code>0x60</code>开始），将该行更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_cap_pointer = <span class=\"number\">8&#x27;h60</span>; <span class=\"comment\">// 更新以匹配捐赠设备的第一个能力偏移量</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>确保正确对齐：</strong>  能力结构必须对齐到4字节边界。能力指针应始终指向配置空间中有效的4字节对齐偏移量。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li><strong>保存配置文件：</strong>  进行更改后，点击 <strong>文件 &gt; 保存</strong> 或按下 <code>Ctrl + S</code> 保存文件。</li>\n<li><strong>验证语法：</strong>  确保更改未引入任何语法错误（VS Code通常会高亮显示这些错误）。</li>\n<li><strong>添加注释以清晰说明：</strong>  添加注释解释更改，以便将来参考和维护。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_cap_pointer = <span class=\"number\">8&#x27;h60</span>; <span class=\"comment\">// 设置为捐赠设备的能力指针（例如，PCIe能力位于0x60）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-1-3-调整最大载荷和读取请求大小\"><a href=\"#8-1-3-调整最大载荷和读取请求大小\" class=\"headerlink\" title=\"8.1.3 调整最大载荷和读取请求大小\"></a><strong>8.1.3 调整最大载荷和读取请求大小</strong></h4><p>这些参数定义了单个PCIe事务层数据包（TLP）中可以传输的最大数据量，以及非posted内存读取请求TLP的最大大小。将这些设置与捐赠设备匹配可确保兼容性并优化数据传输操作的性能。不匹配可能导致吞吐量降低或通信错误。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>设置支持的最大载荷大小（IP核）：</strong></p>\n<ul>\n<li><strong>访问设备功能：</strong>  在PCIe IP核定制窗口（Vivado中的<code>pcie_7x_0.xci</code>）中，导航到 <strong>PCIe Capabilities</strong>（PCIe功能）选项卡。</li>\n<li><strong>配置支持的最大载荷大小：</strong>  找到标有 <strong>Max Payload Size Supported</strong>（支持的最大载荷大小）的设置（或类似名称）。</li>\n<li>将其设置为与您的捐赠设备支持和广告的值相匹配（例如，128字节、256字节、512字节、1024字节、2048字节、4096字节）。<ul>\n<li><strong>示例：</strong>  如果捐赠设备支持的最大载荷大小为 <strong>256字节</strong>，请从下拉列表中选择 <strong>256字节</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>设置支持的最大读取请求大小（IP核）：</strong></p>\n<ul>\n<li><strong>配置支持的最大读取请求大小：</strong>  在同一选项卡中，找到 <strong>Max Read Request Size Supported</strong>（支持的最大读取请求大小）设置。</li>\n<li>将其设置为与捐赠设备的能力相匹配。这指定了设备在单个读取事务中可以请求的最大数据量。<ul>\n<li><strong>示例：</strong>  如果捐赠设备支持的最大读取请求大小为 <strong>512字节</strong>，请选择 <strong>512字节</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>调整固件参数（匹配IP核）：</strong></p>\n<ul>\n<li><strong>打开 <strong>​</strong>​<code>pcileech_pcie_cfg_a7.sv</code>​</strong>​ <strong>：</strong>  确保配置文件在Visual Studio Code中打开。</li>\n<li><strong>更新固件常量：</strong>  找到定义<code>max_payload_size_supported</code>和<code>max_read_request_size_supported</code>的行。这些通常是与您在IP核中选择的字节大小对应的位编码值。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_payload_size_supported = <span class=\"number\">3&#x27;bZZZ</span>;   <span class=\"comment\">// 当前值</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_read_request_size_supported = <span class=\"number\">3</span>&#x27;bWWW; <span class=\"comment\">// 当前值</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>设置适当的值：</strong>  将<code>ZZZ</code>和<code>WWW</code>替换为与所选大小对应的3位二进制表示。<ul>\n<li><strong>映射（根据PCIe规范）：</strong><ul>\n<li><strong>128字节</strong>：<code>3&#39;b000</code></li>\n<li><strong>256字节</strong>：<code>3&#39;b001</code></li>\n<li><strong>512字节</strong>：<code>3&#39;b010</code></li>\n<li><strong>1024字节</strong>：<code>3&#39;b011</code></li>\n<li><strong>2048字节</strong>：<code>3&#39;b100</code></li>\n<li><strong>4096字节</strong>：<code>3&#39;b101</code></li>\n</ul>\n</li>\n<li><strong>示例：</strong><ul>\n<li>对于 <strong>256字节</strong> 载荷大小：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_payload_size_supported = <span class=\"number\">3&#x27;b001</span>; <span class=\"comment\">// 支持最大256字节 (0x100)</span></span><br></pre></td></tr></table></figure></li>\n<li>对于 <strong>512字节</strong> 读取请求大小：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_read_request_size_supported = <span class=\"number\">3&#x27;b010</span>; <span class=\"comment\">// 支持最大512字节 (0x200)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>原因</strong>：这些固件参数通常决定了与PCIe核接口的用户逻辑的行为，确保您的逻辑遵循配置的最大值。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li><strong>保存文件：</strong>  更新<code>pcileech_pcie_cfg_a7.sv</code>中的值后，保存文件。</li>\n<li><strong>验证一致性：</strong>  Vivado PCIe IP核GUI中配置的值<em>必须</em>与您的HDL配置文件中设置的值<em>匹配</em>。任何不匹配都可能导致意外行为或链路训练问题。</li>\n<li><strong>添加注释：</strong>  在您的代码中清晰地记录这些更改，以便将来参考。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"8-2-调整BARs和内存映射\"><a href=\"#8-2-调整BARs和内存映射\" class=\"headerlink\" title=\"8.2 调整BARs和内存映射\"></a><strong>8.2 调整BARs和内存映射</strong></h3><p>基地址寄存器（BARs）是PCIe设备向主机系统公开其内部内存和寄存器的基本方式。正确配置BARs并在FPGA的BRAMs（块RAMs）和逻辑中定义它们的内存映射对于精确仿真和主机端设备驱动程序的正常运行至关重要。</p>\n<h4 id=\"8-2-1-设置BAR大小和类型（IP核和BRAM）\"><a href=\"#8-2-1-设置BAR大小和类型（IP核和BRAM）\" class=\"headerlink\" title=\"8.2.1 设置BAR大小和类型（IP核和BRAM）\"></a><strong>8.2.1 设置BAR大小和类型（IP核和BRAM）</strong></h4><p>配置BAR大小和类型可确保您的仿真设备在枚举期间向主机请求正确的地址空间量，并且主机适当地分配和映射这些区域。这还涉及将这些地址区域与FPGA内的物理内存块关联起来。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>访问BAR配置（PCIe IP核）：</strong></p>\n<ul>\n<li><strong>定制PCIe IP核：</strong>  在Vivado中，右键单击 <code>pcie_7x_0.xci</code> 并选择 <strong>Customize IP</strong>（定制IP）以打开其配置GUI。</li>\n<li><strong>导航到BARs选项卡：</strong>  在IP定制窗口中，点击 <strong>Base Address Registers (BARs)</strong> （基地址寄存器（BARs））选项卡。</li>\n</ul>\n</li>\n<li><p><strong>配置每个BAR（IP核）：</strong></p>\n<ul>\n<li><strong>匹配捐赠设备的BARs：</strong>  对于每个BAR（BAR0到BAR5），根据您使用Arbor从捐赠设备中提取的信息，细致地设置大小、类型和可预取状态。</li>\n<li><strong>启用&#x2F;禁用BARs：</strong>  确保只启用捐赠设备实际使用的BARs。禁用（取消选中）任何未使用的BARs。</li>\n<li><strong>设置BAR大小：</strong>  为每个<em>已启用</em>的BAR从下拉列表中选择适当的大小。这将是2的幂次（例如，4KB、8KB、64KB、1MB、256MB、1GB）。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果 <strong>BAR0</strong> 是 <strong>64 KB</strong>，将 <strong>BAR0 Size</strong> 设置为 <strong>64 KB</strong>。</li>\n<li>如果 <strong>BAR1</strong> 是 <strong>128 MB</strong>，将 <strong>BAR1 Size</strong> 设置为 <strong>128 MB</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>设置BAR类型：</strong><ul>\n<li>如果BAR是内存映射的，选择 <strong>Memory (32-bit Addressing)</strong> （内存（32位寻址））或 <strong>Memory (64-bit Addressing)</strong> （内存（64位寻址））。如果捐赠设备的BAR是64位或您需要访问4GB以上的地址，请选择 <strong>64-bit Addressing</strong>。</li>\n<li>如果BAR用于I&#x2F;O端口空间（现代PCIe设备较少见），选择 <strong>I&#x2F;O</strong>。</li>\n</ul>\n</li>\n<li><strong>设置可预取状态</strong>：如果捐赠设备的BAR被识别为可预取，请选中“Prefetchable”（可预取）框。此位允许主机预取该区域的数据，可能提高性能。</li>\n</ul>\n</li>\n<li><p><strong>更新BRAM配置（如果适用）：</strong></p>\n<ul>\n<li>许多PCILeech-FPGA项目使用Xilinx块RAM（BRAM）IP核来表示BARs暴露的内存区域。这些BRAM提供仿真设备内存的物理存储。</li>\n<li><strong>定位BRAM IP核：</strong>  在您的Vivado项目 <strong>Sources</strong>（源文件）窗格中，在<code>ip</code>子目录（或类似目录）中，您可能会找到BRAM的<code>.xci</code>文件，名称可能类似：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/ip/bram_bar_zero4k.xci</span><br><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/ip/bram_pcie_cfgspace.xci</span><br><span class=\"line\"># 可能还有BAR1、BAR2等的其他文件</span><br></pre></td></tr></table></figure></li>\n<li><strong>修改BRAM大小：</strong>  对于与<em>已启用</em>BAR关联的每个BRAM IP核，您可能需要 <strong>Customize IP</strong>（定制IP）（右键单击<code>.xci</code>文件）并调整其内存大小配置，以精确匹配相应的BAR大小。<ul>\n<li><strong>示例：</strong>  如果BAR0是256MB，请确保连接到BAR0的BRAM大小为256MB。</li>\n<li><strong>注意</strong>：确保所有活动BAR所需的总内存不超过您的FPGA设备的物理BRAM容量。超出容量将导致实现失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>保存并重新生成：</strong></p>\n<ul>\n<li><strong>应用更改（IP核）：</strong>  在PCIe IP核中配置BAR后，点击IP定制窗口中的 <strong>OK</strong>。</li>\n<li><strong>重新生成IP核：</strong>  Vivado将提示您由于所做的更改而重新生成PCIe IP核和任何相关的BRAM IP核。允许重新生成完成。这可确保硬件网表反映您的新BAR定义。</li>\n<li><strong>检查错误：</strong>  检查 <strong>Messages</strong>（消息）窗口中是否有与BAR配置或BRAM实例化相关的任何警告或错误。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-2-2-在固件中定义BAR地址空间\"><a href=\"#8-2-2-在固件中定义BAR地址空间\" class=\"headerlink\" title=\"8.2.2 在固件中定义BAR地址空间\"></a><strong>8.2.2 在固件中定义BAR地址空间</strong></h4><p>尽管PCIe IP核配置了BAR的<em>硬件</em>方面，但您的定制固件（SystemVerilog代码）需要定义当主机CPU对这些BAR区域内的地址执行读写操作时，仿真设备如何响应的<em>逻辑</em>。这涉及地址解码和实现寄存器&#x2F;内存访问逻辑。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>打开BAR控制器文件：</strong></p>\n<ul>\n<li>在Visual Studio Code中，打开负责处理BAR访问的SystemVerilog文件。对于PCILeech-FPGA，这通常是：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_tlps128_bar_controller.sv</span><br></pre></td></tr></table></figure>\n\n此模块通常接收PCIe内存读&#x2F;写TLP，并解码地址以确定正在访问哪个BAR（以及该BAR内的哪个偏移量）。</li>\n</ul>\n</li>\n<li><p><strong>实现地址解码逻辑：</strong></p>\n<ul>\n<li>在<code>pcileech_tlps128_bar_controller.sv</code>模块中，您会找到确定传入事务目标是哪个BAR的逻辑。这通常涉及根据配置的BAR大小检查地址位。</li>\n<li>您需要定义传入地址<code>req_addr</code>（来自TLP）如何映射到您的特定BAR内的偏移量。</li>\n<li><strong>概念示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：BAR0的逻辑（假设它是一个256MB的64位内存BAR，用于寄存器/数据）</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;bar_hit[0]&#x27;是一个指示命中BAR0的输入信号，通常来自PCIe核。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;req_addr&#x27;是传入的PCIe地址。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;req_be&#x27;是来自TLP的字节使能。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;req_data&#x27;是传入的写入数据。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;rsp_data&#x27;是传出的读取数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设BAR0是256MB (2^28字节)，地址位 [27:0] 在BAR范围内。</span></span><br><span class=\"line\"><span class=\"keyword\">localparam</span> BAR0_SIZE_BITS = <span class=\"number\">28</span>; <span class=\"comment\">// 2^28 = 256MB</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] internal_register_0; <span class=\"comment\">// BAR0内的示例寄存器</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] internal_register_1; <span class=\"comment\">// 另一个示例寄存器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assign</span> bar0_offset = req_addr[BAR0_SIZE_BITS-<span class=\"number\">1</span>:<span class=\"number\">0</span>]; <span class=\"comment\">// 提取BAR0内的偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always_comb</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认响应</span></span><br><span class=\"line\">    rsp_data = <span class=\"number\">32&#x27;hFFFFFFFF</span>; <span class=\"comment\">// 默认值为全F或类似值，表示未映射区域</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>]) <span class=\"keyword\">begin</span> <span class=\"comment\">// 如果事务目标是BAR0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req_write) <span class=\"keyword\">begin</span> <span class=\"comment\">// 这是写入操作</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">                <span class=\"comment\">// 示例：将偏移量0x0映射到internal_register_0</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0000</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">3</span>]) internal_register_0[<span class=\"number\">31</span>:<span class=\"number\">24</span>] = req_data[<span class=\"number\">31</span>:<span class=\"number\">24</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">2</span>]) internal_register_0[<span class=\"number\">23</span>:<span class=\"number\">16</span>] = req_data[<span class=\"number\">23</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">1</span>]) internal_register_0[<span class=\"number\">15</span>:<span class=\"number\">8</span>]  = req_data[<span class=\"number\">15</span>:<span class=\"number\">8</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">0</span>]) internal_register_0[<span class=\"number\">7</span>:<span class=\"number\">0</span>]   = req_data[<span class=\"number\">7</span>:<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"comment\">// 示例：将偏移量0x4映射到internal_register_1</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0004</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">3</span>]) internal_register_1[<span class=\"number\">31</span>:<span class=\"number\">24</span>] = req_data[<span class=\"number\">31</span>:<span class=\"number\">24</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">2</span>]) internal_register_1[<span class=\"number\">23</span>:<span class=\"number\">16</span>] = req_data[<span class=\"number\">23</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">1</span>]) internal_register_1[<span class=\"number\">15</span>:<span class=\"number\">8</span>]  = req_data[<span class=\"number\">15</span>:<span class=\"number\">8</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">0</span>]) internal_register_1[<span class=\"number\">7</span>:<span class=\"number\">0</span>]   = req_data[<span class=\"number\">7</span>:<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"comment\">// 添加更多寄存器映射或内存访问（例如，BRAM访问）</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"comment\">// 处理BAR0内未映射的写入，例如，忽略或记录</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req_read) <span class=\"keyword\">begin</span> <span class=\"comment\">// 这是读取操作</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">                <span class=\"comment\">// 示例：从internal_register_0读取</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0000</span>: rsp_data = internal_register_0;</span><br><span class=\"line\">                <span class=\"comment\">// 示例：从internal_register_1读取</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0004</span>: rsp_data = internal_register_1;</span><br><span class=\"line\">                <span class=\"comment\">// 添加更多寄存器映射或内存访问（例如，BRAM访问）</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    rsp_data = <span class=\"number\">32&#x27;h0</span>; <span class=\"comment\">// 对于未映射的读取返回0或特定错误值</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>处理数据传输：</strong>  <code>always_comb</code>块（或<code>always_ff</code>用于时序逻辑）应定义如何为读取生成<code>rsp_data</code>，以及如何根据<code>bar0_offset</code>和字节使能（<code>req_be</code>）更新内部寄存器&#x2F;内存。</li>\n</ul>\n</li>\n<li><p><strong>实现BRAM访问（如果BAR映射到BRAM）：</strong></p>\n<ul>\n<li>如果BAR映射到大块内存（例如，256MB），您通常会实例化一个BRAM IP核（如8.2.1所述）并将其<code>bar_controller</code>逻辑与它连接。<code>bar_controller</code>将向BRAM提供地址和控制信号。</li>\n<li><strong>概念性BRAM集成（简化）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在pcileech_tlps128_bar_controller.sv或子模块中</span></span><br><span class=\"line\"><span class=\"comment\">// BRAM接口</span></span><br><span class=\"line\"><span class=\"keyword\">wire</span> [BAR0_SIZE_BITS-<span class=\"number\">1</span>:<span class=\"number\">0</span>] bram_addr;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] bram_wr_data;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] bram_wr_en; <span class=\"comment\">// BRAM的字节使能</span></span><br><span class=\"line\"><span class=\"keyword\">wire</span> bram_wr_ce;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> bram_rd_ce;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] bram_rd_data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将TLP信号映射到BRAM接口</span></span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_addr = bar0_offset;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_wr_data = req_data;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_wr_en = req_be;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_wr_ce = bar_hit[<span class=\"number\">0</span>] &amp;&amp; req_write;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_rd_ce = bar_hit[<span class=\"number\">0</span>] &amp;&amp; req_read;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例化BRAM IP核</span></span><br><span class=\"line\">bram_bar_zero bram_inst ( <span class=\"comment\">// 假设&#x27;bram_bar_zero&#x27;是您的BRAM IP模块</span></span><br><span class=\"line\">    <span class=\"variable\">.clka</span>(clk),</span><br><span class=\"line\">    <span class=\"variable\">.ena</span>(<span class=\"number\">1&#x27;b1</span>),</span><br><span class=\"line\">    <span class=\"variable\">.wea</span>(bram_wr_en),</span><br><span class=\"line\">    <span class=\"variable\">.addra</span>(bram_addr),</span><br><span class=\"line\">    <span class=\"variable\">.dina</span>(bram_wr_data),</span><br><span class=\"line\">    <span class=\"variable\">.douta</span>(bram_rd_data)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于从BAR0的读取，输出BRAM的数据</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>] &amp;&amp; req_read) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    rsp_data = bram_rd_data;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>实现每个BAR的逻辑后，保存<code>pcileech_tlps128_bar_controller.sv</code>文件。</li>\n<li><strong>验证功能：</strong>  此逻辑很复杂。彻底的仿真（使用测试平台）和后续的硬件测试对于确保正确行为至关重要。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-2-3-处理多个BAR\"><a href=\"#8-2-3-处理多个BAR\" class=\"headerlink\" title=\"8.2.3 处理多个BAR\"></a><strong>8.2.3 处理多个BAR</strong></h4><p>正确管理多个BAR对于暴露多个独立内存或I&#x2F;O区域的设备至关重要。<code>bar_controller</code>模块通常处理所有BAR。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>实现每个BAR的逻辑：</strong></p>\n<ul>\n<li>在<code>pcileech_tlps128_bar_controller.sv</code>内部，扩展逻辑以处理您的捐赠设备使用的所有已启用BAR（BAR0、BAR1、BAR2等）。</li>\n<li><strong>独立逻辑块：</strong>  为清晰和可维护性，创建独立的<code>if/else if</code>块或<code>case</code>语句，根据哪个<code>bar_hit</code>信号被断言而激活。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BAR0处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// BAR0特定读/写逻辑，用于其寄存器/内存</span></span><br><span class=\"line\"><span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">1</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// BAR1特定读/写逻辑，用于其寄存器/内存</span></span><br><span class=\"line\"><span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">2</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// BAR2特定逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">// ... 继续其他BAR</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>定义寄存器和内存：</strong>  根据需要为每个BAR分配独立的寄存器集或连接不同的BRAM实例。</li>\n</ul>\n</li>\n<li><p><strong>确保非重叠地址空间：</strong></p>\n<ul>\n<li>虽然PCIe IP核处理与主机操作系统的每个BAR的不同地址空间的协商，但您的内部固件逻辑<em>必须</em>假定这些空间是独立的且不重叠的。</li>\n<li><strong>验证地址范围</strong>：仔细检查PCIe IP核中的BAR大小配置，以确保它们是独立的，并且根据PCIe规范正确地对齐到2的幂次方边界。</li>\n<li><strong>更新地址解码</strong>：您的<code>bar_controller</code>逻辑依赖于PCIe IP核生成的<code>bar_hit</code>信号。确保这些信号被正确解释并导致每个BAR的独特处理逻辑。</li>\n</ul>\n</li>\n<li><p><strong>测试BAR访问：</strong></p>\n<ul>\n<li><strong>仿真测试：</strong>  在硬件部署之前，使用仿真工具（例如Vivado仿真器）和全面的测试平台来验证对每个BAR的所有读写操作。<ul>\n<li>向每个BAR内的特定偏移量发送内存写入TLP。</li>\n<li>向每个BAR内的特定偏移量发送内存读取TLP并验证返回的数据。</li>\n</ul>\n</li>\n<li><strong>硬件测试：</strong>  编程FPGA后，使用主机端软件工具（如PCILeech客户端软件或定制C&#x2F;Python脚本）访问和验证每个BAR。<ul>\n<li><strong>Linux</strong>：使用<code>lspci -vvv</code>检查BAR映射（<code>Memory at XXXX (64-bit, prefetchable) [size=YYYY]</code>）。然后可以使用<code>devmem2</code>或自定义内核模块来读&#x2F;写这些映射地址。</li>\n<li><strong>Windows</strong>：使用“RW-Everything”等工具或自定义用户模式应用程序来检查和与映射的内存区域交互。</li>\n<li>执行各种读&#x2F;写模式以确保所有BAR之间的数据完整性和正确寻址。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"8-3-仿真设备电源管理和中断\"><a href=\"#8-3-仿真设备电源管理和中断\" class=\"headerlink\" title=\"8.3 仿真设备电源管理和中断\"></a><strong>8.3 仿真设备电源管理和中断</strong></h3><p>实现电源管理功能和中断对于需要与主机操作系统的电源管理和中断处理机制密切高效交互的设备至关重要。没有这些，仿真设备可能无法完全正常工作，或者性能可能不理想。</p>\n<h4 id=\"8-3-1-电源管理配置\"><a href=\"#8-3-1-电源管理配置\" class=\"headerlink\" title=\"8.3.1 电源管理配置\"></a><strong>8.3.1 电源管理配置</strong></h4><p>实现电源管理允许仿真设备支持各种电源状态（例如D0、D3hot），有助于系统范围的电源效率并符合操作系统的预期。主机操作系统将查询设备的功能并发送命令以在这些状态之间转换。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>在PCIe IP核中启用电源管理：</strong></p>\n<ul>\n<li><strong>访问功能：</strong>  在PCIe IP核定制窗口（<code>pcie_7x_0.xci</code>）中，导航到 <strong>PCIe Capabilities</strong>（PCIe功能）选项卡。</li>\n<li><strong>启用电源管理：</strong>  查找与 <strong>Power Management Capability</strong>（电源管理功能）相关的部分或选项。确保已选中或启用此选项，以便在设备的配置空间中包含电源管理（PM）功能结构。</li>\n</ul>\n</li>\n<li><p><strong>设置支持的电源状态：</strong></p>\n<ul>\n<li><strong>配置支持的状态：</strong>  在IP核的电源管理功能部分，指定设备支持的电源状态。这些通常是复选框或下拉菜单。将这些设置与您通过Arbor观察到的捐赠设备的能力相匹配。<ul>\n<li><strong>D0（完全开启&#x2F;运行）</strong> ：始终支持。</li>\n<li><strong>D1、D2（中间状态）</strong> ：可选，用于低功耗空闲状态。</li>\n<li><strong>D3hot（断电，辅助电源存在）</strong> ：设备逻辑关闭，但可以响应PM事件。</li>\n<li><strong>D3cold（完全断电）</strong> ：设备没有电源。</li>\n</ul>\n</li>\n<li><strong>示例</strong>：如果捐赠设备仅支持D0和D3hot，则只启用它们。</li>\n</ul>\n</li>\n<li><p><strong>在固件中实现电源状态逻辑：</strong></p>\n<ul>\n<li><strong>打开 <strong>​</strong>​<code>pcileech_pcie_cfg_a7.sv</code>​</strong>​ <strong>（或相关控制模块）：</strong>  您通常需要修改固件以反映并可能响应主机命令的电源状态转换。PCIe核本身处理大部分协议，但您的用户逻辑需要知道当前状态。</li>\n<li><strong>处理电源管理控制和状态寄存器（PMCSR）写入：</strong>  主机操作系统通过写入PMCSR中的特定位来改变设备的电源状态，PMCSR是PM能力结构的一部分。您的固件理想情况下应有逻辑来读取这些位并调整设备行为（例如，暂停&#x2F;恢复操作，启用&#x2F;禁用时钟）。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：pcileech_pcie_cfg_a7.sv或专用PM模块的一部分</span></span><br><span class=\"line\"><span class=\"comment\">// 假设&#x27;cfg_write&#x27;在配置写入时被断言，&#x27;cfg_address&#x27;是偏移量，&#x27;cfg_writedata&#x27;是数据。</span></span><br><span class=\"line\"><span class=\"comment\">// D状态位位于PM能力结构中偏移量0x04处，位[1:0]。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PMCSR寄存器（内部表示）</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] pmcsr_reg = <span class=\"number\">16&#x27;h0000</span>; <span class=\"comment\">// 初始化为D0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户逻辑信号，指示当前电源状态</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">1</span>:<span class=\"number\">0</span>] current_d_state = <span class=\"number\">2&#x27;b00</span>; <span class=\"comment\">// 00 = D0, 01 = D1, 10 = D2, 11 = D3hot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        pmcsr_reg &lt;= <span class=\"number\">16&#x27;h0000</span>;</span><br><span class=\"line\">        current_d_state &lt;= <span class=\"number\">2&#x27;b00</span>; <span class=\"comment\">// 重置为D0</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例：捕获对PMCSR的写入（如果直接在用户逻辑中处理）</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意：PCIe IP核管理大部分内容，但您的用户逻辑可能需要从中读取值。</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设PCIe核提供一个反映当前D状态的输出：</span></span><br><span class=\"line\">        <span class=\"comment\">// assign current_d_state = pcie_core_d_state_output;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果用户逻辑*需要*写入PMCSR（较少见，通常是只读状态）</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者它需要处理命令</span></span><br><span class=\"line\">        <span class=\"comment\">// if (cfg_write &amp;&amp; (cfg_address == PM_CAP_OFFSET + 2&#x27;h04)) begin // PMCSR在PM Cap基础地址+0x04</span></span><br><span class=\"line\">        <span class=\"comment\">//     pmcsr_reg[1:0] &lt;= cfg_writedata[1:0]; // 捕获新D状态</span></span><br><span class=\"line\">        <span class=\"comment\">//     // current_d_state &lt;= cfg_writedata[1:0]; // 更新内部状态</span></span><br><span class=\"line\">        <span class=\"comment\">// end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在PCILeech中，PCIe核管理PMCSR。您可能会从核读取信号。</span></span><br><span class=\"line\">        <span class=\"comment\">// 为了演示，假设&#x27;pcie_d_state&#x27;是来自IP核的输入。</span></span><br><span class=\"line\">        current_d_state &lt;= pcie_d_state; <span class=\"comment\">// 根据PCIe核的状态更新</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：响应D状态变化的逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current_d_state == <span class=\"number\">2&#x27;b11</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// D3hot状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 禁用非必要模块的电源，暂停操作，</span></span><br><span class=\"line\">        <span class=\"comment\">// 断言信号给主DMA逻辑以停止活动。</span></span><br><span class=\"line\">        <span class=\"comment\">// 例如：dma_engine_enable = 1&#x27;b0;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current_d_state == <span class=\"number\">2&#x27;b00</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// D0状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 启用全部功能</span></span><br><span class=\"line\">        <span class=\"comment\">// 例如：dma_engine_enable = 1&#x27;b1;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>管理电源状态效果：</strong>  实现逻辑以根据<code>current_d_state</code>更改设备的内部行为（例如，启用&#x2F;禁用时钟，将子模块置于低功耗模式）。这对于精确的功耗仿真以及确保设备正确响应操作系统命令至关重要。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>保存任何修改过的固件文件。</li>\n<li>通过仿真或硬件测试（例如，Windows“睡眠”或“休眠”功能，或Linux <code>poweroff</code>命令）彻底测试电源管理功能，以查看设备是否正确转换。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-3-2-MSI-MSI-X配置\"><a href=\"#8-3-2-MSI-MSI-X配置\" class=\"headerlink\" title=\"8.3.2 MSI&#x2F;MSI-X配置\"></a><strong>8.3.2 MSI&#x2F;MSI-X配置</strong></h4><p>实现消息信号中断（MSI）或其扩展版本（MSI-X）允许仿真设备使用基于消息的中断。这些中断比传统的引脚中断（INTx）效率更高、可扩展性更强，是现代PCIe设备的优选方法。MSI&#x2F;MSI-X允许设备通过向特定内存地址写入特殊TLP来通知CPU。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>在PCIe IP核中启用MSI&#x2F;MSI-X：</strong></p>\n<ul>\n<li><strong>访问中断配置：</strong>  在PCIe IP核定制窗口（<code>pcie_7x_0.xci</code>）中，导航到 <strong>Interrupts</strong>（中断）选项卡或专门标记为 <strong>MSI&#x2F;MSI-X Capabilities</strong>（MSI&#x2F;MSI-X功能）的部分。</li>\n<li><strong>选择中断类型：</strong>  根据捐赠设备的功能，选择 <strong>MSI</strong> 或 <strong>MSI-X</strong>。MSI-X通常因其灵活性（更多向量，每个向量可屏蔽）而受到青睐。</li>\n<li><strong>配置支持的向量数量：</strong>  设置设备将支持的中断向量（消息）数量。这应与捐赠设备匹配。<ul>\n<li><strong>MSI</strong> 支持最多32个向量（通常是1、2、4、8、16或32）。</li>\n<li><strong>MSI-X</strong> 支持最多2048个向量，允许更细粒度的中断源。</li>\n</ul>\n</li>\n<li><strong>启用功能：</strong>  确保MSI或MSI-X功能结构已明确启用，以便包含在设备的配置空间中。这是主机操作系统发现设备中断能力的方式。</li>\n</ul>\n</li>\n<li><p><strong>在固件中实现中断逻辑：</strong></p>\n<ul>\n<li><strong>打开 <strong>​</strong>​<code>pcileech_pcie_tlp_a7.sv</code>​</strong>​ <strong>（或用户逻辑模块）：</strong>  此文件通常负责用户定义的TLP生成，并且可能是启动MSI&#x2F;MSI-X消息的合适位置。但是，中断的<em>触发</em>将来自您的自定义逻辑。</li>\n<li><strong>定义中断信号：</strong>  声明内部信号，指示何时需要生成中断。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在自定义模块中（例如，&#x27;my_device_logic.sv&#x27;），该模块与TLP生成逻辑接口</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> msi_trigger_signal; <span class=\"comment\">// 当发生中断条件时断言此信号</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>实现中断生成逻辑：</strong>  定义应该触发中断的条件。这通常涉及在仿真设备的逻辑中检测事件。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在&#x27;my_device_logic.sv&#x27;内部</span></span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> clk;</span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> reset;</span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> event_data_ready; <span class=\"comment\">// 示例：当数据就绪时来自您的逻辑的输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        msi_trigger_signal &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event_data_ready) <span class=\"keyword\">begin</span> <span class=\"comment\">// 当特定事件发生时</span></span><br><span class=\"line\">        msi_trigger_signal &lt;= <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 触发MSI</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        msi_trigger_signal &lt;= <span class=\"number\">1&#x27;b0</span>; <span class=\"comment\">// 一个周期后或被确认后清除</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>连接到PCIe核的MSI接口：</strong>  <code>msi_trigger_signal</code>（或您的自定义逻辑的类似输出）需要连接到PCIe IP核的适当输入（例如，如果使用AXI-Stream接口进行MSI TLP，则连接到<code>s_axis_tdata_tready</code>、<code>s_axis_tdata_tvalid</code>、<code>s_axis_tdata_tlast</code>；或者连接到IP核提供的专用MSI请求端口）。然后PCIe核会形成并发送实际的MSI&#x2F;MSI-X TLP。有关精确的接口详细信息，请查阅Xilinx PCIe IP核文档。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>实现中断逻辑后，保存所有修改过的固件文件。</li>\n<li><strong>检查时序约束：</strong>  新逻辑，特别是中断路径，可能对时序很敏感。确保综合和实现工具不会报告与您的中断生成逻辑相关的任何时序违规。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-3-3-实现中断处理逻辑（设备端）\"><a href=\"#8-3-3-实现中断处理逻辑（设备端）\" class=\"headerlink\" title=\"8.3.3 实现中断处理逻辑（设备端）\"></a><strong>8.3.3 实现中断处理逻辑（设备端）</strong></h4><p>除了启用功能之外，定义仿真设备何时以及如何生成中断对于其与主机中断处理机制和驱动程序行为的正确交互至关重要。这涉及创建断言中断请求的内部逻辑。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>定义中断条件：</strong></p>\n<ul>\n<li><strong>识别触发事件：</strong>  根据您的捐赠设备的行为，确定哪些特定的内部事件应导致您的仿真设备生成中断。<ul>\n<li><strong>示例</strong>：数据传输完成、接收缓冲区中有新数据、内部错误条件、特定命令完成、链路状态更改。</li>\n</ul>\n</li>\n<li><strong>实现条件逻辑：</strong>  在您的自定义SystemVerilog模块中使用组合逻辑或时序逻辑，精确检测这些事件并生成一个短脉冲或电平信号，指示中断请求。</li>\n</ul>\n</li>\n<li><p><strong>创建中断生成模块（模块化设计）：</strong></p>\n<ul>\n<li>将中断生成逻辑封装到一个单独的专用模块中是一个好习惯，这样可以提高清晰度、可重用性并方便调试。此模块将内部事件作为输入，并产生一个连接到PCIe核的<code>msi_req</code>（或类似）输出。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件：interrupt_generator.sv</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> interrupt_generator (</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> clk,</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> reset,</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> event_trigger,        <span class=\"comment\">// 来自您的自定义逻辑的输入信号（例如，data_ready, error_flag）</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> msi_req_o            <span class=\"comment\">// 输出：断言此信号以请求MSI/MSI-X</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MSI的简单脉冲发生器（一次性中断）</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> event_trigger_d1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        msi_req_o &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">        event_trigger_d1 &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        event_trigger_d1 &lt;= event_trigger;</span><br><span class=\"line\">        <span class=\"comment\">// 当event_trigger从低到高跳变时，生成一个单周期脉冲</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event_trigger &amp;&amp; !event_trigger_d1) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            msi_req_o &lt;= <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 断言MSI请求</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            msi_req_o &lt;= <span class=\"number\">1&#x27;b0</span>; <span class=\"comment\">// 一个周期后取消断言</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span> <span class=\"comment\">// interrupt_generator</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>与主固件集成：</strong>  在您的顶层用户逻辑中（例如，在<code>pcileech_squirrel_top.sv</code>或其实例化的模块中）实例化此<code>interrupt_generator</code>模块，并将其<code>msi_req_o</code>输出连接到PCIe IP核的MSI输入。</li>\n</ul>\n</li>\n<li><p><strong>确保正确的时序和序列：</strong></p>\n<ul>\n<li><strong>遵守PCIe规范：</strong>  MSI&#x2F;MSI-X消息是TLP。确保这些消息的生成符合PCIe TLP格式、流控制和时序要求。PCIe IP核处理大部分内容，但您提供给它的输入信号必须稳定且时序正确。</li>\n<li><strong>管理中断延迟：</strong>  优化您的逻辑，以最大限度地减少内部事件发生与<code>msi_req_o</code>信号断言之间的任何不必要延迟。</li>\n</ul>\n</li>\n<li><p><strong>测试中断传递：</strong></p>\n<ul>\n<li><strong>仿真：</strong>  使用全面的测试平台模拟应生成中断的场景。验证您的<code>msi_req_o</code>信号是否按预期工作，以及PCIe核是否生成正确的MSI&#x2F;MSI-X TLP。</li>\n<li><strong>硬件测试：</strong><ul>\n<li>用更新的固件编程FPGA。</li>\n<li>使用主机端软件触发应引起中断的事件（例如，启动完成的DMA传输）。</li>\n<li>确认主机操作系统接收到中断。在Linux上，<code>dmesg</code>可以显示中断消息。在Windows上，您可以使用特定的驱动程序调试工具或事件查看器。</li>\n<li><strong>调试工具：</strong>  利用Vivado的集成逻辑分析仪（ILA）核（如第12节所述）实时监控<code>event_trigger</code>、<code>msi_req_o</code>和PCIe核的TLP输出信号，以验证正确的中断生成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>完成所有代码修改并保存相关固件文件。</li>\n<li>根据测试结果审查并改进您的中断逻辑，以确保可靠性。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"9-仿真设备特定功能\"><a href=\"#9-仿真设备特定功能\" class=\"headerlink\" title=\"9. 仿真设备特定功能\"></a><strong>9. 仿真设备特定功能</strong></h2><p>除了标准的PCIe配置空间和通用DMA功能之外，许多捐赠设备还具有独特的功能、自定义寄存器或厂商特定功能，这些对于其完整功能或与其专有驱动程序交互至关重要。精确的仿真需要理解和复制这些细微之处。本节将深入探讨如何实现这些高级功能，从而实现更忠实和功能更全面的仿真。</p>\n<h3 id=\"9-1-实现高级PCIe功能\"><a href=\"#9-1-实现高级PCIe功能\" class=\"headerlink\" title=\"9.1 实现高级PCIe功能\"></a><strong>9.1 实现高级PCIe功能</strong></h3><p>PCIe规范包含除了基本配置空间之外的各种<em>扩展功能</em>。这些功能提供了高级错误报告、电源管理、虚拟化等特性。实现这些功能有助于您的仿真设备显得更合法，并与现代主机系统正确交互。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>识别所需的扩展功能：</strong></p>\n<ul>\n<li>在使用Arbor等工具收集捐赠设备信息时，请仔细查找并记录捐赠设备配置空间中存在的任何扩展功能。这些通常在标准配置空间的初始256字节之外找到。</li>\n<li><strong>常见示例：</strong><ul>\n<li><strong>高级错误报告（AER）</strong> ：为PCIe链路提供强大的错误检测、日志记录和报告机制。</li>\n<li><strong>设备序列号（DSN）</strong> ：（已在第6.2节中介绍）。</li>\n<li><strong>电源管理（PM）</strong> ：（已在第8.3.1节中介绍）。</li>\n<li><strong>PCI Express（PCIe）功能结构</strong>：（已在第8.1节中介绍链路速度&#x2F;宽度、最大载荷&#x2F;读取请求，但也包括其他字段，如设备控制&#x2F;状态、链路控制&#x2F;状态）。</li>\n<li><strong>虚拟通道（VC）&#x2F;多功能虚拟通道（MFVC）</strong> ：用于服务质量（QoS）和流量管理。</li>\n<li><strong>精确时间测量（PTM）</strong> ：用于设备之间的时间同步。</li>\n<li><strong>延迟容忍报告（LTR）</strong> ：基于延迟要求进行电源管理。</li>\n<li><strong>可重置FPC（功能级重置）</strong> ：用于更细粒度的重置。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>在Vivado PCIe IP核中启用功能：</strong></p>\n<ul>\n<li>访问Vivado中的PCIe IP核定制窗口（<code>pcie_7x_0.xci</code>）。</li>\n<li>导航到各个选项卡（例如，“PCIe Capabilities”、“Extended Capabilities”、“Advanced Options”）。</li>\n<li>查找复选框或下拉菜单，以启用和配置从捐赠设备中识别出的特定扩展功能。</li>\n<li><strong>示例（AER）：</strong>  您会找到一个“高级错误报告”部分，您可以在其中启用它并配置其寄存器（例如，严重性掩码）。</li>\n<li><strong>注意：</strong>  Xilinx PCIe IP核为许多标准和扩展功能提供了高度可配置性。通常只需在GUI中启用正确的选项即可。</li>\n</ul>\n</li>\n<li><p><strong>实现功能寄存器的固件逻辑（如果需要）：</strong></p>\n<ul>\n<li>虽然PCIe IP核处理这些功能的<em>存在</em>和大部分<em>协议</em>，但某些功能会暴露您的自定义固件可能需要读写或其值需要固件响应的寄存器。</li>\n<li><strong>示例（AER）：</strong>  如果您的仿真设备检测到应通过AER报告的内部错误，您的固件需要写入特定的AER错误状态寄存器（这些寄存器可能作为BAR的一部分暴露，或由PCIe核内部处理，然后反映到用户逻辑）。然后您的用户逻辑将向PCIe核断言错误输入。</li>\n<li><strong>示例（电源管理）：</strong>  如8.3.1节所述，您的固件需要响应PCIe核发出的D状态变化。</li>\n<li><strong>流程：</strong><ul>\n<li>识别您的捐赠设备驱动程序交互的每个已启用功能结构中的特定寄存器。</li>\n<li>在PCILeech-FPGA框架中找到与这些寄存器接口的相应信号或逻辑（通常在<code>pcileech_pcie_cfg_a7.sv</code>或<code>bar_controller</code>中）。</li>\n<li>实现这些寄存器的读写逻辑，确保您的仿真设备的内部状态准确反映驱动程序期望的值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"9-2-仿真厂商特定功能\"><a href=\"#9-2-仿真厂商特定功能\" class=\"headerlink\" title=\"9.2 仿真厂商特定功能\"></a><strong>9.2 仿真厂商特定功能</strong></h3><p>这是真正的“全设备仿真”变得高度专业化的部分。许多实际设备具有独特的寄存器、未文档化的命令、自定义数据格式或专有控制流程，这些都使其与众不同。复制这些需要更深入的分析和定制HDL开发。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>逆向工程厂商特定行为：</strong></p>\n<ul>\n<li>这通常是最具挑战性的部分。</li>\n<li><strong>静态分析（驱动程序&#x2F;固件）：</strong>  反汇编捐赠设备的官方驱动程序（Windows <code>.sys</code>，Linux <code>.ko</code>）或设备的原始固件（如果可用）。查找独特的I&#x2F;O或MMIO访问模式、魔术值或寄存器写入序列。Ghidra、IDA Pro或objdump等工具会非常有价值。</li>\n<li><strong>动态分析（驱动程序执行）：</strong>  运行捐赠设备及其驱动程序，并使用<strong>PCIe协议分析仪</strong>（例如，Teledyne LeCroy，Keysight，如第12.2节所述）监控PCIe流量。这是理解实际TLP交换，包括厂商定义消息和寄存器访问序列的黄金标准。请注意：<ul>\n<li>BARs中访问的特定内存地址。</li>\n<li>对这些地址的读&#x2F;写模式。</li>\n<li>写入或读取特定寄存器的值。</li>\n<li>命令和响应之间的时序关系。</li>\n</ul>\n</li>\n<li><strong>系统调用&#x2F;API监控</strong>：在主机上，使用Procmon（Windows）或<code>strace</code>（Linux）等工具查看驱动程序如何与操作系统交互以及它使用了哪些特定的设备I&#x2F;O控制（IOCTL）代码，这些代码可能对应于特定的硬件操作。</li>\n<li><strong>硬件嗅探</strong>：如果可能，使用硬件嗅探器（如Saleae逻辑分析仪）捕获设备内部总线（例如SPI，I2C）上的信号，如果它有外部闪存或组件。</li>\n</ul>\n</li>\n<li><p><strong>在BARs中实现自定义寄存器和逻辑：</strong></p>\n<ul>\n<li>一旦您识别出厂商特定的寄存器或命令协议，您将需要将这些定义到您的FPGA固件中，通常作为可通过您的某个BAR访问的内存映射寄存器。</li>\n<li><strong>创建内部寄存器：</strong>  在您的SystemVerilog代码中声明<code>reg</code>变量来表示这些自定义寄存器。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在pcileech_tlps128_bar_controller.sv或子模块中</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] custom_control_reg;</span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] custom_status_reg;</span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] custom_data_reg;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：将它们映射到BAR0中的特定偏移量（假设BAR0足够大）</span></span><br><span class=\"line\"><span class=\"comment\">// 调整&#x27;bar0_offset&#x27; case语句（来自第8.2.2节）</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req_write) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1000</span>: custom_control_reg &lt;= req_data; <span class=\"comment\">// 自定义控制寄存器</span></span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1004</span>: custom_data_reg &lt;= req_data;    <span class=\"comment\">// 自定义数据写入寄存器</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 其他映射</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req_read) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1000</span>: rsp_data = custom_control_reg; <span class=\"comment\">// 读取控制寄存器</span></span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1008</span>: rsp_data = custom_status_reg;  <span class=\"comment\">// 自定义状态寄存器</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 其他映射</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>实现行为逻辑：</strong>  创建SystemVerilog逻辑（状态机、组合逻辑），用于：<ul>\n<li>响应对<code>custom_control_reg</code>的写入。例如，此寄存器中的某个特定位可能触发DMA传输、清除状态标志或启动内部操作。</li>\n<li>根据仿真设备的内部状态更新<code>custom_status_reg</code>（例如，“操作完成”、“发生错误”、“数据可用”）。</li>\n<li>处理写入<code>custom_data_reg</code>的数据，或在读取时从中提供数据，模仿捐赠设备的数据路径。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>仿真厂商特定消息（如果适用）：</strong></p>\n<ul>\n<li>一些复杂设备可能通过PCIe使用“厂商定义消息”（VDM）进行特定控制或通信。如果您的分析揭示了此类消息，您将需要：<ul>\n<li>在PCIe IP核中启用VDM支持（如果可用）。</li>\n<li>实现TLP生成逻辑（如第10节所述）来制作和发送这些VDM。</li>\n<li>实现TLP接收和解析逻辑来解释来自主机的传入VDM。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>验证仿真行为：</strong></p>\n<ul>\n<li><strong>迭代测试：</strong>  这是一个高度迭代的过程。进行小修改，编译，烧录，然后测试。</li>\n<li><strong>驱动程序加载：</strong>  捐赠设备的驱动程序是否正确加载而没有错误？</li>\n<li><strong>功能测试：</strong>  驱动程序能否启动基本操作？它是否从您的仿真寄存器获得预期的响应？</li>\n<li><strong>应用程序测试：</strong>  依赖捐赠设备的应用程序能否在您的仿真版本下正常运行？</li>\n<li><strong>调试：</strong>  广泛使用ILA和PCIe协议分析仪来比较您的仿真设备的行为与真实捐赠设备捕获的行为。寻找TLP时序、寄存器值和总体协议流中的差异。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"10-事务层数据包（TLP）仿真\"><a href=\"#10-事务层数据包（TLP）仿真\" class=\"headerlink\" title=\"10. 事务层数据包（TLP）仿真\"></a><strong>10. 事务层数据包（TLP）仿真</strong></h2><p>事务层数据包（TLP）是PCIe架构中通信的基本单位。主机系统与PCIe设备之间的每一次交互，从配置读取到数据传输，都被封装在一个或多个TLP中。精确的TLP仿真不仅重要；它对于您的仿真设备与主机系统正确交互，确保驱动程序正常运行和数据按预期移动，是<em>至关重要</em>的。</p>\n<h3 id=\"10-1-理解和捕获TLP\"><a href=\"#10-1-理解和捕获TLP\" class=\"headerlink\" title=\"10.1 理解和捕获TLP\"></a><strong>10.1 理解和捕获TLP</strong></h3><p>在您能够制作自定义TLP之前，您必须深入理解它们的结构和常见类型。从您的捐赠设备捕获真实世界的TLP可提供最精确的蓝图。</p>\n<ul>\n<li><p><strong>TLP结构的学习</strong>：<br>TLP通常由报头、可选数据载荷和可选的端到端CRC（ECRC）组成。报头至关重要，它定义了TLP的类型、事务细节和路由信息。</p>\n<ul>\n<li><strong>TLP的组成部分</strong>：<ul>\n<li><strong>报头（Header）</strong> ：最重要的部分，通常是3或4个双字（Dword &#x3D; 4字节）。它包含定义TLP目的和处理方式的关键字段：<ul>\n<li><strong>Fmt（格式）和 Type（类型）</strong> ：定义TLP的格式（3DW&#x2F;4DW，带&#x2F;不带数据）及其特定目的（例如，内存读取请求、内存写入、完成、配置读取&#x2F;写入）。</li>\n<li><strong>Length（长度）</strong> ：指定数据载荷的长度（以双字为单位）。</li>\n<li><strong>Requester ID（总线、设备、功能）</strong> ：标识发起请求的PCIe功能。对于将完成数据路由回正确的源头至关重要。</li>\n<li><strong>Tag（标签）</strong> ：由请求者分配给事务的唯一标识符，允许完成者将完成TLP与其原始请求TLP匹配。</li>\n<li><strong>Address（地址）</strong> ：对于内存&#x2F;IO事务，这是目标内存或I&#x2F;O地址。</li>\n<li><strong>First DW Byte Enable (FBE)</strong>  和 <strong>Last DW Byte Enable (LBE)</strong> ：指定数据载荷的第一个和最后一个双字中哪些字节对于写入操作有效，或哪些字节正在请求读取完成。</li>\n<li><strong>Traffic Class (TC)</strong>  和 <strong>Transaction ID (TID)</strong> ：用于QoS和排序规则。</li>\n</ul>\n</li>\n<li><strong>数据载荷（可选）</strong> ：存在于内存写入、配置写入和读取完成等TLP中。它包含实际传输的数据。</li>\n<li><strong>端到端CRC (ECRC)（可选）</strong> ：一个32位CRC，覆盖整个TLP，确保从源到目的地的数据完整性，通常由软件生成&#x2F;检查。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>理解常见的TLP类型</strong>：您的固件将主要处理这些类型：</p>\n<ul>\n<li><strong>Memory Read Request (MRd)</strong> ：由请求者（例如，主机CPU，或您的FPGA作为DMA主设备）发送的TLP，用于从特定内存地址读取数据。</li>\n<li><strong>Memory Read Completion (CplD)</strong> ：由完成者（例如，您的FPGA响应主机MRd）发送的TLP，携带请求的数据。</li>\n<li><strong>Memory Write (MWr)</strong> ：由请求者（例如，主机CPU，或您的FPGA）发送的TLP，用于向特定内存地址写入数据。</li>\n<li><strong>Completion Without Data (Cpl)</strong> ：由完成者发送的TLP，用于确认不返回数据的请求（例如，成功的MWr）。</li>\n<li><strong>Configuration Read Request (CfgRd)</strong> ：来自主机的TLP，用于读取设备配置空间中的寄存器。</li>\n<li><strong>Configuration Read Completion (CplD)</strong> ：来自设备返回CfgRd数据数据的TLP。</li>\n<li><strong>Configuration Write Request (CfgWr)</strong> ：来自主机的TLP，用于写入设备配置空间中的寄存器。</li>\n<li><strong>Vendor-Defined Messages (VDM)</strong> ：特定厂商用于专有通信的自定义TLP。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"10-1-2-从捐赠设备捕获TLP\"><a href=\"#10-1-2-从捐赠设备捕获TLP\" class=\"headerlink\" title=\"10.1.2 从捐赠设备捕获TLP\"></a><strong>10.1.2 从捐赠设备捕获TLP</strong></h4><p>从您的捐赠设备捕获真实的PCIe流量是无价的。它提供了TLP结构、序列和时序的具体示例，使您能够精确地复制它们。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>设置PCIe协议分析仪</strong>：<ul>\n<li>最有效的方法是使用专用的硬件工具，通常称为“PCIe协议分析仪”。这些设备位于主机和捐赠PCIe卡之间，被动捕获所有流量。</li>\n<li><strong>示例</strong>：<ul>\n<li><strong>Teledyne LeCroy PCIe 分析仪</strong>：行业标准，功能强大，但投资巨大。</li>\n<li><strong>Keysight PCIe 分析仪</strong>：另一个领先的供应商。</li>\n<li>（对于基本调试，一些带PCIe解码器的高端逻辑分析仪可能提供有限的TLP查看功能，但真正的协议分析仪更优越）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>捕获事务</strong>：<ul>\n<li>在连接了协议分析仪的测试系统中安装捐赠设备。</li>\n<li>运行捐赠设备的驱动程序和任何相关应用程序。</li>\n<li>在正常操作期间，尤其是关键阶段，监控和记录PCIe事务，例如：<ul>\n<li>设备枚举（操作系统首次检测到它时）。</li>\n<li>驱动程序加载和初始化。</li>\n<li>典型数据传输操作（例如，存储设备的大文件复制，网卡的网络流量）。</li>\n<li>设备特定命令或诊断。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>分析捕获的TLP</strong>：<ul>\n<li>使用协议分析仪的先进软件解剖捕获的TLP。软件将解码字段，提供时间顺序视图，并允许过滤和搜索。</li>\n<li>密切关注：<ul>\n<li>精确的<code>Fmt</code>和<code>Type</code>字段。</li>\n<li><code>Requester ID</code>和<code>Tag</code>值（特别是对于完成）。</li>\n<li>内存事务的<code>Address</code>和<code>Length</code>。</li>\n<li>写入和读取完成的<code>Data Payload</code>内容。</li>\n<li>任何厂商特定字段或自定义TLP。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"10-1-3-记录关键TLP事务\"><a href=\"#10-1-3-记录关键TLP事务\" class=\"headerlink\" title=\"10.1.3 记录关键TLP事务\"></a><strong>10.1.3 记录关键TLP事务</strong></h4><p>对捕获的TLP进行结构化文档创建了一个用于您的仿真的蓝图。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>识别关键事务</strong>：<ul>\n<li>重点关注对设备核心功能至关重要的TLP。这包括：<ul>\n<li><strong>初始化序列</strong>：操作系统在枚举期间执行的一系列配置读&#x2F;写。</li>\n<li><strong>驱动程序初始化</strong>：驱动程序启动时交换的命令和数据。</li>\n<li><strong>主要数据传输</strong>：<code>MWr</code>和<code>MRd</code> TLP如何为设备的主要功能构建和完成。</li>\n<li><strong>错误处理</strong>：设备如何报告错误（例如，带有Completer Abort (CA)、Unsupported Request (UR)的Completion）。</li>\n<li><strong>电源管理转换</strong>：与D状态变化相关的TLP。</li>\n<li><strong>中断生成</strong>：MSI&#x2F;MSI-X消息如何发送。</li>\n</ul>\n</li>\n<li>协议分析仪的截图在这里会非常有帮助。</li>\n</ul>\n</li>\n<li><strong>创建详细文档</strong>：<ul>\n<li>对于每个关键TLP序列，记录：<ul>\n<li><strong>TLP类型</strong>（例如，MWr、MRd、CplD）。</li>\n<li>其<strong>报头字段</strong>（Fmt、Type、Requester ID、Tag、Length、Address、Byte Enables）。</li>\n<li><strong>数据载荷</strong>（如果适用）。</li>\n<li>事务中的<strong>序列号</strong>或顺序。</li>\n<li>发送它的<strong>条件</strong>（例如，“主机在驱动程序初始化时发送”，“设备在DMA完成时发送”）。</li>\n<li>任何<strong>预期的响应</strong>或后续TLP。</li>\n</ul>\n</li>\n<li>协议分析仪的截图在这里会非常有帮助。</li>\n</ul>\n</li>\n<li><strong>理解时序和序列</strong>：<ul>\n<li>除了TLP内容，TLP的<em>时序</em>和<em>序列</em>至关重要。PCIe有严格的排序规则和流控制机制。注意：<ul>\n<li><strong>请求和完成之间的延迟</strong>：真实设备响应的速度。</li>\n<li><strong>流控制信用</strong>：设备如何管理其传入&#x2F;传出TLP的缓冲区空间。虽然Xilinx PCIe IP核处理基本的流控制，但对于高级仿真，了解捐赠设备的典型信用使用情况会有所帮助。</li>\n<li><strong>事务层数据包排序</strong>：理解posted（写入）和non-posted（读取、完成）事务如何排序。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"10-2-制作用于特定操作的定制TLP\"><a href=\"#10-2-制作用于特定操作的定制TLP\" class=\"headerlink\" title=\"10.2 制作用于特定操作的定制TLP\"></a><strong>10.2 制作用于特定操作的定制TLP</strong></h3><p>一旦您理解了蓝图，您就可以将这些知识转化为您的FPGA固件（SystemVerilog），以主动生成和响应TLP。PCILeech-FPGA框架提供了抽象层，但对于深度仿真，您可能需要直接与TLP生成&#x2F;解析逻辑交互。</p>\n<h4 id=\"10-2-1-在固件中实现TLP处理\"><a href=\"#10-2-1-在固件中实现TLP处理\" class=\"headerlink\" title=\"10.2.1 在固件中实现TLP处理\"></a><strong>10.2.1 在固件中实现TLP处理</strong></h4><p>您的固件需要逻辑来发送和接收TLP。PCIe IP核处理物理层和数据链路层，向您的用户逻辑暴露一个事务层接口（通常是AXI-Stream）。</p>\n<ul>\n<li><p><strong>要修改的文件（主要）</strong> ：</p>\n<ul>\n<li><code>pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_pcie_tlp_a7.sv</code>（或类似文件，取决于板卡变体）<ul>\n<li>此文件通常包含将用户请求转换为出站TLP并将传入TLP解析为用户逻辑信号的核心逻辑。</li>\n</ul>\n</li>\n<li><code>pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_tlps128_bar_controller.sv</code><ul>\n<li>此模块专门处理解析目标为设备BAR的传入内存读&#x2F;写TLP，并生成相应的完成TLP。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>步骤</strong>：</p>\n<ol>\n<li><p><strong>理解PCIe IP核接口</strong>：</p>\n<ul>\n<li>在编写TLP逻辑之前，请彻底阅读Xilinx PCIe IP核用户指南（特别是关于用户应用接口或AXI4-Stream接口的部分）。这定义了您的SystemVerilog逻辑如何连接到PCIe核以发送和接收TLP。您通常会与<code>s_axis_rx_tdata</code>（接收到的TLP数据）、<code>s_axis_rx_tvalid</code>（接收到有效TLP）、<code>m_axis_tx_tdata</code>（传出TLP数据）、<code>m_axis_tx_tready</code>（核已准备好接受TLP）等进行交互。</li>\n</ul>\n</li>\n<li><p><strong>创建TLP生成函数（用于出站TLP）</strong> ：</p>\n<ul>\n<li>在<code>pcileech_pcie_tlp_a7.sv</code>（或与<code>m_axis_tx_*</code>接口的模块）中，您将编写逻辑来组装具有所需报头和载荷的TLP。这通常涉及将各种字段组合成一个<code>[127:0]</code>（对于128位接口）或<code>[63:0]</code>（对于64位接口）总线，该总线馈送PCIe核。</li>\n<li><strong>示例（概念性，简化函数，用于3DW TLP报头）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个概念性辅助函数。实际上，您将构建一个状态机</span></span><br><span class=\"line\"><span class=\"comment\">// 通过AXI-Stream接口发送TLP，可能使用FIFO。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"keyword\">automatic</span> [<span class=\"number\">95</span>:<span class=\"number\">0</span>] create_3dw_tlp_header; <span class=\"comment\">// 假设3个双字 = 96位</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] tlp_type_fmt;   <span class=\"comment\">// 格式和类型字段</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] requester_id;  <span class=\"comment\">// BDF</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] tag;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] lower_address_bits; <span class=\"comment\">// 或更复杂的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] byte_enables;   <span class=\"comment\">// 第一个双字字节使能</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">begin</span></span><br><span class=\"line\">        create_3dw_tlp_header = &#123;</span><br><span class=\"line\">            tlp_type_fmt,                     <span class=\"comment\">// Fmt[6:4], Type[3:0]</span></span><br><span class=\"line\">            <span class=\"number\">8&#x27;b0</span>,                             <span class=\"comment\">// 保留</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;b0</span>,                             <span class=\"comment\">// TC[3:0] (流量类别)</span></span><br><span class=\"line\">            <span class=\"number\">3&#x27;b0</span>,                             <span class=\"comment\">// Attr[2:0]</span></span><br><span class=\"line\">            <span class=\"number\">1&#x27;b0</span>,                             <span class=\"comment\">// TH (TLP提示)</span></span><br><span class=\"line\">            <span class=\"number\">2&#x27;b0</span>,                             <span class=\"comment\">// D(igest) (ECRC存在)</span></span><br><span class=\"line\">            <span class=\"number\">1&#x27;b0</span>,                             <span class=\"comment\">// EP (Poisoned)</span></span><br><span class=\"line\">            <span class=\"number\">1&#x27;b0</span>,                             <span class=\"comment\">// TD (类型依赖)</span></span><br><span class=\"line\">            <span class=\"comment\">// DW0: Fmt, Type, TC, Attr, TH, D, EP, TD, Length (不在3DW中, 4DW有)</span></span><br><span class=\"line\"></span><br><span class=\"line\">            requester_id,                     <span class=\"comment\">// 请求者ID (Bus[7:0], Device[4:0], Function[2:0])</span></span><br><span class=\"line\">            tag,                              <span class=\"comment\">// 标签</span></span><br><span class=\"line\">            lower_address_bits,               <span class=\"comment\">// 示例：地址的低位或数据的一部分</span></span><br><span class=\"line\">            byte_enables,                     <span class=\"comment\">// 第一个双字字节使能</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;b0</span>,                             <span class=\"comment\">// 保留</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;b0</span>                              <span class=\"comment\">// 最后一个双字字节使能 (通常用于MWr)</span></span><br><span class=\"line\">            <span class=\"comment\">// DW1, DW2... 字段</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">endfunction</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：在状态机中生成带数据的完成（CplD）</span></span><br><span class=\"line\"><span class=\"comment\">// 这只是一个片段，不是完整实现</span></span><br><span class=\"line\"><span class=\"keyword\">localparam</span>  CPLD_3DW_FMT = <span class=\"number\">8&#x27;h4A</span>; <span class=\"comment\">// Fmt=100 (4DW, 带数据), Type=1010 (Cpl)</span></span><br><span class=\"line\"><span class=\"keyword\">localparam</span>  CPL_D_FMT_TYPE_LEN = <span class=\"number\">8&#x27;h4A</span>; <span class=\"comment\">// 根据PCIe规范调整。(带数据的4DW报头)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 发送TLP的状态机</span></span><br><span class=\"line\"><span class=\"comment\">// 在准备发送CplD的状态下</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (tx_ready_from_pcie_core) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// 构建报头和载荷</span></span><br><span class=\"line\">    <span class=\"comment\">// 对于CplD，您需要Compliter ID, Status, Byte Count, Requester ID, Tag, Completion ID, Lower Address</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后是实际的读取数据载荷</span></span><br><span class=\"line\">    m_axis_tx_tdata_reg = &#123;</span><br><span class=\"line\">        CPL_D_FMT_TYPE_LEN,         <span class=\"comment\">// 字节0: Fmt/Type</span></span><br><span class=\"line\">        tlp_length_dw_minus_one,    <span class=\"comment\">// 字节1: TLP长度 (以双字为单位) - 1</span></span><br><span class=\"line\">        status_completion_bits,     <span class=\"comment\">// 字节2: Cpl Status, BCM, Rsvd</span></span><br><span class=\"line\">        byte_count_dws_upper,       <span class=\"comment\">// 字节3: 字节计数 (高位)</span></span><br><span class=\"line\">        requester_id,               <span class=\"comment\">// 字节4-5: 请求者ID (来自原始MRd)</span></span><br><span class=\"line\">        tag,                        <span class=\"comment\">// 字节6: 标签 (来自原始MRd)</span></span><br><span class=\"line\">        byte_count_dws_lower,       <span class=\"comment\">// 字节7: 字节计数 (低位)</span></span><br><span class=\"line\">        completion_id,              <span class=\"comment\">// 字节8-9: 完成ID (您的BDF)</span></span><br><span class=\"line\">        lower_address_from_request  <span class=\"comment\">// 字节10-11: 请求的低位地址</span></span><br><span class=\"line\">        <span class=\"comment\">// ... 接着是实际的数据载荷</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    m_axis_tx_tvalid_reg = <span class=\"number\">1&#x27;b1</span>;</span><br><span class=\"line\">    m_axis_tx_tlast_reg = <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 最后一个TLP片段</span></span><br><span class=\"line\">    <span class=\"comment\">// ... 状态转换以等待tready</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>注意</strong>：实际实现涉及状态机、FIFO，以及遵循PCIe IP核的AXI-Stream协议。PCILeech-FPGA框架已经为此提供了良好的基础，但您可能需要为非常特定的TLP行为进行扩展或修改。</li>\n</ul>\n</li>\n<li><p><strong>处理TLP接收（用于入站TLP）</strong> ：</p>\n<ul>\n<li>实现逻辑以解析来自PCIe核接收接口的传入TLP（例如，<code>s_axis_rx_tdata</code>、<code>s_axis_rx_tvalid</code>）。</li>\n<li>此解析包括：<ul>\n<li>检查<code>s_axis_rx_tvalid</code>以判断是否存在TLP。</li>\n<li>从TLP报头中读取<code>Fmt</code>和<code>Type</code>字段以确定其目的。</li>\n<li>提取<code>Requester ID</code>、<code>Tag</code>、<code>Address</code>、<code>Length</code>和<code>Data Payload</code>等相关字段。</li>\n</ul>\n</li>\n<li>使用<code>case</code>语句或<code>if/else if</code>块，根据TLP类型将信息路由到适当的内部逻辑（例如，用于内存写入的<code>bar_controller</code>，用于配置写入的配置模块）。</li>\n<li><strong>示例（概念性，简化解析）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在pcileech_pcie_tlp_a7.sv或TLP解析模块中</span></span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> [<span class=\"number\">127</span>:<span class=\"number\">0</span>] s_axis_rx_tdata;</span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> s_axis_rx_tvalid;</span><br><span class=\"line\"><span class=\"keyword\">output</span> <span class=\"keyword\">wire</span> s_axis_rx_tready; <span class=\"comment\">// 需要断言此信号以接受更多数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] received_tlp_fmt_type;</span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] received_requester_id;</span><br><span class=\"line\"><span class=\"comment\">// ... 声明其他已解析的字段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assign</span> s_axis_rx_tready = <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 为简化起见始终准备好接收，在实际设计中管理反压</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s_axis_rx_tvalid) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        received_tlp_fmt_type = s_axis_rx_tdata[<span class=\"number\">127</span>:<span class=\"number\">120</span>]; <span class=\"comment\">// 假设最高位</span></span><br><span class=\"line\">        received_requester_id = s_axis_rx_tdata[<span class=\"number\">111</span>:<span class=\"number\">96</span>]; <span class=\"comment\">// 示例偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据TLP类型解码</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> (received_tlp_fmt_type[<span class=\"number\">3</span>:<span class=\"number\">0</span>]) <span class=\"comment\">// 仅TLP类型位</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;h0</span>: <span class=\"comment\">// 内存写入 (3DW或4DW取决于Fmt)</span></span><br><span class=\"line\">                <span class=\"comment\">// 提取地址、长度、载荷并传递给BAR控制器</span></span><br><span class=\"line\">                <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"comment\">// 传递给BAR控制器，用于写入仿真内存</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_write_enable = 1&#x27;b1;</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_write_address = s_axis_rx_tdata[...];</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_write_data = s_axis_rx_tdata[...];</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;h1</span>: <span class=\"comment\">// 内存读取</span></span><br><span class=\"line\">                <span class=\"comment\">// 提取地址、长度，并传递给BAR控制器进行读取</span></span><br><span class=\"line\">                <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_read_enable = 1&#x27;b1;</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_read_address = s_axis_rx_tdata[...];</span></span><br><span class=\"line\">                    <span class=\"comment\">// (完成将由BAR控制器生成)</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 其他TLP类型</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"comment\">// 处理不支持或保留的TLP类型（例如，日志记录、错误）</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>确保符合性</strong>：</p>\n<ul>\n<li>严格验证您生成和解析的TLP是否符合PCIe规范的格式、字段定义和时序。偏差将导致通信失败。</li>\n</ul>\n</li>\n<li><p><strong>实现完成处理</strong>：</p>\n<ul>\n<li>对于从主机接收到的内存读取请求（MRd）和配置读取请求（CfgRd），您的设备必须在指定的时间内返回适当的完成TLP（CplD表示数据，Cpl表示无数据）。<code>bar_controller</code>模块（第8.2.2节）是此BAR读取逻辑所在的位置。</li>\n</ul>\n</li>\n<li><p><strong>保存更改</strong>：</p>\n<ul>\n<li>保存文件（<code>pcileech_pcie_tlp_a7.sv</code>、<code>pcileech_tlps128_bar_controller.sv</code>或任何自定义模块）后，实现更改。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"10-2-2-处理不同TLP类型\"><a href=\"#10-2-2-处理不同TLP类型\" class=\"headerlink\" title=\"10.2.2 处理不同TLP类型\"></a><strong>10.2.2 处理不同TLP类型</strong></h4><p>每种TLP类型都有特定的报头格式和行为。您的固件必须擅长处理与您的捐赠设备相关的那些类型。</p>\n<ul>\n<li><p><strong>内存读取请求（MRd）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>当接收到MRd TLP（由<code>pcileech_pcie_tlp_a7.sv</code>解析并路由到<code>bar_controller</code>）时，<code>bar_controller</code>需要：<ul>\n<li>解析请求的地址和长度。</li>\n<li>从适当的内部内存位置（例如，连接到BAR的BRAM）或内部寄存器中获取数据。</li>\n<li>组装一个<strong>带数据的完成（CplD）</strong>  TLP。关键是，此TLP必须包含来自MRd请求的原始<code>Requester ID</code>、<code>Tag</code>和<code>Completion ID</code>（您的设备BDF），以及获取的数据载荷。</li>\n<li>通过PCIe IP核的传输接口将CplD TLP发送回主机。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>内存写入请求（MWr）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>当接收到MWr TLP时，<code>bar_controller</code>需要：<ul>\n<li>解析目标地址、长度和<code>Byte Enables</code>（FBE&#x2F;LBE）。</li>\n<li>提取<code>数据载荷</code>。</li>\n<li>将数据写入仿真设备内的指定内存位置（例如，BRAM或内部寄存器），并遵循字节使能。</li>\n</ul>\n</li>\n<li>内存写入是“posted事务”，这意味着它们不需要完成TLP进行确认，除非发生错误。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>配置读&#x2F;写请求（CfgRd&#x2F;CfgWr）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>这些TLP针对设备的配置空间（厂商ID、设备ID、BAR、功能等）。Xilinx PCIe IP核根据其配置自动处理大部分标准配置空间访问。</li>\n<li>但是，如果您的配置空间中存在非标准的自定义寄存器或扩展功能，您可能需要特定的逻辑来：<ul>\n<li>对于CfgRd：从您的内部<code>cfg_</code>寄存器返回请求的数据。</li>\n<li>对于CfgWr：更新您的内部<code>cfg_</code>寄存器或根据写入的数据触发操作。</li>\n</ul>\n</li>\n<li>配置读取需要<strong>带数据的完成（CplD）</strong> ，而配置写入需要<strong>不带数据的完成（Cpl）</strong> 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>厂商定义消息（VDM）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>如果您的捐赠设备使用VDM，这将需要专门的解析和响应逻辑。</li>\n<li><strong>解析传入VDM</strong>：根据其<code>Fmt</code>和<code>Type</code>字段识别VDM。提取厂商特定数据并根据您的逆向工程发现进行解释。</li>\n<li><strong>制作出站VDM</strong>：当您的仿真设备需要发送VDM时，创建逻辑来组装具有精确厂商特定报头和载荷格式的VDM。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"10-2-3-验证TLP时序和序列\"><a href=\"#10-2-3-验证TLP时序和序列\" class=\"headerlink\" title=\"10.2.3 验证TLP时序和序列\"></a><strong>10.2.3 验证TLP时序和序列</strong></h4><p>即使TLP格式完美，不正确的时序或序列也会导致设备故障或被检测为不兼容。</p>\n<ul>\n<li><p><strong>步骤</strong>：</p>\n<ol>\n<li><p><strong>使用仿真工具</strong>：</p>\n<ul>\n<li><strong>测试平台</strong>：为您的TLP生成和解析模块开发全面的SystemVerilog测试平台。</li>\n<li>模拟各种场景（例如，主机发送MRd，您的设备发送CplD；主机发送MWr；主机枚举设备），以验证TLP是否正确形成、传输、接收和处理。</li>\n<li>验证TLP的序列，并确保在合理的时间内发送完成。</li>\n</ul>\n</li>\n<li><p><strong>使用ILA监控（集成逻辑分析仪）</strong> ：</p>\n<ul>\n<li>如第12.1节所述，在您的Vivado设计中插入一个ILA核。</li>\n<li>将ILA探头连接到PCIe IP核的AXI-Stream接口（例如，<code>s_axis_rx_tdata</code>、<code>s_axis_rx_tvalid</code>、<code>m_axis_tx_tdata</code>、<code>m_axis_tx_tready</code>）。</li>\n<li>设置触发器以捕获特定TLP（例如，在<code>m_axis_tx_tvalid</code>上针对某种TLP类型触发）。</li>\n<li>这使您可以在硬件操作期间实时查看FPGA上的实际TLP位，验证您的固件是否向&#x2F;从PCIe IP核发送&#x2F;接收正确的数据和控制信号。</li>\n</ul>\n</li>\n<li><p><strong>检查时序约束</strong>：</p>\n<ul>\n<li>PCIe IP核对其AXI-Stream接口有严格的时序要求。确保您的用户逻辑向<code>m_axis_tx_tdata</code>提供数据和处理<code>s_axis_rx_tdata</code>满足这些时序约束。</li>\n<li>Vivado的时序分析报告（综合和实现后）将标记任何违规。通过优化您的逻辑或在可能的情况下调整时钟来解决这些问题。</li>\n</ul>\n</li>\n<li><p><strong>符合性测试（高级）</strong> ：</p>\n<ul>\n<li>对于高保真仿真，请考虑使用专用的PCIe符合性测试套件（通常与高端协议分析仪集成）。这些测试系统地检查是否符合PCIe规范，揭示细微的协议违规。</li>\n</ul>\n</li>\n<li><p><strong>保存更改</strong>：</p>\n<ul>\n<li>在彻底测试和验证后保存所有修改过的文件。迭代是TLP级调试的关键。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"第三部分：高级技术与优化-1\"><a href=\"#第三部分：高级技术与优化-1\" class=\"headerlink\" title=\"第三部分：高级技术与优化\"></a><strong>第三部分：高级技术与优化</strong></h2><hr>\n<h2 id=\"11-构建、烧录与测试\"><a href=\"#11-构建、烧录与测试\" class=\"headerlink\" title=\"11. 构建、烧录与测试\"></a><strong>11. 构建、烧录与测试</strong></h2><p>完成所有定制后，就到了验证的时刻：构建固件，将其编程到您的FPGA上，并严格测试其功能，以确保它与捐赠设备的行为完全一致。此阶段将您的设计从代码转换为可工作的硬件仿真。</p>\n<h3 id=\"11-1-综合与实现\"><a href=\"#11-1-综合与实现\" class=\"headerlink\" title=\"11.1 综合与实现\"></a><strong>11.1 综合与实现</strong></h3><p>这是FPGA设计流程中的核心步骤，您的SystemVerilog高级代码将被转换为可以加载到FPGA上的低级硬件配置。</p>\n<h4 id=\"11-1-1-运行综合\"><a href=\"#11-1-1-运行综合\" class=\"headerlink\" title=\"11.1.1 运行综合\"></a><strong>11.1.1 运行综合</strong></h4><p>综合是Vivado将您的HDL代码转换为门级网表（逻辑门及其互连的描述）的过程。它还执行初步的时序分析和资源估算。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>开始综合</strong>：<ul>\n<li>在Vivado GUI中，在 <strong>Flow Navigator</strong>（流程导航器）窗格（通常在左侧）中，在“Synthesis”（综合）下，点击 <strong>Run Synthesis</strong>（运行综合）。</li>\n</ul>\n</li>\n<li><strong>监控进度</strong>：<ul>\n<li>Vivado将打开一个“Launch Runs”（启动运行）对话框。您通常只需点击“OK”。</li>\n<li>监控Vivado窗口底部的 <strong>Messages</strong>（消息）选项卡。它将显示综合运行的进度。</li>\n<li><strong>常见警告&#x2F;错误关注点</strong>：<ul>\n<li><strong>​<code>[Synth 8-327]</code>​</strong>​ ** Unconnected Ports &#x2F; Unused Inputs（未连接端口&#x2F;未使用的输入）** ：这表明您设计中的信号或端口未连接到任何东西。虽然有时是故意的（例如，FPGA上未使用的引脚），但它们也可能指向端口名称中的拼写错误或遗忘的连接。检查每个警告以确保这不是功能问题。</li>\n<li><strong>​<code>[Synth 8-256]</code>​</strong>​ ** Registers&#x2F;Wires Not Optimized（寄存器&#x2F;线未优化）** ：这可能表明逻辑推断不正确，或者您有冗余逻辑可以优化。</li>\n<li><strong>Syntax Errors（语法错误）</strong> ：如果您的SystemVerilog代码中有致命的语法错误，综合将立即失败。请在Visual Studio Code中修复这些错误。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>审查综合报告</strong>：<ul>\n<li>成功完成后，Vivado将询问您下一步要做什么。选择 <strong>Open Synthesized Design</strong>（打开综合设计）或 <strong>Open Report</strong>（打开报告）。</li>\n<li>最重要的是，查看综合报告中的 <strong>Utilization Summary</strong>（资源利用率摘要）。这显示了您的设计消耗了FPGA多少资源（LUT、触发器、BRAM、DSP）。确保设计适合您的目标FPGA的容量（例如，对于Artix-7 35T，您应该在其限制内）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-1-2-运行实现\"><a href=\"#11-1-2-运行实现\" class=\"headerlink\" title=\"11.1.2 运行实现\"></a><strong>11.1.2 运行实现</strong></h4><p>实现是最耗时的一步。它接收综合后的网表并将其物理映射到FPGA的资源上（放置逻辑块，布线连接），然后执行详细的时序分析，以确保设计能够以指定的时钟频率运行。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>开始实现</strong>：<ul>\n<li>成功综合后，在 <strong>Flow Navigator</strong>（流程导航器）中，在“Implementation”（实现）下，点击 <strong>Run Implementation</strong>（运行实现）。</li>\n<li>确认“Launch Runs”（启动运行）对话框。</li>\n</ul>\n</li>\n<li><strong>监控进度</strong>：<ul>\n<li>实现包括几个阶段：Opt Design（优化设计）、Power Opt Design（功耗优化设计）、Place Design（放置设计）、Post-Placement Phys Opt Design（后放置物理优化设计）、Route Design（布线设计）、Post-Route Phys Opt Design（后布线物理优化设计）。每个阶段都可能需要大量时间。</li>\n<li>监控 <strong>Messages</strong>（消息）选项卡以了解进度和潜在问题。</li>\n</ul>\n</li>\n<li><strong>分析时序报告</strong>：<ul>\n<li>这是实现后<em>最关键的步骤</em>。完成后，Vivado会再次询问下一步做什么。选择 <strong>Open Implemented Design</strong>（打开已实现设计），或者更重要的是，选择 <strong>Open Report</strong>（打开报告），然后选择 <strong>Report Timing Summary</strong>（报告时序摘要）。</li>\n<li><strong>确保所有时序约束都得到满足。</strong>  查找“WNS (Worst Negative Slack)”值。<ul>\n<li><strong>正WNS</strong>：表示所有时序路径都满足其要求（有余量）。这是您想要的结果。</li>\n<li><strong>负WNS</strong>：表示<strong>时序违规</strong>，这意味着您的设计无法在所需的时钟频率下运行，或者数据可能不稳定。<strong>这是一个必须解决的关键问题。</strong></li>\n</ul>\n</li>\n<li><strong>解决违规</strong>：<ul>\n<li>如果您有负余量，请调查失败的具体路径。Vivado的时序报告将显示失败路径的源、目标和组件。</li>\n<li>解决方案可以包括：<ul>\n<li>优化HDL代码以减少逻辑深度或关键路径延迟。</li>\n<li>添加流水线级（寄存器）以打断长组合路径。</li>\n<li>改进XDC（约束）文件，确保所有时钟都正确定义和传播。</li>\n<li>调整时钟频率（如果应用程序允许）。</li>\n<li>在Vivado中使用更快的时序收敛策略。</li>\n<li>确保您的自定义逻辑与PCIe核的AXI-Stream接口时序要求正确接口。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>验证布局（可选）</strong> ：<ul>\n<li>在已实现的设计中，您可以打开“Device”（器件）视图，查看您的逻辑如何在FPGA上布局。这通常适用于高级用户，以确认关键组件是否最佳布局（例如，靠近PCIe收发器）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-1-3-生成比特流\"><a href=\"#11-1-3-生成比特流\" class=\"headerlink\" title=\"11.1.3 生成比特流\"></a><strong>11.1.3 生成比特流</strong></h4><p>比特流是最终的二进制配置文件（<code>.bit</code>扩展名），将被加载到您的FPGA上。它是综合和实现的成果。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>生成比特流</strong>：<ul>\n<li>成功实现后（没有严重的时序违规），在 <strong>Flow Navigator</strong>（流程导航器）中，在“Program and Debug”（编程和调试）下，点击 <strong>Generate Bitstream</strong>（生成比特流）。</li>\n</ul>\n</li>\n<li><strong>等待完成</strong>：<ul>\n<li>此过程通常比实现花费的时间少，但仍可能因设计复杂性而异。</li>\n</ul>\n</li>\n<li><strong>审查比特流生成日志</strong>：<ul>\n<li>完成后，Vivado会指示成功。审查日志中是否有任何警告，但通常如果实现顺利通过，比特流生成也会顺利通过。</li>\n<li><code>.bit</code>文件将生成在您的项目目录<code>pcileech_squirrel_top.runs/impl_1/</code>（或您的板卡类似路径）中。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"11-2-烧录比特流\"><a href=\"#11-2-烧录比特流\" class=\"headerlink\" title=\"11.2 烧录比特流\"></a><strong>11.2 烧录比特流</strong></h3><p>编程（烧录）比特流会将您编译的设计加载到FPGA上，使您的仿真设备激活。</p>\n<h4 id=\"11-2-1-连接FPGA设备\"><a href=\"#11-2-1-连接FPGA设备\" class=\"headerlink\" title=\"11.2.1 连接FPGA设备\"></a><strong>11.2.1 连接FPGA设备</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>准备硬件</strong>：<ul>\n<li>确保您的基于FPGA的DMA板卡已正确插入主机系统的兼容PCIe插槽。</li>\n<li>将JTAG编程器（例如，Digilent HS3，Xilinx Platform Cable）连接到FPGA板卡上的JTAG接口和开发PC的USB端口。</li>\n<li>打开主机系统电源。</li>\n<li>请参阅您的特定FPGA板卡手册，了解精确的电源、JTAG和PCIe连接说明。</li>\n</ul>\n</li>\n<li><strong>打开硬件管理器</strong>：<ul>\n<li>在Vivado中，导航到 <strong>Flow Navigator &gt; Program and Debug &gt; Open Hardware Manager</strong>（流程导航器 &gt; 编程和调试 &gt; 打开硬件管理器）。</li>\n<li>如果Vivado未运行，您可以作为独立应用程序启动硬件管理器。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-2-2-编程FPGA\"><a href=\"#11-2-2-编程FPGA\" class=\"headerlink\" title=\"11.2.2 编程FPGA\"></a><strong>11.2.2 编程FPGA</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>连接到目标</strong>：<ul>\n<li>在硬件管理器窗口中，点击 <strong>Open Target</strong>（打开目标）（通常是一个大按钮或链接），然后选择 <strong>Auto Connect</strong>（自动连接）。</li>\n<li>Vivado应该自动检测到您的JTAG编程器，然后检测到JTAG链上连接的FPGA设备。如果检测失败，请检查JTAG电缆连接、板卡电源以及PC上的JTAG驱动程序。</li>\n</ul>\n</li>\n<li><strong>编程设备</strong>：<ul>\n<li>一旦您的FPGA设备在硬件窗口中被检测并显示，<strong>右键单击</strong> 您的FPGA设备（例如，<code>xc7a35t_0</code>）并选择 <strong>Program Device</strong>（编程设备）。</li>\n<li>将出现一个对话框。点击“Bitstream file”（比特流文件）字段旁边的“…”按钮，导航到您生成的比特流文件（例如，<code>pcileech_squirrel_top.runs/impl_1/pcileech_squirrel_top.bit</code>）。</li>\n<li>点击 <strong>Program</strong>（编程）开始将固件烧录到FPGA上。</li>\n<li>等待编程过程完成。您将看到一个进度条。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-2-3-验证编程\"><a href=\"#11-2-3-验证编程\" class=\"headerlink\" title=\"11.2.3 验证编程\"></a><strong>11.2.3 验证编程</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>检查状态</strong>：<ul>\n<li>确保编程在Vivado的硬件管理器中无错误地完成。Vivado将在完成后显示“Program Device”成功消息。</li>\n</ul>\n</li>\n<li><strong>观察LED或指示灯</strong>：<ul>\n<li>许多FPGA板卡都有状态LED。成功的编程操作通常会导致特定LED亮起或改变状态（例如，“DONE”LED）。这是一个快速的视觉确认。</li>\n</ul>\n</li>\n<li><strong>主机系统重启（有时需要）</strong> ：<ul>\n<li>为了让主机操作系统正确识别新编程的PCIe设备，通常需要系统重启，尤其是在Windows上，以触发完整的PCIe枚举过程。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"11-3-测试与验证\"><a href=\"#11-3-测试与验证\" class=\"headerlink\" title=\"11.3 测试与验证\"></a><strong>11.3 测试与验证</strong></h3><p>编程完成后，关键一步是验证您的仿真设备是否被主机正确检测，并且其功能是否按预期工作，模仿捐赠设备。</p>\n<h4 id=\"11-3-1-验证设备枚举\"><a href=\"#11-3-1-验证设备枚举\" class=\"headerlink\" title=\"11.3.1 验证设备枚举\"></a><strong>11.3.1 验证设备枚举</strong></h4><p>这证实主机操作系统根据您编程的ID将您的FPGA识别为捐赠设备。</p>\n<ul>\n<li><strong>Windows</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>打开设备管理器</strong>：按下 <code>Win + X</code> 并从快速链接菜单中选择 <strong>Device Manager</strong>（设备管理器）。</li>\n<li><strong>检查设备属性</strong>：<ul>\n<li>在适当的设备类别下查找（例如，<strong>Network Adapters</strong>（网络适配器）、<strong>Storage Controllers</strong>（存储控制器）、<strong>System devices</strong>（系统设备））。</li>\n<li>找到您的仿真设备。它现在应该显示为<em>捐赠设备的名称</em>（例如，“Intel(R) Ethernet Connection…”）。</li>\n<li>右键单击该设备，选择 <strong>Properties</strong>（属性），然后转到 <strong>Details</strong>（详细信息）选项卡。</li>\n<li>在“Property”（属性）下拉菜单中，选择“Hardware Ids”（硬件ID）。确认 <strong>设备ID（DID）</strong>  和 <strong>厂商ID（VID）</strong> （例如，<code>PCI\\VEN_ABCD&amp;DEV_1234</code>）与您编程到固件中的值匹配。</li>\n<li>还应检查“Class Code”（类别代码）和“Subsystem ID”（子系统ID）以进行进一步验证。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>Linux</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>使用 <strong>​</strong>​<code>lspci</code>​</strong>：打开终端并使用<code>lspci</code>命令。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lspci -nn <span class=\"comment\"># 显示厂商ID:设备ID</span></span><br><span class=\"line\">lspci -vvv <span class=\"comment\"># 显示包括BAR、功能等详细信息</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>验证设备列表</strong>：<ul>\n<li>检查仿真设备是否在<code>lspci</code>输出中显示了正确的厂商ID、设备ID和类别代码。</li>\n<li><strong>示例输出（仿真Intel NIC）</strong> ：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">03:00.0 Network controller [0280]: Intel Corporation Ethernet Connection I219-V [8086:1570] (rev 21)</span><br></pre></td></tr></table></figure>\n\n（<code>8086</code>是Intel的厂商ID，<code>1570</code>是I219-V的设备ID，<code>0280</code>是网络控制器类别代码）。</li>\n<li>使用<code>lspci -vvv</code>确认BAR是否以正确的大小和类型枚举，与您的捐赠设备配置匹配。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-3-2-测试设备功能\"><a href=\"#11-3-2-测试设备功能\" class=\"headerlink\" title=\"11.3.2 测试设备功能\"></a><strong>11.3.2 测试设备功能</strong></h4><p>一旦设备被枚举，最终的测试是它是否像原始设备一样工作。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>安装必要的驱动程序</strong>：<ul>\n<li>如果主机操作系统未自动加载合适的驱动程序，您将需要手动安装捐赠设备的官方驱动程序。从制造商网站下载它们。</li>\n<li>按照制造商的说明进行安装。如果仿真成功，驱动程序应该安装并识别您的FPGA为真实硬件。</li>\n</ul>\n</li>\n<li><strong>执行功能测试</strong>：<ul>\n<li>运行通常与捐赠设备交互的应用程序或实用程序。</li>\n<li><strong>示例</strong>：<ul>\n<li><strong>网卡</strong>：执行ping测试、浏览网页或启动大文件传输以测试吞吐量。</li>\n<li><strong>存储控制器</strong>：尝试格式化模拟驱动器（如果您的仿真包括存储功能），执行读&#x2F;写操作，或运行磁盘基准测试。</li>\n<li><strong>USB控制器</strong>：连接USB设备（如果您的仿真包括USB主机功能）并测试它们的检测和操作。</li>\n</ul>\n</li>\n<li>监控主机系统以获取预期的行为和性能特征。</li>\n</ul>\n</li>\n<li><strong>监控系统行为</strong>：<ul>\n<li>检查系统稳定性（Windows上没有蓝屏，Linux上没有内核崩溃）。</li>\n<li>在系统日志中查找设备特定错误（Windows上的事件查看器，Linux上的<code>dmesg</code>或<code>journalctl</code>）。</li>\n<li>确保仿真设备在各种工作负载下（包括大数据传输或压力测试）按预期运行。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-3-3-监控错误\"><a href=\"#11-3-3-监控错误\" class=\"headerlink\" title=\"11.3.3 监控错误\"></a><strong>11.3.3 监控错误</strong></h4><p>主动的错误监控对于识别可能不会立即导致崩溃的细微仿真问题至关重要。</p>\n<ul>\n<li><strong>Windows</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>检查事件查看器</strong>：按下 <code>Win + X</code> 并选择 <strong>Event Viewer</strong>（事件查看器）。</li>\n<li><strong>查找与PCIe相关的错误</strong>：导航到 <strong>Windows Logs &gt; System</strong>（Windows 日志 &gt; 系统）。筛选或搜索与“PCIe”、“PCI Express”相关的警告、错误或关键事件，或源自特定设备驱动程序的事件（查找与您的仿真设备驱动程序匹配的源名称）。<ul>\n<li>常见错误包括资源冲突、驱动程序初始化失败或意外的设备响应。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>Linux</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>检查 <strong>​</strong>​<code>dmesg</code>​</strong>​ ** 日志**：打开终端并输入：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg | grep -i pci <span class=\"comment\"># 不区分大小写地搜索pci消息</span></span><br><span class=\"line\">dmesg | grep -i &lt;VendorID&gt; <span class=\"comment\"># 过滤您的设备的厂商ID</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>识别问题</strong>：查找指示PCIe链路训练问题、设备初始化问题、内存分配失败或意外DMA活动的消息。Linux内核的PCIe子系统非常详细。</li>\n</ol>\n</li>\n<li><strong>Systemd Journal (现代Linux)</strong> ：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">journalctl -b | grep -i pci <span class=\"comment\"># 当前引导日志</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"12-高级调试技术\"><a href=\"#12-高级调试技术\" class=\"headerlink\" title=\"12. 高级调试技术\"></a><strong>12. 高级调试技术</strong></h2><p>当问题出现时，特别是在复杂的PCIe设备仿真中，基本的故障排除可能不足以解决问题。高级调试工具和技术提供对FPGA内部逻辑和PCIe总线的深入可见性，使您能够高效地识别和解决问题。</p>\n<h3 id=\"12-1-使用Vivado的集成逻辑分析仪（ILA）\"><a href=\"#12-1-使用Vivado的集成逻辑分析仪（ILA）\" class=\"headerlink\" title=\"12.1 使用Vivado的集成逻辑分析仪（ILA）\"></a><strong>12.1 使用Vivado的集成逻辑分析仪（ILA）</strong></h3><p>集成逻辑分析仪（ILA）是Xilinx提供的一种强大、可配置的调试IP核，您可以直接将其嵌入到FPGA设计中。它允许您监控内部FPGA信号（线和寄存器）的实时行为，而无需外部探测硬件，其功能类似于一个强大的内部示波器或逻辑分析仪。</p>\n<h4 id=\"12-1-1-插入ILA核\"><a href=\"#12-1-1-插入ILA核\" class=\"headerlink\" title=\"12.1.1 插入ILA核\"></a><strong>12.1.1 插入ILA核</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>规划您的探头</strong>：确定您需要观察的关键信号。对于PCIe仿真，这些信号通常包括：<ul>\n<li>PCIe IP核的AXI-Stream接口（例如，<code>s_axis_rx_tdata</code>、<code>s_axis_rx_tvalid</code>、<code>m_axis_tx_tdata</code>、<code>m_axis_tx_tready</code>）。</li>\n<li>内部状态机信号（<code>current_state</code>、<code>next_state</code>）。</li>\n<li>BAR地址解码输出（<code>bar_hit[0]</code>、<code>bar_hit[1]</code>）。</li>\n<li>自定义寄存器值（<code>custom_control_reg</code>、<code>custom_status_reg</code>）。</li>\n<li>中断请求信号（<code>msi_trigger_signal</code>）。</li>\n</ul>\n</li>\n<li><strong>添加ILA IP核</strong>：<ul>\n<li>在Vivado中，打开 <strong>IP Catalog</strong>（IP目录）（通常在 <strong>Flow Navigator</strong>（流程导航器）窗格中）。</li>\n<li>搜索“ILA”（Integrated Logic Analyzer）。</li>\n<li>双击“Debug Bridge”（用于基本ILA）或“Integrated Logic Analyzer (ILA)”以打开其定制GUI。</li>\n<li>配置ILA：<ul>\n<li>设置您需要的<strong>捕获数据端口数量</strong>（探头）。</li>\n<li>设置每个探头的<strong>宽度</strong>以匹配您计划连接的信号。</li>\n<li>配置<strong>采样深度</strong>（在触发前&#x2F;后存储多少个样本）。更深的深度会消耗更多BRAM。</li>\n<li>点击“OK”并让Vivado生成IP。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>实例化并连接信号</strong>：<ul>\n<li>Vivado将生成ILA的<code>.xci</code>文件。您可以将其直接实例化在您的顶层SystemVerilog文件（例如，<code>pcileech_squirrel_top.sv</code>）中，或在可用信号的模块中。</li>\n<li><strong>示例（在</strong>​<strong>​<code>pcileech_squirrel_top.sv</code>​</strong>​<strong>或子模块中）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设您已从IP Catalog生成了ila_0</span></span><br><span class=\"line\"><span class=\"comment\">// 连接到您设计的时钟和感兴趣的信号</span></span><br><span class=\"line\">ila_0 your_ila_instance (</span><br><span class=\"line\">    <span class=\"variable\">.clk</span>(clk_125mhz), <span class=\"comment\">// 连接到您设计中稳定的时钟，通常是PCIe用户时钟</span></span><br><span class=\"line\">    <span class=\"variable\">.probe0</span>(pcie_s_axis_rx_tdata),    <span class=\"comment\">// 示例：PCIe入站TLP数据</span></span><br><span class=\"line\">    <span class=\"variable\">.probe1</span>(pcie_s_axis_rx_tvalid),   <span class=\"comment\">// 示例：PCIe入站TLP有效</span></span><br><span class=\"line\">    <span class=\"variable\">.probe2</span>(pcie_m_axis_tx_tdata),    <span class=\"comment\">// 示例：PCIe出站TLP数据</span></span><br><span class=\"line\">    <span class=\"variable\">.probe3</span>(my_bar_controller_state), <span class=\"comment\">// 示例：您的BAR逻辑状态</span></span><br><span class=\"line\">    <span class=\"variable\">.probe4</span>(my_custom_register),      <span class=\"comment\">// 示例：自定义寄存器的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据需要添加更多探头</span></span><br><span class=\"line\">    <span class=\"variable\">.probeN</span>(signal_to_monitor_N)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li><strong>替代方法（标记用于调试）：</strong>  对于更简单的信号，有时可以直接在HDL代码中标记它们用于调试。使用<code>(* mark_debug = &quot;true&quot; *) wire my_signal;</code> 或 <code>(* mark_debug = &quot;true&quot; *) reg my_register;</code>。Vivado随后会自动建议将它们添加到ILA中。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"12-1-2-配置触发条件\"><a href=\"#12-1-2-配置触发条件\" class=\"headerlink\" title=\"12.1.2 配置触发条件\"></a><strong>12.1.2 配置触发条件</strong></h4><p>当您配置智能触发条件以精确地在感兴趣的事件发生时（例如，错误、特定TLP类型、状态转换）捕获数据时，ILA最强大。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>生成带有ILA的比特流</strong>：插入并连接ILA后，您必须运行综合、实现并生成新的比特流。ILA核消耗FPGA资源，并将嵌入到您的设计中。</li>\n<li><strong>打开硬件管理器</strong>：使用支持ILA的比特流编程您的FPGA（第11.2节）。然后，在Vivado中，打开硬件管理器并连接到您的目标。</li>\n<li><strong>访问ILA仪表板</strong>：在硬件管理器中，选择您的ILA实例（例如，<code>hw_ila_1</code>）。这将打开ILA仪表板。</li>\n<li><strong>定义触发器</strong>：<ul>\n<li>选择要用作触发输入的探头。</li>\n<li>设置特定的<strong>触发模式</strong>（例如，<code>pcie_s_axis_rx_tdata</code>为<code>0x4A</code>以触发完成TLP）。</li>\n<li>配置<strong>触发条件</strong>（例如，“等于”、“不等于”、“上升沿”、“下降沿”）。</li>\n<li>设置<strong>触发位置</strong>（在触发事件<em>之前</em>捕获多少样本，用于预触发可见性）。</li>\n<li>您可以设置多个触发序列以检测复杂事件。</li>\n<li><strong>触发器示例场景</strong>：<ul>\n<li>在收到的TLP中触发特定的<code>Fmt/Type</code>以分析传入命令。</li>\n<li>当特定寄存器（<code>my_custom_register</code>）达到某个值时触发。</li>\n<li>在<code>pcie_m_axis_tx_tvalid</code>断言 AND <code>pcie_m_axis_tx_tdata[3:0]</code> &#x3D;&#x3D; <code>4&#39;hC</code>（用于内存写入TLP）时触发，以分析出站写入。</li>\n<li>在错误信号断言时触发。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"12-1-3-捕获和分析数据\"><a href=\"#12-1-3-捕获和分析数据\" class=\"headerlink\" title=\"12.1.3 捕获和分析数据\"></a><strong>12.1.3 捕获和分析数据</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>运行设计</strong>：让您的主机系统与已编程的FPGA交互，从而引发您要调试的事件。</li>\n<li><strong>布防ILA</strong>：在ILA仪表板中，点击 <strong>Run Trigger</strong>（运行触发器）按钮（通常是绿色的“播放”图标）。ILA将等待定义的触发条件。</li>\n<li><strong>捕获数据</strong>：一旦满足触发条件，ILA将把信号快照捕获到其内部内存缓冲区中。</li>\n<li><strong>分析波形</strong>：<ul>\n<li>捕获的数据将出现在波形查看器中。</li>\n<li>检查信号随时间的变化行为。放大、添加光标并解码值。</li>\n<li>寻找：<ul>\n<li><strong>意外的跳变</strong>：信号在错误的时间改变。</li>\n<li><strong>不正确的值</strong>：寄存器中保存了错误的数据。</li>\n<li><strong>协议违规</strong>：您的逻辑在PCIe接口上发送了不正确的数据。</li>\n<li><strong>时序问题</strong>：如果信号在预期时不稳定（尽管完整的时序分析在实现中完成，但ILA显示运行时行为）。</li>\n</ul>\n</li>\n<li>将捕获到的行为与您的预期设计逻辑和捐赠设备的观察行为（如果您使用协议分析仪捕获了它）进行比较。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"12-2-PCIe流量分析工具\"><a href=\"#12-2-PCIe流量分析工具\" class=\"headerlink\" title=\"12.2 PCIe流量分析工具\"></a><strong>12.2 PCIe流量分析工具</strong></h3><p>虽然ILA提供了FPGA内部可见性，但外部PCIe流量分析工具提供了对您的仿真设备和主机之间PCIe总线上实际通信的无与伦比的视图。这对于验证协议符合性和调试链路级问题至关重要。</p>\n<h4 id=\"12-2-1-PCIe协议分析仪（硬件）\"><a href=\"#12-2-1-PCIe协议分析仪（硬件）\" class=\"headerlink\" title=\"12.2.1 PCIe协议分析仪（硬件）\"></a><strong>12.2.1 PCIe协议分析仪（硬件）</strong></h4><ul>\n<li><strong>示例</strong>：<ul>\n<li><strong>Teledyne LeCroy PCIe 分析仪</strong>：深度分析的黄金标准，完整的协议解码，高级触发，以及错误注入功能。</li>\n<li><strong>Keysight PCIe 分析仪</strong>：另一个领先的供应商，具有类似的高端功能。</li>\n</ul>\n</li>\n<li><strong>步骤</strong>：<ol>\n<li><strong>设置分析仪</strong>：将硬件分析仪串联连接在主机系统的PCIe插槽和您的基于FPGA的DMA设备之间。这通常涉及一个特殊的中间卡。</li>\n<li><strong>配置捕获设置</strong>：使用分析仪的软件定义要捕获的流量。您可以按TLP类型、地址、请求者ID、错误条件等进行过滤，以关注相关事件。</li>\n<li><strong>捕获流量</strong>：在主机上运行您的仿真设备。分析仪将被动记录所有PCIe事务。</li>\n<li><strong>分析结果</strong>：<ul>\n<li>使用分析仪强大的软件查看解码的TLP、事务列表和波形视图。</li>\n<li><strong>检查TLP的符合性和正确性</strong>：所有字段都正确吗？序列是否正确？</li>\n<li><strong>识别任何协议违规或意外行为</strong>：这是您发现驱动程序可能失败的原因（例如，您的设备发送了带数据的完成，而规范要求不带数据的完成，或者响应太慢）。</li>\n<li><strong>与捐赠设备捕获进行比较</strong>：直接比较您的仿真设备捕获的流量与您从真实捐赠设备捕获的流量。这是仿真准确性的最终测试。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"12-2-2-基于软件的工具\"><a href=\"#12-2-2-基于软件的工具\" class=\"headerlink\" title=\"12.2.2 基于软件的工具\"></a><strong>12.2.2 基于软件的工具</strong></h4><p>对于基本的PCIe总线检查，或者在没有专用硬件分析仪的情况下，一些软件工具可以提供有限的洞察。</p>\n<ul>\n<li><strong>示例</strong>：<ul>\n<li><strong>Wireshark with PCIe Plugins</strong>：虽然Wireshark主要用于网络流量，但通过专用硬件（例如，将PCIe跟踪暴露给操作系统的网卡，或特定的捕获硬件&#x2F;驱动程序），它有时可以捕获和解码PCIe数据包。这高度依赖于系统。</li>\n<li><strong>ChipScope Pro（传统Xilinx，现已集成到Vivado中）</strong> ：Integrated Logic Analyzer (ILA) 是现代的等效工具，但ChipScope曾是一个独立工具。</li>\n<li><strong>​<code>lspci</code>​</strong>​ ** (Linux)** ：如第11.3.1节所述，<code>lspci -vvv</code>提供了广泛的静态配置空间信息。您可以将其与<code>watch</code>或脚本结合使用来监控随时间的变化。</li>\n<li><strong>​<code>pcileech</code>​</strong>​<strong>客户端（来自PCILeech框架）</strong> ：<code>pcileech</code>客户端软件本身可以通过您的FPGA执行内存和配置空间的读写操作，并可用于测试基本的DMA功能。虽然不是“流量分析仪”，但它对于测试功能接口至关重要。</li>\n</ul>\n</li>\n<li><strong>步骤</strong>：<ol>\n<li><strong>安装必要的工具&#x2F;插件</strong>：确保工具已安装并配置了任何所需的驱动程序或插件。</li>\n<li><strong>监控PCIe总线</strong>：运行软件工具以捕获和显示PCIe相关信息。</li>\n<li><strong>分析通信</strong>：<ul>\n<li>查找设备配置中的差异。</li>\n<li>如果工具支持，分析捕获数据包的结构是否存在异常或错误。</li>\n<li>验证您的仿真设备是否正确响应了配置请求。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"13-故障排除\"><a href=\"#13-故障排除\" class=\"headerlink\" title=\"13. 故障排除\"></a><strong>13. 故障排除</strong></h2><p>本节提供了在PCIe设备仿真定制固件开发、比特流编程和硬件测试过程中可能遇到的常见问题的解决方案。固件调试可能具有挑战性，因此采用系统方法是关键。</p>\n<h3 id=\"13-1-设备检测问题\"><a href=\"#13-1-设备检测问题\" class=\"headerlink\" title=\"13.1 设备检测问题\"></a><strong>13.1 设备检测问题</strong></h3><p><strong>问题</strong>：您的基于FPGA的DMA设备在编程后未被主机系统识别，或者在设备管理器&#x2F;lspci中显示为不正确的ID（例如，“未知设备”）或错误符号。</p>\n<h4 id=\"可能原因及解决方案：\"><a href=\"#可能原因及解决方案：\" class=\"headerlink\" title=\"可能原因及解决方案：\"></a><strong>可能原因及解决方案</strong>：</h4><ol>\n<li><p><strong>设备ID、厂商ID、子系统ID或类别代码不正确</strong>：</p>\n<ul>\n<li><strong>原因</strong>：最常见的原因。您编程到FPGA固件中的识别值与主机操作系统预期或您打算仿真的值不匹配。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>验证</strong>：仔细检查<code>pcileech_pcie_cfg_a7.sv</code>（或等效文件）中的所有<code>cfg_deviceid</code>、<code>cfg_vendorid</code>、<code>cfg_subsysid</code>、<code>cfg_subsysvendorid</code>、<code>cfg_revisionid</code>和<code>cfg_classcode</code>参数，与您精心记录的捐赠设备信息（来自第5节）进行比对。</li>\n<li><strong>一致性</strong>：确保这些值在Vivado PCIe IP核定制GUI（第7.2.2节）中也保持一致设置。</li>\n<li><strong>重新构建并重新烧录</strong>：进行任何更改后，始终重新综合、重新实现、生成新的比特流并重新烧录FPGA（第11.1、11.2节）。</li>\n<li><strong>重启主机</strong>：烧录后务必重启主机系统，因为Windows通常需要完全重启才能正确重新枚举PCIe设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>PCIe链路训练失败</strong>：</p>\n<ul>\n<li><strong>原因</strong>：主机根联合体与您的FPGA卡之间的基本PCIe链路未能建立。这发生在任何配置空间读取之前。症状包括设备完全不出现（<code>lspci</code>在该总线&#x2F;插槽上没有任何显示，或设备管理器显示“PCI Express Root Port”错误）。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>物理连接</strong>：确保FPGA板卡牢固地插入PCIe插槽，并且所有电源连接都牢固。如果可能，尝试不同的PCIe插槽。</li>\n<li><strong>电源</strong>：验证FPGA板卡是否获得足够的电源。某些板卡需要辅助PCIe电源连接器。</li>\n<li><strong>链路速度&#x2F;宽度</strong>：<ul>\n<li>检查Vivado PCIe IP核中的<code>Max Link Speed</code>和<code>Link Width</code>设置（第8.1.1节）。</li>\n<li>尝试将链路速度设置为较低的代数（例如，Gen1 &#x2F; 2.5 GT&#x2F;s）并将宽度设置为x1，即使您的板卡支持更高。有时，在较高速度下与特定主板会产生兼容性问题。</li>\n<li>检查主板BIOS设置中的PCIe插槽速度选项。</li>\n</ul>\n</li>\n<li><strong>复位</strong>：确保FPGA的复位逻辑正确实现（例如，与PCIe参考时钟同步），并在上电&#x2F;重启时正确断言&#x2F;去断言。</li>\n<li><strong>PCIe IP核</strong>：确保PCIe IP核正确实例化，并且其时钟和复位在您的顶层设计中正确连接。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>电源问题（电源不足或不稳定）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：FPGA板卡未获得足够的稳定电源，或电源供应不稳定，导致操作不可靠。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>验证连接</strong>：仔细检查所有电源线（主PCIe插槽电源、辅助PCIe电源、如果使用则包括外部直流插孔）。</li>\n<li><strong>电源供应</strong>：确保您的主机系统电源（PSU）具有足够的瓦数和稳定的12V电压轨。对于高功耗FPGA，弱电源可能导致问题。</li>\n<li><strong>外部电源</strong>：如果板卡有外部电源插孔，请确保使用正确电压和电流额定值的电源。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>固件错误（早期阶段）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：SystemVerilog代码中的逻辑错误，特别是顶层模块或PCIe核的包装器中，导致PCIe核无法初始化或正确呈现自身。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>Vivado消息</strong>：仔细检查Vivado的综合和实现日志中与PCIe IP核相关的<strong>严重警告</strong>或<strong>错误</strong>。这些通常是配置错误或连接不当的指示。</li>\n<li><strong>ILA调试</strong>：如果链路尝试训练但失败，请使用连接到PCIe IP核的状态信号（例如，<code>link_up</code>、<code>link_speed</code>、<code>link_width</code>）和AXI-Stream接口的ILA（第12.1节），以查看链路协商在哪个点失败，或者核是否生成了意外流量。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"13-2-内存映射和BAR配置错误\"><a href=\"#13-2-内存映射和BAR配置错误\" class=\"headerlink\" title=\"13.2 内存映射和BAR配置错误\"></a><strong>13.2 内存映射和BAR配置错误</strong></h3><p><strong>问题</strong>：仿真设备已检测到，但当主机操作系统或驱动程序尝试通过BAR访问其内存映射寄存器或缓冲区时，系统崩溃、冻结或报告错误。</p>\n<h4 id=\"可能原因及解决方案：-1\"><a href=\"#可能原因及解决方案：-1\" class=\"headerlink\" title=\"可能原因及解决方案：\"></a><strong>可能原因及解决方案</strong>：</h4><ol>\n<li><p><strong>BAR大小或类型不正确（IP核和固件）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：您在Vivado PCIe IP核（第7.2.2节）中配置的BAR大小或类型（32位&#x2F;64位、内存&#x2F;I&#x2F;O、可预取&#x2F;不可预取）和&#x2F;或在<code>pcileech_tlps128_bar_controller.sv</code>中处理的值与捐赠设备实际提供的值不匹配。这可能导致主机分配不正确的地址空间或尝试不支持的访问。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>交叉验证</strong>：返回到您的Arbor&#x2F;协议分析仪数据（第5节），重新验证每个BAR配置（大小、类型、可预取）。</li>\n<li><strong>一致性</strong>：确保这些值在PCIe IP核定制中完全匹配，并且您的<code>bar_controller</code>逻辑正确处理每个BAR的大小（地址解码范围）和类型。</li>\n<li><strong>BRAM大小</strong>：如果您的BAR映射到BRAM，请确认BRAM IP核的大小（第8.2.1节）与BAR大小完全匹配。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>固件中的地址解码错误</strong>：</p>\n<ul>\n<li><strong>原因</strong>：您的<code>pcileech_tlps128_bar_controller.sv</code>（或自定义BAR逻辑）错误地解释了传入的PCIe地址，导致访问了不正确的内部寄存器或内存位置。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>审查逻辑</strong>：仔细审查<code>bar_controller</code>中的<code>case</code>语句和地址计算。</li>\n<li><strong>仿真</strong>：在您的SystemVerilog测试平台中开发特定的测试用例，模拟主机对每个BAR中不同偏移量的读写访问。验证内部<code>bar_hit</code>信号是否正确，以及数据是否正确路由到&#x2F;从正确的内部寄存器&#x2F;BRAM。</li>\n<li><strong>ILA调试</strong>：在<code>req_addr</code>、<code>req_write</code>、<code>req_read</code>、<code>req_data</code>、<code>rsp_data</code>以及<code>bar_controller</code>中与您的地址解码和寄存器访问相关的内部信号上放置ILA探头。实时观察地址如何解码以及正在读&#x2F;写的数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>内部地址空间重叠</strong>：</p>\n<ul>\n<li><strong>原因</strong>：虽然PCIe标准确保不同设备的BAR在主机的内存映射中不重叠，但在FPGA<em>内部</em>，您可能会意外地将不同的逻辑组件映射到单个BAR中的相同物理地址空间。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>仔细映射</strong>：在BAR中定义内部寄存器和内存块时，显式为每个寄存器和内存块分配唯一的、不重叠的偏移量。使用<code>localparam</code>来定义这些偏移量以防止错误。</li>\n<li><strong>设计审查</strong>：需要对您的<code>bar_controller</code>进行彻底的设计审查，以确保每个地址范围都得到唯一处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>BRAM访问问题</strong>：</p>\n<ul>\n<li><strong>原因</strong>：您的逻辑与BRAM IP核接口存在问题（例如，不正确的BRAM时钟、异步复位、错误的字节使能或不正确的写入使能逻辑）。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>BRAM文档</strong>：查阅Xilinx BRAM IP核文档，了解正确的实例化和接口信号。</li>\n<li><strong>ILA</strong>：在BRAM接口信号（地址、写入使能、数据输入、数据输出）上放置ILA探头，以验证您的逻辑是否向BRAM发送了正确的控制信号。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"13-3-DMA性能和TLP错误\"><a href=\"#13-3-DMA性能和TLP错误\" class=\"headerlink\" title=\"13.3 DMA性能和TLP错误\"></a><strong>13.3 DMA性能和TLP错误</strong></h3><p><strong>问题</strong>：设备已检测到并功能上看起来正常，但在大型DMA操作期间，数据传输速率缓慢，或者系统间歇性崩溃、挂起或报错。PCIe协议分析仪报告TLP格式错误或流控制问题。</p>\n<h4 id=\"可能原因及解决方案：-2\"><a href=\"#可能原因及解决方案：-2\" class=\"headerlink\" title=\"可能原因及解决方案：\"></a><strong>可能原因及解决方案</strong>：</h4><ol>\n<li><p><strong>TLP格式错误（报头&#x2F;载荷）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：您的固件生成的TLP（特别是您的FPGA作为DMA主设备时发送的完成或出站内存写入）具有不正确的报头、长度、字节使能或载荷。主机系统的PCIe核或驱动程序将其检测为违规。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>PCIe协议分析仪</strong>：这是最好的工具（第12.2.1节）。捕获流量并仔细比较您生成的TLP与PCIe规范，更重要的是，与您<em>真实捐赠设备</em>的捕获进行比较。</li>\n<li><strong>TLP生成逻辑</strong>：审查您的TLP组装代码（<code>pcileech_pcie_tlp_a7.sv</code>及相关模块）。确保所有字段（Fmt、Type、Requester ID、Tag、Completion ID、Length、Byte Enables、Address）都正确派生并打包到TLP结构中。</li>\n<li><strong>错误检查</strong>：在固件中实现基本的错误检查（例如，检查是否存在意外的<code>req_valid</code>而没有<code>req_ready</code>，反之亦然）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>流控制问题</strong>：</p>\n<ul>\n<li><strong>原因</strong>：PCIe使用基于信用的流控制机制。如果您的固件（或PCIe IP核与其的交互）错误地管理信用，可能导致死锁、超时或丢包。症状包括PCIe链路“停滞”、超时或低吞吐量。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>PCIe IP核配置</strong>：确保Vivado PCIe IP核定制中的流控制设置适用于您预期的流量模式。默认设置通常是健壮的。</li>\n<li><strong>用户逻辑反压</strong>：您的用户逻辑向PCIe IP核发送TLP（<code>m_axis_tx_*</code>接口）<em>必须</em>遵守来自IP核的<code>m_axis_tx_tready</code>信号。如果<code>tready</code>被去断言，您<em>必须</em>暂停发送数据。否则将导致核的缓冲区溢出。</li>\n<li><strong>ILA调试</strong>：将ILA探头连接到PCIe IP核的流控制接口信号和您的用户逻辑，以观察<code>tvalid</code>&#x2F;<code>tready</code>握手是否正常工作。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>DMA逻辑效率低下&#x2F;缓冲问题</strong>：</p>\n<ul>\n<li><strong>原因</strong>：FPGA内部的DMA引擎实现（读取&#x2F;写入主机内存数据的部分）未优化，导致瓶颈。这可能涉及：<ul>\n<li>缺少流水线。</li>\n<li>BRAM使用效率低下。</li>\n<li>外部内存访问延迟导致的停滞。</li>\n<li>突发大小过小。</li>\n</ul>\n</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>流水线</strong>：将长组合路径分解为更小、更连续的阶段，使用寄存器。这允许更高的时钟频率和更好的吞吐量。</li>\n<li><strong>缓冲</strong>：使用FIFO（先进先出缓冲区）来解耦发送方和接收方逻辑，平滑数据流并防止停滞。</li>\n<li><strong>突发传输</strong>：利用PCIe执行突发读&#x2F;写的能力以提高效率。确保您的DMA逻辑以适当的突发大小请求和处理数据。</li>\n<li><strong>内存带宽</strong>：确保您的BRAM或外部DDR内存接口能够足够快地提供&#x2F;消耗数据，以满足您所需的DMA速率。</li>\n<li><strong>ILA</strong>：监控您的DMA引擎的内部状态、读写指针和数据路径信号，以识别瓶颈。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>完成超时&#x2F;不支持的请求</strong>：</p>\n<ul>\n<li><strong>原因</strong>：主机发送请求（例如MRd、CfgRd），但您的FPGA设备未在允许的超时时间内响应完成TLP，或者它以错误状态（例如，带有Unsupported Request (UR) 或 Completer Abort (CA) 的完成）进行响应。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>响应逻辑</strong>：验证您的<code>bar_controller</code>（用于MRd）和<code>pcileech_pcie_cfg_a7.sv</code>（用于自定义配置空间的CfgRd）是否正确识别请求并生成适当的完成。</li>\n<li><strong>超时值</strong>：审查您的捐赠设备预期的完成延迟。虽然PCIe定义了默认超时，但某些驱动程序可能对此敏感。</li>\n<li><strong>ILA&#x2F;协议分析仪</strong>：对于查明<em>为什么</em>未发送完成或完成格式错误至关重要。请求TLP是否甚至到达了您的用户逻辑？您的逻辑是否生成了响应？PCIe核是否成功发送了响应？</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"14-仿真精度与优化\"><a href=\"#14-仿真精度与优化\" class=\"headerlink\" title=\"14. 仿真精度与优化\"></a><strong>14. 仿真精度与优化</strong></h2><p>实现真正令人信服的仿真意味着让您的基于FPGA的设备与捐赠设备难以区分，不仅在ID上，而且在行为上。这需要对时序、响应速度和微妙的操作细节进行细致的关注。</p>\n<h3 id=\"14-1-精确定时仿真技术\"><a href=\"#14-1-精确定时仿真技术\" class=\"headerlink\" title=\"14.1 精确定时仿真技术\"></a><strong>14.1 精确定时仿真技术</strong></h3><p>精确的时序在硬件中至关重要，特别是对于PCIe这样的高速接口。不匹配可能导致驱动程序超时、数据解释不正确或系统不稳定。</p>\n<ul>\n<li><p><strong>实现时序约束（XDC文件）</strong> ：</p>\n<ul>\n<li><strong>目的</strong>：时序约束是 Vivado 综合和实现工具的指令，告诉它们您的设计需要运行多快。它们定义了时钟周期、输入&#x2F;输出延迟和路径延迟。</li>\n<li><strong>用法</strong>：PCILeech-FPGA项目包含 XDC 文件（例如，<code>pcileech_squirrel_top.xdc</code>），它们定义了主时钟（例如，<code>create_clock -name sys_clk_p -period 8.0 [get_ports sys_clk_p]</code>）。</li>\n<li><strong>优化</strong>：如果您的仿真需要非常特定的内部时序或对时间敏感的命令做出反应，您可能需要在自定义逻辑中添加进一步的约束（<code>set_max_delay</code>、<code>set_input_delay</code>、<code>set_output_delay</code>）到关键路径。</li>\n<li><strong>目标</strong>：确保 Vivado 在实现后报告所有路径的 <strong>正 WNS（最差负余量）</strong> ，表明设计满足其时序要求。</li>\n</ul>\n</li>\n<li><p><strong>使用时钟域交叉（CDC）技术</strong>：</p>\n<ul>\n<li><strong>目的</strong>：PCIe设计通常涉及多个时钟域（例如，125MHz PCIe用户时钟，自定义逻辑的单独时钟）。在这些域之间异步移动信号（没有适当的同步）可能导致<strong>亚稳态</strong>，从而导致不可靠的行为。</li>\n<li><strong>实现</strong>：对于跨时钟域的信号，始终使用适当的CDC电路：<ul>\n<li><strong>双触发器同步器</strong>：用于单比特控制信号。</li>\n<li><strong>异步FIFO（先进先出）</strong> ：用于多比特数据路径，提供时钟域之间的数据缓冲和流控制。</li>\n<li><strong>格雷码编码器&#x2F;解码器</strong>：用于跨域的计数器或地址，以确保每次只有一个比特发生变化。</li>\n</ul>\n</li>\n<li><strong>Vivado 工具</strong>：Vivado 包含 CDC 分析工具（例如，<code>report_cdc</code>），可以识别潜在的亚稳态问题。</li>\n</ul>\n</li>\n<li><p><strong>使用时间精确模型仿真设备行为</strong>：</p>\n<ul>\n<li><strong>高级测试平台</strong>：使用 SystemVerilog 测试平台，其中包含真实的定时延迟，甚至提供时间精确的 PCIe 总线功能模型（BFM）。</li>\n<li><strong>验证</strong>：这使您可以观察您的仿真设备的内部状态以及外部 TLP 生成&#x2F;响应时序在各种条件下如何表现，确保它们与您捕获的捐赠设备行为相匹配。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-2-对系统调用的动态响应\"><a href=\"#14-2-对系统调用的动态响应\" class=\"headerlink\" title=\"14.2 对系统调用的动态响应\"></a><strong>14.2 对系统调用的动态响应</strong></h3><p>真正精确的仿真不仅能呈现正确的ID；它还能智能且动态地响应主机系统的命令和查询，模仿真实、活动设备的行为。</p>\n<ul>\n<li><p><strong>实现设备控制的状态机</strong>：</p>\n<ul>\n<li><strong>目的</strong>：设计健壮的 SystemVerilog 状态机来管理设备的操作模式、命令处理和数据流。</li>\n<li><strong>响应性</strong>：确保状态机能够逻辑地、快速地响应传入命令（例如，写入 BAR 中的控制寄存器，特定的 TLP）。</li>\n<li><strong>优雅处理</strong>：状态机应能够优雅地处理意外或无序的请求，可能返回错误 TLP 或仅仅忽略无效命令，而不是崩溃或冻结。</li>\n</ul>\n</li>\n<li><p><strong>监控和响应主机命令（超越简单的读写）</strong> ：</p>\n<ul>\n<li><strong>配置写入</strong>：除了初始枚举之外，驱动程序通常会写入配置空间寄存器以启用功能、设置阈值或清除状态位。您的固件必须处理这些写入并相应地更新内部状态。</li>\n<li><strong>厂商特定命令</strong>：如第9.2节所述，如果捐赠设备具有专有命令（通过自定义寄存器或厂商定义消息访问），您的固件必须解析这些命令并触发适当的仿真行为。</li>\n<li><strong>电源管理命令</strong>：通过启用&#x2F;禁用内部逻辑并确认状态更改来响应主机发起的电源状态转换（D0、D1、D3hot 等）。</li>\n<li><strong>中断确认</strong>：如果主机驱动程序通过写入特定寄存器来确认中断，请确保您的固件能够检测到此并清除内部中断请求。</li>\n</ul>\n</li>\n<li><p><strong>优化固件逻辑以提高响应性</strong>：</p>\n<ul>\n<li><strong>降低延迟</strong>：关键数据路径和控制路径应优化，以最小化组合逻辑深度和流水线停顿。</li>\n<li><strong>并行性</strong>：利用 FPGA 固有的并行性来同时执行多个操作，提高吞吐量和响应时间。</li>\n<li><strong>高效内存访问</strong>：优化对内部 BRAM 或外部 DDR 内存的访问，以确保在需要时为 DMA 传输或寄存器读取提供数据。</li>\n<li><strong>硬件加速</strong>：对于捐赠设备执行的复杂计算或数据操作，请考虑在 FPGA 上实现专用的硬件加速器，而不是尝试以缓慢、类似软件的方式执行它们。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"15-固件开发最佳实践\"><a href=\"#15-固件开发最佳实践\" class=\"headerlink\" title=\"15. 固件开发最佳实践\"></a><strong>15. 固件开发最佳实践</strong></h2><p>在定制固件开发中遵循最佳实践对于保持代码质量、促进协作（如果团队合作）、简化调试以及确保项目的长期可维护性和可靠性至关重要。这对于安全敏感的应用尤为如此。</p>\n<h3 id=\"15-1-持续测试与文档\"><a href=\"#15-1-持续测试与文档\" class=\"headerlink\" title=\"15.1 持续测试与文档\"></a><strong>15.1 持续测试与文档</strong></h3><ul>\n<li><p><strong>定期、增量测试</strong>：</p>\n<ul>\n<li><strong>单元测试</strong>：使用专用测试平台隔离测试小型独立模块（例如，TLP解析器、寄存器块）。</li>\n<li><strong>集成测试</strong>：验证不同模块是否协同工作。</li>\n<li><strong>系统测试</strong>：烧录后，与主机系统执行端到端测试，确保整体功能。</li>\n<li><strong>尽早测试，经常测试</strong>：在每次重大更改后，无论多小，都要测试固件，以便尽早发现问题，此时问题更容易调试。</li>\n</ul>\n</li>\n<li><p><strong>自动化测试（高级）</strong> ：</p>\n<ul>\n<li>对于复杂项目，在主机端实现自动化测试脚本（例如，使用Python和硬件抽象层）以重复验证功能和性能。</li>\n<li>在团队环境中，考虑与持续集成（CI）工具（例如，Jenkins、GitLab CI）集成，以自动化每次代码提交的构建、测试和静态分析。</li>\n</ul>\n</li>\n<li><p><strong>维护全面的文档</strong>：</p>\n<ul>\n<li><strong>设计文档</strong>：创建并更新描述固件架构的文档，包括：<ul>\n<li><strong>框图</strong>：说明主要模块及其互连。</li>\n<li><strong>状态机图</strong>：适用于所有有状态逻辑。</li>\n<li><strong>接口规范</strong>：详细说明模块之间的输入&#x2F;输出信号、时序和协议。</li>\n<li><strong>内存映射</strong>：针对所有BAR，定义寄存器地址、位域及其功能。</li>\n</ul>\n</li>\n<li><strong>代码注释</strong>：在SystemVerilog代码中使用清晰、简洁的注释来解释复杂的逻辑、信号的目的以及任何不明显的设计选择。</li>\n<li><strong>更改日志&#x2F;提交消息</strong>：维护更改日志或使用详细的Git提交消息来跟踪所有修改、错误修复和功能添加，解释<em>为什么</em>进行更改。</li>\n<li><strong>用户指南</strong>：对于您的定制固件，一个简单的用户指南，解释如何从主机端构建、烧录和与仿真设备交互，是无价的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-2-管理固件版本\"><a href=\"#15-2-管理固件版本\" class=\"headerlink\" title=\"15.2 管理固件版本\"></a><strong>15.2 管理固件版本</strong></h3><p>正确的版本控制对于跟踪更改、有效协作和管理发布至关重要。</p>\n<ul>\n<li><p><strong>使用版本控制系统（VCS）</strong> ：</p>\n<ul>\n<li><strong>Git</strong>：强烈推荐。使用Git管理您的HDL源代码、约束文件和项目脚本。</li>\n<li><strong>组织仓库</strong>：保持清晰的目录结构（例如，为<code>src</code>、<code>xdc</code>、<code>ip</code>、<code>scripts</code>、<code>doc</code>等设置单独的文件夹）。</li>\n<li><strong>分支</strong>：使用功能分支开发新功能或进行重大更改。在彻底测试后合并回<code>main</code>或<code>develop</code>分支。</li>\n<li><strong>定期提交</strong>：频繁提交，提交内容原子化，提交消息有意义。</li>\n</ul>\n</li>\n<li><p><strong>标记发布和里程碑</strong>：</p>\n<ul>\n<li><strong>稳定版本</strong>：使用Git标签（例如，<code>v1.0.0</code>、<code>v1.0.1_bugfix</code>）标记固件的稳定、经过测试的版本。这使得回溯或部署已知良好状态变得容易。</li>\n<li><strong>里程碑</strong>：标记重要的开发里程碑（例如，“基本枚举工作正常”、“DMA读&#x2F;写功能正常”）。</li>\n</ul>\n</li>\n<li><p><strong>备份和恢复策略</strong>：</p>\n<ul>\n<li><strong>基于云的仓库</strong>：将您的Git仓库托管在GitHub、GitLab或Bitbucket等平台上。这提供了异地备份并促进了协作。</li>\n<li><strong>本地备份</strong>：即使有云仓库，也要定期对整个Vivado项目目录进行本地备份（由于生成的文件，它可能非常大）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-3-安全注意事项\"><a href=\"#15-3-安全注意事项\" class=\"headerlink\" title=\"15.3 安全注意事项\"></a><strong>15.3 安全注意事项</strong></h3><p>开发用于PCIe设备仿真（特别是能够直接内存访问的设备）的定制固件具有重要的安全影响。这项技术本质上是一种“两用”能力，意味着它既可以用于合法目的（例如，硬件测试、安全研究），也可以用于恶意目的（例如，DMA攻击、安全绕过）。<strong>理解并负责任地管理这些风险至关重要。</strong></p>\n<ul>\n<li><p><strong>两用性质与道德影响</strong>：</p>\n<ul>\n<li><strong>道德黑客行为与恶意使用</strong>：明确区分将这些知识用于授权安全测试（红队演练、渗透测试）和未经授权的非法活动。</li>\n<li><strong>负责任的披露</strong>：如果您使用这些技术发现漏洞，请遵循负责任的披露准则。</li>\n<li><strong>法律和许可合规性</strong>：了解并遵守所有与硬件逆向工程和设备修改相关的法律、法规和许可协议（例如，PCIe-SIG规范、Xilinx EULA）。</li>\n<li><strong>“武器化”</strong> ：认识到精确仿真受信任硬件的能力可以被武器化用于高级持久威胁（APTs）或复杂恶意软件。</li>\n</ul>\n</li>\n<li><p><strong>理解攻击向量（攻击视角）</strong> ：</p>\n<ul>\n<li><strong>内存窃取</strong>：恶意仿真设备可以执行DMA读取，以访问任何物理内存地址，包括内核、用户进程中的敏感数据、加密密钥或网络缓冲区。</li>\n<li><strong>内存注入&#x2F;修改</strong>：恶意仿真设备可以执行DMA写入以任意修改内存，从而实现：<ul>\n<li><strong>权限提升</strong>：修改内核数据结构（例如，进程令牌、SID）以获得管理员或系统权限。</li>\n<li><strong>代码注入</strong>：将恶意代码注入正在运行的进程或内核，然后触发其执行。</li>\n<li><strong>安全软件绕过</strong>：通过直接修改内存来禁用或颠覆端点检测和响应（EDR）、防病毒或防火墙软件。</li>\n</ul>\n</li>\n<li><strong>模糊测试和崩溃</strong>：发送格式错误或不符合规范的TLP&#x2F;命令，以触发驱动程序漏洞，导致系统崩溃（蓝屏死机）或潜在的可利用内存损坏。</li>\n<li><strong>固件&#x2F;BIOS操作</strong>：在某些高级场景中，DMA设备可能能够与包含BIOS&#x2F;UEFI的主机SPI闪存进行交互，可能用于持久性修改。</li>\n</ul>\n</li>\n<li><p><strong>防御措施和缓解策略（防御视角）</strong> ：</p>\n<ul>\n<li><strong>IOMMU&#x2F;VT-d&#x2F;AMD-Vi</strong>：如第3.2节所述，这些技术旨在通过为外设提供内存保护来缓解DMA攻击。<strong>对于合法测试，您会禁用它们，但在生产系统中，它们应始终启用。</strong>  它们阻止外设未经授权的内存访问。</li>\n<li><strong>内核DMA保护（Windows）&#x2F; Thunderbolt安全（Linux）</strong> ：现代操作系统功能专门解决“冷启动”DMA攻击（攻击者在系统关闭或锁定时连接恶意设备）。在生产系统上保持这些功能启用。</li>\n<li><strong>安全启动</strong>：虽然不是直接的DMA保护，但安全启动有助于确保只加载受信任的引导加载程序和内核模块，从而减少攻击者注入恶意内核组件以绕过DMA保护的机会。</li>\n<li><strong>物理安全</strong>：最基本但最关键的防御。如果攻击者可以物理访问PCIe插槽或Thunderbolt端口，他们可以绕过许多软件保护。保护对关键系统的物理访问。</li>\n<li><strong>驱动程序强化</strong>：驱动程序应以防御性方式编写，严格验证来自硬件的所有输入并在严格的内存边界内操作。</li>\n<li><strong>内存强化</strong>：操作系统级的内存保护（例如KASLR、DEP、SMAP&#x2F;SMEP）有助于减少内存损坏的影响，但直接DMA攻击会绕过这些保护。</li>\n<li><strong>监控和日志记录</strong>：虽然在硬件层面很难，但异常的DMA活动或未知PCIe设备的枚举应在安全监控系统中触发警报。</li>\n</ul>\n</li>\n<li><p><strong>固件安全编码实践</strong>：</p>\n<ul>\n<li><strong>输入验证</strong>：如果您的固件接受任何输入（例如，通过UART调试接口，或由主机写入的内部寄存器），请严格验证它们，以防止缓冲区溢出、整数溢出或意外行为。</li>\n<li><strong>最小权限</strong>：设计您的固件逻辑，使其仅执行其功能绝对必要的操作。避免授予不必要的功能。</li>\n<li><strong>状态管理</strong>：实现健壮的状态机，以防止由于无效状态转换而导致的意外行为。</li>\n<li><strong>无硬编码秘密</strong>：避免直接在固件中嵌入敏感信息（例如，加密密钥、硬编码凭据），如果它们可以轻易被提取。</li>\n<li><strong>篡改检测</strong>：对于生产固件，考虑实现检测固件本身是否已被篡改或是否加载了未经授权配置的机制。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"16-其他资源\"><a href=\"#16-其他资源\" class=\"headerlink\" title=\"16. 其他资源\"></a><strong>16. 其他资源</strong></h2><p>为了加深您对FPGA开发、PCIe和硬件安全等动态领域的理解并保持更新，请查阅以下资源：</p>\n<ul>\n<li><p><strong>Xilinx (AMD) 文档</strong>：您获取Vivado和Xilinx FPGA所有信息的主要来源。</p>\n<ul>\n<li><strong>主文档门户</strong>：<a href=\"https://docs.amd.com/\">https://docs.amd.com/</a>（原Xilinx.com&#x2F;support&#x2F;documentation）。</li>\n<li><strong>Vivado 设计套件用户指南</strong>：<ul>\n<li><strong>UG900 - 入门指南</strong>：Vivado新用户必备。</li>\n<li><strong>UG901 - 逻辑综合</strong>：深入了解综合。</li>\n<li><strong>UG904 - 实现</strong>：关于放置和布线的详细指南。</li>\n<li><strong>UG912 - Tcl 命令参考指南</strong>：对于脚本编写价值巨大。</li>\n<li><strong>UG939 - 调试</strong>：ILA和其他调试功能的综合指南。</li>\n</ul>\n</li>\n<li><strong>PCI Express IP 核用户指南</strong>：理解Xilinx PCIe IP至关重要（例如，<strong>PG054 for 7 Series Integrated Block for PCI Express</strong>）。在文档门户上搜索“PCI Express”。这详细介绍了核的配置、接口和限制。</li>\n</ul>\n</li>\n<li><p><strong>PCI-SIG 规范</strong>：PCIe 标准的权威来源。</p>\n<ul>\n<li><strong>PCI Express Base Specification</strong>：基础文档。虽然不公开免费，但基于它的摘要和教育材料广泛可用。您通常可以在其网站上找到信息：<a href=\"https://pcisig.com/specifications\">https://pcisig.com/specifications</a>（注意：完整规范通常需要PCI-SIG会员资格）。</li>\n</ul>\n</li>\n<li><p><strong>FPGA 教程和学习平台</strong>：</p>\n<ul>\n<li><strong>FPGA4Fun</strong>：<a href=\"http://www.fpga4fun.com/\">http://www.fpga4fun.com/</a> - 一个经典网站，提供许多实用的FPGA项目和教程。</li>\n<li><strong>Verilog&#x2F;VHDL 教程</strong>：<ul>\n<li><strong>ASIC World Verilog 教程</strong>：<a href=\"https://www.asic-world.com/verilog/index.html\">https://www.asic-world.com/verilog/index.html</a> - 很好的Verilog基础参考。</li>\n<li><strong>VHDLwhiz</strong>：<a href=\"https://www.vhdlwhiz.com/\">https://www.vhdlwhiz.com/</a> - VHDL 参考和教程。</li>\n</ul>\n</li>\n<li><strong>Stack Overflow (FPGA&#x2F;Verilog&#x2F;PCIe 标签)</strong> ：<a href=\"https://stackoverflow.com/questions/tagged/fpga\">https://stackoverflow.com/questions/tagged/fpga</a> - 社区驱动的针对特定技术问题的问答。</li>\n</ul>\n</li>\n<li><p><strong>PCIe 协议分析工具</strong>：</p>\n<ul>\n<li><strong>Teledyne LeCroy Protocol Analyzers</strong>：<a href=\"https://teledynelecroy.com/protocolanalyzer/\">https://teledynelecroy.com/protocolanalyzer/</a> - 探索他们的高性能PCIe分析仪和软件系列。</li>\n<li><strong>Telescan PE Software</strong>：<a href=\"https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software\">https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software</a> - 一款免费软件工具，提供一些PCIe分析功能（需要注册）。</li>\n</ul>\n</li>\n<li><p><strong>PCILeech 社区和资源</strong>：</p>\n<ul>\n<li><code>ufrisk/pcileech</code> GitHub 仓库是核心。积极关注其更新和问题。</li>\n<li>寻找致力于PCILeech或类似开源DMA项目的社区论坛或Discord服务器。</li>\n</ul>\n</li>\n<li><p><strong>硬件安全与逆向工程</strong>：</p>\n<ul>\n<li>关于硬件黑客、逆向工程和低级系统利用的书籍。</li>\n<li>Black Hat、DEF CON、Recon 和 Troopers 等会议通常会举办关于 PCIe 和 DMA 攻击的讲座。</li>\n<li>专注于硬件的安全研究人员的博客和研究论文。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"17-联系方式\"><a href=\"#17-联系方式\" class=\"headerlink\" title=\"17. 联系方式\"></a><strong>17. 联系方式</strong></h2><p>如果您需要帮助、有疑问或希望就本指南、固件开发或硬件安全相关主题进行合作，请随时联系。我乐意提供指导、解决复杂问题或详细讨论想法。</p>\n<h3 id=\"Discord：\"><a href=\"#Discord：\" class=\"headerlink\" title=\"Discord：\"></a><strong>Discord</strong>：</h3><ul>\n<li><strong>用户</strong>：**<a href=\"https://discord.com/users/196741541094621184\">VCPU</a>**</li>\n<li><strong>服务器邀请链接</strong>：**<a href=\"https://discord.gg/dS2gDUDQmV\">加入硬件黑客与固件开发Discord</a>**</li>\n</ul>\n<hr>\n<h2 id=\"18-支持与贡献\"><a href=\"#18-支持与贡献\" class=\"headerlink\" title=\"18. 支持与贡献\"></a><strong>18. 支持与贡献</strong></h2><p>您的支持有助于维护和改进本指南及相关项目。创建和更新全面的技术文档以及开源硬件项目需要大量时间和精力。</p>\n<h3 id=\"捐赠\"><a href=\"#捐赠\" class=\"headerlink\" title=\"捐赠\"></a><strong>捐赠</strong></h3><p>如果您觉得本指南有帮助并希望支持正在进行的工作，请考虑捐赠。每一笔捐款，无论大小，都有助于我们继续通过进一步的研究、开发和文档工作来创建、分享和支持社区。</p>\n<ul>\n<li><strong>加密货币捐赠（LTC - 莱特币）</strong> ：<ul>\n<li><strong>地址</strong>：<code>MPMyQD5zgy2b2CpDn1C1KZ31KmHpT7AwRi</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>特别奖励</strong>：如果您捐赠，请随时在Discord上（VCPU）与我联系，以获得个人感谢，并可能获得额外资源、新内容的早期访问或项目上的个性化帮助。</p>\n<p><strong>注意</strong>：如果您需要我审查您实现的特定部分、解决问题或提供详细的代码反馈，请在您的代码中用<code>//VCPU-REVIEW//</code>注释标记相关部分，并提供您遇到的问题或疑问的详细说明。这有助于我集中精力并提供最有效的支持。</p>\n<p>愿上帝保佑您的灵魂。</p>\n<hr>\n<p><strong>指南结束</strong></p>\n","more":"<h1 id=\"全设备仿真的定制固件开发指南\"><a href=\"#全设备仿真的定制固件开发指南\" class=\"headerlink\" title=\"全设备仿真的定制固件开发指南\"></a>全设备仿真的定制固件开发指南</h1><h1 id=\"全设备仿真的定制固件开发指南-1\"><a href=\"#全设备仿真的定制固件开发指南-1\" class=\"headerlink\" title=\"全设备仿真的定制固件开发指南\"></a><strong>全设备仿真的定制固件开发指南</strong></h1><hr>\n<p><strong>特别鸣谢慷慨捐助的传奇人物，我将很快与您联系。如果您愿意，请DM我，我会在本文中添加鸣谢并提供更多信息！</strong></p>\n<p>正在将此指南整理到<a href=\"https://github.com/JPShag/PCILeech-DMA-Firmware/wiki/Introduction\">维基</a>中。欢迎提供帮助！</p>\n<hr>\n<p><strong>作者留言及指南状态：</strong></p>\n<p>我正在透明地分享这一切，因为最近的日子异常艰难。除了因欺诈性退款造成的巨大经济损失外，我还面临多重生活和健康困境，严重影响了我上网和投入项目的时间。坦率地说，在这些个人困难中，继续创作像本指南这样全面的资源已成为一项深刻的挣扎。</p>\n<p>这预计是主指南的最后一次重大迭代。对于已经熟悉基本硬件概念（例如，FTDI芯片的功能）的更有经验的用户，我们将提供一个简洁的精简版。</p>\n<p>如果您觉得这项工作有价值并能够提供帮助，任何形式的支持都将不胜感激。您的慷慨使我尽管面临持续的挑战，仍能继续为这个社区做出贡献。我真诚地希望本指南已经并将继续成为一份宝贵的资源。</p>\n<hr>\n<h2 id=\"纪念与献词\"><a href=\"#纪念与献词\" class=\"headerlink\" title=\"纪念与献词\"></a>纪念与献词</h2><p><img src=\"https://github.com/user-attachments/assets/de7f12fe-8992-4738-a6af-712dc48217ee\" alt=\"Ross\"></p>\n<p>本指南谨献给<br><strong>Ross Freeman (1947–1989)</strong>  的记忆</p>\n<p>作为一位富有远见的工程师、杰出的密歇根人，以及Xilinx的联合创始人，Ross Freeman被广泛认为是现场可编程门阵列（FPGA）技术之父，该技术彻底改变了计算领域。</p>\n<p>在1984年，半导体行业主要专注于固定功能芯片之时，Freeman敢于想象一种不同的范式：制造后可以重新编程的硬件。他的革命性专利（#4,870,302）和对可重构计算的不懈倡导，开启了一个四十年后仍在改变我们世界的科技范式。</p>\n<p>他的开创性创新使得在无需承担传统ASIC开发高昂成本的情况下，快速原型化和部署定制芯片解决方案成为可能，从而使硬件设计民主化，并加速了无数领域的技术进步。</p>\n<p>如今，Freeman的愿景驱动着人工智能、高性能计算、电信、汽车系统、航空航天应用以及他在世时仅是梦想的许多其他领域的尖端发展。</p>\n<p>他于2009年被追授进入国家发明家名人堂，其遗产不仅体现在硅片中，更体现在挑战我们所有人质疑既定限制并想象新可能性的技术勇气精神中。</p>\n<p> <em>“FPGA的最终目标是制造可编程逻辑器件，以取代标准数字芯片。”</em>  — Ross Freeman</p>\n<hr>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a><strong>目录</strong></h2><h3 id=\"第一部分：基础概念\"><a href=\"#第一部分：基础概念\" class=\"headerlink\" title=\"第一部分：基础概念\"></a><strong>第一部分：基础概念</strong></h3><ol>\n<li><a href=\"#1-%E5%BC%95%E8%A8%80\">引言</a><ul>\n<li><a href=\"#11-%E6%9C%AC%E6%8C%87%E5%8D%97%E7%9A%84%E7%9B%AE%E7%9A%84\">1.1 本指南的目的</a></li>\n<li><a href=\"#12-%E7%9B%AE%E6%A0%87%E8%AF%BB%E8%80%85\">1.2 目标读者</a></li>\n<li><a href=\"#13-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%AC%E6%8C%87%E5%8D%97\">1.3 如何使用本指南</a></li>\n</ul>\n</li>\n<li><a href=\"#2-%E5%85%B3%E9%94%AE%E5%AE%9A%E4%B9%89\">关键定义</a></li>\n<li><a href=\"#3-%E8%AE%BE%E5%A4%87%E5%85%BC%E5%AE%B9%E6%80%A7\">设备兼容性</a><ul>\n<li><a href=\"#31-%E6%94%AF%E6%8C%81%E7%9A%84%E5%9F%BA%E4%BA%8Efpga%E7%9A%84%E7%A1%AC%E4%BB%B6\">3.1 支持的基于FPGA的硬件</a></li>\n<li><a href=\"#32-pcie%E7%A1%AC%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">3.2 PCIe硬件注意事项</a></li>\n<li><a href=\"#33-%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82\">3.3 系统要求</a></li>\n</ul>\n</li>\n<li><a href=\"#4-%E8%A6%81%E6%B1%82\">要求</a><ul>\n<li><a href=\"#41-%E7%A1%AC%E4%BB%B6\">4.1 硬件</a></li>\n<li><a href=\"#42-%E8%BD%AF%E4%BB%B6\">4.2 软件</a></li>\n<li><a href=\"#43-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE\">4.3 环境设置</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%E6%94%B6%E9%9B%86%E6%8D%90%E8%B5%A0%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF\">收集捐赠设备信息</a><ul>\n<li><a href=\"#51-%E4%BD%BF%E7%94%A8arbor%E8%BF%9B%E8%A1%8Cpcie%E8%AE%BE%E5%A4%87%E6%89%AB%E6%8F%8F\">5.1 使用Arbor进行PCIe设备扫描</a></li>\n<li><a href=\"#52-%E6%8F%90%E5%8F%96%E5%92%8C%E8%AE%B0%E5%BD%95%E8%AE%BE%E5%A4%87%E5%B1%9E%E6%80%A7\">5.2 提取和记录设备属性</a></li>\n</ul>\n</li>\n<li><a href=\"#6-%E5%88%9D%E5%A7%8B%E5%9B%BA%E4%BB%B6%E5%AE%9A%E5%88%B6\">初始固件定制</a><ul>\n<li><a href=\"#61-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4\">6.1 修改配置空间</a></li>\n<li><a href=\"#62-%E6%8F%92%E5%85%A5%E8%AE%BE%E5%A4%87%E5%BA%8F%E5%88%97%E5%8F%B7dsn\">6.2 插入设备序列号（DSN）</a></li>\n</ul>\n</li>\n<li><a href=\"#7-vivado%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%AE%9A%E5%88%B6\">Vivado项目设置与定制</a><ul>\n<li><a href=\"#71-%E7%94%9F%E6%88%90vivado%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6\">7.1 生成Vivado项目文件</a></li>\n<li><a href=\"#72-%E4%BF%AE%E6%94%B9ip%E6%A0%B8\">7.2 修改IP核</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第二部分：中级概念与实现\"><a href=\"#第二部分：中级概念与实现\" class=\"headerlink\" title=\"第二部分：中级概念与实现\"></a><strong>第二部分：中级概念与实现</strong></h3><ol start=\"8\">\n<li><a href=\"#8-%E9%AB%98%E7%BA%A7%E5%9B%BA%E4%BB%B6%E5%AE%9A%E5%88%B6\">高级固件定制</a><ul>\n<li><a href=\"#81-%E9%85%8D%E7%BD%AEpcie%E5%8F%82%E6%95%B0%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F\">8.1 配置PCIe参数以进行仿真</a></li>\n<li><a href=\"#82-%E8%B0%83%E6%95%B4bars%E5%92%8C%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84\">8.2 调整BARs和内存映射</a></li>\n<li><a href=\"#83-%E4%BB%BF%E7%9C%9F%E8%AE%BE%E5%A4%87%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E4%B8%AD%E6%96%AD\">8.3 仿真设备电源管理和中断</a></li>\n</ul>\n</li>\n<li><a href=\"#9-%E4%BB%BF%E7%9C%9F%E8%AE%BE%E5%A4%87%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD\">仿真设备特定功能</a><ul>\n<li><a href=\"#91-%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7pcie%E5%8A%9F%E8%83%BD\">9.1 实现高级PCIe功能</a></li>\n<li><a href=\"#92-%E4%BB%BF%E7%9C%9F%E5%8E%82%E5%95%86%E7%89%B9%E5%AE%9A%E5%8A%9F%E8%83%BD\">9.2 仿真厂商特定功能</a></li>\n</ul>\n</li>\n<li><a href=\"#10-%E4%BA%8B%E5%8A%A1%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85tlp%E4%BB%BF%E7%9C%9F\">事务层数据包（TLP）仿真</a><ul>\n<li><a href=\"#101-%E7%90%86%E8%A7%A3%E5%92%8C%E6%8D%95%E8%8E%B7tlp\">10.1 理解和捕获TLP</a></li>\n<li><a href=\"#102-%E5%88%B6%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9A%E5%88%B6tlp\">10.2 制作用于特定操作的定制TLP</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第三部分：高级技术与优化\"><a href=\"#第三部分：高级技术与优化\" class=\"headerlink\" title=\"第三部分：高级技术与优化\"></a><strong>第三部分：高级技术与优化</strong></h3><ol start=\"11\">\n<li><a href=\"#11-%E6%9E%84%E5%BB%BA%E7%83%A7%E5%BD%95%E4%B8%8E%E6%B5%8B%E8%AF%95\">构建、烧录与测试</a><ul>\n<li><a href=\"#111-%E7%BB%BC%E5%90%88%E4%B8%8E%E5%AE%9E%E7%8E%B0\">11.1 综合与实现</a></li>\n<li><a href=\"#112-%E7%83%A7%E5%BD%95%E6%AF%94%E7%89%B9%E6%B5%81\">11.2 烧录比特流</a></li>\n<li><a href=\"#113-%E6%B5%8B%E8%AF%95%E4%B8%8E%E9%AA%8C%E8%AF%81\">11.3 测试与验证</a></li>\n</ul>\n</li>\n<li><a href=\"#12-%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF\">高级调试技术</a><ul>\n<li><a href=\"#121-%E4%BD%BF%E7%94%A8vivado%E7%9A%84%E9%9B%86%E6%88%90%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E4%BB%AA\">12.1 使用Vivado的集成逻辑分析仪</a></li>\n<li><a href=\"#122-pcie%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7\">12.2 PCIe流量分析工具</a></li>\n</ul>\n</li>\n<li><a href=\"#13-%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4\">故障排除</a><ul>\n<li><a href=\"#131-%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B%E9%97%AE%E9%A2%98\">13.1 设备检测问题</a></li>\n<li><a href=\"#132-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%92%8Cbar%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF\">13.2 内存映射和BAR配置错误</a></li>\n<li><a href=\"#133-dma%E6%80%A7%E8%83%BD%E5%92%8Ctlp%E9%94%99%E8%AF%AF\">13.3 DMA性能和TLP错误</a></li>\n</ul>\n</li>\n<li><a href=\"#14-%E4%BB%BF%E7%9C%9F%E7%B2%BE%E5%BA%A6%E4%B8%8E%E4%BC%98%E5%8C%96\">仿真精度与优化</a><ul>\n<li><a href=\"#141-%E7%B2%BE%E7%A1%AE%E5%AE%9A%E6%97%B6%E4%BB%BF%E7%9C%9F%E6%8A%80%E6%9C%AF\">14.1 精确定时仿真技术</a></li>\n<li><a href=\"#142-%E5%AF%B9%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8A%A8%E6%80%81%E5%93%8D%E5%BA%94\">14.2 对系统调用的动态响应</a></li>\n</ul>\n</li>\n<li><a href=\"#15-%E5%9B%BA%E4%BB%B6%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">固件开发最佳实践</a><ul>\n<li><a href=\"#151-%E6%8C%81%E7%BB%AD%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%96%87%E6%A1%A3\">15.1 持续测试与文档</a></li>\n<li><a href=\"#152-%E7%AE%A1%E7%90%86%E5%9B%BA%E4%BB%B6%E7%89%88%E6%9C%AC\">15.2 管理固件版本</a></li>\n<li><a href=\"#153-%E5%AE%89%E5%85%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">15.3 安全注意事项</a></li>\n</ul>\n</li>\n<li><a href=\"#16-%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90\">其他资源</a></li>\n<li><a href=\"#17-%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F\">联系方式</a></li>\n<li><a href=\"#18-%E6%94%AF%E6%8C%81%E4%B8%8E%E8%B4%A1%E7%8C%AE\">支持与贡献</a></li>\n</ol>\n<hr>\n<h2 id=\"第一部分：基础概念-1\"><a href=\"#第一部分：基础概念-1\" class=\"headerlink\" title=\"第一部分：基础概念\"></a><strong>第一部分：基础概念</strong></h2><hr>\n<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1. 引言\"></a><strong>1. 引言</strong></h2><h3 id=\"1-1-本指南的目的\"><a href=\"#1-1-本指南的目的\" class=\"headerlink\" title=\"1.1 本指南的目的\"></a><strong>1.1 本指南的目的</strong></h3><p>本指南的总体目标是让您掌握开发基于现场可编程门阵列（FPGA）设备的定制直接内存访问（DMA）固件的知识和实践技能。这种专用固件允许您的FPGA精确地仿真其他PCIe（Peripheral Component Interconnect Express）硬件设备的身份和行为。这种仿真是一种强大的技术，在多个高级领域具有深远意义：</p>\n<p><strong>硬件安全研究</strong>：</p>\n<ul>\n<li><strong>漏洞发现</strong>：通过仿真设备，您可以创建一个受控环境，向主机驱动程序发送格式错误或意外数据，系统性地进行模糊测试，以发现可能通过硬件外设利用的漏洞（例如，缓冲区溢出、竞态条件）。</li>\n<li><strong>驱动程序分析</strong>：观察操作系统和特定驱动程序如何与硬件交互。您可以仿真具有非标准配置或未文档化功能的设备，以了解驱动程序行为、识别安全假设或逆向工程专有协议。</li>\n<li><strong>侧信道分析</strong>：虽然更复杂，但仿真设备可以通过精确控制外设操作，潜在地协助进行与通过时序或功耗分析进行信息泄漏相关的实验。</li>\n</ul>\n<p><strong>红队演练与渗透测试</strong>：</p>\n<ul>\n<li><strong>绕过安全措施</strong>：仿真一个看似良性或白名单的硬件设备（例如，一个常见的网卡或存储控制器），以获取DMA权限。一旦实现，这允许直接与系统内存交互，可能绕过在更高软件层运行的端点检测和响应（EDR）系统或反恶意软件解决方案。</li>\n<li><strong>隐蔽持久性</strong>：仿真恶意设备可以提供一种隐蔽的方式来维护对受损系统的访问，因为它可能比基于软件的植入物更难检测。</li>\n<li><strong>利用信任关系</strong>：系统通常对连接的硬件有隐式信任。定制固件可以通过模仿被授予特定权限或访问的设备来利用这一点。</li>\n</ul>\n<p><strong>系统调试与诊断</strong>：</p>\n<ul>\n<li><strong>可复现的测试平台</strong>：创建高度特定的硬件场景，以可靠地复现可能仅在特定设备状态或数据模式下发生的难以捉摸的错误。</li>\n<li><strong>故障注入</strong>：故意仿真有缺陷的设备行为（例如，错误的TLP形成、延迟响应），以测试主机系统及其驱动程序的健壮性和错误处理能力。</li>\n</ul>\n<p><strong>硬件测试与验证</strong>：</p>\n<ul>\n<li><strong>驱动程序开发</strong>：在物理原型可用之前，或为了模拟比物理可访问的更广泛的硬件变体，针对仿真硬件配置文件测试新的或修改的驱动程序。</li>\n<li><strong>合规性测试</strong>：虽然不能替代官方合规性测试，但仿真设备可以帮助预验证PCIe协议遵守的某些方面。</li>\n</ul>\n<p><strong>传统系统支持与互操作性</strong>：</p>\n<ul>\n<li>仿真老旧、停产或难以采购的PCIe设备，以保持传统系统运行或弥合不同硬件代之间的兼容性差距。</li>\n</ul>\n<p>通过学习本指南，您将熟练掌握：</p>\n<ul>\n<li>精细地从物理“捐赠”PCIe设备中提取识别属性和配置细节。</li>\n<li>修改和扩展现有开源FPGA固件框架（主要关注广泛使用的PCILeech-FPGA项目），以采用捐赠设备的身份。</li>\n<li>配置和利用以Xilinx Vivado为核心的专业FPGA开发工具链，以及Visual Studio Code等基本代码编辑工具。</li>\n<li>对PCIe架构的分层模型、DMA数据传输机制以及低级别复制硬件行为的固件开发细微之处，形成扎实的理解。</li>\n</ul>\n<h3 id=\"1-2-目标读者\"><a href=\"#1-2-目标读者\" class=\"headerlink\" title=\"1.2 目标读者\"></a><strong>1.2 目标读者</strong></h3><p>本指南专为已具备计算机系统、硬件原理和软件开发基础到中级知识的个人量身定制。内容技术性强，并假定读者具备进行详细、低级别工作的能力。具体来说，它面向以下人群：</p>\n<ul>\n<li><strong>固件开发人员</strong>：旨在为FPGA设计或改编固件的工程师，特别是涉及高速数据传输（DMA）和通过PCIe直接硬件接口操作的应用。强烈建议具备Verilog&#x2F;VHDL背景和FPGA开发工具经验。</li>\n<li><strong>硬件工程师</strong>：参与PCIe硬件设计、测试或验证的专业人员。本指南可以帮助创建复杂的测试线束或在更大的系统设计中仿真组件。预计熟悉PCIe协议和数字设计。</li>\n<li><strong>网络安全专业人员与研究人员</strong>：<ul>\n<li><strong>漏洞研究员与漏洞利用开发人员</strong>：希望探索硬件级攻击面或开发利用DMA的概念验证漏洞。操作系统内部、内存管理和驱动程序架构的理解至关重要。</li>\n<li><strong>红队成员</strong>：寻求通过直接硬件操作来获取系统访问、持久性和数据窃取的先进技术操作员。</li>\n<li><strong>数字取证与事件响应人员</strong>：虽然本指南侧重于攻击，但理解这些技术有助于识别和分析复杂的基于硬件的攻击。</li>\n</ul>\n</li>\n<li><strong>FPGA爱好者与高级业余爱好者</strong>：有FPGA项目经验，渴望应对PCIe通信和硬件仿真等复杂挑战的个人。愿意深入研究数据手册和技术规范是关键。</li>\n</ul>\n<p>学习曲线可能很陡峭，特别是如果PCIe或高级FPGA概念是新知识。然而，本指南旨在将复杂主题分解为可管理的步骤。</p>\n<h3 id=\"1-3-如何使用本指南\"><a href=\"#1-3-如何使用本指南\" class=\"headerlink\" title=\"1.3 如何使用本指南\"></a><strong>1.3 如何使用本指南</strong></h3><p>本指南分为三个逻辑递进的部分，旨在逐步构建您的知识：</p>\n<ul>\n<li><strong>第一部分：基础概念</strong>：这第一部分至关重要。它介绍了核心术语、PCIe和DMA的基本原理、必要的硬件和软件堆栈（包括Xilinx Vivado和PCILeech-FPGA框架等工具的设置说明），以及从目标“捐赠”设备获取重要信息和进行基本固件修改的初始程序。强烈建议按顺序彻底学习本部分。</li>\n<li><strong>第二部分：中级概念与实现</strong>：（后续章节）在基础知识之上，本部分将引导您进行更高级的固件定制。主题将包括微调PCIe操作参数、仿真设备特定寄存器和功能（如电源管理状态和消息信号中断 - MSI&#x2F;MSI-X），以及初步理解事务层数据包（TLP）的构建和解释。</li>\n<li><strong>第三部分：高级技术与优化</strong>：（后续章节）最后一部分将探讨复杂的调试方法（包括使用集成逻辑分析仪 - ILA和外部PCIe协议分析仪）、优化固件性能和仿真精度的技术、常见和复杂问题的全面故障排除，以及关于最佳实践的关键讨论，特别关注开发和部署仿真PCIe设备的安全影响。</li>\n</ul>\n<p><strong>学习本指南的步骤</strong>：</p>\n<ul>\n<li><strong>顺序学习</strong>：特别是对于第一部分和第二部分，请按顺序学习各节，因为后面的概念建立在前面的基础之上。</li>\n<li><strong>动手实践</strong>：这是一份实践指南。请在您自己的硬件上积极执行设置步骤、代码修改和实验。</li>\n<li><strong>适应您的环境</strong>：文件路径、特定设备ID和软件版本可能有所不同。理解指令背后的概念，以使其适应您的特定设置。</li>\n<li><strong>查阅外部资源</strong>：PCIe规范和FPGA文档是您的最终参考。本指南进行简化和引导，但深入研究通常需要查阅原始资料。</li>\n<li><strong>迭代开发</strong>：固件开发很少是线性的。预期会进行迭代、调试和改进您的设计。广泛使用故障排除部分和调试技术。</li>\n</ul>\n<p>您将使用HDL（PCILeech-FPGA中的SystemVerilog）、FPGA综合和实现工具（Vivado），并可能使用主机端编程工具和PCIe分析实用程序。</p>\n<hr>\n<h2 id=\"2-关键定义\"><a href=\"#2-关键定义\" class=\"headerlink\" title=\"2. 关键定义\"></a><strong>2. 关键定义</strong></h2><p>牢固掌握以下术语对于理解PCIe设备仿真和定制固件开发的复杂性至关重要。这些术语将在整个指南中广泛使用。</p>\n<ul>\n<li><p><strong>DMA (Direct Memory Access)</strong>  (直接内存访问)：</p>\n<ul>\n<li><strong>定义</strong>：现代计算机体系结构的一项基本功能，允许硬件外设（如网卡、GPU或您的基于FPGA的仿真设备）直接读取和写入主系统内存（RAM），而无需CPU参与每个字节的传输。</li>\n<li><strong>重要性</strong>：DMA对于高性能I&#x2F;O操作至关重要。通过将数据传输任务从CPU卸载，它使CPU能够执行其他计算，显著提高整体系统吞吐量和效率。在本指南中，您的FPGA将利用DMA与主机系统的内存进行交互，这是一种在安全研究和红队演练中经常被利用的强大功能。</li>\n</ul>\n</li>\n<li><p><strong>PCIe (Peripheral Component Interconnect Express)</strong>  (外围组件互连高速)：</p>\n<ul>\n<li><strong>定义</strong>：一种高速串行计算机扩展总线标准，旨在取代旧的总线标准，如PCI、PCI-X和AGP。它采用点对点拓扑结构，每个设备通过独立的串行链路连接到根联合体（通常是芯片组或CPU的一部分）。通信通过数据包进行。</li>\n<li><strong>重要性</strong>：PCIe是连接高性能外设到主板的主导标准。理解其协议、分层架构（物理层、数据链路层、事务层）和配置机制对于仿真任何现代硬件设备至关重要。</li>\n</ul>\n</li>\n<li><p><strong>TLP (Transaction Layer Packet)</strong>  (事务层数据包)：</p>\n<ul>\n<li><strong>定义</strong>：PCIe协议事务层的数据交换基本单位。TLP负责在PCIe设备之间传输请求（例如，内存读&#x2F;写、I&#x2F;O读&#x2F;写、配置读&#x2F;写）和完成（对请求的响应）。每个TLP由一个报头、一个可选的数据有效载荷和一个可选的端到端CRC（ECRC）组成。</li>\n<li><strong>重要性</strong>：为了精确仿真设备，您的FPGA固件必须能够正确地形成、传输、接收和解释与捐赠设备行为匹配的TLP。理解TLP类型、格式和流控制对于高级仿真至关重要。</li>\n</ul>\n</li>\n<li><p><strong>BAR (Base Address Register)</strong>  (基地址寄存器)：</p>\n<ul>\n<li><strong>定义</strong>：位于PCIe设备的配置空间内，BAR是特殊的寄存器，设备通过它们向主机系统请求地址空间资源。一个设备最多可以有六个32位BAR（或更少，或成对的32位BAR可以形成64位BAR）。这些寄存器定义了设备用于向主机CPU公开其寄存器和内部内存的内存映射I&#x2F;O（MMIO）区域或I&#x2F;O端口区域的起始地址和大小。</li>\n<li><strong>重要性</strong>：当主机系统枚举PCIe设备时，它会读取BAR以确定设备的内存和I&#x2F;O要求，然后分配并用系统中物理地址图中的实际基地址来编程这些BAR。您的仿真设备必须精确定义其BAR以匹配捐赠设备，以便主机操作系统和驱动程序能够正确地与其交互。</li>\n</ul>\n</li>\n<li><p><strong>FPGA (Field-Programmable Gate Array)</strong>  (现场可编程门阵列)：</p>\n<ul>\n<li><strong>定义</strong>：一种集成电路（IC），可以在制造后由设计者或客户进行配置——因此称为“现场可编程”。FPGA包含一个可编程逻辑块阵列和可重构互连的层次结构，允许这些块“连接”起来以实现定制数字逻辑电路。</li>\n<li><strong>重要性</strong>：FPGA是本指南中使用的核心硬件。其可重构特性使其成为仿真其他硬件设备的理想选择，因为您可以定义精确的逻辑和接口来模仿捐赠设备的PCIe存在和行为。</li>\n</ul>\n</li>\n<li><p><strong>MSI&#x2F;MSI-X (Message Signaled Interrupts &#x2F; Message Signaled Interrupts Extended)</strong>  (消息信号中断 &#x2F; 扩展消息信号中断)：</p>\n<ul>\n<li><strong>定义</strong>：允许PCIe设备通过向系统定义的内存地址写入特殊消息（TLP，特别是内存写入TLP）来向CPU传递中断的机制，而不是使用专用的物理中断线（如传统PCI）。MSI-X是MSI的增强版，提供更多的中断向量和更大的灵活性。</li>\n<li><strong>重要性</strong>：大多数现代PCIe设备使用MSI或MSI-X以实现更高效、更灵活的中断处理。精确仿真通常需要实现捐赠设备选择的中断机制，包括配置MSI&#x2F;MSI-X能力结构并正确生成中断消息。</li>\n</ul>\n</li>\n<li><p><strong>DSN (Device Serial Number)</strong>  (设备序列号)：</p>\n<ul>\n<li><strong>定义</strong>：一个64位全局唯一标识符，可由PCIe设备可选实现。如果存在，它通常位于设备配置空间内的扩展能力结构中。</li>\n<li><strong>重要性</strong>：虽然并非所有设备都具有DSN，但某些驱动程序或管理软件可能会使用它进行唯一标识、许可或跟踪。正确仿真它对于完全透明和避免检测到仿真设备可能很重要。</li>\n</ul>\n</li>\n<li><p><strong>PCIe Configuration Space</strong> (PCIe配置空间)：</p>\n<ul>\n<li><strong>定义</strong>：与每个PCIe功能（一个设备可以有多个功能）关联的标准化256字节（对于Type 0、端点设备）或4KB地址区域。此空间包含有关设备的重要信息，包括其厂商ID、设备ID、类别代码、修订ID、BAR、能力指针以及各种状态和控制寄存器。主机系统使用特殊的配置读和配置写TLP访问此空间。</li>\n<li><strong>重要性</strong>：配置空间是PCIe设备的“身份证”。设备仿真的第一步就是将捐赠设备配置空间的相关部分精确复制到您的FPGA固件中。主机系统使用此信息来识别、配置和分配资源给设备。</li>\n</ul>\n</li>\n<li><p><strong>Donor Device</strong> (捐赠设备)：</p>\n<ul>\n<li><strong>定义</strong>：您旨在在FPGA上仿真其身份和行为的物理PCIe硬件设备。该设备作为提取配置细节（厂商ID、设备ID、BAR设置、能力等）和行为模式的来源。</li>\n<li><strong>重要性</strong>：您的仿真 fidelity 直接取决于您能够多么精确和完整地收集并复制捐赠设备的特性。</li>\n</ul>\n</li>\n<li><p><strong>Root Complex (RC)</strong>  (根联合体)：</p>\n<ul>\n<li><strong>定义</strong>：PCIe层级结构中将CPU和内存子系统连接到PCIe结构的实体。它代表CPU生成PCIe事务，并处理下游PCIe设备发起的事务。它还执行初始的总线枚举和配置。</li>\n<li><strong>重要性</strong>：您的仿真设备在与主机系统通信时，将主要与根联合体（或与其连接的交换机）交互。</li>\n</ul>\n</li>\n<li><p><strong>Endpoint (EP)</strong>  (端点)：</p>\n<ul>\n<li><strong>定义</strong>：位于PCIe结构外围，消费或生产数据的一种PCIe设备。示例包括网卡、显卡、存储控制器以及您将要编程的FPGA设备。端点请求资源并向根联合体发起事务。</li>\n<li><strong>重要性</strong>：在本指南中，您的FPGA将被编程为充当一个端点设备，仿真一个特定的捐赠端点。</li>\n</ul>\n</li>\n<li><p><strong>HDL (Hardware Description Language)</strong>  (硬件描述语言)：</p>\n<ul>\n<li><strong>定义</strong>：一种专用计算机语言，用于描述电子电路的结构、设计和操作，特别是数字逻辑电路。常见的HDL包括Verilog和VHDL。</li>\n<li><strong>重要性</strong>：您将在PCILeech-FPGA项目中使用Verilog（特别是SystemVerilog，Verilog的扩展）来定义仿真设备的定制逻辑。</li>\n</ul>\n</li>\n<li><p><strong>Bitstream</strong> (比特流)：</p>\n<ul>\n<li><strong>定义</strong>：加载到FPGA上的最终配置文件，用于编程其逻辑块和互连，从而实现您的定制硬件设计。它是FPGA开发工具（如Xilinx Vivado）的编译输出。</li>\n<li><strong>重要性</strong>：生成和烧录正确的比特流是将定制固件部署到FPGA的最终步骤。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-设备兼容性\"><a href=\"#3-设备兼容性\" class=\"headerlink\" title=\"3. 设备兼容性\"></a><strong>3. 设备兼容性</strong></h2><p>成功且精确的PCIe设备仿真取决于确保您选择的基于FPGA的硬件和主机系统配置完全兼容。本节详细介绍了支持的FPGA平台、关键的PCIe硬件注意事项以及设置开发环境所需的系统要求。</p>\n<h3 id=\"3-1-支持的基于FPGA的硬件\"><a href=\"#3-1-支持的基于FPGA的硬件\" class=\"headerlink\" title=\"3.1 支持的基于FPGA的硬件\"></a><strong>3.1 支持的基于FPGA的硬件</strong></h3><p>虽然本指南提供了一种可适用于各种基于FPGA的DMA硬件的通用方法，但我们的主要示例和具体说明将侧重于 <strong>Xilinx 7系列FPGA</strong>，由于其性能和可访问性的平衡，它们在开源DMA板中很常见。<strong>Squirrel DMA (35T)</strong>  卡因其受欢迎程度以及与PCILeech-FPGA框架的良好兼容性而受到强调。</p>\n<p>定制PCIe IP核和开发硬件描述语言（HDL）逻辑的核心原则和技术广泛适用于以下FPGA系列和特定板卡：</p>\n<ul>\n<li><strong>Squirrel (Artix-7 35T)</strong><ul>\n<li><strong>描述</strong>：一种广泛可用且经济高效的基于FPGA的DMA设备，采用Xilinx Artix-7 35T FPGA。它为标准内存采集任务以及各种基本到中级设备仿真项目提供了足够的逻辑资源和内存。它是初次接触基于FPGA的DMA的优秀起点。</li>\n<li><strong>主要特点</strong>：Artix-7提供了良好的性能价格比，适用于教育和研究目的。</li>\n</ul>\n</li>\n<li><strong>Enigma-X1 (Artix-7 75T)</strong><ul>\n<li><strong>描述</strong>：与35T相比，提供增强的逻辑和内存资源的中级FPGA，通常基于Xilinx Artix-7 75T FPGA。这为更复杂的仿真场景、更大的内存映射区域或需要额外FPGA逻辑的更复杂的DMA操作提供了更大的灵活性。</li>\n<li><strong>主要特点</strong>：增加的逻辑单元和块RAM（BRAM）支持更复杂的设计。</li>\n</ul>\n</li>\n<li><strong>ZDMA (Artix-7 100T)</strong><ul>\n<li><strong>描述</strong>：基于更高性能的Artix-7 100T FPGA，针对要求更高的内存交互和大量的读&#x2F;写操作进行了优化。此板卡适用于大规模DMA解决方案、高吞吐量仿真或需要大量片上内存的项目。</li>\n<li><strong>主要特点</strong>：100T变体在资源方面提供了显著升级，是突破仿真界限的理想选择。</li>\n</ul>\n</li>\n<li><strong>Kintex-7 (K325T, K410T等)</strong><ul>\n<li><strong>描述</strong>：代表高级别，Kintex-7 FPGA（例如K325T、K410T）为高度复杂的项目、大规模DMA解决方案以及需要更高PCIe通道数或速度（例如，Gen3 x8&#x2F;x16）的应用提供了强大的功能。虽然价格更昂贵，但它们提供了更多的逻辑、DSP切片和内存，从而能够仿真高度复杂和苛刻的捐赠设备。</li>\n<li><strong>主要特点</strong>：用于更快PCIe世代的高性能收发器，丰富的逻辑和内存资源，适用于复杂设计。</li>\n</ul>\n</li>\n</ul>\n<p><strong>关于FPGA系列的重要说明</strong>：尽管原理相似，但不同的Xilinx 7系列FPGA（Artix-7、Kintex-7、Zynq-7000 PS&#x2F;PL）之间，特定的IP核配置和时钟结构可能略有不同。请始终参考特定板卡文档和您所选FPGA系列的Xilinx PCIe IP核用户指南。PCILeech-FPGA项目通常提供板卡特定的Tcl脚本和源文件以简化此过程。</p>\n<h3 id=\"3-2-PCIe硬件注意事项\"><a href=\"#3-2-PCIe硬件注意事项\" class=\"headerlink\" title=\"3.2 PCIe硬件注意事项\"></a><strong>3.2 PCIe硬件注意事项</strong></h3><p>为了确保基于FPGA的DMA设备在仿真中平稳无限制地运行，需要仔细考虑一些PCIe特定和主机系统功能，并在某些情况下进行修改。</p>\n<ul>\n<li><strong>IOMMU &#x2F; VT-d &#x2F; AMD-Vi 设置</strong><ul>\n<li><strong>建议</strong>：对于初始设置和测试，<strong>强烈建议在系统的BIOS&#x2F;UEFI设置中禁用IOMMU（Intel的定向I&#x2F;O虚拟化技术 - VT-d）或AMD的等效技术（AMD-Vi）</strong> 。</li>\n<li><strong>理由</strong>：IOMMU是为DMA功能设备提供内存管理单元的硬件组件。它们执行地址转换，类似于CPU的MMU，并且可以强制执行内存访问权限。虽然它们对于安全和虚拟化（防止恶意设备访问未经授权的内存区域）至关重要，但它们<strong>会</strong>限制DMA设备对系统内存的访问，可能干扰内存采集和设备仿真。禁用IOMMU允许DMA设备不受限制地访问内存，这对于高级仿真和安全研究目的通常是必要的。</li>\n<li><strong>位置</strong>：通常在BIOS&#x2F;UEFI中的“CPU Configuration”、“Virtualization”、“Advanced Settings”或“I&#x2F;O Virtualization”下找到。</li>\n</ul>\n</li>\n<li><strong>内核DMA保护（Windows）&#x2F; Thunderbolt安全级别（Linux）</strong><ul>\n<li><strong>建议（Windows）</strong> ：在现代Windows系统中禁用<strong>内核DMA保护</strong>功能。这包括<strong>基于虚拟化的安全性（VBS）</strong>和<strong>内存完整性（HVCI）</strong>等设置。这些功能利用IOMMU来防止通过Thunderbolt或PCIe连接的外部外设进行未经授权的DMA攻击。</li>\n<li><strong>步骤（Windows）</strong> ：<ul>\n<li>访问Windows安全设置：<strong>开始 &gt; 设置 &gt; 隐私和安全性 &gt; Windows 安全中心 &gt; 设备安全性</strong>。</li>\n<li>在“核心隔离”下，点击“核心隔离详细信息”。</li>\n<li>关闭“内存完整性”。</li>\n<li>您可能还需要在BIOS&#x2F;UEFI中禁用安全启动，因为VBS通常依赖于它。</li>\n<li><strong>注意</strong>：禁用这些功能会显著<strong>降低您系统的安全态势</strong>，使其容易受到包括涉及恶意DMA设备的各种攻击。这应该只在专用测试系统上进行，而不是在您的主机器上，并且在您了解风险的安全、隔离环境中进行。</li>\n</ul>\n</li>\n<li><strong>建议（Linux&#x2F;Thunderbolt）</strong> ：如果使用带有Thunderbolt端口的系统，请了解并可能调整BIOS&#x2F;UEFI中的<strong>Thunderbolt安全级别</strong>。较低的安全级别（例如，“无安全”、“用户授权”）通常是任意Thunderbolt&#x2F;PCIe设备在未经明确主机批准的情况下执行DMA所必需的。</li>\n</ul>\n</li>\n<li><strong>PCIe插槽要求</strong><ul>\n<li><strong>建议</strong>：使用与FPGA设备要求物理匹配的兼容PCIe插槽。大多数基于Artix-7的DMA卡在PCIe Gen2 x1或x4下运行。</li>\n<li><strong>理由</strong>：<ul>\n<li><strong>物理匹配</strong>：x1卡可以插入x1、x4、x8或x16插槽，但x4卡至少需要x4插槽。</li>\n<li><strong>性能</strong>：虽然x4卡<em>可能</em>在x1插槽中工作（如果物理连接是开放式或已修改的），但它将以x1速度运行，严重限制数据传输速率。为了获得最佳性能和精确仿真捐赠设备的功能，请确保FPGA板卡安装在提供至少<em>仿真</em>链路宽度和速度的插槽中（例如，如果您要仿真Gen2 x4设备，请在主机上使用Gen2 x4插槽）。</li>\n</ul>\n</li>\n<li><strong>主板BIOS设置</strong>：一些主板允许配置PCIe插槽速度（例如，强制Gen1或Gen2）。确保这些设置不与您期望的仿真速度冲突。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3-系统要求\"><a href=\"#3-3-系统要求\" class=\"headerlink\" title=\"3.3 系统要求\"></a><strong>3.3 系统要求</strong></h3><p>建立一个健壮的开发环境对于高效的固件开发、综合和调试至关重要。</p>\n<ul>\n<li><strong>主机系统</strong><ul>\n<li><strong>处理器</strong>：现代多核CPU对于运行Vivado等FPGA开发工具至关重要，这些工具在综合和实现过程中计算密集。（例如，Intel Core i5&#x2F;i7&#x2F;i9 或 AMD Ryzen 5&#x2F;7&#x2F;9 等效处理器，建议8代或更新）。</li>\n<li><strong>内存（RAM）</strong> ：强烈建议最低16 GB RAM；对于复杂FPGA设计，<strong>32 GB 或更高是理想选择</strong>，因为Vivado会消耗大量内存，尤其是在实现阶段。</li>\n<li><strong>存储</strong>：一个固态硬盘（SSD）并至少有 <strong>200 GB 的可用空间</strong> 至关重要。FPGA工具安装（仅Vivado就可能超过50 GB）、项目文件以及综合&#x2F;实现输出会迅速占用磁盘空间。SSD的速度能显著缩短构建时间。</li>\n<li><strong>操作系统</strong>：<ul>\n<li><strong>Windows 10&#x2F;11 (64位 专业版或企业版)</strong> ：Xilinx Vivado 和许多硬件调试工具广泛支持。请记住内核DMA保护的注意事项。</li>\n<li><strong>兼容的Linux发行版 (64位)</strong> ：Ubuntu LTS（长期支持）版本（例如 20.04、22.04）是Vivado常用且支持良好的系统。Linux通常为脚本编写和低级PCIe交互工具提供更灵活的环境。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>外围设备</strong><ul>\n<li><strong>JTAG编程器</strong>：将编译后的比特流烧录到基于FPGA的DMA卡上绝对必需。示例包括Xilinx Platform Cable USB II、Digilent JTAG-HS3 或某些开发板上集成的JTAG编程器。确保它与您的FPGA板卡和Vivado兼容。</li>\n<li><strong>PCIe插槽</strong>：如第3.2节所述，确保您的主机系统有可用的兼容PCIe插槽用于DMA卡。</li>\n<li><strong>USB端口</strong>：用于连接JTAG编程器，并可能用于连接FPGA板卡的UART&#x2F;串行控制台以进行调试输出。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-要求\"><a href=\"#4-要求\" class=\"headerlink\" title=\"4. 要求\"></a><strong>4. 要求</strong></h2><p>本节概述了进行PCIe设备仿真定制固件开发所必需的基本硬件和软件组件，以及推荐的环境设置。在开始之前，具备这些先决条件将简化您的开发过程。</p>\n<h3 id=\"4-1-硬件\"><a href=\"#4-1-硬件\" class=\"headerlink\" title=\"4.1 硬件\"></a><strong>4.1 硬件</strong></h3><ul>\n<li><strong>捐赠PCIe设备</strong><ul>\n<li><strong>目的</strong>：这是您打算在FPGA上仿真其配置和行为的物理硬件设备。它作为关键识别细节、寄存器值和操作特性的权威来源。</li>\n<li><strong>示例</strong>：常见示例包括标准网卡（NIC）、SATA或NVMe存储控制器、USB控制器，或任何其他您可以安全地从系统中移除进行分析的通用PCIe扩展卡。强烈建议使用对系统操作非必需的设备，因为您将检查其低级配置。</li>\n</ul>\n</li>\n<li><strong>DMA FPGA卡</strong><ul>\n<li><strong>描述</strong>：一种基于FPGA的开发板，专门设计或改编用于通过PCIe接口执行直接内存访问（DMA）操作。这是您的定制固件将加载到的平台。</li>\n<li><strong>示例</strong>：如第3.1节所述，兼容卡包括 <strong>Squirrel (Artix-7 35T)</strong> 、<strong>Enigma-X1 (Artix-7 75T)</strong> 、<strong>ZDMA (Artix-7 100T)</strong>  或各种基于 <strong>Kintex-7</strong> 的解决方案。确保您选择的卡具有PCIe金手指连接器。</li>\n</ul>\n</li>\n<li><strong>JTAG编程器</strong><ul>\n<li><strong>目的</strong>：这个关键工具促进了您的开发PC与DMA卡上FPGA之间的通信。它用于将编译后的比特流编程（烧录）到FPGA上，更重要的是，用于使用Vivado的硬件管理器和集成逻辑分析仪（ILA）等工具进行交互式调试。</li>\n<li><strong>示例</strong>：<ul>\n<li><strong>Xilinx Platform Cable USB II</strong>：Xilinx FPGA传统且广泛兼容的编程器。确保您已安装必要的驱动程序。</li>\n<li><strong>Digilent JTAG-HS3 &#x2F; JTAG-HS2</strong>：流行且可靠的编程器，以良好的Vivado集成和支持而闻名。HS3提供更快的编程速度。</li>\n<li><strong>集成JTAG</strong>：某些FPGA板可能具有板载USB转JTAG桥（例如FTDI芯片），这消除了对独立编程器的需求。请查阅您的板卡文档。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-软件\"><a href=\"#4-2-软件\" class=\"headerlink\" title=\"4.2 软件\"></a><strong>4.2 软件</strong></h3><ul>\n<li><strong>Xilinx Vivado Design Suite</strong><ul>\n<li><strong>描述</strong>：Xilinx（现为AMD）官方的、全面的FPGA开发环境。Vivado对于综合您的HDL代码、将设计实现到目标FPGA上、生成最终比特流以及执行硬件调试至关重要。它包括必要的IP核、编译器和实用程序。</li>\n<li><strong>下载</strong>：访问Xilinx（AMD）官方下载页面：<a href=\"https://www.xilinx.com/support/download.html\">https://www.xilinx.com/support/download.html</a>。</li>\n<li><strong>版本说明</strong>：虽然一些旧指南可能引用Vivado 2020.1等旧版本，但强烈建议下载与您的目标FPGA系列（Artix-7、Kintex-7）兼容的<strong>最新稳定版本</strong>（例如Vivado 2023.x或更高版本）。PCILeech-FPGA项目通常支持较新的Vivado版本。</li>\n</ul>\n</li>\n<li><strong>Visual Studio Code</strong><ul>\n<li><strong>描述</strong>：Microsoft出品的高度可定制且功能丰富的代码编辑器。它是编写和编辑Verilog&#x2F;SystemVerilog HDL代码的绝佳选择，因为它拥有广泛的扩展生态系统，提供语法高亮、代码检查、自动补全和版本控制集成等功能。</li>\n<li><strong>下载</strong>：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a></li>\n</ul>\n</li>\n<li><strong>PCILeech-FPGA</strong><ul>\n<li><strong>描述</strong>：一个用于基于FPGA的DMA开发的开源框架和基础代码库。它提供了即插即用的PCIe IP核实例化和一个结构良好的项目，是定制固件的绝佳起点。本指南将大量利用其架构。</li>\n<li><strong>仓库</strong>：<a href=\"https://github.com/ufrisk/pcileech-fpga\">https://github.com/ufrisk/pcileech-fpga</a></li>\n</ul>\n</li>\n<li><strong>Arbor (MindShare)</strong><ul>\n<li><strong>描述</strong>：一款强大且用户友好的软件工具，专门设计用于深入扫描和分析PCIe设备。它提供了对连接PCIe硬件的配置空间、功能和寄存器的详细洞察，对于收集捐赠设备信息来说非常有价值。</li>\n<li><strong>下载</strong>：可从MindShare网站获取：<a href=\"https://www.mindshare.com/\">https://www.mindshare.com/</a>（您可能需要导航到他们的软件部分）。</li>\n<li><strong>注意</strong>：通常需要创建账户，并且可能提供限时试用。</li>\n</ul>\n</li>\n<li><strong>替代PCIe设备分析工具</strong><ul>\n<li><strong>Telescan PE (Teledyne LeCroy)</strong> ：<ul>\n<li><strong>描述</strong>：Teledyne LeCroy提供的一款免费PCIe流量分析和设备枚举工具。虽然它主要是一款与其硬件协议分析仪交互的软件工具，但它也可以在没有专用硬件的情况下提供一些基本的配置空间视图。</li>\n<li><strong>下载</strong>：<a href=\"https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software\">https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software</a></li>\n<li><strong>注意</strong>：需要手动注册和批准才能下载。</li>\n</ul>\n</li>\n<li><strong>OS原生工具（用于基本检查）</strong> ：<ul>\n<li><strong>Windows设备管理器</strong>：在设备属性的“详细信息”选项卡下提供基本的厂商ID、设备ID、子系统ID和类别代码信息。</li>\n<li><strong>Linux <strong>​</strong>​<code>lspci</code>​</strong>​ ** 工具**：一个强大的命令行工具，用于检查PCIe设备。使用<code>lspci -nn</code>查看厂商&#x2F;设备ID，<code>lspci -vvv</code>查看包括BAR和功能在内的详细信息，<code>lspci -s &lt;BUS:DEV.FUN&gt; -xxxx</code>用于原始配置空间转储。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-3-环境设置\"><a href=\"#4-3-环境设置\" class=\"headerlink\" title=\"4.3 环境设置\"></a><strong>4.3 环境设置</strong></h3><p>一个干净且正确配置的开发环境对于避免常见陷阱并确保流畅的工作流程至关重要。</p>\n<h4 id=\"4-3-1-安装Xilinx-Vivado设计套件\"><a href=\"#4-3-1-安装Xilinx-Vivado设计套件\" class=\"headerlink\" title=\"4.3.1 安装Xilinx Vivado设计套件\"></a><strong>4.3.1 安装Xilinx Vivado设计套件</strong></h4><p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>访问Xilinx (AMD) Vivado下载页面</strong>：<a href=\"https://www.xilinx.com/support/download.html\">https://www.xilinx.com/support/download.html</a>。</li>\n<li><strong>下载适当版本</strong>：选择与您的操作系统兼容的最新稳定版Vivado，更重要的是，它必须与您的特定FPGA设备（例如Artix-7、Kintex-7）兼容。查阅Vivado发行说明以了解设备支持情况。</li>\n<li><strong>运行安装程序</strong>：执行下载的安装程序并仔细遵循屏幕上的说明。</li>\n<li><strong>选择必要组件</strong>：在安装过程中，系统会提示您选择要安装的设备家族。<strong>至关重要的是，选择与您的FPGA板卡对应的设备家族（例如，Artix-7&#x2F;Kintex-7的“7 Series”）</strong> 。这与安装所有家族相比，能节省大量磁盘空间。确保您选择“设计工具”（综合、实现）和“编程与调试”组件。</li>\n<li><strong>启动Vivado</strong>：安装完成后，启动Vivado以确认它能无错误打开，并且许可证（如果适用）已正确配置。</li>\n</ol>\n<h4 id=\"4-3-2-安装Visual-Studio-Code\"><a href=\"#4-3-2-安装Visual-Studio-Code\" class=\"headerlink\" title=\"4.3.2 安装Visual Studio Code\"></a><strong>4.3.2 安装Visual Studio Code</strong></h4><p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>访问Visual Studio Code下载页面</strong>：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a>。</li>\n<li><strong>下载并安装</strong>：下载适用于您操作系统的安装程序，并遵循标准安装提示。</li>\n<li><strong>安装HDL支持扩展</strong>：安装VS Code后，打开它并导航到扩展视图（Ctrl+Shift+X或Cmd+Shift+X）。搜索并安装适用于Verilog&#x2F;SystemVerilog的相关扩展，例如：<ul>\n<li><strong>Verilog-HDL&#x2F;SystemVerilog</strong> (由mshr-h提供)</li>\n<li><strong>VHDL</strong> (如果您也使用VHDL)<br>这些扩展提供了语法高亮、代码检查和其他有用的功能。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-3-3-克隆PCILeech-FPGA仓库\"><a href=\"#4-3-3-克隆PCILeech-FPGA仓库\" class=\"headerlink\" title=\"4.3.3 克隆PCILeech-FPGA仓库\"></a><strong>4.3.3 克隆PCILeech-FPGA仓库</strong></h4><p>此仓库包含您将要修改的基础固件结构和脚本。</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>打开终端或命令提示符</strong>：（例如，Windows上的Git Bash，Linux上的Terminal）。</li>\n<li><strong>导航到您想要的目录</strong>：选择一个您想存储项目的位置。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/Projects/ <span class=\"comment\"># 在Linux/macOS上</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> C:\\Users\\YourUsername\\Documents\\Projects\\ <span class=\"comment\"># 在Windows上</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>克隆仓库</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ufrisk/pcileech-fpga.git</span><br></pre></td></tr></table></figure></li>\n<li><strong>导航到克隆的目录</strong>：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> pcileech-fpga</span><br></pre></td></tr></table></figure>\n\n这将是您的主项目目录。PCILeech-FPGA项目通常包含不同板卡变体的子目录（例如<code>pcileech-artix-7-50t</code>、<code>pcileech-squirrel-35t</code>）。您将根据您的特定硬件导航到相关的板卡特定目录。</li>\n</ol>\n<h4 id=\"4-3-4-设置一个干净的开发环境\"><a href=\"#4-3-4-设置一个干净的开发环境\" class=\"headerlink\" title=\"4.3.4 设置一个干净的开发环境\"></a><strong>4.3.4 设置一个干净的开发环境</strong></h4><p><strong>建议</strong>：始终在隔离或专用的环境中工作，尤其是在处理低级硬件和潜在的安全隐患时。</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li><strong>使用专用开发机或虚拟机</strong>：<ul>\n<li><strong>物理机</strong>：如果可能，使用一台单独的物理计算机进行FPGA开发和测试。这可以防止在您的主机器上发生意外的系统不稳定或安全风险。</li>\n<li><strong>虚拟机（VM）</strong> ：虚拟机可以是隔离开发环境的好选择。然而，通常需要向虚拟机进行直接PCIe直通（PCIe热插拔或VT-d直通），FPGA卡才能被正确检测和操作，这可能配置复杂，并且如果操作不当，仍然可能暴露主机。对于初始工具安装和代码编辑，虚拟机完全没问题。</li>\n</ul>\n</li>\n<li><strong>最小化后台应用程序</strong>：确保没有其他资源密集型应用程序正在运行，这些应用程序可能会干扰Vivado在综合和实现过程中的性能。</li>\n<li><strong>禁用冲突软件</strong>：在开发和测试期间，暂时禁用任何可能干扰低级硬件访问或JTAG通信的防病毒、防火墙或安全软件。完成工作后请记得重新启用它们。</li>\n</ol>\n<hr>\n<h2 id=\"5-收集捐赠设备信息\"><a href=\"#5-收集捐赠设备信息\" class=\"headerlink\" title=\"5. 收集捐赠设备信息\"></a><strong>5. 收集捐赠设备信息</strong></h2><p>精确的设备仿真取决于精细地提取和复制捐赠设备的关键信息。这种全面的数据收集使您的FPGA能够忠实地模仿目标硬件的PCIe配置和行为，确保与主机系统接口时的兼容性和功能性。</p>\n<h3 id=\"5-1-使用Arbor进行PCIe设备扫描\"><a href=\"#5-1-使用Arbor进行PCIe设备扫描\" class=\"headerlink\" title=\"5.1 使用Arbor进行PCIe设备扫描\"></a><strong>5.1 使用Arbor进行PCIe设备扫描</strong></h3><p><strong>Arbor</strong> 是一款强大且用户友好的工具，专为深入扫描PCIe设备而设计。它提供了对连接硬件配置空间的详细洞察，使其成为提取设备仿真所需信息的宝贵资源。</p>\n<h4 id=\"5-1-1-安装Arbor\"><a href=\"#5-1-1-安装Arbor\" class=\"headerlink\" title=\"5.1.1 安装Arbor\"></a><strong>5.1.1 安装Arbor</strong></h4><p>要开始使用Arbor进行设备扫描，您必须首先在系统上安装该软件。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>访问Arbor下载页面：</strong><ul>\n<li>使用您偏好的网页浏览器导航到MindShare官方网站（<a href=\"https://www.mindshare.com/\">https://www.mindshare.com/</a>）。您需要找到他们的“Software”或“Downloads”部分来定位Arbor。</li>\n<li>确保您直接访问该网站，以避免任何恶意重定向。</li>\n</ul>\n</li>\n<li><strong>创建账户（如果需要）：</strong><ul>\n<li>Arbor可能要求您创建用户账户才能访问下载链接。</li>\n<li>提供必要的信息，例如您的姓名、电子邮件地址和组织。</li>\n<li>如果出现提示，请验证您的电子邮件以激活您的账户。</li>\n</ul>\n</li>\n<li><strong>下载Arbor：</strong><ul>\n<li>登录后，找到Arbor的下载部分。</li>\n<li>选择与您的操作系统兼容的版本（例如，Windows 10&#x2F;11 64位）。</li>\n<li>点击 <strong>Download</strong> 按钮并将安装程序保存到计算机上已知的位置。</li>\n</ul>\n</li>\n<li><strong>安装Arbor：</strong><ul>\n<li>找到下载的安装程序文件（例如，<code>ArborSetup.exe</code>）。</li>\n<li>右键单击安装程序并选择 <strong>以管理员身份运行</strong> 以确保它具有必要的权限。</li>\n<li>按照屏幕上的说明完成安装过程。<ul>\n<li>接受许可协议。</li>\n<li>选择安装目录。</li>\n<li>如果需要，选择创建桌面快捷方式。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>验证安装：</strong><ul>\n<li>安装完成后，确保Arbor列在您的“开始”菜单或桌面上。</li>\n<li>启动Arbor以确认它能无错误打开。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-2-扫描PCIe设备\"><a href=\"#5-1-2-扫描PCIe设备\" class=\"headerlink\" title=\"5.1.2 扫描PCIe设备\"></a><strong>5.1.2 扫描PCIe设备</strong></h4><p>安装Arbor后，您可以继续扫描系统中的PCIe设备。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>启动Arbor：</strong><ul>\n<li>双击桌面上的Arbor图标或通过“开始”菜单找到它。</li>\n<li>如果用户账户控制（UAC）提示，允许应用程序对设备进行更改。</li>\n</ul>\n</li>\n<li><strong>导航到本地系统选项卡：</strong><ul>\n<li>在Arbor界面中，找到导航窗格或选项卡。</li>\n<li>单击 <strong>Local System</strong> 以访问扫描本地机器的工具。</li>\n</ul>\n</li>\n<li><strong>扫描PCIe设备：</strong><ul>\n<li>查找 <strong>Scan</strong> 或 <strong>Rescan</strong> 按钮，通常位于界面的顶部或底部。</li>\n<li>点击 <strong>Scan&#x2F;Rescan</strong> 以启动检测过程。</li>\n<li>等待扫描过程完成；这可能需要几分钟，具体取决于连接的设备数量。</li>\n</ul>\n</li>\n<li><strong>审查检测到的设备：</strong><ul>\n<li>扫描完成后，Arbor将显示所有检测到的PCIe设备的列表。</li>\n<li>设备通常会列出其名称、设备ID和其他识别信息。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-3-识别捐赠设备\"><a href=\"#5-1-3-识别捐赠设备\" class=\"headerlink\" title=\"5.1.3 识别捐赠设备\"></a><strong>5.1.3 识别捐赠设备</strong></h4><p>识别正确的捐赠设备对于精确仿真至关重要。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>在列表中找到您的捐赠设备：</strong><ul>\n<li>滚动浏览Arbor检测到的设备列表。</li>\n<li>查找与您的捐赠硬件的品牌和型号匹配的设备。</li>\n<li>设备可能按其厂商名称、设备类型或功能列出。</li>\n</ul>\n</li>\n<li><strong>验证设备详细信息：</strong><ul>\n<li>单击设备以选中它。</li>\n<li>确认 <strong>Device ID</strong> 和 <strong>Vendor ID</strong> 与您的捐赠设备匹配。<ul>\n<li><strong>提示：</strong>  这些ID通常可以在设备文档或制造商网站上找到。对于常见设备，快速在网上搜索“[设备名称] Vendor ID Device ID”通常能得到结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>查看详细配置：</strong><ul>\n<li>选中设备后，找到并单击类似 <strong>View Details</strong> 或 <strong>Properties</strong> 的选项。</li>\n<li>这将打开一个详细视图，显示设备的配置空间和功能。</li>\n</ul>\n</li>\n<li><strong>与物理硬件交叉引用：</strong><ul>\n<li>如果列出了多个类似设备，请将 <strong>Slot Number</strong> 或 <strong>Bus Address</strong> 与安装捐赠设备的物理插槽交叉引用。这有助于确认您正在分析正确的硬件。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-1-4-捕获设备数据\"><a href=\"#5-1-4-捕获设备数据\" class=\"headerlink\" title=\"5.1.4 捕获设备数据\"></a><strong>5.1.4 捕获设备数据</strong></h4><p>从捐赠设备中提取详细信息对于精确仿真至关重要。</p>\n<p><strong>要提取的信息：</strong></p>\n<ul>\n<li><strong>设备ID (0xXXXX)：</strong>  唯一标识设备型号的16位标识符。</li>\n<li><strong>厂商ID (0xYYYY)：</strong>  分配给制造商的16位标识符。</li>\n<li><strong>子系统ID (0xZZZZ)：</strong>  标识特定子系统或变体（例如，产品线中的特定型号）。</li>\n<li><strong>子系统厂商ID (0xWWWW)：</strong>  标识子系统的厂商（通常与主厂商ID相同，但对于OEM版本可能会有所不同）。</li>\n<li><strong>修订ID (0xRR)：</strong>  指示设备的硬件修订级别。</li>\n<li><strong>类别代码 (0xCCCCCC)：</strong>  一个24位代码，定义设备的主要功能&#x2F;类型（例如，<code>0x020000</code>用于以太网控制器，<code>0x010802</code>用于NVMe控制器）。这有助于操作系统加载通用驱动程序。</li>\n<li><strong>基地址寄存器 (BARs)：</strong><ul>\n<li>定义设备使用的内存或I&#x2F;O地址区域的寄存器。</li>\n<li>包括BAR0到BAR5，每个都可能是32位或64位。对于每个BAR，请记录其 <strong>类型（内存或I&#x2F;O）</strong> 、<strong>位宽（32位或64位）</strong> 、<strong>大小（例如，256 MB，4KB）</strong>  和 <strong>可预取状态（是&#x2F;否）</strong> 。这对于内存映射至关重要。</li>\n</ul>\n</li>\n<li><strong>功能：</strong>  列出支持的功能及其配置，通常在配置空间中的链表结构中找到。示例包括：<ul>\n<li><strong>PCIe功能结构</strong>：PCIe链路速度（例如，Gen2，Gen3），链路宽度（例如，x1，x4），最大载荷大小，最大读取请求大小。</li>\n<li><strong>MSI&#x2F;MSI-X功能结构</strong>：消息信号中断信息，包括支持的向量数量。</li>\n<li><strong>电源管理功能结构</strong>：支持的电源状态（D0，D1，D2，D3hot，D3cold）。</li>\n</ul>\n</li>\n<li><strong>设备序列号 (DSN)：</strong>  一个64位唯一标识符，如果设备支持（在“设备序列号”扩展功能中找到）。并非所有设备都实现了此功能。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>导航到PCI配置选项卡：</strong><ul>\n<li>在设备详细视图中，找到并选择 <strong>PCI Config</strong> 或 <strong>Configuration Space</strong> 选项卡。这通常会以解码视图显示原始配置空间寄存器。</li>\n</ul>\n</li>\n<li><strong>记录相关详细信息：</strong><ul>\n<li>仔细记录上面列出的每个所需字段。</li>\n<li>使用截图或将值复制到文本文件、专用电子表格或结构化文档格式中以确保准确性。</li>\n<li>确保十六进制值正确记录，包括是否使用<code>0x</code>前缀。</li>\n</ul>\n</li>\n<li><strong>展开功能列表：</strong><ul>\n<li>查找标记为 <strong>Capabilities</strong> 或 <strong>Advanced Features</strong> 的部分。这些通常是可点击或可展开以显示子部分的。</li>\n<li>记录存在的每个功能及其相关参数（例如，MSI消息控制，电源状态标志，当前&#x2F;最大PCIe链路设置）。</li>\n</ul>\n</li>\n<li><strong>详细检查BAR：</strong><ul>\n<li>在配置空间中，找到BAR0到BAR5的条目。</li>\n<li>对于每个活动的BAR，记录其分配的大小、是内存映射还是I&#x2F;O、其位宽（32位或64位）以及是否可预取。这些信息通常在Arbor的GUI中清晰显示。</li>\n</ul>\n</li>\n<li><strong>保存数据以备参考：</strong><ul>\n<li>将所有提取的信息编译成一个组织良好的文档（例如，Markdown文件、<code>.txt</code>文件或Excel电子表格）。</li>\n<li>为每个部分清晰标记，以便在固件定制期间轻松参考。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-2-提取和记录设备属性\"><a href=\"#5-2-提取和记录设备属性\" class=\"headerlink\" title=\"5.2 提取和记录设备属性\"></a><strong>5.2 提取和记录设备属性</strong></h3><p>捕获数据后，理解每个属性的重要性并确保其准确记录对于成功仿真至关重要。</p>\n<p><strong>确保您已准确记录以下内容：</strong></p>\n<ol>\n<li><strong>设备ID：</strong><ul>\n<li><strong>目的：</strong>  唯一标识PCIe设备的特定型号。</li>\n<li><strong>仿真用法：</strong>  对于主机操作系统（OS）正确识别仿真设备至关重要，更重要的是，它能尝试加载适当的设备驱动程序。</li>\n</ul>\n</li>\n<li><strong>厂商ID：</strong><ul>\n<li><strong>目的：</strong>  标识PCIe设备的制造商。</li>\n<li><strong>仿真用法：</strong>  与设备ID结合使用，形成主机操作系统用于将设备与相应驱动程序匹配的唯一标识符（<code>VendorID:DeviceID</code>）。</li>\n</ul>\n</li>\n<li><strong>子系统ID和子系统厂商ID：</strong><ul>\n<li><strong>目的：</strong>  这些可选ID允许区分同一厂商设备的变体，或区分主厂商&#x2F;设备ID可能为通用的OEM特定版本。</li>\n<li><strong>仿真用法：</strong>  对于仿真具有多种配置的设备或OEM提供的设备很重要，因为驱动程序可能会专门查找这些值。</li>\n</ul>\n</li>\n<li><strong>修订ID：</strong><ul>\n<li><strong>目的：</strong>  指示设备的硬件修订级别。</li>\n<li><strong>仿真用法：</strong>  有助于识别可能需要不同驱动程序、固件或具有细微行为差异的特定硬件版本。</li>\n</ul>\n</li>\n<li><strong>类别代码：</strong><ul>\n<li><strong>目的：</strong>  一个24位代码，用于对设备的通用功能进行分类（例如，<code>0x020000</code>用于以太网控制器，<code>0x010802</code>用于NVMe控制器，<code>0x0C0300</code>用于USB主机控制器）。它由基本类别、子类别和编程接口组成。</li>\n<li><strong>仿真用法：</strong>  允许操作系统理解设备的通用功能，并在找不到特定厂商驱动程序时加载通用类别驱动程序。这对于初始设备识别至关重要。</li>\n</ul>\n</li>\n<li><strong>基地址寄存器（BARs）：</strong><ul>\n<li><strong>目的：</strong>  定义设备用于寄存器、内部缓冲区或配置空间扩展的内存映射或I&#x2F;O端口地址区域。主机操作系统在枚举期间将物理地址分配给这些BAR。</li>\n<li><strong>仿真用法：</strong>  对于将仿真设备的内部内存和寄存器映射到主机系统的地址空间至关重要。每个BAR的大小、类型（内存&#x2F;I&#x2F;O，32&#x2F;64位）和可预取状态必须与捐赠设备精确匹配。</li>\n</ul>\n</li>\n<li><strong>功能：</strong><ul>\n<li><strong>目的：</strong>  列出设备支持的高级功能，如高级错误报告、电源管理、MSI&#x2F;MSI-X、PCIe高级功能（如AER、VC&#x2F;PF）等。每个功能由一个具有其自身寄存器的结构定义。</li>\n<li><strong>仿真用法：</strong>  对于准确复制捐赠设备如何宣传其功能以及主机系统如何与这些功能交互（例如，中断传递机制、电源状态转换、错误报告）至关重要。</li>\n</ul>\n</li>\n<li><strong>设备序列号（DSN）：</strong><ul>\n<li><strong>目的：</strong>  设备的唯一64位标识符，通常是可选的扩展功能。</li>\n<li><strong>仿真用法：</strong>  虽然可选，但某些驱动程序或管理应用程序可能会专门查询并依赖DSN进行识别、许可或安全检查。准确仿真此功能可以防止您的设备被检测为通用或修改的外设。</li>\n</ul>\n</li>\n</ol>\n<p><strong>数据收集的最佳实践：</strong></p>\n<ul>\n<li><strong>组织数据：</strong>  创建一个结构化的文档或电子表格。为每个属性使用清晰的标题和子标题。模板会很有益。</li>\n<li><strong>包含单位和格式：</strong>  始终注明大小的单位（例如，MB、KB），并为十六进制值使用一致的格式（例如，<code>0x1234</code>、<code>16&#39;h1234</code>）。</li>\n<li><strong>与规范交叉引用（如果可能）：</strong>  如果可用，查阅捐赠设备的数据手册或公开可用的规范以验证值。这有助于识别原始扫描中不明显或不寻常的配置。</li>\n<li><strong>保护数据：</strong>  安全存储收集到的信息。请注意，这些数据可能包含专有或敏感信息。</li>\n<li><strong>理解“缺少什么”：</strong>  像Arbor这样的专业工具非常出色，但它们可能无法捕捉复杂、高度专有设备的每一个细微之处（例如，标准配置空间之外的特定厂商定义寄存器）。对于高级仿真，您可能需要将此信息与捐赠设备驱动程序的逆向工程结合起来。</li>\n</ul>\n<hr>\n<h2 id=\"6-初始固件定制\"><a href=\"#6-初始固件定制\" class=\"headerlink\" title=\"6. 初始固件定制\"></a><strong>6. 初始固件定制</strong></h2><p>在细致地记录了捐赠设备的信息之后，下一个关键阶段是定制您的FPGA固件，以准确仿真捐赠设备。这个过程首先要修改PCIe配置空间中的关键识别寄存器，并确保设备序列号等特定标识符被正确集成。</p>\n<h3 id=\"6-1-修改配置空间\"><a href=\"#6-1-修改配置空间\" class=\"headerlink\" title=\"6.1 修改配置空间\"></a><strong>6.1 修改配置空间</strong></h3><p>PCIe配置空间是定义设备如何被识别并与主机系统在枚举期间交互的基本组件。精确定制此空间以匹配捐赠设备的配置文件对于成功仿真绝对至关重要，它能让主机操作系统加载正确的驱动程序并按预期交互。</p>\n<h4 id=\"6-1-1-导航到配置文件\"><a href=\"#6-1-1-导航到配置文件\" class=\"headerlink\" title=\"6.1.1 导航到配置文件\"></a><strong>6.1.1 导航到配置文件</strong></h4><p>PCIe配置空间参数通常在PCILeech-FPGA项目中的特定SystemVerilog（<code>.sv</code>）文件中定义。此文件将综合成配置PCIe IP核并向主机公开设备身份的逻辑。</p>\n<p><strong>PCILeech-FPGA（基于Artix-7的板卡，如Squirrel）的常见路径：</strong><br>找到负责为您特定板卡配置PCIe参数的文件。对于许多Artix-7 PCILeech变体，这将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_pcie_cfg_a7.sv</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>示例（对于Squirrel 35T）</strong> ：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv</span><br></pre></td></tr></table></figure>\n\n<em>注意：实际的文件夹名称，如</em>​<em>​<code>pcileech-squirrel-35t</code>​</em>​ <em>，可能会根据您克隆的PCILeech-FPGA的具体版本或分支略有不同。克隆主仓库后，请始终导航到相关的板卡特定子目录。</em></li>\n</ul>\n<h4 id=\"6-1-2-在Visual-Studio-Code中打开文件\"><a href=\"#6-1-2-在Visual-Studio-Code中打开文件\" class=\"headerlink\" title=\"6.1.2 在Visual Studio Code中打开文件\"></a><strong>6.1.2 在Visual Studio Code中打开文件</strong></h4><p>编辑配置文件需要一个合适的代码编辑器，该编辑器支持SystemVerilog（或Verilog）的语法高亮，使代码更易于阅读和修改。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>启动Visual Studio Code：</strong><ul>\n<li>点击VS Code图标或通过“开始”菜单找到它。</li>\n</ul>\n</li>\n<li><strong>打开文件：</strong><ul>\n<li>使用 <strong>文件 &gt; 打开文件</strong> 或按下 <code>Ctrl + O</code>（macOS上为 <code>Cmd + O</code>）。</li>\n<li>导航到第6.1.1节中确定的配置文件路径（例如，<code>pcileech-fpga/pcileech-squirrel-35t/src/pcileech_pcie_cfg_a7.sv</code>）。</li>\n<li>选择文件并点击 <strong>打开</strong>。</li>\n</ul>\n</li>\n<li><strong>验证语法高亮：</strong><ul>\n<li>确保编辑器识别 <code>.sv</code> 文件扩展名并应用正确的SystemVerilog语法高亮。如果不行，请返回第4.3.2节，确保您已安装推荐的Verilog&#x2F;SystemVerilog扩展程序。</li>\n</ul>\n</li>\n<li><strong>熟悉文件结构：</strong><ul>\n<li>滚动浏览文件。您通常会发现使用<code>localparam</code>或<code>reg</code>赋值定义的参数，通常附有解释其目的的注释。查找定义和赋值标准PCIe配置寄存器（厂商ID、设备ID等）的部分。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-3-修改设备ID和厂商ID\"><a href=\"#6-1-3-修改设备ID和厂商ID\" class=\"headerlink\" title=\"6.1.3 修改设备ID和厂商ID\"></a><strong>6.1.3 修改设备ID和厂商ID</strong></h4><p>更新这些基本标识符是主机系统正确将仿真设备识别为您的捐赠设备的最关键步骤。操作系统严重依赖 <code>Vendor ID</code> 和 <code>Device ID</code> 对来识别连接的硬件并加载适当的设备驱动程序。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>搜索 <strong>​</strong>​<code>cfg_deviceid</code>​</strong>​ <strong>：</strong><ul>\n<li>在VS Code中使用搜索功能（<code>Ctrl + F</code>或<code>Cmd + F</code>）。</li>\n<li>找到定义<code>cfg_deviceid</code>的行。它通常看起来像这样：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_deviceid = <span class=\"number\">16&#x27;hAAAA</span>; <span class=\"comment\">// 默认或占位符设备ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>更新设备ID：</strong><ul>\n<li>将<code>AAAA</code>替换为您使用Arbor从捐赠设备中提取的16位十六进制设备ID（例如，<code>0x1234</code>）。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的设备ID是<code>0x1234</code>，则将该行更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_deviceid = <span class=\"number\">16&#x27;h1234</span>; <span class=\"comment\">// 更新为捐赠设备的设备ID（例如，来自网卡）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>搜索 <strong>​</strong>​<code>cfg_vendorid</code>​</strong>​ <strong>：</strong><ul>\n<li>找到定义<code>cfg_vendorid</code>的行。其格式将类似于<code>cfg_deviceid</code>：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_vendorid = <span class=\"number\">16&#x27;hBBBB</span>; <span class=\"comment\">// 默认或占位符厂商ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>更新厂商ID：</strong><ul>\n<li>将<code>BBBB</code>替换为您从捐赠设备中提取的16位十六进制厂商ID（例如，<code>0xABCD</code>）。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的厂商ID是<code>0xABCD</code>，则将该行更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_vendorid = <span class=\"number\">16&#x27;hABCD</span>; <span class=\"comment\">// 更新为捐赠设备的厂商ID（例如，Intel Corporation）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>确保格式正确：</strong><ul>\n<li>验证十六进制值是否正确以<code>16&#39;h</code>为前缀（表示一个16位十六进制数）。</li>\n<li>保持一致的缩进和注释风格以提高可读性。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-4-修改子系统ID和修订ID\"><a href=\"#6-1-4-修改子系统ID和修订ID\" class=\"headerlink\" title=\"6.1.4 修改子系统ID和修订ID\"></a><strong>6.1.4 修改子系统ID和修订ID</strong></h4><p>这些标识符提供了关于设备变体、特定产品型号或硬件修订的额外详细信息。虽然通常是可选的，但匹配它们能增强仿真的真实性，并且对于执行细粒度检查的驱动程序可能至关重要。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_subsysid</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_subsysid</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysid = <span class=\"number\">16&#x27;hCCCC</span>; <span class=\"comment\">// 占位符子系统ID</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新子系统ID：</strong></p>\n<ul>\n<li>将<code>CCCC</code>替换为您捐赠设备的16位十六进制子系统ID（例如，<code>0x5678</code>）。</li>\n<li><strong>示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysid = <span class=\"number\">16&#x27;h5678</span>; <span class=\"comment\">// 设置为捐赠设备的子系统ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_subsysvendorid</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_subsysvendorid</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysvendorid = <span class=\"number\">16&#x27;hDDDD</span>; <span class=\"comment\">// 占位符子系统厂商ID</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新子系统厂商ID（如果适用）：</strong></p>\n<ul>\n<li>将<code>DDDD</code>替换为您捐赠设备的16位十六进制子系统厂商ID（例如，<code>0x9ABC</code>）。如果您的捐赠设备没有唯一的子系统厂商ID（即与主厂商ID相同），您仍应将其设置为该值。</li>\n<li><strong>示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] cfg_subsysvendorid = <span class=\"number\">16&#x27;h9ABC</span>; <span class=\"comment\">// 设置为捐赠设备的子系统厂商ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_revisionid</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_revisionid</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_revisionid = <span class=\"number\">8&#x27;hEE</span>; <span class=\"comment\">// 占位符修订ID</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新修订ID：</strong></p>\n<ul>\n<li>将<code>EE</code>替换为您捐赠设备的8位十六进制修订ID（例如，<code>0x01</code>）。</li>\n<li><strong>示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_revisionid = <span class=\"number\">8&#x27;h01</span>; <span class=\"comment\">// 设置为捐赠设备的修订ID</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-5-更新类别代码\"><a href=\"#6-1-5-更新类别代码\" class=\"headerlink\" title=\"6.1.5 更新类别代码\"></a><strong>6.1.5 更新类别代码</strong></h4><p>类别代码通知主机操作系统设备的通用类型和功能（例如，网络控制器、存储设备）。这对于操作系统加载通用类别驱动程序至关重要，即使没有安装特定厂商驱动程序。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>搜索 <strong>​</strong>​<code>cfg_classcode</code>​</strong>​ <strong>：</strong></p>\n<ul>\n<li>找到定义<code>cfg_classcode</code>的行。</li>\n</ul>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">23</span>:<span class=\"number\">0</span>] cfg_classcode = <span class=\"number\">24&#x27;hFFFFFF</span>; <span class=\"comment\">// 默认或占位符类别代码</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>更新类别代码：</strong></p>\n<ul>\n<li>将<code>FFFFFF</code>替换为您从捐赠设备中提取的24位十六进制类别代码（例如，<code>0x020000</code>用于以太网控制器）。请记住格式：基本类别、子类别、编程接口。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的类别代码是<code>0x020000</code>（表示基本类别：0x02 - 网络控制器，子类别：0x00 - 以太网控制器，编程接口：0x00），则更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">23</span>:<span class=\"number\">0</span>] cfg_classcode = <span class=\"number\">24&#x27;h020000</span>; <span class=\"comment\">// 设置为捐赠设备的类别代码（例如，以太网控制器）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>验证正确的位宽：</strong></p>\n<ul>\n<li>确保类别代码使用<code>24&#39;h</code>前缀正确表示为24位十六进制值。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-6-保存更改\"><a href=\"#6-1-6-保存更改\" class=\"headerlink\" title=\"6.1.6 保存更改\"></a><strong>6.1.6 保存更改</strong></h4><p>在对配置参数进行所有修改后，保存和审查更改至关重要。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>保存文件：</strong><ul>\n<li>在VS Code中点击 <strong>文件 &gt; 保存</strong>，或按下 <code>Ctrl + S</code>（macOS上为 <code>Cmd + S</code>）。</li>\n</ul>\n</li>\n<li><strong>审查更改：</strong><ul>\n<li>在关闭之前，快速重新阅读修改过的行，以根据您的捐赠设备信息文档确认其准确性。</li>\n<li>检查是否有任何明显的语法错误或拼写错误（VS Code的扩展可能会高亮显示这些）。</li>\n</ul>\n</li>\n<li><strong>可选 - 使用版本控制：</strong><ul>\n<li>如果您正在使用Git（强烈推荐用于任何代码项目，尤其是固件），请以清晰且有意义的消息提交您的更改。这将创建您的修改历史记录。</li>\n<li><strong>示例Git命令：</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add pcileech_pcie_cfg_a7.sv</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;更新PCIe配置寄存器（VID, DID, SubIDs, Revision, Class Code）以匹配捐赠设备：[捐赠设备名称]&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-2-插入设备序列号（DSN）\"><a href=\"#6-2-插入设备序列号（DSN）\" class=\"headerlink\" title=\"6.2 插入设备序列号（DSN）\"></a><strong>6.2 插入设备序列号（DSN）</strong></h3><p>设备序列号（DSN）是一些PCIe设备（特别是那些具有高级功能或特定驱动程序的设备）可能使用的独特64位标识符。包含它能增强仿真的真实性，并有助于绕过明确查询此值的驱动程序中的检查。</p>\n<h4 id=\"6-2-1-定位DSN字段\"><a href=\"#6-2-1-定位DSN字段\" class=\"headerlink\" title=\"6.2.1 定位DSN字段\"></a><strong>6.2.1 定位DSN字段</strong></h4><p>DSN（如果由捐赠设备实现）是PCIe扩展能力的一部分。在PCILeech-FPGA框架中，DSN字段通常作为您一直在编辑的同一配置文件中的可配置参数公开。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>搜索 <strong>​</strong>​<code>cfg_dsn</code>​</strong>​ <strong>：</strong><ul>\n<li>在 <code>pcileech_pcie_cfg_a7.sv</code>（或您的板卡等效配置文件）中，使用搜索功能（<code>Ctrl + F</code> 或 <code>Cmd + F</code>）查找 <code>cfg_dsn</code>。</li>\n</ul>\n</li>\n<li><strong>理解现有赋值：</strong><ul>\n<li>DSN可能被设置为默认值（通常是全零）或被注释掉。它通常看起来像这样：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">63</span>:<span class=\"number\">0</span>] cfg_dsn = <span class=\"number\">64&#x27;h0000000000000000</span>; <span class=\"comment\">// 默认DSN（如果未使用，通常为0）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-2-插入DSN\"><a href=\"#6-2-2-插入DSN\" class=\"headerlink\" title=\"6.2.2 插入DSN\"></a><strong>6.2.2 插入DSN</strong></h4><p>更新DSN涉及将其设置为从捐赠设备捕获的精确64位十六进制值。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>更新 <strong>​</strong>​<code>cfg_dsn</code>​</strong>​ <strong>：</strong><ul>\n<li>将现有的十六进制值替换为您使用Arbor从捐赠设备中提取的64位DSN。</li>\n<li><strong>示例：</strong><br>如果捐赠设备的DSN是<code>0x0011223344556677</code>，则更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">63</span>:<span class=\"number\">0</span>] cfg_dsn = <span class=\"number\">64&#x27;h0011223344556677</span>; <span class=\"comment\">// 捐赠设备序列号</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>处理DSN不可用或不相关的情况：</strong><ul>\n<li>如果您的捐赠设备<em>没有</em>DSN，或者您已确定它不是您目标驱动程序所需的参数，您可以简单地将其保留为零：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">63</span>:<span class=\"number\">0</span>] cfg_dsn = <span class=\"number\">64&#x27;h0000000000000000</span>; <span class=\"comment\">// 捐赠设备没有特定DSN，保留为默认0</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>注意</strong>：对于关键仿真，如果捐赠设备有DSN，最好准确仿真它。</li>\n</ul>\n</li>\n<li><strong>确保格式正确：</strong><ul>\n<li>DSN是64位值；确保它以<code>64&#39;h</code>前缀正确格式化为十六进制值。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-3-保存更改\"><a href=\"#6-2-3-保存更改\" class=\"headerlink\" title=\"6.2.3 保存更改\"></a><strong>6.2.3 保存更改</strong></h4><p>通过保存和审查文件来完成DSN修改。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>保存文件：</strong><ul>\n<li>在VS Code中点击 <strong>文件 &gt; 保存</strong>，或按下 <code>Ctrl + S</code>。</li>\n</ul>\n</li>\n<li><strong>验证语法：</strong><ul>\n<li>检查VS Code的语法检查器是否有任何红色下划线或错误指示。立即纠正任何问题。</li>\n</ul>\n</li>\n<li><strong>记录更改：</strong><ul>\n<li>如果使用版本控制，请使用适当的消息提交更新。</li>\n<li><strong>示例Git命令：</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -am <span class=\"string\">&quot;在PCIe配置中插入捐赠设备序列号（DSN）&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"7-Vivado项目设置与定制\"><a href=\"#7-Vivado项目设置与定制\" class=\"headerlink\" title=\"7. Vivado项目设置与定制\"></a><strong>7. Vivado项目设置与定制</strong></h2><p>在固件文件更新以反映捐赠设备的关键识别和配置数据后，下一个关键步骤是将这些更改集成到Vivado项目中。这包括为您的特定FPGA板卡生成项目文件，定制嵌入式PCIe IP核，并准备整个设计以进行综合和实现阶段。</p>\n<h3 id=\"7-1-生成Vivado项目文件\"><a href=\"#7-1-生成Vivado项目文件\" class=\"headerlink\" title=\"7.1 生成Vivado项目文件\"></a><strong>7.1 生成Vivado项目文件</strong></h3><p>Vivado是Xilinx（AMD）开发套件，使用Tcl（工具命令语言）脚本来自动化项目创建、添加源文件和配置项目设置。通过运行PCILeech-FPGA框架提供的这些脚本，您可以确保您的Vivado项目已为目标FPGA板卡正确设置。</p>\n<h4 id=\"7-1-1-打开Vivado\"><a href=\"#7-1-1-打开Vivado\" class=\"headerlink\" title=\"7.1.1 打开Vivado\"></a><strong>7.1.1 打开Vivado</strong></h4><p>启动Vivado的新会话可确保之前会话中没有残留设置或打开项目干扰当前工作。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>启动Vivado：</strong><ul>\n<li>在“开始”菜单（Windows）或“应用程序”文件夹（Linux&#x2F;macOS）中找到Vivado应用程序图标。</li>\n<li>点击打开。</li>\n</ul>\n</li>\n<li><strong>选择正确的版本：</strong><ul>\n<li>如果您安装了多个Vivado版本，请确保您启动的是与您的FPGA板卡和PCILeech-FPGA项目兼容的版本（如第4.3.1节所述，建议使用Vivado 2023.x等最新稳定版本）。</li>\n</ul>\n</li>\n<li><strong>等待启动界面：</strong><ul>\n<li>让Vivado完全初始化并显示欢迎界面或项目仪表板，然后才能继续。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-2-访问Tcl控制台\"><a href=\"#7-1-2-访问Tcl控制台\" class=\"headerlink\" title=\"7.1.2 访问Tcl控制台\"></a><strong>7.1.2 访问Tcl控制台</strong></h4><p>Vivado内的Tcl控制台是您执行脚本和直接命令的主要界面。您将在此处运行项目生成脚本。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>打开Tcl控制台：</strong><ul>\n<li>在Vivado界面中，导航到菜单栏。</li>\n<li>单击 <strong>Window</strong> &gt; <strong>Tcl Console</strong>。</li>\n<li>Tcl控制台窗格通常会出现在Vivado窗口的底部。</li>\n</ul>\n</li>\n<li><strong>调整控制台大小（可选）：</strong><ul>\n<li>您可以拖动控制台的顶部边框来调整其大小，使其更高以便更好地查看命令和输出。</li>\n</ul>\n</li>\n<li><strong>清除先前命令（可选但推荐）：</strong><ul>\n<li>如果存在任何先前的命令或消息，您可以在控制台内右键单击并选择“Clear Console”以获得一个干净的开始。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-3-导航到项目目录\"><a href=\"#7-1-3-导航到项目目录\" class=\"headerlink\" title=\"7.1.3 导航到项目目录\"></a><strong>7.1.3 导航到项目目录</strong></h4><p>在运行Tcl脚本之前，您必须确保Tcl控制台的当前工作目录已设置为您的板卡特定PCILeech-FPGA项目脚本所在的正确位置。</p>\n<p><strong>对于Squirrel DMA (Artix-7 35T) 或类似板卡：</strong></p>\n<p><strong>典型路径（克隆</strong>​<strong>​<code>pcileech-fpga</code>​</strong>​<strong>并导航到您的板卡变体后）：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel-35t/  # 在Windows上</span><br><span class=\"line\">~/Projects/pcileech-fpga/pcileech-squirrel-35t/  # 在Linux/macOS上</span><br></pre></td></tr></table></figure>\n\n<p><em>注意：将</em>​ <em>​<code>&lt;your_board_variant&gt;</code>​</em>​<em>替换为您的板卡子目录的实际名称（例如，</em>​<em>​<code>pcileech-squirrel-35t</code>​</em>​ <em>，</em>​<em>​<code>pcileech-artix-7-50t</code>​</em>​ <em>）。</em></p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>在Tcl控制台中设置工作目录：</strong><ul>\n<li>在Vivado Tcl控制台中，输入<code>cd</code>命令，后跟您的板卡项目目录的完整路径。</li>\n<li><strong>示例（Windows）：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cd</span> C:/Users/YourUsername/Documents/pcileech-fpga/pcileech-squirrel<span class=\"number\">-35</span>t/</span><br></pre></td></tr></table></figure></li>\n<li><strong>示例（Linux&#x2F;macOS）：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cd</span> ~/Projects/pcileech-fpga/pcileech-squirrel<span class=\"number\">-35</span>t/</span><br></pre></td></tr></table></figure></li>\n<li><em>自我纠正提示：即使在Windows上，Tcl路径也使用正斜杠（</em>​ <em>​<code>/</code>​</em>​ <em>）。</em></li>\n</ul>\n</li>\n<li><strong>验证目录更改：</strong><ul>\n<li>要确认您处于正确的目录中，请在Tcl控制台中输入<code>pwd</code>（打印工作目录）。</li>\n<li>控制台应显示您刚刚设置的完整路径，确认更改。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-4-生成Vivado项目\"><a href=\"#7-1-4-生成Vivado项目\" class=\"headerlink\" title=\"7.1.4 生成Vivado项目\"></a><strong>7.1.4 生成Vivado项目</strong></h4><p>运行适用于您的FPGA板卡的相应Tcl脚本将自动化Vivado内部的整个项目设置过程。这包括创建项目、添加所有必要的源文件（HDL、约束）以及配置核心项目设置。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>运行Tcl脚本：</strong><ul>\n<li>输入<code>source</code>命令，后跟您的板卡的项​​目生成脚本的名称。PCILeech-FPGA项目通常在主板卡目录中提供这些脚本。</li>\n<li><strong>对于Squirrel (Artix-7 35T)（以及类似的Artix-7板卡）：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">source</span> vivado_generate_project_squirrel.tcl -notrace</span><br></pre></td></tr></table></figure></li>\n<li><strong>对于Enigma-X1 (Artix-7 75T)：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">source</span> vivado_generate_project_enigma_x1.tcl -notrace</span><br></pre></td></tr></table></figure></li>\n<li><strong>对于ZDMA (Artix-7 100T)：</strong><figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">source</span> vivado_generate_project_100t.tcl -notrace</span><br></pre></td></tr></table></figure></li>\n<li><code>-notrace</code>选项可防止每个Tcl命令的详细输出，使控制台更整洁。</li>\n</ul>\n</li>\n<li><strong>等待脚本完成：</strong><ul>\n<li>脚本将按顺序执行许多命令。此过程可能需要几分钟，具体取决于您的系统性能和项目的复杂性。</li>\n<li>监控Tcl控制台的进度消息。脚本将：<ul>\n<li>在当前目录中创建一个新的Vivado项目（<code>.xpr</code>文件）。</li>\n<li>添加所有SystemVerilog&#x2F;Verilog源文件（<code>.sv</code>，<code>.v</code>）。</li>\n<li>添加Xilinx IP核配置（<code>.xci</code>）。</li>\n<li>添加XDC（Xilinx设计约束）文件。</li>\n<li>可能配置各种项目设置。</li>\n</ul>\n</li>\n<li><strong>处理任何错误</strong>：如果发生任何错误（例如，“文件未找到”、“无效命令”），脚本通常会停止。检查错误消息，纠正底层问题（例如，路径不正确、文件丢失），然后重新运行脚本。</li>\n</ul>\n</li>\n<li><strong>确认项目生成：</strong><ul>\n<li>成功完成后，Tcl控制台通常会指示项目已创建，并且您应该在项目目录中看到新生成的项目文件（例如，<code>pcileech_squirrel_top.xpr</code>）和相关目录（例如，<code>pcileech_squirrel_top.runs</code>，<code>pcileech_squirrel_top.ip</code>）。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-1-5-打开生成的项目\"><a href=\"#7-1-5-打开生成的项目\" class=\"headerlink\" title=\"7.1.5 打开生成的项目\"></a><strong>7.1.5 打开生成的项目</strong></h4><p>现在Vivado项目文件已成功由Tcl脚本生成，您可以在Vivado GUI中打开该项目以进行进一步检查和定制。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>打开项目：</strong><ul>\n<li>在Vivado中，点击 <strong>文件</strong> &gt; <strong>打开项目</strong>。</li>\n<li>导航到您的项目目录（与您在第7.1.3节中在Tcl控制台中设置的目录相同）。</li>\n</ul>\n</li>\n<li><strong>选择项目文件：</strong><ul>\n<li>找到并选择与您的板卡对应的Vivado项目文件（<code>.xpr</code>扩展名）。</li>\n<li><strong>对于Squirrel：</strong>  文件名通常为 <code>pcileech_squirrel_top.xpr</code>。</li>\n<li>点击 <code>.xpr</code> 文件以选择它。</li>\n</ul>\n</li>\n<li><strong>点击打开：</strong><ul>\n<li>Vivado将加载项目，显示设计层次结构、源文件、IP集成器块设计（如果使用）和各种设计视图。这可能需要一些时间。</li>\n</ul>\n</li>\n<li><strong>验证项目内容：</strong><ul>\n<li>在 <strong>项目管理器</strong> 窗口（通常在左侧）中，展开 <strong>源文件</strong> 窗格。</li>\n<li>确保所有预期的源文件（Verilog&#x2F;SystemVerilog、XDC、IP核）都已列出，并且设计层次结构看起来正确。</li>\n<li>检查 <strong>消息</strong> 窗格（底部）中打开项目时出现的任何警告或严重警告，因为这些可能表明潜在问题。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"7-2-修改IP核\"><a href=\"#7-2-修改IP核\" class=\"headerlink\" title=\"7.2 修改IP核\"></a><strong>7.2 修改IP核</strong></h3><p>PCIe IP核是设备PCIe接口的核心。它是一个经过Xilinx（AMD）预验证、可配置的模块，用于处理复杂的PCIe协议层。尽管某些配置空间值在SystemVerilog文件中处理（第6.1节），但其他核心PCIe参数，特别是与链路能力和BAR结构相关的参数，是在Vivado中直接通过PCIe IP核的定制设置进行配置的。定制IP核可确保您的FPGA在PCIe协议级别上与捐赠硬件的行为完全一致。</p>\n<h4 id=\"7-2-1-访问PCIe-IP核\"><a href=\"#7-2-1-访问PCIe-IP核\" class=\"headerlink\" title=\"7.2.1 访问PCIe IP核\"></a><strong>7.2.1 访问PCIe IP核</strong></h4><p>PCIe IP核在您的Vivado项目中被实例化为一个IP块。您需要打开其定制GUI来修改其参数。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>定位PCIe IP核：</strong><ul>\n<li>在 <strong>Sources</strong>（源文件）窗格（位于 <strong>Project Manager</strong>（项目管理器）窗口内）中，确保已选择 <strong>Hierarchy</strong>（层次结构）选项卡。</li>\n<li>展开设计层次结构，直到找到PCIe IP核的实例。</li>\n<li>对于7系列FPGA（如Squirrel中使用的Artix-7），它通常被命名为 <code>pcie_7x_0.xci</code> 或类似名称，通常位于项目源文件的 <code>ip</code> 子目录中。</li>\n</ul>\n</li>\n<li><strong>打开IP定制窗口：</strong><ul>\n<li><strong>右键单击</strong> <code>pcie_7x_0.xci</code> 文件。</li>\n<li>从上下文菜单中选择 <strong>Customize IP</strong>（定制IP）。</li>\n<li>将打开 <strong>IP Configuration</strong>（IP配置）窗口（或类似名称，如“Customize IP”或“Re-customize IP”），显示带有各种选项卡和选项的图形界面，用于配置PCIe核。</li>\n</ul>\n</li>\n<li><strong>等待IP设置加载：</strong><ul>\n<li>IP定制界面可能需要几分钟才能初始化并填充所有设置。在您开始进行更改之前，请确保所有选项和选项卡都已完全加载并响应。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-2-在IP核内部定制设备ID和BAR\"><a href=\"#7-2-2-在IP核内部定制设备ID和BAR\" class=\"headerlink\" title=\"7.2.2 在IP核内部定制设备ID和BAR\"></a><strong>7.2.2 在IP核内部定制设备ID和BAR</strong></h4><p>尽管某些设备标识符在<code>pcileech_pcie_cfg_a7.sv</code>中设置，但PCIe IP核本身也包含设备ID、厂商ID以及至关重要的基地址寄存器（BARs）的定义参数。您必须确保这些参数保持一致。<code>.sv</code>文件中的某些值可能会覆盖或输入到IP核中，但在此处也确保一致性是一个好习惯。IP核中的BAR设置尤其重要，因为它们决定了内存映射的硬件实现。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>导航到基本&#x2F;识别参数：</strong><ul>\n<li>在IP定制窗口中，查找与 <strong>基本</strong>、<strong>设备和厂商标识符</strong>、<strong>通用</strong> 或 <strong>PCIe能力</strong> 相关的选项卡或部分。这是定义基本ID和初始链路设置的地方。</li>\n</ul>\n</li>\n<li><strong>验证&#x2F;输入设备ID、厂商ID、子系统ID、修订ID、类别代码：</strong><ul>\n<li><strong>至关重要：请确认这些值与您在</strong>​<strong>​<code>pcileech_pcie_cfg_a7.sv</code>​</strong>​<strong>中设置的以及从捐赠设备中获取的值相匹配。</strong></li>\n<li>查找以下字段：<ul>\n<li><strong>设备ID</strong>：输入<code>0xXXXX</code>（例如，<code>0x1234</code>）。</li>\n<li><strong>厂商ID</strong>：输入<code>0xYYYY</code>（例如，<code>0xABCD</code>）。</li>\n<li><strong>子系统ID</strong>：输入<code>0xZZZZ</code>（例如，<code>0x5678</code>）。</li>\n<li><strong>子系统厂商ID</strong>：输入<code>0xWWWW</code>（例如，<code>0x9ABC</code>）。</li>\n<li><strong>修订ID</strong>：输入<code>0xRR</code>（例如，<code>0x01</code>）。</li>\n<li><strong>类别代码</strong>：输入<code>0xCCCCCC</code>（例如，<code>0x020000</code>）。</li>\n</ul>\n</li>\n<li><strong>重要提示</strong>：某些IP核版本或特定配置可能会直接从用户逻辑（如<code>pcileech_pcie_cfg_a7.sv</code>）拉取这些值，或者可能允许直接在此处设置它们。最可靠的方法是，如果IP GUI中提供此选项，则在两个位置都保持一致设置。</li>\n</ul>\n</li>\n<li><strong>导航到基地址寄存器（BARs）选项卡：</strong><ul>\n<li>在IP定制窗口中，找到并选择 <strong>BARs</strong> 选项卡或部分。这是您定义PCIe设备暴露的内存区域的地方。</li>\n</ul>\n</li>\n<li><strong>配置每个BAR：</strong><ul>\n<li>对于您的捐赠设备使用的每个BAR（BAR0到BAR5），根据您使用Arbor提取的信息，仔细配置以下参数：<ul>\n<li><strong>启用BAR</strong>：仅当捐赠设备使用此特定BAR时才选中此框。禁用（取消选中）捐赠设备不使用的任何BAR。</li>\n<li><strong>BAR大小</strong>：从下拉列表中选择精确的大小（例如，<strong>256 MB</strong>，<strong>64 KB</strong>，<strong>4 KB</strong>）。这对于主机操作系统分配正确数量的内存至关重要。</li>\n<li><strong>BAR类型</strong>：选择适当的类型：<ul>\n<li><strong>Memory (32-bit Addressing)</strong> （内存（32位寻址））: 用于32位地址可访问的内存映射区域。</li>\n<li><strong>Memory (64-bit Addressing)</strong> （内存（64位寻址））: 用于可以驻留在64位地址空间中任何位置的内存映射区域（对于大内存区域或如果捐赠设备使用它，则需要）。</li>\n<li><strong>I&#x2F;O</strong>: 用于传统I&#x2F;O端口区域（在现代PCIe中较不常见，但仍然可能）。</li>\n</ul>\n</li>\n<li><strong>可预取</strong>：如果捐赠设备的BAR被标记为可预取，则选中此框。此属性允许主机系统从此区域缓存或预取数据以提高性能。</li>\n</ul>\n</li>\n<li><strong>示例配置（基于您的捐赠设备）：</strong><ul>\n<li><strong>BAR0</strong>：<ul>\n<li>启用：是</li>\n<li>大小：<strong>256 MB</strong></li>\n<li>类型：<strong>Memory (64-bit Addressing)</strong></li>\n<li>可预取：是</li>\n</ul>\n</li>\n<li><strong>BAR1</strong>：<ul>\n<li>启用：否（如果捐赠设备不使用BAR1）</li>\n</ul>\n</li>\n<li><em>继续配置BAR2-BAR5，镜像捐赠设备的配置。</em></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>确保对齐和非重叠空间</strong>：<ul>\n<li>Vivado IP核通常会根据您选择的大小自动处理对齐。但是，请注意PCIe规范要求BAR大小是2的幂，并且BAR必须对其大小进行对齐。</li>\n<li>确保所有活动BAR映射的总内存不超过FPGA可用的块RAM（BRAM）或外部内存容量。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-3-完成IP定制\"><a href=\"#7-2-3-完成IP定制\" class=\"headerlink\" title=\"7.2.3 完成IP定制\"></a><strong>7.2.3 完成IP定制</strong></h4><p>在IP核定制窗口中配置所有必要的设置后，您必须应用这些更改，使其在Vivado项目中生效。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><strong>审查所有设置：</strong><ul>\n<li>在应用之前，花点时间快速最后一次审查IP定制窗口中的每个选项卡。</li>\n<li>确认所有条目都与您捐赠设备的文档规范精确匹配。这里的一个小错误可能导致设备检测或功能问题。</li>\n</ul>\n</li>\n<li><strong>应用更改：</strong><ul>\n<li>点击IP定制窗口底部的 <strong>OK</strong> 或 <strong>Generate</strong> 按钮（标签可能不同）。</li>\n<li>如果Vivado提示您确认是否继续更改并重新生成IP输出产品，请点击 <strong>Yes</strong> 确认。</li>\n</ul>\n</li>\n<li><strong>重新生成IP核：</strong><ul>\n<li>Vivado现在将重新生成IP核的输出产品（例如，网表、仿真模型、新的<code>.xci</code>配置文件），以反映您的新配置。</li>\n<li>监控 <strong>消息</strong> 窗格（Vivado窗口底部），查看在此重新生成过程中可能出现的任何错误、警告或严重警告。立即解决任何严重警告。</li>\n</ul>\n</li>\n<li><strong>更新项目中的IP：</strong><ul>\n<li>在IP核重新生成后，Vivado可能会自动更新或提示您更新项目中的任何IP依赖项。允许它这样做，以确保在整个设计中使用最新的配置。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-4-锁定IP核\"><a href=\"#7-2-4-锁定IP核\" class=\"headerlink\" title=\"7.2.4 锁定IP核\"></a><strong>7.2.4 锁定IP核</strong></h4><p>锁定IP核是Vivado中推荐的最佳实践，可防止在后续综合和实现运行期间意外修改或重新定制，这可能会潜在地恢复您精心配置的设置。</p>\n<p><strong>锁定的目的：</strong></p>\n<ul>\n<li><strong>防止覆盖：</strong>  确保您在IP核GUI中进行的手动配置得以保留，不会因Vivado自动化或IP因细微项目更改而被检测为“过时”而意外覆盖。</li>\n<li><strong>保持一致性：</strong>  在整个构建过程中保持IP核处于已知、稳定的状态，这对于PCIe接口等关键组件尤其重要。</li>\n</ul>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>打开Tcl控制台：</strong></p>\n<ul>\n<li>在Vivado中，如果Tcl控制台尚未打开，请转到 <strong>Window</strong> &gt; <strong>Tcl Console</strong>。</li>\n</ul>\n</li>\n<li><p><strong>执行锁定命令：</strong></p>\n<ul>\n<li>在Tcl控制台中，精确输入以下命令。此命令将PCIe IP核实例（<code>pcie_7x_0</code>）的<code>IP_LOCKED</code>属性设置为<code>true</code>。</li>\n</ul>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set_property -name &#123;IP_LOCKED&#125; -value true -objects [get_ips pcie_7x_0]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>按 <strong>Enter</strong> 执行命令。</li>\n</ul>\n</li>\n<li><p><strong>验证锁定：</strong></p>\n<ul>\n<li>检查 <strong>消息</strong> 窗格。您应该会看到一条确认属性已设置的消息。</li>\n<li>您还可以右键单击源文件窗格中的 <code>pcie_7x_0.xci</code>，选择“IP Properties”（IP属性），并验证 <code>IP_LOCKED</code> 是否设置为 <code>true</code>。您可能还会注意到“Customize IP”（定制IP）选项现在已灰显，或者只允许“Re-customize IP”（重新定制IP），然后会警告您关于锁定。</li>\n</ul>\n</li>\n<li><p><strong>解锁（如果需要）：</strong></p>\n<ul>\n<li>如果您将来需要对PCIe IP核的设置进行进一步修改，则必须先将其解锁。使用以下Tcl命令：</li>\n</ul>\n<figure class=\"highlight tcl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set_property -name &#123;IP_LOCKED&#125; -value false -objects [get_ips pcie_7x_0]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>请记住在进行和应用更改后重新锁定它。</li>\n</ul>\n</li>\n<li><p><strong>记录操作：</strong></p>\n<ul>\n<li>在您的项目文档（例如，README文件、项目说明）中注明PCIe IP核已锁定是一个好习惯。这有助于项目中其他人理解其配置状态并避免混淆。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"第二部分：中级概念与实现-1\"><a href=\"#第二部分：中级概念与实现-1\" class=\"headerlink\" title=\"第二部分：中级概念与实现\"></a><strong>第二部分：中级概念与实现</strong></h2><hr>\n<h2 id=\"8-高级固件定制\"><a href=\"#8-高级固件定制\" class=\"headerlink\" title=\"8. 高级固件定制\"></a><strong>8. 高级固件定制</strong></h2><p>为了实现对捐赠设备精确且令人信服的仿真，除了基本识别之外，还需要对FPGA固件进行更深入的定制。这包括调整PCIe参数（例如链路速度和事务大小），细致地调整基地址寄存器（BARs）及其相关的内存映射，以及准确仿真电源管理和中断机制。这些步骤确保仿真设备不仅在主机系统看来与原始硬件相同，而且在协议和功能级别上行为也完全一致。</p>\n<h3 id=\"8-1-配置PCIe参数以进行仿真\"><a href=\"#8-1-配置PCIe参数以进行仿真\" class=\"headerlink\" title=\"8.1 配置PCIe参数以进行仿真\"></a><strong>8.1 配置PCIe参数以进行仿真</strong></h3><p>精确仿真要求您的FPGA设备的PCIe操作参数经过细致配置，以匹配捐赠设备的参数。这包括PCIe链路速度、链路宽度、能力指针和最大有效载荷大小等设置。正确的配置可确保与主机系统的兼容性、驱动程序和应用程序与设备交互的正确操作以及数据传输的最佳性能。</p>\n<h4 id=\"8-1-1-匹配PCIe链路速度和宽度\"><a href=\"#8-1-1-匹配PCIe链路速度和宽度\" class=\"headerlink\" title=\"8.1.1 匹配PCIe链路速度和宽度\"></a><strong>8.1.1 匹配PCIe链路速度和宽度</strong></h4><p>PCIe链路速度（例如，Gen1、Gen2、Gen3）和链路宽度（例如，x1、x4、x8）是决定设备最大理论数据吞吐量和性能的关键参数。将这些设置与捐赠设备匹配对于精确仿真至关重要，因为驱动程序或系统组件可能期望特定的链路能力。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>访问PCIe IP核设置：</strong></p>\n<ul>\n<li><strong>打开您的Vivado项目：</strong>  启动Vivado并打开您之前创建或修改的项目（例如，<code>pcileech_squirrel_top.xpr</code>）。确保所有源文件都已正确添加到项目中。</li>\n<li><strong>定位PCIe IP核：</strong>  在 <strong>Sources</strong>（源文件）窗格（通常在左侧）中，展开设计层次结构以找到PCIe IP核实例。对于Xilinx 7系列设计（如Squirrel中使用的Artix-7），这通常被命名为 <code>pcie_7x_0.xci</code>。</li>\n<li><strong>定制IP核：</strong>  右键单击 <code>pcie_7x_0.xci</code> 并选择 <strong>Customize IP</strong>（定制IP）。IP定制窗口将打开，显示多个选项卡中的各种配置选项。</li>\n</ul>\n</li>\n<li><p><strong>设置最大链路速度：</strong></p>\n<ul>\n<li><strong>导航到链路参数：</strong>  在IP定制窗口中，点击 <strong>PCIe Capabilities</strong>（PCIe功能）选项卡（有时是“PCIe Configuration”或“General”）。在此选项卡内，查找与 <strong>Link Parameters</strong>（链路参数）或 <strong>Link Capability Register</strong>（链路能力寄存器）相关的部分。</li>\n<li><strong>配置最大链路速度：</strong>  找到标有 <strong>Maximum Link Speed</strong>（最大链路速度）的选项（或“Target Link Speed”）。</li>\n<li>将其设置为与您的捐赠设备支持和广告的最大链路速度相匹配。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果捐赠设备在 <strong>PCIe Gen2 (5.0 GT&#x2F;s)</strong>  下运行，选择 <strong>5.0 GT&#x2F;s</strong>。</li>\n<li>如果它在 <strong>PCIe Gen1 (2.5 GT&#x2F;s)</strong>  或 <strong>PCIe Gen3 (8.0 GT&#x2F;s)</strong>  下运行，请选择相应的选项。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>注意</strong>：确保您的FPGA的收发器和物理硬件（主板PCIe插槽）支持所选的链路速度。FPGA只会协商到其配置的最大速度。</li>\n</ul>\n</li>\n<li><p><strong>设置链路宽度：</strong></p>\n<ul>\n<li><strong>配置链路宽度：</strong>  在相同的 <strong>Link Parameters</strong>（链路参数）部分中，找到 <strong>Link Width</strong>（链路宽度）设置（或“PCIe Link Width”、“Target Link Width”）。</li>\n<li>将其设置为与您的捐赠设备广告的最大链路宽度相匹配。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果捐赠设备使用 <strong>x4</strong> 链路，将 <strong>Link Width</strong> 设置为 <strong>4</strong>。</li>\n<li>选项通常包括 <strong>1</strong>、<strong>2</strong>、<strong>4</strong>、<strong>8</strong>、<strong>16</strong> 通道。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>注意</strong>：物理PCIe插槽和FPGA的封装必须支持所选的链路宽度。尝试配置大于物理连接的宽度将导致链路协商问题。</li>\n</ul>\n</li>\n<li><p><strong>保存并重新生成：</strong></p>\n<ul>\n<li><strong>应用更改：</strong>  配置链路速度和宽度后，点击 <strong>OK</strong> 以在IP定制窗口中应用更改。</li>\n<li><strong>重新生成IP输出产品：</strong>  Vivado很可能会提示您由于所做的更改而重新生成IP核的输出产品。确认并允许重新生成过程完成。这可能需要一些时间。</li>\n<li><strong>验证设置：</strong>  一旦重新生成完成，您可以选择性地重新访问IP核设置，以确保配置已正确应用。检查Vivado中 <strong>Messages</strong>（消息）窗口中是否有任何警告或错误。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-1-2-设置能力指针\"><a href=\"#8-1-2-设置能力指针\" class=\"headerlink\" title=\"8.1.2 设置能力指针\"></a><strong>8.1.2 设置能力指针</strong></h4><p>PCIe配置空间中的能力指针是8位寄存器，它们形成一个链表，指向各种能力结构（例如，电源管理、MSI&#x2F;MSI-X、PCIe Express能力）。正确设置这些指针可确保主机系统能够遍历能力列表并定位和利用设备广告的功能。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>在固件中定位能力指针：</strong></p>\n<ul>\n<li><strong>打开配置文件：</strong>  在Visual Studio Code中，打开您的板卡的主配置文件，通常是<code>pcileech_pcie_cfg_a7.sv</code>，位于<code>pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_pcie_cfg_a7.sv</code>。</li>\n<li><strong>理解能力指针：</strong>  此文件中的能力指针（<code>cfg_cap_pointer</code>）指向PCIe配置空间中的<em>第一个</em>能力结构，通常从标准64字节配置头之后开始。后续的能力通过其“下一个能力指针”字段链接起来。</li>\n</ul>\n</li>\n<li><p><strong>设置能力指针值：</strong></p>\n<ul>\n<li><strong>找到</strong>​<strong>​<code>cfg_cap_pointer</code>​</strong>​<strong>的赋值：</strong>  在代码中搜索定义<code>cfg_cap_pointer</code>的行。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_cap_pointer = <span class=\"number\">8&#x27;hXX</span>; <span class=\"comment\">// 当前值（例如，默认的8&#x27;h40）</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>更新能力指针：</strong>  将<code>XX</code>替换为您使用Arbor从捐赠设备观察到的8位十六进制能力指针值。此值通常指向设备特定配置空间（通常在偏移量<code>0x3F</code>结束）之后第一个能力结构的偏移量。能力常见的起始点是<code>0x40</code>或<code>0x60</code>。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果捐赠设备的第一个能力指针是<code>0x60</code>（表示其第一个能力结构在配置空间中从偏移量<code>0x60</code>开始），将该行更新为：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_cap_pointer = <span class=\"number\">8&#x27;h60</span>; <span class=\"comment\">// 更新以匹配捐赠设备的第一个能力偏移量</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>确保正确对齐：</strong>  能力结构必须对齐到4字节边界。能力指针应始终指向配置空间中有效的4字节对齐偏移量。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li><strong>保存配置文件：</strong>  进行更改后，点击 <strong>文件 &gt; 保存</strong> 或按下 <code>Ctrl + S</code> 保存文件。</li>\n<li><strong>验证语法：</strong>  确保更改未引入任何语法错误（VS Code通常会高亮显示这些错误）。</li>\n<li><strong>添加注释以清晰说明：</strong>  添加注释解释更改，以便将来参考和维护。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] cfg_cap_pointer = <span class=\"number\">8&#x27;h60</span>; <span class=\"comment\">// 设置为捐赠设备的能力指针（例如，PCIe能力位于0x60）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-1-3-调整最大载荷和读取请求大小\"><a href=\"#8-1-3-调整最大载荷和读取请求大小\" class=\"headerlink\" title=\"8.1.3 调整最大载荷和读取请求大小\"></a><strong>8.1.3 调整最大载荷和读取请求大小</strong></h4><p>这些参数定义了单个PCIe事务层数据包（TLP）中可以传输的最大数据量，以及非posted内存读取请求TLP的最大大小。将这些设置与捐赠设备匹配可确保兼容性并优化数据传输操作的性能。不匹配可能导致吞吐量降低或通信错误。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>设置支持的最大载荷大小（IP核）：</strong></p>\n<ul>\n<li><strong>访问设备功能：</strong>  在PCIe IP核定制窗口（Vivado中的<code>pcie_7x_0.xci</code>）中，导航到 <strong>PCIe Capabilities</strong>（PCIe功能）选项卡。</li>\n<li><strong>配置支持的最大载荷大小：</strong>  找到标有 <strong>Max Payload Size Supported</strong>（支持的最大载荷大小）的设置（或类似名称）。</li>\n<li>将其设置为与您的捐赠设备支持和广告的值相匹配（例如，128字节、256字节、512字节、1024字节、2048字节、4096字节）。<ul>\n<li><strong>示例：</strong>  如果捐赠设备支持的最大载荷大小为 <strong>256字节</strong>，请从下拉列表中选择 <strong>256字节</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>设置支持的最大读取请求大小（IP核）：</strong></p>\n<ul>\n<li><strong>配置支持的最大读取请求大小：</strong>  在同一选项卡中，找到 <strong>Max Read Request Size Supported</strong>（支持的最大读取请求大小）设置。</li>\n<li>将其设置为与捐赠设备的能力相匹配。这指定了设备在单个读取事务中可以请求的最大数据量。<ul>\n<li><strong>示例：</strong>  如果捐赠设备支持的最大读取请求大小为 <strong>512字节</strong>，请选择 <strong>512字节</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>调整固件参数（匹配IP核）：</strong></p>\n<ul>\n<li><strong>打开 <strong>​</strong>​<code>pcileech_pcie_cfg_a7.sv</code>​</strong>​ <strong>：</strong>  确保配置文件在Visual Studio Code中打开。</li>\n<li><strong>更新固件常量：</strong>  找到定义<code>max_payload_size_supported</code>和<code>max_read_request_size_supported</code>的行。这些通常是与您在IP核中选择的字节大小对应的位编码值。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_payload_size_supported = <span class=\"number\">3&#x27;bZZZ</span>;   <span class=\"comment\">// 当前值</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_read_request_size_supported = <span class=\"number\">3</span>&#x27;bWWW; <span class=\"comment\">// 当前值</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>设置适当的值：</strong>  将<code>ZZZ</code>和<code>WWW</code>替换为与所选大小对应的3位二进制表示。<ul>\n<li><strong>映射（根据PCIe规范）：</strong><ul>\n<li><strong>128字节</strong>：<code>3&#39;b000</code></li>\n<li><strong>256字节</strong>：<code>3&#39;b001</code></li>\n<li><strong>512字节</strong>：<code>3&#39;b010</code></li>\n<li><strong>1024字节</strong>：<code>3&#39;b011</code></li>\n<li><strong>2048字节</strong>：<code>3&#39;b100</code></li>\n<li><strong>4096字节</strong>：<code>3&#39;b101</code></li>\n</ul>\n</li>\n<li><strong>示例：</strong><ul>\n<li>对于 <strong>256字节</strong> 载荷大小：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_payload_size_supported = <span class=\"number\">3&#x27;b001</span>; <span class=\"comment\">// 支持最大256字节 (0x100)</span></span><br></pre></td></tr></table></figure></li>\n<li>对于 <strong>512字节</strong> 读取请求大小：<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] max_read_request_size_supported = <span class=\"number\">3&#x27;b010</span>; <span class=\"comment\">// 支持最大512字节 (0x200)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>原因</strong>：这些固件参数通常决定了与PCIe核接口的用户逻辑的行为，确保您的逻辑遵循配置的最大值。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li><strong>保存文件：</strong>  更新<code>pcileech_pcie_cfg_a7.sv</code>中的值后，保存文件。</li>\n<li><strong>验证一致性：</strong>  Vivado PCIe IP核GUI中配置的值<em>必须</em>与您的HDL配置文件中设置的值<em>匹配</em>。任何不匹配都可能导致意外行为或链路训练问题。</li>\n<li><strong>添加注释：</strong>  在您的代码中清晰地记录这些更改，以便将来参考。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"8-2-调整BARs和内存映射\"><a href=\"#8-2-调整BARs和内存映射\" class=\"headerlink\" title=\"8.2 调整BARs和内存映射\"></a><strong>8.2 调整BARs和内存映射</strong></h3><p>基地址寄存器（BARs）是PCIe设备向主机系统公开其内部内存和寄存器的基本方式。正确配置BARs并在FPGA的BRAMs（块RAMs）和逻辑中定义它们的内存映射对于精确仿真和主机端设备驱动程序的正常运行至关重要。</p>\n<h4 id=\"8-2-1-设置BAR大小和类型（IP核和BRAM）\"><a href=\"#8-2-1-设置BAR大小和类型（IP核和BRAM）\" class=\"headerlink\" title=\"8.2.1 设置BAR大小和类型（IP核和BRAM）\"></a><strong>8.2.1 设置BAR大小和类型（IP核和BRAM）</strong></h4><p>配置BAR大小和类型可确保您的仿真设备在枚举期间向主机请求正确的地址空间量，并且主机适当地分配和映射这些区域。这还涉及将这些地址区域与FPGA内的物理内存块关联起来。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>访问BAR配置（PCIe IP核）：</strong></p>\n<ul>\n<li><strong>定制PCIe IP核：</strong>  在Vivado中，右键单击 <code>pcie_7x_0.xci</code> 并选择 <strong>Customize IP</strong>（定制IP）以打开其配置GUI。</li>\n<li><strong>导航到BARs选项卡：</strong>  在IP定制窗口中，点击 <strong>Base Address Registers (BARs)</strong> （基地址寄存器（BARs））选项卡。</li>\n</ul>\n</li>\n<li><p><strong>配置每个BAR（IP核）：</strong></p>\n<ul>\n<li><strong>匹配捐赠设备的BARs：</strong>  对于每个BAR（BAR0到BAR5），根据您使用Arbor从捐赠设备中提取的信息，细致地设置大小、类型和可预取状态。</li>\n<li><strong>启用&#x2F;禁用BARs：</strong>  确保只启用捐赠设备实际使用的BARs。禁用（取消选中）任何未使用的BARs。</li>\n<li><strong>设置BAR大小：</strong>  为每个<em>已启用</em>的BAR从下拉列表中选择适当的大小。这将是2的幂次（例如，4KB、8KB、64KB、1MB、256MB、1GB）。<ul>\n<li><strong>示例：</strong><ul>\n<li>如果 <strong>BAR0</strong> 是 <strong>64 KB</strong>，将 <strong>BAR0 Size</strong> 设置为 <strong>64 KB</strong>。</li>\n<li>如果 <strong>BAR1</strong> 是 <strong>128 MB</strong>，将 <strong>BAR1 Size</strong> 设置为 <strong>128 MB</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>设置BAR类型：</strong><ul>\n<li>如果BAR是内存映射的，选择 <strong>Memory (32-bit Addressing)</strong> （内存（32位寻址））或 <strong>Memory (64-bit Addressing)</strong> （内存（64位寻址））。如果捐赠设备的BAR是64位或您需要访问4GB以上的地址，请选择 <strong>64-bit Addressing</strong>。</li>\n<li>如果BAR用于I&#x2F;O端口空间（现代PCIe设备较少见），选择 <strong>I&#x2F;O</strong>。</li>\n</ul>\n</li>\n<li><strong>设置可预取状态</strong>：如果捐赠设备的BAR被识别为可预取，请选中“Prefetchable”（可预取）框。此位允许主机预取该区域的数据，可能提高性能。</li>\n</ul>\n</li>\n<li><p><strong>更新BRAM配置（如果适用）：</strong></p>\n<ul>\n<li>许多PCILeech-FPGA项目使用Xilinx块RAM（BRAM）IP核来表示BARs暴露的内存区域。这些BRAM提供仿真设备内存的物理存储。</li>\n<li><strong>定位BRAM IP核：</strong>  在您的Vivado项目 <strong>Sources</strong>（源文件）窗格中，在<code>ip</code>子目录（或类似目录）中，您可能会找到BRAM的<code>.xci</code>文件，名称可能类似：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/ip/bram_bar_zero4k.xci</span><br><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/ip/bram_pcie_cfgspace.xci</span><br><span class=\"line\"># 可能还有BAR1、BAR2等的其他文件</span><br></pre></td></tr></table></figure></li>\n<li><strong>修改BRAM大小：</strong>  对于与<em>已启用</em>BAR关联的每个BRAM IP核，您可能需要 <strong>Customize IP</strong>（定制IP）（右键单击<code>.xci</code>文件）并调整其内存大小配置，以精确匹配相应的BAR大小。<ul>\n<li><strong>示例：</strong>  如果BAR0是256MB，请确保连接到BAR0的BRAM大小为256MB。</li>\n<li><strong>注意</strong>：确保所有活动BAR所需的总内存不超过您的FPGA设备的物理BRAM容量。超出容量将导致实现失败。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>保存并重新生成：</strong></p>\n<ul>\n<li><strong>应用更改（IP核）：</strong>  在PCIe IP核中配置BAR后，点击IP定制窗口中的 <strong>OK</strong>。</li>\n<li><strong>重新生成IP核：</strong>  Vivado将提示您由于所做的更改而重新生成PCIe IP核和任何相关的BRAM IP核。允许重新生成完成。这可确保硬件网表反映您的新BAR定义。</li>\n<li><strong>检查错误：</strong>  检查 <strong>Messages</strong>（消息）窗口中是否有与BAR配置或BRAM实例化相关的任何警告或错误。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-2-2-在固件中定义BAR地址空间\"><a href=\"#8-2-2-在固件中定义BAR地址空间\" class=\"headerlink\" title=\"8.2.2 在固件中定义BAR地址空间\"></a><strong>8.2.2 在固件中定义BAR地址空间</strong></h4><p>尽管PCIe IP核配置了BAR的<em>硬件</em>方面，但您的定制固件（SystemVerilog代码）需要定义当主机CPU对这些BAR区域内的地址执行读写操作时，仿真设备如何响应的<em>逻辑</em>。这涉及地址解码和实现寄存器&#x2F;内存访问逻辑。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>打开BAR控制器文件：</strong></p>\n<ul>\n<li>在Visual Studio Code中，打开负责处理BAR访问的SystemVerilog文件。对于PCILeech-FPGA，这通常是：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_tlps128_bar_controller.sv</span><br></pre></td></tr></table></figure>\n\n此模块通常接收PCIe内存读&#x2F;写TLP，并解码地址以确定正在访问哪个BAR（以及该BAR内的哪个偏移量）。</li>\n</ul>\n</li>\n<li><p><strong>实现地址解码逻辑：</strong></p>\n<ul>\n<li>在<code>pcileech_tlps128_bar_controller.sv</code>模块中，您会找到确定传入事务目标是哪个BAR的逻辑。这通常涉及根据配置的BAR大小检查地址位。</li>\n<li>您需要定义传入地址<code>req_addr</code>（来自TLP）如何映射到您的特定BAR内的偏移量。</li>\n<li><strong>概念示例：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：BAR0的逻辑（假设它是一个256MB的64位内存BAR，用于寄存器/数据）</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;bar_hit[0]&#x27;是一个指示命中BAR0的输入信号，通常来自PCIe核。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;req_addr&#x27;是传入的PCIe地址。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;req_be&#x27;是来自TLP的字节使能。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;req_data&#x27;是传入的写入数据。</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;rsp_data&#x27;是传出的读取数据。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设BAR0是256MB (2^28字节)，地址位 [27:0] 在BAR范围内。</span></span><br><span class=\"line\"><span class=\"keyword\">localparam</span> BAR0_SIZE_BITS = <span class=\"number\">28</span>; <span class=\"comment\">// 2^28 = 256MB</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] internal_register_0; <span class=\"comment\">// BAR0内的示例寄存器</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] internal_register_1; <span class=\"comment\">// 另一个示例寄存器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assign</span> bar0_offset = req_addr[BAR0_SIZE_BITS-<span class=\"number\">1</span>:<span class=\"number\">0</span>]; <span class=\"comment\">// 提取BAR0内的偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always_comb</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认响应</span></span><br><span class=\"line\">    rsp_data = <span class=\"number\">32&#x27;hFFFFFFFF</span>; <span class=\"comment\">// 默认值为全F或类似值，表示未映射区域</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>]) <span class=\"keyword\">begin</span> <span class=\"comment\">// 如果事务目标是BAR0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req_write) <span class=\"keyword\">begin</span> <span class=\"comment\">// 这是写入操作</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">                <span class=\"comment\">// 示例：将偏移量0x0映射到internal_register_0</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0000</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">3</span>]) internal_register_0[<span class=\"number\">31</span>:<span class=\"number\">24</span>] = req_data[<span class=\"number\">31</span>:<span class=\"number\">24</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">2</span>]) internal_register_0[<span class=\"number\">23</span>:<span class=\"number\">16</span>] = req_data[<span class=\"number\">23</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">1</span>]) internal_register_0[<span class=\"number\">15</span>:<span class=\"number\">8</span>]  = req_data[<span class=\"number\">15</span>:<span class=\"number\">8</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">0</span>]) internal_register_0[<span class=\"number\">7</span>:<span class=\"number\">0</span>]   = req_data[<span class=\"number\">7</span>:<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"comment\">// 示例：将偏移量0x4映射到internal_register_1</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0004</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">3</span>]) internal_register_1[<span class=\"number\">31</span>:<span class=\"number\">24</span>] = req_data[<span class=\"number\">31</span>:<span class=\"number\">24</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">2</span>]) internal_register_1[<span class=\"number\">23</span>:<span class=\"number\">16</span>] = req_data[<span class=\"number\">23</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">1</span>]) internal_register_1[<span class=\"number\">15</span>:<span class=\"number\">8</span>]  = req_data[<span class=\"number\">15</span>:<span class=\"number\">8</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (req_be[<span class=\"number\">0</span>]) internal_register_1[<span class=\"number\">7</span>:<span class=\"number\">0</span>]   = req_data[<span class=\"number\">7</span>:<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"comment\">// 添加更多寄存器映射或内存访问（例如，BRAM访问）</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"comment\">// 处理BAR0内未映射的写入，例如，忽略或记录</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req_read) <span class=\"keyword\">begin</span> <span class=\"comment\">// 这是读取操作</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">                <span class=\"comment\">// 示例：从internal_register_0读取</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0000</span>: rsp_data = internal_register_0;</span><br><span class=\"line\">                <span class=\"comment\">// 示例：从internal_register_1读取</span></span><br><span class=\"line\">                <span class=\"number\">32&#x27;h0000_0004</span>: rsp_data = internal_register_1;</span><br><span class=\"line\">                <span class=\"comment\">// 添加更多寄存器映射或内存访问（例如，BRAM访问）</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    rsp_data = <span class=\"number\">32&#x27;h0</span>; <span class=\"comment\">// 对于未映射的读取返回0或特定错误值</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>处理数据传输：</strong>  <code>always_comb</code>块（或<code>always_ff</code>用于时序逻辑）应定义如何为读取生成<code>rsp_data</code>，以及如何根据<code>bar0_offset</code>和字节使能（<code>req_be</code>）更新内部寄存器&#x2F;内存。</li>\n</ul>\n</li>\n<li><p><strong>实现BRAM访问（如果BAR映射到BRAM）：</strong></p>\n<ul>\n<li>如果BAR映射到大块内存（例如，256MB），您通常会实例化一个BRAM IP核（如8.2.1所述）并将其<code>bar_controller</code>逻辑与它连接。<code>bar_controller</code>将向BRAM提供地址和控制信号。</li>\n<li><strong>概念性BRAM集成（简化）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在pcileech_tlps128_bar_controller.sv或子模块中</span></span><br><span class=\"line\"><span class=\"comment\">// BRAM接口</span></span><br><span class=\"line\"><span class=\"keyword\">wire</span> [BAR0_SIZE_BITS-<span class=\"number\">1</span>:<span class=\"number\">0</span>] bram_addr;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] bram_wr_data;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] bram_wr_en; <span class=\"comment\">// BRAM的字节使能</span></span><br><span class=\"line\"><span class=\"keyword\">wire</span> bram_wr_ce;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> bram_rd_ce;</span><br><span class=\"line\"><span class=\"keyword\">wire</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] bram_rd_data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将TLP信号映射到BRAM接口</span></span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_addr = bar0_offset;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_wr_data = req_data;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_wr_en = req_be;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_wr_ce = bar_hit[<span class=\"number\">0</span>] &amp;&amp; req_write;</span><br><span class=\"line\"><span class=\"keyword\">assign</span> bram_rd_ce = bar_hit[<span class=\"number\">0</span>] &amp;&amp; req_read;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例化BRAM IP核</span></span><br><span class=\"line\">bram_bar_zero bram_inst ( <span class=\"comment\">// 假设&#x27;bram_bar_zero&#x27;是您的BRAM IP模块</span></span><br><span class=\"line\">    <span class=\"variable\">.clka</span>(clk),</span><br><span class=\"line\">    <span class=\"variable\">.ena</span>(<span class=\"number\">1&#x27;b1</span>),</span><br><span class=\"line\">    <span class=\"variable\">.wea</span>(bram_wr_en),</span><br><span class=\"line\">    <span class=\"variable\">.addra</span>(bram_addr),</span><br><span class=\"line\">    <span class=\"variable\">.dina</span>(bram_wr_data),</span><br><span class=\"line\">    <span class=\"variable\">.douta</span>(bram_rd_data)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于从BAR0的读取，输出BRAM的数据</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>] &amp;&amp; req_read) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    rsp_data = bram_rd_data;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>实现每个BAR的逻辑后，保存<code>pcileech_tlps128_bar_controller.sv</code>文件。</li>\n<li><strong>验证功能：</strong>  此逻辑很复杂。彻底的仿真（使用测试平台）和后续的硬件测试对于确保正确行为至关重要。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-2-3-处理多个BAR\"><a href=\"#8-2-3-处理多个BAR\" class=\"headerlink\" title=\"8.2.3 处理多个BAR\"></a><strong>8.2.3 处理多个BAR</strong></h4><p>正确管理多个BAR对于暴露多个独立内存或I&#x2F;O区域的设备至关重要。<code>bar_controller</code>模块通常处理所有BAR。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>实现每个BAR的逻辑：</strong></p>\n<ul>\n<li>在<code>pcileech_tlps128_bar_controller.sv</code>内部，扩展逻辑以处理您的捐赠设备使用的所有已启用BAR（BAR0、BAR1、BAR2等）。</li>\n<li><strong>独立逻辑块：</strong>  为清晰和可维护性，创建独立的<code>if/else if</code>块或<code>case</code>语句，根据哪个<code>bar_hit</code>信号被断言而激活。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BAR0处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// BAR0特定读/写逻辑，用于其寄存器/内存</span></span><br><span class=\"line\"><span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">1</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// BAR1特定读/写逻辑，用于其寄存器/内存</span></span><br><span class=\"line\"><span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">2</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// BAR2特定逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">// ... 继续其他BAR</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>定义寄存器和内存：</strong>  根据需要为每个BAR分配独立的寄存器集或连接不同的BRAM实例。</li>\n</ul>\n</li>\n<li><p><strong>确保非重叠地址空间：</strong></p>\n<ul>\n<li>虽然PCIe IP核处理与主机操作系统的每个BAR的不同地址空间的协商，但您的内部固件逻辑<em>必须</em>假定这些空间是独立的且不重叠的。</li>\n<li><strong>验证地址范围</strong>：仔细检查PCIe IP核中的BAR大小配置，以确保它们是独立的，并且根据PCIe规范正确地对齐到2的幂次方边界。</li>\n<li><strong>更新地址解码</strong>：您的<code>bar_controller</code>逻辑依赖于PCIe IP核生成的<code>bar_hit</code>信号。确保这些信号被正确解释并导致每个BAR的独特处理逻辑。</li>\n</ul>\n</li>\n<li><p><strong>测试BAR访问：</strong></p>\n<ul>\n<li><strong>仿真测试：</strong>  在硬件部署之前，使用仿真工具（例如Vivado仿真器）和全面的测试平台来验证对每个BAR的所有读写操作。<ul>\n<li>向每个BAR内的特定偏移量发送内存写入TLP。</li>\n<li>向每个BAR内的特定偏移量发送内存读取TLP并验证返回的数据。</li>\n</ul>\n</li>\n<li><strong>硬件测试：</strong>  编程FPGA后，使用主机端软件工具（如PCILeech客户端软件或定制C&#x2F;Python脚本）访问和验证每个BAR。<ul>\n<li><strong>Linux</strong>：使用<code>lspci -vvv</code>检查BAR映射（<code>Memory at XXXX (64-bit, prefetchable) [size=YYYY]</code>）。然后可以使用<code>devmem2</code>或自定义内核模块来读&#x2F;写这些映射地址。</li>\n<li><strong>Windows</strong>：使用“RW-Everything”等工具或自定义用户模式应用程序来检查和与映射的内存区域交互。</li>\n<li>执行各种读&#x2F;写模式以确保所有BAR之间的数据完整性和正确寻址。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"8-3-仿真设备电源管理和中断\"><a href=\"#8-3-仿真设备电源管理和中断\" class=\"headerlink\" title=\"8.3 仿真设备电源管理和中断\"></a><strong>8.3 仿真设备电源管理和中断</strong></h3><p>实现电源管理功能和中断对于需要与主机操作系统的电源管理和中断处理机制密切高效交互的设备至关重要。没有这些，仿真设备可能无法完全正常工作，或者性能可能不理想。</p>\n<h4 id=\"8-3-1-电源管理配置\"><a href=\"#8-3-1-电源管理配置\" class=\"headerlink\" title=\"8.3.1 电源管理配置\"></a><strong>8.3.1 电源管理配置</strong></h4><p>实现电源管理允许仿真设备支持各种电源状态（例如D0、D3hot），有助于系统范围的电源效率并符合操作系统的预期。主机操作系统将查询设备的功能并发送命令以在这些状态之间转换。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>在PCIe IP核中启用电源管理：</strong></p>\n<ul>\n<li><strong>访问功能：</strong>  在PCIe IP核定制窗口（<code>pcie_7x_0.xci</code>）中，导航到 <strong>PCIe Capabilities</strong>（PCIe功能）选项卡。</li>\n<li><strong>启用电源管理：</strong>  查找与 <strong>Power Management Capability</strong>（电源管理功能）相关的部分或选项。确保已选中或启用此选项，以便在设备的配置空间中包含电源管理（PM）功能结构。</li>\n</ul>\n</li>\n<li><p><strong>设置支持的电源状态：</strong></p>\n<ul>\n<li><strong>配置支持的状态：</strong>  在IP核的电源管理功能部分，指定设备支持的电源状态。这些通常是复选框或下拉菜单。将这些设置与您通过Arbor观察到的捐赠设备的能力相匹配。<ul>\n<li><strong>D0（完全开启&#x2F;运行）</strong> ：始终支持。</li>\n<li><strong>D1、D2（中间状态）</strong> ：可选，用于低功耗空闲状态。</li>\n<li><strong>D3hot（断电，辅助电源存在）</strong> ：设备逻辑关闭，但可以响应PM事件。</li>\n<li><strong>D3cold（完全断电）</strong> ：设备没有电源。</li>\n</ul>\n</li>\n<li><strong>示例</strong>：如果捐赠设备仅支持D0和D3hot，则只启用它们。</li>\n</ul>\n</li>\n<li><p><strong>在固件中实现电源状态逻辑：</strong></p>\n<ul>\n<li><strong>打开 <strong>​</strong>​<code>pcileech_pcie_cfg_a7.sv</code>​</strong>​ <strong>（或相关控制模块）：</strong>  您通常需要修改固件以反映并可能响应主机命令的电源状态转换。PCIe核本身处理大部分协议，但您的用户逻辑需要知道当前状态。</li>\n<li><strong>处理电源管理控制和状态寄存器（PMCSR）写入：</strong>  主机操作系统通过写入PMCSR中的特定位来改变设备的电源状态，PMCSR是PM能力结构的一部分。您的固件理想情况下应有逻辑来读取这些位并调整设备行为（例如，暂停&#x2F;恢复操作，启用&#x2F;禁用时钟）。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：pcileech_pcie_cfg_a7.sv或专用PM模块的一部分</span></span><br><span class=\"line\"><span class=\"comment\">// 假设&#x27;cfg_write&#x27;在配置写入时被断言，&#x27;cfg_address&#x27;是偏移量，&#x27;cfg_writedata&#x27;是数据。</span></span><br><span class=\"line\"><span class=\"comment\">// D状态位位于PM能力结构中偏移量0x04处，位[1:0]。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PMCSR寄存器（内部表示）</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] pmcsr_reg = <span class=\"number\">16&#x27;h0000</span>; <span class=\"comment\">// 初始化为D0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户逻辑信号，指示当前电源状态</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">1</span>:<span class=\"number\">0</span>] current_d_state = <span class=\"number\">2&#x27;b00</span>; <span class=\"comment\">// 00 = D0, 01 = D1, 10 = D2, 11 = D3hot</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        pmcsr_reg &lt;= <span class=\"number\">16&#x27;h0000</span>;</span><br><span class=\"line\">        current_d_state &lt;= <span class=\"number\">2&#x27;b00</span>; <span class=\"comment\">// 重置为D0</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"comment\">// 示例：捕获对PMCSR的写入（如果直接在用户逻辑中处理）</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意：PCIe IP核管理大部分内容，但您的用户逻辑可能需要从中读取值。</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设PCIe核提供一个反映当前D状态的输出：</span></span><br><span class=\"line\">        <span class=\"comment\">// assign current_d_state = pcie_core_d_state_output;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果用户逻辑*需要*写入PMCSR（较少见，通常是只读状态）</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者它需要处理命令</span></span><br><span class=\"line\">        <span class=\"comment\">// if (cfg_write &amp;&amp; (cfg_address == PM_CAP_OFFSET + 2&#x27;h04)) begin // PMCSR在PM Cap基础地址+0x04</span></span><br><span class=\"line\">        <span class=\"comment\">//     pmcsr_reg[1:0] &lt;= cfg_writedata[1:0]; // 捕获新D状态</span></span><br><span class=\"line\">        <span class=\"comment\">//     // current_d_state &lt;= cfg_writedata[1:0]; // 更新内部状态</span></span><br><span class=\"line\">        <span class=\"comment\">// end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在PCILeech中，PCIe核管理PMCSR。您可能会从核读取信号。</span></span><br><span class=\"line\">        <span class=\"comment\">// 为了演示，假设&#x27;pcie_d_state&#x27;是来自IP核的输入。</span></span><br><span class=\"line\">        current_d_state &lt;= pcie_d_state; <span class=\"comment\">// 根据PCIe核的状态更新</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：响应D状态变化的逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current_d_state == <span class=\"number\">2&#x27;b11</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// D3hot状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 禁用非必要模块的电源，暂停操作，</span></span><br><span class=\"line\">        <span class=\"comment\">// 断言信号给主DMA逻辑以停止活动。</span></span><br><span class=\"line\">        <span class=\"comment\">// 例如：dma_engine_enable = 1&#x27;b0;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current_d_state == <span class=\"number\">2&#x27;b00</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// D0状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 启用全部功能</span></span><br><span class=\"line\">        <span class=\"comment\">// 例如：dma_engine_enable = 1&#x27;b1;</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>管理电源状态效果：</strong>  实现逻辑以根据<code>current_d_state</code>更改设备的内部行为（例如，启用&#x2F;禁用时钟，将子模块置于低功耗模式）。这对于精确的功耗仿真以及确保设备正确响应操作系统命令至关重要。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>保存任何修改过的固件文件。</li>\n<li>通过仿真或硬件测试（例如，Windows“睡眠”或“休眠”功能，或Linux <code>poweroff</code>命令）彻底测试电源管理功能，以查看设备是否正确转换。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-3-2-MSI-MSI-X配置\"><a href=\"#8-3-2-MSI-MSI-X配置\" class=\"headerlink\" title=\"8.3.2 MSI&#x2F;MSI-X配置\"></a><strong>8.3.2 MSI&#x2F;MSI-X配置</strong></h4><p>实现消息信号中断（MSI）或其扩展版本（MSI-X）允许仿真设备使用基于消息的中断。这些中断比传统的引脚中断（INTx）效率更高、可扩展性更强，是现代PCIe设备的优选方法。MSI&#x2F;MSI-X允许设备通过向特定内存地址写入特殊TLP来通知CPU。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>在PCIe IP核中启用MSI&#x2F;MSI-X：</strong></p>\n<ul>\n<li><strong>访问中断配置：</strong>  在PCIe IP核定制窗口（<code>pcie_7x_0.xci</code>）中，导航到 <strong>Interrupts</strong>（中断）选项卡或专门标记为 <strong>MSI&#x2F;MSI-X Capabilities</strong>（MSI&#x2F;MSI-X功能）的部分。</li>\n<li><strong>选择中断类型：</strong>  根据捐赠设备的功能，选择 <strong>MSI</strong> 或 <strong>MSI-X</strong>。MSI-X通常因其灵活性（更多向量，每个向量可屏蔽）而受到青睐。</li>\n<li><strong>配置支持的向量数量：</strong>  设置设备将支持的中断向量（消息）数量。这应与捐赠设备匹配。<ul>\n<li><strong>MSI</strong> 支持最多32个向量（通常是1、2、4、8、16或32）。</li>\n<li><strong>MSI-X</strong> 支持最多2048个向量，允许更细粒度的中断源。</li>\n</ul>\n</li>\n<li><strong>启用功能：</strong>  确保MSI或MSI-X功能结构已明确启用，以便包含在设备的配置空间中。这是主机操作系统发现设备中断能力的方式。</li>\n</ul>\n</li>\n<li><p><strong>在固件中实现中断逻辑：</strong></p>\n<ul>\n<li><strong>打开 <strong>​</strong>​<code>pcileech_pcie_tlp_a7.sv</code>​</strong>​ <strong>（或用户逻辑模块）：</strong>  此文件通常负责用户定义的TLP生成，并且可能是启动MSI&#x2F;MSI-X消息的合适位置。但是，中断的<em>触发</em>将来自您的自定义逻辑。</li>\n<li><strong>定义中断信号：</strong>  声明内部信号，指示何时需要生成中断。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在自定义模块中（例如，&#x27;my_device_logic.sv&#x27;），该模块与TLP生成逻辑接口</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> msi_trigger_signal; <span class=\"comment\">// 当发生中断条件时断言此信号</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>实现中断生成逻辑：</strong>  定义应该触发中断的条件。这通常涉及在仿真设备的逻辑中检测事件。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在&#x27;my_device_logic.sv&#x27;内部</span></span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> clk;</span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> reset;</span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> event_data_ready; <span class=\"comment\">// 示例：当数据就绪时来自您的逻辑的输入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        msi_trigger_signal &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event_data_ready) <span class=\"keyword\">begin</span> <span class=\"comment\">// 当特定事件发生时</span></span><br><span class=\"line\">        msi_trigger_signal &lt;= <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 触发MSI</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        msi_trigger_signal &lt;= <span class=\"number\">1&#x27;b0</span>; <span class=\"comment\">// 一个周期后或被确认后清除</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>连接到PCIe核的MSI接口：</strong>  <code>msi_trigger_signal</code>（或您的自定义逻辑的类似输出）需要连接到PCIe IP核的适当输入（例如，如果使用AXI-Stream接口进行MSI TLP，则连接到<code>s_axis_tdata_tready</code>、<code>s_axis_tdata_tvalid</code>、<code>s_axis_tdata_tlast</code>；或者连接到IP核提供的专用MSI请求端口）。然后PCIe核会形成并发送实际的MSI&#x2F;MSI-X TLP。有关精确的接口详细信息，请查阅Xilinx PCIe IP核文档。</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>实现中断逻辑后，保存所有修改过的固件文件。</li>\n<li><strong>检查时序约束：</strong>  新逻辑，特别是中断路径，可能对时序很敏感。确保综合和实现工具不会报告与您的中断生成逻辑相关的任何时序违规。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-3-3-实现中断处理逻辑（设备端）\"><a href=\"#8-3-3-实现中断处理逻辑（设备端）\" class=\"headerlink\" title=\"8.3.3 实现中断处理逻辑（设备端）\"></a><strong>8.3.3 实现中断处理逻辑（设备端）</strong></h4><p>除了启用功能之外，定义仿真设备何时以及如何生成中断对于其与主机中断处理机制和驱动程序行为的正确交互至关重要。这涉及创建断言中断请求的内部逻辑。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>定义中断条件：</strong></p>\n<ul>\n<li><strong>识别触发事件：</strong>  根据您的捐赠设备的行为，确定哪些特定的内部事件应导致您的仿真设备生成中断。<ul>\n<li><strong>示例</strong>：数据传输完成、接收缓冲区中有新数据、内部错误条件、特定命令完成、链路状态更改。</li>\n</ul>\n</li>\n<li><strong>实现条件逻辑：</strong>  在您的自定义SystemVerilog模块中使用组合逻辑或时序逻辑，精确检测这些事件并生成一个短脉冲或电平信号，指示中断请求。</li>\n</ul>\n</li>\n<li><p><strong>创建中断生成模块（模块化设计）：</strong></p>\n<ul>\n<li>将中断生成逻辑封装到一个单独的专用模块中是一个好习惯，这样可以提高清晰度、可重用性并方便调试。此模块将内部事件作为输入，并产生一个连接到PCIe核的<code>msi_req</code>（或类似）输出。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件：interrupt_generator.sv</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> interrupt_generator (</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> clk,</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> reset,</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> event_trigger,        <span class=\"comment\">// 来自您的自定义逻辑的输入信号（例如，data_ready, error_flag）</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> msi_req_o            <span class=\"comment\">// 输出：断言此信号以请求MSI/MSI-X</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MSI的简单脉冲发生器（一次性中断）</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> event_trigger_d1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        msi_req_o &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">        event_trigger_d1 &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        event_trigger_d1 &lt;= event_trigger;</span><br><span class=\"line\">        <span class=\"comment\">// 当event_trigger从低到高跳变时，生成一个单周期脉冲</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event_trigger &amp;&amp; !event_trigger_d1) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            msi_req_o &lt;= <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 断言MSI请求</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            msi_req_o &lt;= <span class=\"number\">1&#x27;b0</span>; <span class=\"comment\">// 一个周期后取消断言</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span> <span class=\"comment\">// interrupt_generator</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>与主固件集成：</strong>  在您的顶层用户逻辑中（例如，在<code>pcileech_squirrel_top.sv</code>或其实例化的模块中）实例化此<code>interrupt_generator</code>模块，并将其<code>msi_req_o</code>输出连接到PCIe IP核的MSI输入。</li>\n</ul>\n</li>\n<li><p><strong>确保正确的时序和序列：</strong></p>\n<ul>\n<li><strong>遵守PCIe规范：</strong>  MSI&#x2F;MSI-X消息是TLP。确保这些消息的生成符合PCIe TLP格式、流控制和时序要求。PCIe IP核处理大部分内容，但您提供给它的输入信号必须稳定且时序正确。</li>\n<li><strong>管理中断延迟：</strong>  优化您的逻辑，以最大限度地减少内部事件发生与<code>msi_req_o</code>信号断言之间的任何不必要延迟。</li>\n</ul>\n</li>\n<li><p><strong>测试中断传递：</strong></p>\n<ul>\n<li><strong>仿真：</strong>  使用全面的测试平台模拟应生成中断的场景。验证您的<code>msi_req_o</code>信号是否按预期工作，以及PCIe核是否生成正确的MSI&#x2F;MSI-X TLP。</li>\n<li><strong>硬件测试：</strong><ul>\n<li>用更新的固件编程FPGA。</li>\n<li>使用主机端软件触发应引起中断的事件（例如，启动完成的DMA传输）。</li>\n<li>确认主机操作系统接收到中断。在Linux上，<code>dmesg</code>可以显示中断消息。在Windows上，您可以使用特定的驱动程序调试工具或事件查看器。</li>\n<li><strong>调试工具：</strong>  利用Vivado的集成逻辑分析仪（ILA）核（如第12节所述）实时监控<code>event_trigger</code>、<code>msi_req_o</code>和PCIe核的TLP输出信号，以验证正确的中断生成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>保存更改：</strong></p>\n<ul>\n<li>完成所有代码修改并保存相关固件文件。</li>\n<li>根据测试结果审查并改进您的中断逻辑，以确保可靠性。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"9-仿真设备特定功能\"><a href=\"#9-仿真设备特定功能\" class=\"headerlink\" title=\"9. 仿真设备特定功能\"></a><strong>9. 仿真设备特定功能</strong></h2><p>除了标准的PCIe配置空间和通用DMA功能之外，许多捐赠设备还具有独特的功能、自定义寄存器或厂商特定功能，这些对于其完整功能或与其专有驱动程序交互至关重要。精确的仿真需要理解和复制这些细微之处。本节将深入探讨如何实现这些高级功能，从而实现更忠实和功能更全面的仿真。</p>\n<h3 id=\"9-1-实现高级PCIe功能\"><a href=\"#9-1-实现高级PCIe功能\" class=\"headerlink\" title=\"9.1 实现高级PCIe功能\"></a><strong>9.1 实现高级PCIe功能</strong></h3><p>PCIe规范包含除了基本配置空间之外的各种<em>扩展功能</em>。这些功能提供了高级错误报告、电源管理、虚拟化等特性。实现这些功能有助于您的仿真设备显得更合法，并与现代主机系统正确交互。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>识别所需的扩展功能：</strong></p>\n<ul>\n<li>在使用Arbor等工具收集捐赠设备信息时，请仔细查找并记录捐赠设备配置空间中存在的任何扩展功能。这些通常在标准配置空间的初始256字节之外找到。</li>\n<li><strong>常见示例：</strong><ul>\n<li><strong>高级错误报告（AER）</strong> ：为PCIe链路提供强大的错误检测、日志记录和报告机制。</li>\n<li><strong>设备序列号（DSN）</strong> ：（已在第6.2节中介绍）。</li>\n<li><strong>电源管理（PM）</strong> ：（已在第8.3.1节中介绍）。</li>\n<li><strong>PCI Express（PCIe）功能结构</strong>：（已在第8.1节中介绍链路速度&#x2F;宽度、最大载荷&#x2F;读取请求，但也包括其他字段，如设备控制&#x2F;状态、链路控制&#x2F;状态）。</li>\n<li><strong>虚拟通道（VC）&#x2F;多功能虚拟通道（MFVC）</strong> ：用于服务质量（QoS）和流量管理。</li>\n<li><strong>精确时间测量（PTM）</strong> ：用于设备之间的时间同步。</li>\n<li><strong>延迟容忍报告（LTR）</strong> ：基于延迟要求进行电源管理。</li>\n<li><strong>可重置FPC（功能级重置）</strong> ：用于更细粒度的重置。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>在Vivado PCIe IP核中启用功能：</strong></p>\n<ul>\n<li>访问Vivado中的PCIe IP核定制窗口（<code>pcie_7x_0.xci</code>）。</li>\n<li>导航到各个选项卡（例如，“PCIe Capabilities”、“Extended Capabilities”、“Advanced Options”）。</li>\n<li>查找复选框或下拉菜单，以启用和配置从捐赠设备中识别出的特定扩展功能。</li>\n<li><strong>示例（AER）：</strong>  您会找到一个“高级错误报告”部分，您可以在其中启用它并配置其寄存器（例如，严重性掩码）。</li>\n<li><strong>注意：</strong>  Xilinx PCIe IP核为许多标准和扩展功能提供了高度可配置性。通常只需在GUI中启用正确的选项即可。</li>\n</ul>\n</li>\n<li><p><strong>实现功能寄存器的固件逻辑（如果需要）：</strong></p>\n<ul>\n<li>虽然PCIe IP核处理这些功能的<em>存在</em>和大部分<em>协议</em>，但某些功能会暴露您的自定义固件可能需要读写或其值需要固件响应的寄存器。</li>\n<li><strong>示例（AER）：</strong>  如果您的仿真设备检测到应通过AER报告的内部错误，您的固件需要写入特定的AER错误状态寄存器（这些寄存器可能作为BAR的一部分暴露，或由PCIe核内部处理，然后反映到用户逻辑）。然后您的用户逻辑将向PCIe核断言错误输入。</li>\n<li><strong>示例（电源管理）：</strong>  如8.3.1节所述，您的固件需要响应PCIe核发出的D状态变化。</li>\n<li><strong>流程：</strong><ul>\n<li>识别您的捐赠设备驱动程序交互的每个已启用功能结构中的特定寄存器。</li>\n<li>在PCILeech-FPGA框架中找到与这些寄存器接口的相应信号或逻辑（通常在<code>pcileech_pcie_cfg_a7.sv</code>或<code>bar_controller</code>中）。</li>\n<li>实现这些寄存器的读写逻辑，确保您的仿真设备的内部状态准确反映驱动程序期望的值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"9-2-仿真厂商特定功能\"><a href=\"#9-2-仿真厂商特定功能\" class=\"headerlink\" title=\"9.2 仿真厂商特定功能\"></a><strong>9.2 仿真厂商特定功能</strong></h3><p>这是真正的“全设备仿真”变得高度专业化的部分。许多实际设备具有独特的寄存器、未文档化的命令、自定义数据格式或专有控制流程，这些都使其与众不同。复制这些需要更深入的分析和定制HDL开发。</p>\n<p><strong>步骤：</strong></p>\n<ol>\n<li><p><strong>逆向工程厂商特定行为：</strong></p>\n<ul>\n<li>这通常是最具挑战性的部分。</li>\n<li><strong>静态分析（驱动程序&#x2F;固件）：</strong>  反汇编捐赠设备的官方驱动程序（Windows <code>.sys</code>，Linux <code>.ko</code>）或设备的原始固件（如果可用）。查找独特的I&#x2F;O或MMIO访问模式、魔术值或寄存器写入序列。Ghidra、IDA Pro或objdump等工具会非常有价值。</li>\n<li><strong>动态分析（驱动程序执行）：</strong>  运行捐赠设备及其驱动程序，并使用<strong>PCIe协议分析仪</strong>（例如，Teledyne LeCroy，Keysight，如第12.2节所述）监控PCIe流量。这是理解实际TLP交换，包括厂商定义消息和寄存器访问序列的黄金标准。请注意：<ul>\n<li>BARs中访问的特定内存地址。</li>\n<li>对这些地址的读&#x2F;写模式。</li>\n<li>写入或读取特定寄存器的值。</li>\n<li>命令和响应之间的时序关系。</li>\n</ul>\n</li>\n<li><strong>系统调用&#x2F;API监控</strong>：在主机上，使用Procmon（Windows）或<code>strace</code>（Linux）等工具查看驱动程序如何与操作系统交互以及它使用了哪些特定的设备I&#x2F;O控制（IOCTL）代码，这些代码可能对应于特定的硬件操作。</li>\n<li><strong>硬件嗅探</strong>：如果可能，使用硬件嗅探器（如Saleae逻辑分析仪）捕获设备内部总线（例如SPI，I2C）上的信号，如果它有外部闪存或组件。</li>\n</ul>\n</li>\n<li><p><strong>在BARs中实现自定义寄存器和逻辑：</strong></p>\n<ul>\n<li>一旦您识别出厂商特定的寄存器或命令协议，您将需要将这些定义到您的FPGA固件中，通常作为可通过您的某个BAR访问的内存映射寄存器。</li>\n<li><strong>创建内部寄存器：</strong>  在您的SystemVerilog代码中声明<code>reg</code>变量来表示这些自定义寄存器。<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在pcileech_tlps128_bar_controller.sv或子模块中</span></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] custom_control_reg;</span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] custom_status_reg;</span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] custom_data_reg;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：将它们映射到BAR0中的特定偏移量（假设BAR0足够大）</span></span><br><span class=\"line\"><span class=\"comment\">// 调整&#x27;bar0_offset&#x27; case语句（来自第8.2.2节）</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (bar_hit[<span class=\"number\">0</span>]) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req_write) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1000</span>: custom_control_reg &lt;= req_data; <span class=\"comment\">// 自定义控制寄存器</span></span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1004</span>: custom_data_reg &lt;= req_data;    <span class=\"comment\">// 自定义数据写入寄存器</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 其他映射</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req_read) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> (bar0_offset)</span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1000</span>: rsp_data = custom_control_reg; <span class=\"comment\">// 读取控制寄存器</span></span><br><span class=\"line\">            <span class=\"number\">32&#x27;h0000_1008</span>: rsp_data = custom_status_reg;  <span class=\"comment\">// 自定义状态寄存器</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 其他映射</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>实现行为逻辑：</strong>  创建SystemVerilog逻辑（状态机、组合逻辑），用于：<ul>\n<li>响应对<code>custom_control_reg</code>的写入。例如，此寄存器中的某个特定位可能触发DMA传输、清除状态标志或启动内部操作。</li>\n<li>根据仿真设备的内部状态更新<code>custom_status_reg</code>（例如，“操作完成”、“发生错误”、“数据可用”）。</li>\n<li>处理写入<code>custom_data_reg</code>的数据，或在读取时从中提供数据，模仿捐赠设备的数据路径。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>仿真厂商特定消息（如果适用）：</strong></p>\n<ul>\n<li>一些复杂设备可能通过PCIe使用“厂商定义消息”（VDM）进行特定控制或通信。如果您的分析揭示了此类消息，您将需要：<ul>\n<li>在PCIe IP核中启用VDM支持（如果可用）。</li>\n<li>实现TLP生成逻辑（如第10节所述）来制作和发送这些VDM。</li>\n<li>实现TLP接收和解析逻辑来解释来自主机的传入VDM。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>验证仿真行为：</strong></p>\n<ul>\n<li><strong>迭代测试：</strong>  这是一个高度迭代的过程。进行小修改，编译，烧录，然后测试。</li>\n<li><strong>驱动程序加载：</strong>  捐赠设备的驱动程序是否正确加载而没有错误？</li>\n<li><strong>功能测试：</strong>  驱动程序能否启动基本操作？它是否从您的仿真寄存器获得预期的响应？</li>\n<li><strong>应用程序测试：</strong>  依赖捐赠设备的应用程序能否在您的仿真版本下正常运行？</li>\n<li><strong>调试：</strong>  广泛使用ILA和PCIe协议分析仪来比较您的仿真设备的行为与真实捐赠设备捕获的行为。寻找TLP时序、寄存器值和总体协议流中的差异。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"10-事务层数据包（TLP）仿真\"><a href=\"#10-事务层数据包（TLP）仿真\" class=\"headerlink\" title=\"10. 事务层数据包（TLP）仿真\"></a><strong>10. 事务层数据包（TLP）仿真</strong></h2><p>事务层数据包（TLP）是PCIe架构中通信的基本单位。主机系统与PCIe设备之间的每一次交互，从配置读取到数据传输，都被封装在一个或多个TLP中。精确的TLP仿真不仅重要；它对于您的仿真设备与主机系统正确交互，确保驱动程序正常运行和数据按预期移动，是<em>至关重要</em>的。</p>\n<h3 id=\"10-1-理解和捕获TLP\"><a href=\"#10-1-理解和捕获TLP\" class=\"headerlink\" title=\"10.1 理解和捕获TLP\"></a><strong>10.1 理解和捕获TLP</strong></h3><p>在您能够制作自定义TLP之前，您必须深入理解它们的结构和常见类型。从您的捐赠设备捕获真实世界的TLP可提供最精确的蓝图。</p>\n<ul>\n<li><p><strong>TLP结构的学习</strong>：<br>TLP通常由报头、可选数据载荷和可选的端到端CRC（ECRC）组成。报头至关重要，它定义了TLP的类型、事务细节和路由信息。</p>\n<ul>\n<li><strong>TLP的组成部分</strong>：<ul>\n<li><strong>报头（Header）</strong> ：最重要的部分，通常是3或4个双字（Dword &#x3D; 4字节）。它包含定义TLP目的和处理方式的关键字段：<ul>\n<li><strong>Fmt（格式）和 Type（类型）</strong> ：定义TLP的格式（3DW&#x2F;4DW，带&#x2F;不带数据）及其特定目的（例如，内存读取请求、内存写入、完成、配置读取&#x2F;写入）。</li>\n<li><strong>Length（长度）</strong> ：指定数据载荷的长度（以双字为单位）。</li>\n<li><strong>Requester ID（总线、设备、功能）</strong> ：标识发起请求的PCIe功能。对于将完成数据路由回正确的源头至关重要。</li>\n<li><strong>Tag（标签）</strong> ：由请求者分配给事务的唯一标识符，允许完成者将完成TLP与其原始请求TLP匹配。</li>\n<li><strong>Address（地址）</strong> ：对于内存&#x2F;IO事务，这是目标内存或I&#x2F;O地址。</li>\n<li><strong>First DW Byte Enable (FBE)</strong>  和 <strong>Last DW Byte Enable (LBE)</strong> ：指定数据载荷的第一个和最后一个双字中哪些字节对于写入操作有效，或哪些字节正在请求读取完成。</li>\n<li><strong>Traffic Class (TC)</strong>  和 <strong>Transaction ID (TID)</strong> ：用于QoS和排序规则。</li>\n</ul>\n</li>\n<li><strong>数据载荷（可选）</strong> ：存在于内存写入、配置写入和读取完成等TLP中。它包含实际传输的数据。</li>\n<li><strong>端到端CRC (ECRC)（可选）</strong> ：一个32位CRC，覆盖整个TLP，确保从源到目的地的数据完整性，通常由软件生成&#x2F;检查。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>理解常见的TLP类型</strong>：您的固件将主要处理这些类型：</p>\n<ul>\n<li><strong>Memory Read Request (MRd)</strong> ：由请求者（例如，主机CPU，或您的FPGA作为DMA主设备）发送的TLP，用于从特定内存地址读取数据。</li>\n<li><strong>Memory Read Completion (CplD)</strong> ：由完成者（例如，您的FPGA响应主机MRd）发送的TLP，携带请求的数据。</li>\n<li><strong>Memory Write (MWr)</strong> ：由请求者（例如，主机CPU，或您的FPGA）发送的TLP，用于向特定内存地址写入数据。</li>\n<li><strong>Completion Without Data (Cpl)</strong> ：由完成者发送的TLP，用于确认不返回数据的请求（例如，成功的MWr）。</li>\n<li><strong>Configuration Read Request (CfgRd)</strong> ：来自主机的TLP，用于读取设备配置空间中的寄存器。</li>\n<li><strong>Configuration Read Completion (CplD)</strong> ：来自设备返回CfgRd数据数据的TLP。</li>\n<li><strong>Configuration Write Request (CfgWr)</strong> ：来自主机的TLP，用于写入设备配置空间中的寄存器。</li>\n<li><strong>Vendor-Defined Messages (VDM)</strong> ：特定厂商用于专有通信的自定义TLP。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"10-1-2-从捐赠设备捕获TLP\"><a href=\"#10-1-2-从捐赠设备捕获TLP\" class=\"headerlink\" title=\"10.1.2 从捐赠设备捕获TLP\"></a><strong>10.1.2 从捐赠设备捕获TLP</strong></h4><p>从您的捐赠设备捕获真实的PCIe流量是无价的。它提供了TLP结构、序列和时序的具体示例，使您能够精确地复制它们。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>设置PCIe协议分析仪</strong>：<ul>\n<li>最有效的方法是使用专用的硬件工具，通常称为“PCIe协议分析仪”。这些设备位于主机和捐赠PCIe卡之间，被动捕获所有流量。</li>\n<li><strong>示例</strong>：<ul>\n<li><strong>Teledyne LeCroy PCIe 分析仪</strong>：行业标准，功能强大，但投资巨大。</li>\n<li><strong>Keysight PCIe 分析仪</strong>：另一个领先的供应商。</li>\n<li>（对于基本调试，一些带PCIe解码器的高端逻辑分析仪可能提供有限的TLP查看功能，但真正的协议分析仪更优越）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>捕获事务</strong>：<ul>\n<li>在连接了协议分析仪的测试系统中安装捐赠设备。</li>\n<li>运行捐赠设备的驱动程序和任何相关应用程序。</li>\n<li>在正常操作期间，尤其是关键阶段，监控和记录PCIe事务，例如：<ul>\n<li>设备枚举（操作系统首次检测到它时）。</li>\n<li>驱动程序加载和初始化。</li>\n<li>典型数据传输操作（例如，存储设备的大文件复制，网卡的网络流量）。</li>\n<li>设备特定命令或诊断。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>分析捕获的TLP</strong>：<ul>\n<li>使用协议分析仪的先进软件解剖捕获的TLP。软件将解码字段，提供时间顺序视图，并允许过滤和搜索。</li>\n<li>密切关注：<ul>\n<li>精确的<code>Fmt</code>和<code>Type</code>字段。</li>\n<li><code>Requester ID</code>和<code>Tag</code>值（特别是对于完成）。</li>\n<li>内存事务的<code>Address</code>和<code>Length</code>。</li>\n<li>写入和读取完成的<code>Data Payload</code>内容。</li>\n<li>任何厂商特定字段或自定义TLP。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"10-1-3-记录关键TLP事务\"><a href=\"#10-1-3-记录关键TLP事务\" class=\"headerlink\" title=\"10.1.3 记录关键TLP事务\"></a><strong>10.1.3 记录关键TLP事务</strong></h4><p>对捕获的TLP进行结构化文档创建了一个用于您的仿真的蓝图。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>识别关键事务</strong>：<ul>\n<li>重点关注对设备核心功能至关重要的TLP。这包括：<ul>\n<li><strong>初始化序列</strong>：操作系统在枚举期间执行的一系列配置读&#x2F;写。</li>\n<li><strong>驱动程序初始化</strong>：驱动程序启动时交换的命令和数据。</li>\n<li><strong>主要数据传输</strong>：<code>MWr</code>和<code>MRd</code> TLP如何为设备的主要功能构建和完成。</li>\n<li><strong>错误处理</strong>：设备如何报告错误（例如，带有Completer Abort (CA)、Unsupported Request (UR)的Completion）。</li>\n<li><strong>电源管理转换</strong>：与D状态变化相关的TLP。</li>\n<li><strong>中断生成</strong>：MSI&#x2F;MSI-X消息如何发送。</li>\n</ul>\n</li>\n<li>协议分析仪的截图在这里会非常有帮助。</li>\n</ul>\n</li>\n<li><strong>创建详细文档</strong>：<ul>\n<li>对于每个关键TLP序列，记录：<ul>\n<li><strong>TLP类型</strong>（例如，MWr、MRd、CplD）。</li>\n<li>其<strong>报头字段</strong>（Fmt、Type、Requester ID、Tag、Length、Address、Byte Enables）。</li>\n<li><strong>数据载荷</strong>（如果适用）。</li>\n<li>事务中的<strong>序列号</strong>或顺序。</li>\n<li>发送它的<strong>条件</strong>（例如，“主机在驱动程序初始化时发送”，“设备在DMA完成时发送”）。</li>\n<li>任何<strong>预期的响应</strong>或后续TLP。</li>\n</ul>\n</li>\n<li>协议分析仪的截图在这里会非常有帮助。</li>\n</ul>\n</li>\n<li><strong>理解时序和序列</strong>：<ul>\n<li>除了TLP内容，TLP的<em>时序</em>和<em>序列</em>至关重要。PCIe有严格的排序规则和流控制机制。注意：<ul>\n<li><strong>请求和完成之间的延迟</strong>：真实设备响应的速度。</li>\n<li><strong>流控制信用</strong>：设备如何管理其传入&#x2F;传出TLP的缓冲区空间。虽然Xilinx PCIe IP核处理基本的流控制，但对于高级仿真，了解捐赠设备的典型信用使用情况会有所帮助。</li>\n<li><strong>事务层数据包排序</strong>：理解posted（写入）和non-posted（读取、完成）事务如何排序。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"10-2-制作用于特定操作的定制TLP\"><a href=\"#10-2-制作用于特定操作的定制TLP\" class=\"headerlink\" title=\"10.2 制作用于特定操作的定制TLP\"></a><strong>10.2 制作用于特定操作的定制TLP</strong></h3><p>一旦您理解了蓝图，您就可以将这些知识转化为您的FPGA固件（SystemVerilog），以主动生成和响应TLP。PCILeech-FPGA框架提供了抽象层，但对于深度仿真，您可能需要直接与TLP生成&#x2F;解析逻辑交互。</p>\n<h4 id=\"10-2-1-在固件中实现TLP处理\"><a href=\"#10-2-1-在固件中实现TLP处理\" class=\"headerlink\" title=\"10.2.1 在固件中实现TLP处理\"></a><strong>10.2.1 在固件中实现TLP处理</strong></h4><p>您的固件需要逻辑来发送和接收TLP。PCIe IP核处理物理层和数据链路层，向您的用户逻辑暴露一个事务层接口（通常是AXI-Stream）。</p>\n<ul>\n<li><p><strong>要修改的文件（主要）</strong> ：</p>\n<ul>\n<li><code>pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_pcie_tlp_a7.sv</code>（或类似文件，取决于板卡变体）<ul>\n<li>此文件通常包含将用户请求转换为出站TLP并将传入TLP解析为用户逻辑信号的核心逻辑。</li>\n</ul>\n</li>\n<li><code>pcileech-fpga/&lt;your_board_variant&gt;/src/pcileech_tlps128_bar_controller.sv</code><ul>\n<li>此模块专门处理解析目标为设备BAR的传入内存读&#x2F;写TLP，并生成相应的完成TLP。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>步骤</strong>：</p>\n<ol>\n<li><p><strong>理解PCIe IP核接口</strong>：</p>\n<ul>\n<li>在编写TLP逻辑之前，请彻底阅读Xilinx PCIe IP核用户指南（特别是关于用户应用接口或AXI4-Stream接口的部分）。这定义了您的SystemVerilog逻辑如何连接到PCIe核以发送和接收TLP。您通常会与<code>s_axis_rx_tdata</code>（接收到的TLP数据）、<code>s_axis_rx_tvalid</code>（接收到有效TLP）、<code>m_axis_tx_tdata</code>（传出TLP数据）、<code>m_axis_tx_tready</code>（核已准备好接受TLP）等进行交互。</li>\n</ul>\n</li>\n<li><p><strong>创建TLP生成函数（用于出站TLP）</strong> ：</p>\n<ul>\n<li>在<code>pcileech_pcie_tlp_a7.sv</code>（或与<code>m_axis_tx_*</code>接口的模块）中，您将编写逻辑来组装具有所需报头和载荷的TLP。这通常涉及将各种字段组合成一个<code>[127:0]</code>（对于128位接口）或<code>[63:0]</code>（对于64位接口）总线，该总线馈送PCIe核。</li>\n<li><strong>示例（概念性，简化函数，用于3DW TLP报头）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个概念性辅助函数。实际上，您将构建一个状态机</span></span><br><span class=\"line\"><span class=\"comment\">// 通过AXI-Stream接口发送TLP，可能使用FIFO。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"keyword\">automatic</span> [<span class=\"number\">95</span>:<span class=\"number\">0</span>] create_3dw_tlp_header; <span class=\"comment\">// 假设3个双字 = 96位</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] tlp_type_fmt;   <span class=\"comment\">// 格式和类型字段</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] requester_id;  <span class=\"comment\">// BDF</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] tag;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] lower_address_bits; <span class=\"comment\">// 或更复杂的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> <span class=\"keyword\">logic</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] byte_enables;   <span class=\"comment\">// 第一个双字字节使能</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">begin</span></span><br><span class=\"line\">        create_3dw_tlp_header = &#123;</span><br><span class=\"line\">            tlp_type_fmt,                     <span class=\"comment\">// Fmt[6:4], Type[3:0]</span></span><br><span class=\"line\">            <span class=\"number\">8&#x27;b0</span>,                             <span class=\"comment\">// 保留</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;b0</span>,                             <span class=\"comment\">// TC[3:0] (流量类别)</span></span><br><span class=\"line\">            <span class=\"number\">3&#x27;b0</span>,                             <span class=\"comment\">// Attr[2:0]</span></span><br><span class=\"line\">            <span class=\"number\">1&#x27;b0</span>,                             <span class=\"comment\">// TH (TLP提示)</span></span><br><span class=\"line\">            <span class=\"number\">2&#x27;b0</span>,                             <span class=\"comment\">// D(igest) (ECRC存在)</span></span><br><span class=\"line\">            <span class=\"number\">1&#x27;b0</span>,                             <span class=\"comment\">// EP (Poisoned)</span></span><br><span class=\"line\">            <span class=\"number\">1&#x27;b0</span>,                             <span class=\"comment\">// TD (类型依赖)</span></span><br><span class=\"line\">            <span class=\"comment\">// DW0: Fmt, Type, TC, Attr, TH, D, EP, TD, Length (不在3DW中, 4DW有)</span></span><br><span class=\"line\"></span><br><span class=\"line\">            requester_id,                     <span class=\"comment\">// 请求者ID (Bus[7:0], Device[4:0], Function[2:0])</span></span><br><span class=\"line\">            tag,                              <span class=\"comment\">// 标签</span></span><br><span class=\"line\">            lower_address_bits,               <span class=\"comment\">// 示例：地址的低位或数据的一部分</span></span><br><span class=\"line\">            byte_enables,                     <span class=\"comment\">// 第一个双字字节使能</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;b0</span>,                             <span class=\"comment\">// 保留</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;b0</span>                              <span class=\"comment\">// 最后一个双字字节使能 (通常用于MWr)</span></span><br><span class=\"line\">            <span class=\"comment\">// DW1, DW2... 字段</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">endfunction</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：在状态机中生成带数据的完成（CplD）</span></span><br><span class=\"line\"><span class=\"comment\">// 这只是一个片段，不是完整实现</span></span><br><span class=\"line\"><span class=\"keyword\">localparam</span>  CPLD_3DW_FMT = <span class=\"number\">8&#x27;h4A</span>; <span class=\"comment\">// Fmt=100 (4DW, 带数据), Type=1010 (Cpl)</span></span><br><span class=\"line\"><span class=\"keyword\">localparam</span>  CPL_D_FMT_TYPE_LEN = <span class=\"number\">8&#x27;h4A</span>; <span class=\"comment\">// 根据PCIe规范调整。(带数据的4DW报头)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 发送TLP的状态机</span></span><br><span class=\"line\"><span class=\"comment\">// 在准备发送CplD的状态下</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (tx_ready_from_pcie_core) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"comment\">// 构建报头和载荷</span></span><br><span class=\"line\">    <span class=\"comment\">// 对于CplD，您需要Compliter ID, Status, Byte Count, Requester ID, Tag, Completion ID, Lower Address</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后是实际的读取数据载荷</span></span><br><span class=\"line\">    m_axis_tx_tdata_reg = &#123;</span><br><span class=\"line\">        CPL_D_FMT_TYPE_LEN,         <span class=\"comment\">// 字节0: Fmt/Type</span></span><br><span class=\"line\">        tlp_length_dw_minus_one,    <span class=\"comment\">// 字节1: TLP长度 (以双字为单位) - 1</span></span><br><span class=\"line\">        status_completion_bits,     <span class=\"comment\">// 字节2: Cpl Status, BCM, Rsvd</span></span><br><span class=\"line\">        byte_count_dws_upper,       <span class=\"comment\">// 字节3: 字节计数 (高位)</span></span><br><span class=\"line\">        requester_id,               <span class=\"comment\">// 字节4-5: 请求者ID (来自原始MRd)</span></span><br><span class=\"line\">        tag,                        <span class=\"comment\">// 字节6: 标签 (来自原始MRd)</span></span><br><span class=\"line\">        byte_count_dws_lower,       <span class=\"comment\">// 字节7: 字节计数 (低位)</span></span><br><span class=\"line\">        completion_id,              <span class=\"comment\">// 字节8-9: 完成ID (您的BDF)</span></span><br><span class=\"line\">        lower_address_from_request  <span class=\"comment\">// 字节10-11: 请求的低位地址</span></span><br><span class=\"line\">        <span class=\"comment\">// ... 接着是实际的数据载荷</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    m_axis_tx_tvalid_reg = <span class=\"number\">1&#x27;b1</span>;</span><br><span class=\"line\">    m_axis_tx_tlast_reg = <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 最后一个TLP片段</span></span><br><span class=\"line\">    <span class=\"comment\">// ... 状态转换以等待tready</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>注意</strong>：实际实现涉及状态机、FIFO，以及遵循PCIe IP核的AXI-Stream协议。PCILeech-FPGA框架已经为此提供了良好的基础，但您可能需要为非常特定的TLP行为进行扩展或修改。</li>\n</ul>\n</li>\n<li><p><strong>处理TLP接收（用于入站TLP）</strong> ：</p>\n<ul>\n<li>实现逻辑以解析来自PCIe核接收接口的传入TLP（例如，<code>s_axis_rx_tdata</code>、<code>s_axis_rx_tvalid</code>）。</li>\n<li>此解析包括：<ul>\n<li>检查<code>s_axis_rx_tvalid</code>以判断是否存在TLP。</li>\n<li>从TLP报头中读取<code>Fmt</code>和<code>Type</code>字段以确定其目的。</li>\n<li>提取<code>Requester ID</code>、<code>Tag</code>、<code>Address</code>、<code>Length</code>和<code>Data Payload</code>等相关字段。</li>\n</ul>\n</li>\n<li>使用<code>case</code>语句或<code>if/else if</code>块，根据TLP类型将信息路由到适当的内部逻辑（例如，用于内存写入的<code>bar_controller</code>，用于配置写入的配置模块）。</li>\n<li><strong>示例（概念性，简化解析）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在pcileech_pcie_tlp_a7.sv或TLP解析模块中</span></span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> [<span class=\"number\">127</span>:<span class=\"number\">0</span>] s_axis_rx_tdata;</span><br><span class=\"line\"><span class=\"keyword\">input</span> <span class=\"keyword\">wire</span> s_axis_rx_tvalid;</span><br><span class=\"line\"><span class=\"keyword\">output</span> <span class=\"keyword\">wire</span> s_axis_rx_tready; <span class=\"comment\">// 需要断言此信号以接受更多数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">7</span>:<span class=\"number\">0</span>] received_tlp_fmt_type;</span><br><span class=\"line\"><span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] received_requester_id;</span><br><span class=\"line\"><span class=\"comment\">// ... 声明其他已解析的字段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assign</span> s_axis_rx_tready = <span class=\"number\">1&#x27;b1</span>; <span class=\"comment\">// 为简化起见始终准备好接收，在实际设计中管理反压</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s_axis_rx_tvalid) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        received_tlp_fmt_type = s_axis_rx_tdata[<span class=\"number\">127</span>:<span class=\"number\">120</span>]; <span class=\"comment\">// 假设最高位</span></span><br><span class=\"line\">        received_requester_id = s_axis_rx_tdata[<span class=\"number\">111</span>:<span class=\"number\">96</span>]; <span class=\"comment\">// 示例偏移量</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据TLP类型解码</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> (received_tlp_fmt_type[<span class=\"number\">3</span>:<span class=\"number\">0</span>]) <span class=\"comment\">// 仅TLP类型位</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;h0</span>: <span class=\"comment\">// 内存写入 (3DW或4DW取决于Fmt)</span></span><br><span class=\"line\">                <span class=\"comment\">// 提取地址、长度、载荷并传递给BAR控制器</span></span><br><span class=\"line\">                <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"comment\">// 传递给BAR控制器，用于写入仿真内存</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_write_enable = 1&#x27;b1;</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_write_address = s_axis_rx_tdata[...];</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_write_data = s_axis_rx_tdata[...];</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"number\">4&#x27;h1</span>: <span class=\"comment\">// 内存读取</span></span><br><span class=\"line\">                <span class=\"comment\">// 提取地址、长度，并传递给BAR控制器进行读取</span></span><br><span class=\"line\">                <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_read_enable = 1&#x27;b1;</span></span><br><span class=\"line\">                    <span class=\"comment\">// bar_read_address = s_axis_rx_tdata[...];</span></span><br><span class=\"line\">                    <span class=\"comment\">// (完成将由BAR控制器生成)</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"comment\">// ... 其他TLP类型</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"comment\">// 处理不支持或保留的TLP类型（例如，日志记录、错误）</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>确保符合性</strong>：</p>\n<ul>\n<li>严格验证您生成和解析的TLP是否符合PCIe规范的格式、字段定义和时序。偏差将导致通信失败。</li>\n</ul>\n</li>\n<li><p><strong>实现完成处理</strong>：</p>\n<ul>\n<li>对于从主机接收到的内存读取请求（MRd）和配置读取请求（CfgRd），您的设备必须在指定的时间内返回适当的完成TLP（CplD表示数据，Cpl表示无数据）。<code>bar_controller</code>模块（第8.2.2节）是此BAR读取逻辑所在的位置。</li>\n</ul>\n</li>\n<li><p><strong>保存更改</strong>：</p>\n<ul>\n<li>保存文件（<code>pcileech_pcie_tlp_a7.sv</code>、<code>pcileech_tlps128_bar_controller.sv</code>或任何自定义模块）后，实现更改。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"10-2-2-处理不同TLP类型\"><a href=\"#10-2-2-处理不同TLP类型\" class=\"headerlink\" title=\"10.2.2 处理不同TLP类型\"></a><strong>10.2.2 处理不同TLP类型</strong></h4><p>每种TLP类型都有特定的报头格式和行为。您的固件必须擅长处理与您的捐赠设备相关的那些类型。</p>\n<ul>\n<li><p><strong>内存读取请求（MRd）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>当接收到MRd TLP（由<code>pcileech_pcie_tlp_a7.sv</code>解析并路由到<code>bar_controller</code>）时，<code>bar_controller</code>需要：<ul>\n<li>解析请求的地址和长度。</li>\n<li>从适当的内部内存位置（例如，连接到BAR的BRAM）或内部寄存器中获取数据。</li>\n<li>组装一个<strong>带数据的完成（CplD）</strong>  TLP。关键是，此TLP必须包含来自MRd请求的原始<code>Requester ID</code>、<code>Tag</code>和<code>Completion ID</code>（您的设备BDF），以及获取的数据载荷。</li>\n<li>通过PCIe IP核的传输接口将CplD TLP发送回主机。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>内存写入请求（MWr）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>当接收到MWr TLP时，<code>bar_controller</code>需要：<ul>\n<li>解析目标地址、长度和<code>Byte Enables</code>（FBE&#x2F;LBE）。</li>\n<li>提取<code>数据载荷</code>。</li>\n<li>将数据写入仿真设备内的指定内存位置（例如，BRAM或内部寄存器），并遵循字节使能。</li>\n</ul>\n</li>\n<li>内存写入是“posted事务”，这意味着它们不需要完成TLP进行确认，除非发生错误。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>配置读&#x2F;写请求（CfgRd&#x2F;CfgWr）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>这些TLP针对设备的配置空间（厂商ID、设备ID、BAR、功能等）。Xilinx PCIe IP核根据其配置自动处理大部分标准配置空间访问。</li>\n<li>但是，如果您的配置空间中存在非标准的自定义寄存器或扩展功能，您可能需要特定的逻辑来：<ul>\n<li>对于CfgRd：从您的内部<code>cfg_</code>寄存器返回请求的数据。</li>\n<li>对于CfgWr：更新您的内部<code>cfg_</code>寄存器或根据写入的数据触发操作。</li>\n</ul>\n</li>\n<li>配置读取需要<strong>带数据的完成（CplD）</strong> ，而配置写入需要<strong>不带数据的完成（Cpl）</strong> 。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>厂商定义消息（VDM）</strong> ：</p>\n<ul>\n<li><strong>实现</strong>：<ul>\n<li>如果您的捐赠设备使用VDM，这将需要专门的解析和响应逻辑。</li>\n<li><strong>解析传入VDM</strong>：根据其<code>Fmt</code>和<code>Type</code>字段识别VDM。提取厂商特定数据并根据您的逆向工程发现进行解释。</li>\n<li><strong>制作出站VDM</strong>：当您的仿真设备需要发送VDM时，创建逻辑来组装具有精确厂商特定报头和载荷格式的VDM。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"10-2-3-验证TLP时序和序列\"><a href=\"#10-2-3-验证TLP时序和序列\" class=\"headerlink\" title=\"10.2.3 验证TLP时序和序列\"></a><strong>10.2.3 验证TLP时序和序列</strong></h4><p>即使TLP格式完美，不正确的时序或序列也会导致设备故障或被检测为不兼容。</p>\n<ul>\n<li><p><strong>步骤</strong>：</p>\n<ol>\n<li><p><strong>使用仿真工具</strong>：</p>\n<ul>\n<li><strong>测试平台</strong>：为您的TLP生成和解析模块开发全面的SystemVerilog测试平台。</li>\n<li>模拟各种场景（例如，主机发送MRd，您的设备发送CplD；主机发送MWr；主机枚举设备），以验证TLP是否正确形成、传输、接收和处理。</li>\n<li>验证TLP的序列，并确保在合理的时间内发送完成。</li>\n</ul>\n</li>\n<li><p><strong>使用ILA监控（集成逻辑分析仪）</strong> ：</p>\n<ul>\n<li>如第12.1节所述，在您的Vivado设计中插入一个ILA核。</li>\n<li>将ILA探头连接到PCIe IP核的AXI-Stream接口（例如，<code>s_axis_rx_tdata</code>、<code>s_axis_rx_tvalid</code>、<code>m_axis_tx_tdata</code>、<code>m_axis_tx_tready</code>）。</li>\n<li>设置触发器以捕获特定TLP（例如，在<code>m_axis_tx_tvalid</code>上针对某种TLP类型触发）。</li>\n<li>这使您可以在硬件操作期间实时查看FPGA上的实际TLP位，验证您的固件是否向&#x2F;从PCIe IP核发送&#x2F;接收正确的数据和控制信号。</li>\n</ul>\n</li>\n<li><p><strong>检查时序约束</strong>：</p>\n<ul>\n<li>PCIe IP核对其AXI-Stream接口有严格的时序要求。确保您的用户逻辑向<code>m_axis_tx_tdata</code>提供数据和处理<code>s_axis_rx_tdata</code>满足这些时序约束。</li>\n<li>Vivado的时序分析报告（综合和实现后）将标记任何违规。通过优化您的逻辑或在可能的情况下调整时钟来解决这些问题。</li>\n</ul>\n</li>\n<li><p><strong>符合性测试（高级）</strong> ：</p>\n<ul>\n<li>对于高保真仿真，请考虑使用专用的PCIe符合性测试套件（通常与高端协议分析仪集成）。这些测试系统地检查是否符合PCIe规范，揭示细微的协议违规。</li>\n</ul>\n</li>\n<li><p><strong>保存更改</strong>：</p>\n<ul>\n<li>在彻底测试和验证后保存所有修改过的文件。迭代是TLP级调试的关键。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"第三部分：高级技术与优化-1\"><a href=\"#第三部分：高级技术与优化-1\" class=\"headerlink\" title=\"第三部分：高级技术与优化\"></a><strong>第三部分：高级技术与优化</strong></h2><hr>\n<h2 id=\"11-构建、烧录与测试\"><a href=\"#11-构建、烧录与测试\" class=\"headerlink\" title=\"11. 构建、烧录与测试\"></a><strong>11. 构建、烧录与测试</strong></h2><p>完成所有定制后，就到了验证的时刻：构建固件，将其编程到您的FPGA上，并严格测试其功能，以确保它与捐赠设备的行为完全一致。此阶段将您的设计从代码转换为可工作的硬件仿真。</p>\n<h3 id=\"11-1-综合与实现\"><a href=\"#11-1-综合与实现\" class=\"headerlink\" title=\"11.1 综合与实现\"></a><strong>11.1 综合与实现</strong></h3><p>这是FPGA设计流程中的核心步骤，您的SystemVerilog高级代码将被转换为可以加载到FPGA上的低级硬件配置。</p>\n<h4 id=\"11-1-1-运行综合\"><a href=\"#11-1-1-运行综合\" class=\"headerlink\" title=\"11.1.1 运行综合\"></a><strong>11.1.1 运行综合</strong></h4><p>综合是Vivado将您的HDL代码转换为门级网表（逻辑门及其互连的描述）的过程。它还执行初步的时序分析和资源估算。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>开始综合</strong>：<ul>\n<li>在Vivado GUI中，在 <strong>Flow Navigator</strong>（流程导航器）窗格（通常在左侧）中，在“Synthesis”（综合）下，点击 <strong>Run Synthesis</strong>（运行综合）。</li>\n</ul>\n</li>\n<li><strong>监控进度</strong>：<ul>\n<li>Vivado将打开一个“Launch Runs”（启动运行）对话框。您通常只需点击“OK”。</li>\n<li>监控Vivado窗口底部的 <strong>Messages</strong>（消息）选项卡。它将显示综合运行的进度。</li>\n<li><strong>常见警告&#x2F;错误关注点</strong>：<ul>\n<li><strong>​<code>[Synth 8-327]</code>​</strong>​ ** Unconnected Ports &#x2F; Unused Inputs（未连接端口&#x2F;未使用的输入）** ：这表明您设计中的信号或端口未连接到任何东西。虽然有时是故意的（例如，FPGA上未使用的引脚），但它们也可能指向端口名称中的拼写错误或遗忘的连接。检查每个警告以确保这不是功能问题。</li>\n<li><strong>​<code>[Synth 8-256]</code>​</strong>​ ** Registers&#x2F;Wires Not Optimized（寄存器&#x2F;线未优化）** ：这可能表明逻辑推断不正确，或者您有冗余逻辑可以优化。</li>\n<li><strong>Syntax Errors（语法错误）</strong> ：如果您的SystemVerilog代码中有致命的语法错误，综合将立即失败。请在Visual Studio Code中修复这些错误。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>审查综合报告</strong>：<ul>\n<li>成功完成后，Vivado将询问您下一步要做什么。选择 <strong>Open Synthesized Design</strong>（打开综合设计）或 <strong>Open Report</strong>（打开报告）。</li>\n<li>最重要的是，查看综合报告中的 <strong>Utilization Summary</strong>（资源利用率摘要）。这显示了您的设计消耗了FPGA多少资源（LUT、触发器、BRAM、DSP）。确保设计适合您的目标FPGA的容量（例如，对于Artix-7 35T，您应该在其限制内）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-1-2-运行实现\"><a href=\"#11-1-2-运行实现\" class=\"headerlink\" title=\"11.1.2 运行实现\"></a><strong>11.1.2 运行实现</strong></h4><p>实现是最耗时的一步。它接收综合后的网表并将其物理映射到FPGA的资源上（放置逻辑块，布线连接），然后执行详细的时序分析，以确保设计能够以指定的时钟频率运行。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>开始实现</strong>：<ul>\n<li>成功综合后，在 <strong>Flow Navigator</strong>（流程导航器）中，在“Implementation”（实现）下，点击 <strong>Run Implementation</strong>（运行实现）。</li>\n<li>确认“Launch Runs”（启动运行）对话框。</li>\n</ul>\n</li>\n<li><strong>监控进度</strong>：<ul>\n<li>实现包括几个阶段：Opt Design（优化设计）、Power Opt Design（功耗优化设计）、Place Design（放置设计）、Post-Placement Phys Opt Design（后放置物理优化设计）、Route Design（布线设计）、Post-Route Phys Opt Design（后布线物理优化设计）。每个阶段都可能需要大量时间。</li>\n<li>监控 <strong>Messages</strong>（消息）选项卡以了解进度和潜在问题。</li>\n</ul>\n</li>\n<li><strong>分析时序报告</strong>：<ul>\n<li>这是实现后<em>最关键的步骤</em>。完成后，Vivado会再次询问下一步做什么。选择 <strong>Open Implemented Design</strong>（打开已实现设计），或者更重要的是，选择 <strong>Open Report</strong>（打开报告），然后选择 <strong>Report Timing Summary</strong>（报告时序摘要）。</li>\n<li><strong>确保所有时序约束都得到满足。</strong>  查找“WNS (Worst Negative Slack)”值。<ul>\n<li><strong>正WNS</strong>：表示所有时序路径都满足其要求（有余量）。这是您想要的结果。</li>\n<li><strong>负WNS</strong>：表示<strong>时序违规</strong>，这意味着您的设计无法在所需的时钟频率下运行，或者数据可能不稳定。<strong>这是一个必须解决的关键问题。</strong></li>\n</ul>\n</li>\n<li><strong>解决违规</strong>：<ul>\n<li>如果您有负余量，请调查失败的具体路径。Vivado的时序报告将显示失败路径的源、目标和组件。</li>\n<li>解决方案可以包括：<ul>\n<li>优化HDL代码以减少逻辑深度或关键路径延迟。</li>\n<li>添加流水线级（寄存器）以打断长组合路径。</li>\n<li>改进XDC（约束）文件，确保所有时钟都正确定义和传播。</li>\n<li>调整时钟频率（如果应用程序允许）。</li>\n<li>在Vivado中使用更快的时序收敛策略。</li>\n<li>确保您的自定义逻辑与PCIe核的AXI-Stream接口时序要求正确接口。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>验证布局（可选）</strong> ：<ul>\n<li>在已实现的设计中，您可以打开“Device”（器件）视图，查看您的逻辑如何在FPGA上布局。这通常适用于高级用户，以确认关键组件是否最佳布局（例如，靠近PCIe收发器）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-1-3-生成比特流\"><a href=\"#11-1-3-生成比特流\" class=\"headerlink\" title=\"11.1.3 生成比特流\"></a><strong>11.1.3 生成比特流</strong></h4><p>比特流是最终的二进制配置文件（<code>.bit</code>扩展名），将被加载到您的FPGA上。它是综合和实现的成果。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>生成比特流</strong>：<ul>\n<li>成功实现后（没有严重的时序违规），在 <strong>Flow Navigator</strong>（流程导航器）中，在“Program and Debug”（编程和调试）下，点击 <strong>Generate Bitstream</strong>（生成比特流）。</li>\n</ul>\n</li>\n<li><strong>等待完成</strong>：<ul>\n<li>此过程通常比实现花费的时间少，但仍可能因设计复杂性而异。</li>\n</ul>\n</li>\n<li><strong>审查比特流生成日志</strong>：<ul>\n<li>完成后，Vivado会指示成功。审查日志中是否有任何警告，但通常如果实现顺利通过，比特流生成也会顺利通过。</li>\n<li><code>.bit</code>文件将生成在您的项目目录<code>pcileech_squirrel_top.runs/impl_1/</code>（或您的板卡类似路径）中。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"11-2-烧录比特流\"><a href=\"#11-2-烧录比特流\" class=\"headerlink\" title=\"11.2 烧录比特流\"></a><strong>11.2 烧录比特流</strong></h3><p>编程（烧录）比特流会将您编译的设计加载到FPGA上，使您的仿真设备激活。</p>\n<h4 id=\"11-2-1-连接FPGA设备\"><a href=\"#11-2-1-连接FPGA设备\" class=\"headerlink\" title=\"11.2.1 连接FPGA设备\"></a><strong>11.2.1 连接FPGA设备</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>准备硬件</strong>：<ul>\n<li>确保您的基于FPGA的DMA板卡已正确插入主机系统的兼容PCIe插槽。</li>\n<li>将JTAG编程器（例如，Digilent HS3，Xilinx Platform Cable）连接到FPGA板卡上的JTAG接口和开发PC的USB端口。</li>\n<li>打开主机系统电源。</li>\n<li>请参阅您的特定FPGA板卡手册，了解精确的电源、JTAG和PCIe连接说明。</li>\n</ul>\n</li>\n<li><strong>打开硬件管理器</strong>：<ul>\n<li>在Vivado中，导航到 <strong>Flow Navigator &gt; Program and Debug &gt; Open Hardware Manager</strong>（流程导航器 &gt; 编程和调试 &gt; 打开硬件管理器）。</li>\n<li>如果Vivado未运行，您可以作为独立应用程序启动硬件管理器。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-2-2-编程FPGA\"><a href=\"#11-2-2-编程FPGA\" class=\"headerlink\" title=\"11.2.2 编程FPGA\"></a><strong>11.2.2 编程FPGA</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>连接到目标</strong>：<ul>\n<li>在硬件管理器窗口中，点击 <strong>Open Target</strong>（打开目标）（通常是一个大按钮或链接），然后选择 <strong>Auto Connect</strong>（自动连接）。</li>\n<li>Vivado应该自动检测到您的JTAG编程器，然后检测到JTAG链上连接的FPGA设备。如果检测失败，请检查JTAG电缆连接、板卡电源以及PC上的JTAG驱动程序。</li>\n</ul>\n</li>\n<li><strong>编程设备</strong>：<ul>\n<li>一旦您的FPGA设备在硬件窗口中被检测并显示，<strong>右键单击</strong> 您的FPGA设备（例如，<code>xc7a35t_0</code>）并选择 <strong>Program Device</strong>（编程设备）。</li>\n<li>将出现一个对话框。点击“Bitstream file”（比特流文件）字段旁边的“…”按钮，导航到您生成的比特流文件（例如，<code>pcileech_squirrel_top.runs/impl_1/pcileech_squirrel_top.bit</code>）。</li>\n<li>点击 <strong>Program</strong>（编程）开始将固件烧录到FPGA上。</li>\n<li>等待编程过程完成。您将看到一个进度条。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-2-3-验证编程\"><a href=\"#11-2-3-验证编程\" class=\"headerlink\" title=\"11.2.3 验证编程\"></a><strong>11.2.3 验证编程</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>检查状态</strong>：<ul>\n<li>确保编程在Vivado的硬件管理器中无错误地完成。Vivado将在完成后显示“Program Device”成功消息。</li>\n</ul>\n</li>\n<li><strong>观察LED或指示灯</strong>：<ul>\n<li>许多FPGA板卡都有状态LED。成功的编程操作通常会导致特定LED亮起或改变状态（例如，“DONE”LED）。这是一个快速的视觉确认。</li>\n</ul>\n</li>\n<li><strong>主机系统重启（有时需要）</strong> ：<ul>\n<li>为了让主机操作系统正确识别新编程的PCIe设备，通常需要系统重启，尤其是在Windows上，以触发完整的PCIe枚举过程。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"11-3-测试与验证\"><a href=\"#11-3-测试与验证\" class=\"headerlink\" title=\"11.3 测试与验证\"></a><strong>11.3 测试与验证</strong></h3><p>编程完成后，关键一步是验证您的仿真设备是否被主机正确检测，并且其功能是否按预期工作，模仿捐赠设备。</p>\n<h4 id=\"11-3-1-验证设备枚举\"><a href=\"#11-3-1-验证设备枚举\" class=\"headerlink\" title=\"11.3.1 验证设备枚举\"></a><strong>11.3.1 验证设备枚举</strong></h4><p>这证实主机操作系统根据您编程的ID将您的FPGA识别为捐赠设备。</p>\n<ul>\n<li><strong>Windows</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>打开设备管理器</strong>：按下 <code>Win + X</code> 并从快速链接菜单中选择 <strong>Device Manager</strong>（设备管理器）。</li>\n<li><strong>检查设备属性</strong>：<ul>\n<li>在适当的设备类别下查找（例如，<strong>Network Adapters</strong>（网络适配器）、<strong>Storage Controllers</strong>（存储控制器）、<strong>System devices</strong>（系统设备））。</li>\n<li>找到您的仿真设备。它现在应该显示为<em>捐赠设备的名称</em>（例如，“Intel(R) Ethernet Connection…”）。</li>\n<li>右键单击该设备，选择 <strong>Properties</strong>（属性），然后转到 <strong>Details</strong>（详细信息）选项卡。</li>\n<li>在“Property”（属性）下拉菜单中，选择“Hardware Ids”（硬件ID）。确认 <strong>设备ID（DID）</strong>  和 <strong>厂商ID（VID）</strong> （例如，<code>PCI\\VEN_ABCD&amp;DEV_1234</code>）与您编程到固件中的值匹配。</li>\n<li>还应检查“Class Code”（类别代码）和“Subsystem ID”（子系统ID）以进行进一步验证。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>Linux</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>使用 <strong>​</strong>​<code>lspci</code>​</strong>：打开终端并使用<code>lspci</code>命令。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lspci -nn <span class=\"comment\"># 显示厂商ID:设备ID</span></span><br><span class=\"line\">lspci -vvv <span class=\"comment\"># 显示包括BAR、功能等详细信息</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>验证设备列表</strong>：<ul>\n<li>检查仿真设备是否在<code>lspci</code>输出中显示了正确的厂商ID、设备ID和类别代码。</li>\n<li><strong>示例输出（仿真Intel NIC）</strong> ：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">03:00.0 Network controller [0280]: Intel Corporation Ethernet Connection I219-V [8086:1570] (rev 21)</span><br></pre></td></tr></table></figure>\n\n（<code>8086</code>是Intel的厂商ID，<code>1570</code>是I219-V的设备ID，<code>0280</code>是网络控制器类别代码）。</li>\n<li>使用<code>lspci -vvv</code>确认BAR是否以正确的大小和类型枚举，与您的捐赠设备配置匹配。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-3-2-测试设备功能\"><a href=\"#11-3-2-测试设备功能\" class=\"headerlink\" title=\"11.3.2 测试设备功能\"></a><strong>11.3.2 测试设备功能</strong></h4><p>一旦设备被枚举，最终的测试是它是否像原始设备一样工作。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>安装必要的驱动程序</strong>：<ul>\n<li>如果主机操作系统未自动加载合适的驱动程序，您将需要手动安装捐赠设备的官方驱动程序。从制造商网站下载它们。</li>\n<li>按照制造商的说明进行安装。如果仿真成功，驱动程序应该安装并识别您的FPGA为真实硬件。</li>\n</ul>\n</li>\n<li><strong>执行功能测试</strong>：<ul>\n<li>运行通常与捐赠设备交互的应用程序或实用程序。</li>\n<li><strong>示例</strong>：<ul>\n<li><strong>网卡</strong>：执行ping测试、浏览网页或启动大文件传输以测试吞吐量。</li>\n<li><strong>存储控制器</strong>：尝试格式化模拟驱动器（如果您的仿真包括存储功能），执行读&#x2F;写操作，或运行磁盘基准测试。</li>\n<li><strong>USB控制器</strong>：连接USB设备（如果您的仿真包括USB主机功能）并测试它们的检测和操作。</li>\n</ul>\n</li>\n<li>监控主机系统以获取预期的行为和性能特征。</li>\n</ul>\n</li>\n<li><strong>监控系统行为</strong>：<ul>\n<li>检查系统稳定性（Windows上没有蓝屏，Linux上没有内核崩溃）。</li>\n<li>在系统日志中查找设备特定错误（Windows上的事件查看器，Linux上的<code>dmesg</code>或<code>journalctl</code>）。</li>\n<li>确保仿真设备在各种工作负载下（包括大数据传输或压力测试）按预期运行。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-3-3-监控错误\"><a href=\"#11-3-3-监控错误\" class=\"headerlink\" title=\"11.3.3 监控错误\"></a><strong>11.3.3 监控错误</strong></h4><p>主动的错误监控对于识别可能不会立即导致崩溃的细微仿真问题至关重要。</p>\n<ul>\n<li><strong>Windows</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>检查事件查看器</strong>：按下 <code>Win + X</code> 并选择 <strong>Event Viewer</strong>（事件查看器）。</li>\n<li><strong>查找与PCIe相关的错误</strong>：导航到 <strong>Windows Logs &gt; System</strong>（Windows 日志 &gt; 系统）。筛选或搜索与“PCIe”、“PCI Express”相关的警告、错误或关键事件，或源自特定设备驱动程序的事件（查找与您的仿真设备驱动程序匹配的源名称）。<ul>\n<li>常见错误包括资源冲突、驱动程序初始化失败或意外的设备响应。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><strong>Linux</strong>：<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>检查 <strong>​</strong>​<code>dmesg</code>​</strong>​ ** 日志**：打开终端并输入：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg | grep -i pci <span class=\"comment\"># 不区分大小写地搜索pci消息</span></span><br><span class=\"line\">dmesg | grep -i &lt;VendorID&gt; <span class=\"comment\"># 过滤您的设备的厂商ID</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>识别问题</strong>：查找指示PCIe链路训练问题、设备初始化问题、内存分配失败或意外DMA活动的消息。Linux内核的PCIe子系统非常详细。</li>\n</ol>\n</li>\n<li><strong>Systemd Journal (现代Linux)</strong> ：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">journalctl -b | grep -i pci <span class=\"comment\"># 当前引导日志</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"12-高级调试技术\"><a href=\"#12-高级调试技术\" class=\"headerlink\" title=\"12. 高级调试技术\"></a><strong>12. 高级调试技术</strong></h2><p>当问题出现时，特别是在复杂的PCIe设备仿真中，基本的故障排除可能不足以解决问题。高级调试工具和技术提供对FPGA内部逻辑和PCIe总线的深入可见性，使您能够高效地识别和解决问题。</p>\n<h3 id=\"12-1-使用Vivado的集成逻辑分析仪（ILA）\"><a href=\"#12-1-使用Vivado的集成逻辑分析仪（ILA）\" class=\"headerlink\" title=\"12.1 使用Vivado的集成逻辑分析仪（ILA）\"></a><strong>12.1 使用Vivado的集成逻辑分析仪（ILA）</strong></h3><p>集成逻辑分析仪（ILA）是Xilinx提供的一种强大、可配置的调试IP核，您可以直接将其嵌入到FPGA设计中。它允许您监控内部FPGA信号（线和寄存器）的实时行为，而无需外部探测硬件，其功能类似于一个强大的内部示波器或逻辑分析仪。</p>\n<h4 id=\"12-1-1-插入ILA核\"><a href=\"#12-1-1-插入ILA核\" class=\"headerlink\" title=\"12.1.1 插入ILA核\"></a><strong>12.1.1 插入ILA核</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>规划您的探头</strong>：确定您需要观察的关键信号。对于PCIe仿真，这些信号通常包括：<ul>\n<li>PCIe IP核的AXI-Stream接口（例如，<code>s_axis_rx_tdata</code>、<code>s_axis_rx_tvalid</code>、<code>m_axis_tx_tdata</code>、<code>m_axis_tx_tready</code>）。</li>\n<li>内部状态机信号（<code>current_state</code>、<code>next_state</code>）。</li>\n<li>BAR地址解码输出（<code>bar_hit[0]</code>、<code>bar_hit[1]</code>）。</li>\n<li>自定义寄存器值（<code>custom_control_reg</code>、<code>custom_status_reg</code>）。</li>\n<li>中断请求信号（<code>msi_trigger_signal</code>）。</li>\n</ul>\n</li>\n<li><strong>添加ILA IP核</strong>：<ul>\n<li>在Vivado中，打开 <strong>IP Catalog</strong>（IP目录）（通常在 <strong>Flow Navigator</strong>（流程导航器）窗格中）。</li>\n<li>搜索“ILA”（Integrated Logic Analyzer）。</li>\n<li>双击“Debug Bridge”（用于基本ILA）或“Integrated Logic Analyzer (ILA)”以打开其定制GUI。</li>\n<li>配置ILA：<ul>\n<li>设置您需要的<strong>捕获数据端口数量</strong>（探头）。</li>\n<li>设置每个探头的<strong>宽度</strong>以匹配您计划连接的信号。</li>\n<li>配置<strong>采样深度</strong>（在触发前&#x2F;后存储多少个样本）。更深的深度会消耗更多BRAM。</li>\n<li>点击“OK”并让Vivado生成IP。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>实例化并连接信号</strong>：<ul>\n<li>Vivado将生成ILA的<code>.xci</code>文件。您可以将其直接实例化在您的顶层SystemVerilog文件（例如，<code>pcileech_squirrel_top.sv</code>）中，或在可用信号的模块中。</li>\n<li><strong>示例（在</strong>​<strong>​<code>pcileech_squirrel_top.sv</code>​</strong>​<strong>或子模块中）：</strong><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设您已从IP Catalog生成了ila_0</span></span><br><span class=\"line\"><span class=\"comment\">// 连接到您设计的时钟和感兴趣的信号</span></span><br><span class=\"line\">ila_0 your_ila_instance (</span><br><span class=\"line\">    <span class=\"variable\">.clk</span>(clk_125mhz), <span class=\"comment\">// 连接到您设计中稳定的时钟，通常是PCIe用户时钟</span></span><br><span class=\"line\">    <span class=\"variable\">.probe0</span>(pcie_s_axis_rx_tdata),    <span class=\"comment\">// 示例：PCIe入站TLP数据</span></span><br><span class=\"line\">    <span class=\"variable\">.probe1</span>(pcie_s_axis_rx_tvalid),   <span class=\"comment\">// 示例：PCIe入站TLP有效</span></span><br><span class=\"line\">    <span class=\"variable\">.probe2</span>(pcie_m_axis_tx_tdata),    <span class=\"comment\">// 示例：PCIe出站TLP数据</span></span><br><span class=\"line\">    <span class=\"variable\">.probe3</span>(my_bar_controller_state), <span class=\"comment\">// 示例：您的BAR逻辑状态</span></span><br><span class=\"line\">    <span class=\"variable\">.probe4</span>(my_custom_register),      <span class=\"comment\">// 示例：自定义寄存器的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据需要添加更多探头</span></span><br><span class=\"line\">    <span class=\"variable\">.probeN</span>(signal_to_monitor_N)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li>\n<li><strong>替代方法（标记用于调试）：</strong>  对于更简单的信号，有时可以直接在HDL代码中标记它们用于调试。使用<code>(* mark_debug = &quot;true&quot; *) wire my_signal;</code> 或 <code>(* mark_debug = &quot;true&quot; *) reg my_register;</code>。Vivado随后会自动建议将它们添加到ILA中。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"12-1-2-配置触发条件\"><a href=\"#12-1-2-配置触发条件\" class=\"headerlink\" title=\"12.1.2 配置触发条件\"></a><strong>12.1.2 配置触发条件</strong></h4><p>当您配置智能触发条件以精确地在感兴趣的事件发生时（例如，错误、特定TLP类型、状态转换）捕获数据时，ILA最强大。</p>\n<ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>生成带有ILA的比特流</strong>：插入并连接ILA后，您必须运行综合、实现并生成新的比特流。ILA核消耗FPGA资源，并将嵌入到您的设计中。</li>\n<li><strong>打开硬件管理器</strong>：使用支持ILA的比特流编程您的FPGA（第11.2节）。然后，在Vivado中，打开硬件管理器并连接到您的目标。</li>\n<li><strong>访问ILA仪表板</strong>：在硬件管理器中，选择您的ILA实例（例如，<code>hw_ila_1</code>）。这将打开ILA仪表板。</li>\n<li><strong>定义触发器</strong>：<ul>\n<li>选择要用作触发输入的探头。</li>\n<li>设置特定的<strong>触发模式</strong>（例如，<code>pcie_s_axis_rx_tdata</code>为<code>0x4A</code>以触发完成TLP）。</li>\n<li>配置<strong>触发条件</strong>（例如，“等于”、“不等于”、“上升沿”、“下降沿”）。</li>\n<li>设置<strong>触发位置</strong>（在触发事件<em>之前</em>捕获多少样本，用于预触发可见性）。</li>\n<li>您可以设置多个触发序列以检测复杂事件。</li>\n<li><strong>触发器示例场景</strong>：<ul>\n<li>在收到的TLP中触发特定的<code>Fmt/Type</code>以分析传入命令。</li>\n<li>当特定寄存器（<code>my_custom_register</code>）达到某个值时触发。</li>\n<li>在<code>pcie_m_axis_tx_tvalid</code>断言 AND <code>pcie_m_axis_tx_tdata[3:0]</code> &#x3D;&#x3D; <code>4&#39;hC</code>（用于内存写入TLP）时触发，以分析出站写入。</li>\n<li>在错误信号断言时触发。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"12-1-3-捕获和分析数据\"><a href=\"#12-1-3-捕获和分析数据\" class=\"headerlink\" title=\"12.1.3 捕获和分析数据\"></a><strong>12.1.3 捕获和分析数据</strong></h4><ul>\n<li><strong>步骤</strong>：<ol>\n<li><strong>运行设计</strong>：让您的主机系统与已编程的FPGA交互，从而引发您要调试的事件。</li>\n<li><strong>布防ILA</strong>：在ILA仪表板中，点击 <strong>Run Trigger</strong>（运行触发器）按钮（通常是绿色的“播放”图标）。ILA将等待定义的触发条件。</li>\n<li><strong>捕获数据</strong>：一旦满足触发条件，ILA将把信号快照捕获到其内部内存缓冲区中。</li>\n<li><strong>分析波形</strong>：<ul>\n<li>捕获的数据将出现在波形查看器中。</li>\n<li>检查信号随时间的变化行为。放大、添加光标并解码值。</li>\n<li>寻找：<ul>\n<li><strong>意外的跳变</strong>：信号在错误的时间改变。</li>\n<li><strong>不正确的值</strong>：寄存器中保存了错误的数据。</li>\n<li><strong>协议违规</strong>：您的逻辑在PCIe接口上发送了不正确的数据。</li>\n<li><strong>时序问题</strong>：如果信号在预期时不稳定（尽管完整的时序分析在实现中完成，但ILA显示运行时行为）。</li>\n</ul>\n</li>\n<li>将捕获到的行为与您的预期设计逻辑和捐赠设备的观察行为（如果您使用协议分析仪捕获了它）进行比较。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"12-2-PCIe流量分析工具\"><a href=\"#12-2-PCIe流量分析工具\" class=\"headerlink\" title=\"12.2 PCIe流量分析工具\"></a><strong>12.2 PCIe流量分析工具</strong></h3><p>虽然ILA提供了FPGA内部可见性，但外部PCIe流量分析工具提供了对您的仿真设备和主机之间PCIe总线上实际通信的无与伦比的视图。这对于验证协议符合性和调试链路级问题至关重要。</p>\n<h4 id=\"12-2-1-PCIe协议分析仪（硬件）\"><a href=\"#12-2-1-PCIe协议分析仪（硬件）\" class=\"headerlink\" title=\"12.2.1 PCIe协议分析仪（硬件）\"></a><strong>12.2.1 PCIe协议分析仪（硬件）</strong></h4><ul>\n<li><strong>示例</strong>：<ul>\n<li><strong>Teledyne LeCroy PCIe 分析仪</strong>：深度分析的黄金标准，完整的协议解码，高级触发，以及错误注入功能。</li>\n<li><strong>Keysight PCIe 分析仪</strong>：另一个领先的供应商，具有类似的高端功能。</li>\n</ul>\n</li>\n<li><strong>步骤</strong>：<ol>\n<li><strong>设置分析仪</strong>：将硬件分析仪串联连接在主机系统的PCIe插槽和您的基于FPGA的DMA设备之间。这通常涉及一个特殊的中间卡。</li>\n<li><strong>配置捕获设置</strong>：使用分析仪的软件定义要捕获的流量。您可以按TLP类型、地址、请求者ID、错误条件等进行过滤，以关注相关事件。</li>\n<li><strong>捕获流量</strong>：在主机上运行您的仿真设备。分析仪将被动记录所有PCIe事务。</li>\n<li><strong>分析结果</strong>：<ul>\n<li>使用分析仪强大的软件查看解码的TLP、事务列表和波形视图。</li>\n<li><strong>检查TLP的符合性和正确性</strong>：所有字段都正确吗？序列是否正确？</li>\n<li><strong>识别任何协议违规或意外行为</strong>：这是您发现驱动程序可能失败的原因（例如，您的设备发送了带数据的完成，而规范要求不带数据的完成，或者响应太慢）。</li>\n<li><strong>与捐赠设备捕获进行比较</strong>：直接比较您的仿真设备捕获的流量与您从真实捐赠设备捕获的流量。这是仿真准确性的最终测试。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"12-2-2-基于软件的工具\"><a href=\"#12-2-2-基于软件的工具\" class=\"headerlink\" title=\"12.2.2 基于软件的工具\"></a><strong>12.2.2 基于软件的工具</strong></h4><p>对于基本的PCIe总线检查，或者在没有专用硬件分析仪的情况下，一些软件工具可以提供有限的洞察。</p>\n<ul>\n<li><strong>示例</strong>：<ul>\n<li><strong>Wireshark with PCIe Plugins</strong>：虽然Wireshark主要用于网络流量，但通过专用硬件（例如，将PCIe跟踪暴露给操作系统的网卡，或特定的捕获硬件&#x2F;驱动程序），它有时可以捕获和解码PCIe数据包。这高度依赖于系统。</li>\n<li><strong>ChipScope Pro（传统Xilinx，现已集成到Vivado中）</strong> ：Integrated Logic Analyzer (ILA) 是现代的等效工具，但ChipScope曾是一个独立工具。</li>\n<li><strong>​<code>lspci</code>​</strong>​ ** (Linux)** ：如第11.3.1节所述，<code>lspci -vvv</code>提供了广泛的静态配置空间信息。您可以将其与<code>watch</code>或脚本结合使用来监控随时间的变化。</li>\n<li><strong>​<code>pcileech</code>​</strong>​<strong>客户端（来自PCILeech框架）</strong> ：<code>pcileech</code>客户端软件本身可以通过您的FPGA执行内存和配置空间的读写操作，并可用于测试基本的DMA功能。虽然不是“流量分析仪”，但它对于测试功能接口至关重要。</li>\n</ul>\n</li>\n<li><strong>步骤</strong>：<ol>\n<li><strong>安装必要的工具&#x2F;插件</strong>：确保工具已安装并配置了任何所需的驱动程序或插件。</li>\n<li><strong>监控PCIe总线</strong>：运行软件工具以捕获和显示PCIe相关信息。</li>\n<li><strong>分析通信</strong>：<ul>\n<li>查找设备配置中的差异。</li>\n<li>如果工具支持，分析捕获数据包的结构是否存在异常或错误。</li>\n<li>验证您的仿真设备是否正确响应了配置请求。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"13-故障排除\"><a href=\"#13-故障排除\" class=\"headerlink\" title=\"13. 故障排除\"></a><strong>13. 故障排除</strong></h2><p>本节提供了在PCIe设备仿真定制固件开发、比特流编程和硬件测试过程中可能遇到的常见问题的解决方案。固件调试可能具有挑战性，因此采用系统方法是关键。</p>\n<h3 id=\"13-1-设备检测问题\"><a href=\"#13-1-设备检测问题\" class=\"headerlink\" title=\"13.1 设备检测问题\"></a><strong>13.1 设备检测问题</strong></h3><p><strong>问题</strong>：您的基于FPGA的DMA设备在编程后未被主机系统识别，或者在设备管理器&#x2F;lspci中显示为不正确的ID（例如，“未知设备”）或错误符号。</p>\n<h4 id=\"可能原因及解决方案：\"><a href=\"#可能原因及解决方案：\" class=\"headerlink\" title=\"可能原因及解决方案：\"></a><strong>可能原因及解决方案</strong>：</h4><ol>\n<li><p><strong>设备ID、厂商ID、子系统ID或类别代码不正确</strong>：</p>\n<ul>\n<li><strong>原因</strong>：最常见的原因。您编程到FPGA固件中的识别值与主机操作系统预期或您打算仿真的值不匹配。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>验证</strong>：仔细检查<code>pcileech_pcie_cfg_a7.sv</code>（或等效文件）中的所有<code>cfg_deviceid</code>、<code>cfg_vendorid</code>、<code>cfg_subsysid</code>、<code>cfg_subsysvendorid</code>、<code>cfg_revisionid</code>和<code>cfg_classcode</code>参数，与您精心记录的捐赠设备信息（来自第5节）进行比对。</li>\n<li><strong>一致性</strong>：确保这些值在Vivado PCIe IP核定制GUI（第7.2.2节）中也保持一致设置。</li>\n<li><strong>重新构建并重新烧录</strong>：进行任何更改后，始终重新综合、重新实现、生成新的比特流并重新烧录FPGA（第11.1、11.2节）。</li>\n<li><strong>重启主机</strong>：烧录后务必重启主机系统，因为Windows通常需要完全重启才能正确重新枚举PCIe设备。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>PCIe链路训练失败</strong>：</p>\n<ul>\n<li><strong>原因</strong>：主机根联合体与您的FPGA卡之间的基本PCIe链路未能建立。这发生在任何配置空间读取之前。症状包括设备完全不出现（<code>lspci</code>在该总线&#x2F;插槽上没有任何显示，或设备管理器显示“PCI Express Root Port”错误）。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>物理连接</strong>：确保FPGA板卡牢固地插入PCIe插槽，并且所有电源连接都牢固。如果可能，尝试不同的PCIe插槽。</li>\n<li><strong>电源</strong>：验证FPGA板卡是否获得足够的电源。某些板卡需要辅助PCIe电源连接器。</li>\n<li><strong>链路速度&#x2F;宽度</strong>：<ul>\n<li>检查Vivado PCIe IP核中的<code>Max Link Speed</code>和<code>Link Width</code>设置（第8.1.1节）。</li>\n<li>尝试将链路速度设置为较低的代数（例如，Gen1 &#x2F; 2.5 GT&#x2F;s）并将宽度设置为x1，即使您的板卡支持更高。有时，在较高速度下与特定主板会产生兼容性问题。</li>\n<li>检查主板BIOS设置中的PCIe插槽速度选项。</li>\n</ul>\n</li>\n<li><strong>复位</strong>：确保FPGA的复位逻辑正确实现（例如，与PCIe参考时钟同步），并在上电&#x2F;重启时正确断言&#x2F;去断言。</li>\n<li><strong>PCIe IP核</strong>：确保PCIe IP核正确实例化，并且其时钟和复位在您的顶层设计中正确连接。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>电源问题（电源不足或不稳定）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：FPGA板卡未获得足够的稳定电源，或电源供应不稳定，导致操作不可靠。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>验证连接</strong>：仔细检查所有电源线（主PCIe插槽电源、辅助PCIe电源、如果使用则包括外部直流插孔）。</li>\n<li><strong>电源供应</strong>：确保您的主机系统电源（PSU）具有足够的瓦数和稳定的12V电压轨。对于高功耗FPGA，弱电源可能导致问题。</li>\n<li><strong>外部电源</strong>：如果板卡有外部电源插孔，请确保使用正确电压和电流额定值的电源。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>固件错误（早期阶段）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：SystemVerilog代码中的逻辑错误，特别是顶层模块或PCIe核的包装器中，导致PCIe核无法初始化或正确呈现自身。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>Vivado消息</strong>：仔细检查Vivado的综合和实现日志中与PCIe IP核相关的<strong>严重警告</strong>或<strong>错误</strong>。这些通常是配置错误或连接不当的指示。</li>\n<li><strong>ILA调试</strong>：如果链路尝试训练但失败，请使用连接到PCIe IP核的状态信号（例如，<code>link_up</code>、<code>link_speed</code>、<code>link_width</code>）和AXI-Stream接口的ILA（第12.1节），以查看链路协商在哪个点失败，或者核是否生成了意外流量。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"13-2-内存映射和BAR配置错误\"><a href=\"#13-2-内存映射和BAR配置错误\" class=\"headerlink\" title=\"13.2 内存映射和BAR配置错误\"></a><strong>13.2 内存映射和BAR配置错误</strong></h3><p><strong>问题</strong>：仿真设备已检测到，但当主机操作系统或驱动程序尝试通过BAR访问其内存映射寄存器或缓冲区时，系统崩溃、冻结或报告错误。</p>\n<h4 id=\"可能原因及解决方案：-1\"><a href=\"#可能原因及解决方案：-1\" class=\"headerlink\" title=\"可能原因及解决方案：\"></a><strong>可能原因及解决方案</strong>：</h4><ol>\n<li><p><strong>BAR大小或类型不正确（IP核和固件）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：您在Vivado PCIe IP核（第7.2.2节）中配置的BAR大小或类型（32位&#x2F;64位、内存&#x2F;I&#x2F;O、可预取&#x2F;不可预取）和&#x2F;或在<code>pcileech_tlps128_bar_controller.sv</code>中处理的值与捐赠设备实际提供的值不匹配。这可能导致主机分配不正确的地址空间或尝试不支持的访问。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>交叉验证</strong>：返回到您的Arbor&#x2F;协议分析仪数据（第5节），重新验证每个BAR配置（大小、类型、可预取）。</li>\n<li><strong>一致性</strong>：确保这些值在PCIe IP核定制中完全匹配，并且您的<code>bar_controller</code>逻辑正确处理每个BAR的大小（地址解码范围）和类型。</li>\n<li><strong>BRAM大小</strong>：如果您的BAR映射到BRAM，请确认BRAM IP核的大小（第8.2.1节）与BAR大小完全匹配。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>固件中的地址解码错误</strong>：</p>\n<ul>\n<li><strong>原因</strong>：您的<code>pcileech_tlps128_bar_controller.sv</code>（或自定义BAR逻辑）错误地解释了传入的PCIe地址，导致访问了不正确的内部寄存器或内存位置。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>审查逻辑</strong>：仔细审查<code>bar_controller</code>中的<code>case</code>语句和地址计算。</li>\n<li><strong>仿真</strong>：在您的SystemVerilog测试平台中开发特定的测试用例，模拟主机对每个BAR中不同偏移量的读写访问。验证内部<code>bar_hit</code>信号是否正确，以及数据是否正确路由到&#x2F;从正确的内部寄存器&#x2F;BRAM。</li>\n<li><strong>ILA调试</strong>：在<code>req_addr</code>、<code>req_write</code>、<code>req_read</code>、<code>req_data</code>、<code>rsp_data</code>以及<code>bar_controller</code>中与您的地址解码和寄存器访问相关的内部信号上放置ILA探头。实时观察地址如何解码以及正在读&#x2F;写的数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>内部地址空间重叠</strong>：</p>\n<ul>\n<li><strong>原因</strong>：虽然PCIe标准确保不同设备的BAR在主机的内存映射中不重叠，但在FPGA<em>内部</em>，您可能会意外地将不同的逻辑组件映射到单个BAR中的相同物理地址空间。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>仔细映射</strong>：在BAR中定义内部寄存器和内存块时，显式为每个寄存器和内存块分配唯一的、不重叠的偏移量。使用<code>localparam</code>来定义这些偏移量以防止错误。</li>\n<li><strong>设计审查</strong>：需要对您的<code>bar_controller</code>进行彻底的设计审查，以确保每个地址范围都得到唯一处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>BRAM访问问题</strong>：</p>\n<ul>\n<li><strong>原因</strong>：您的逻辑与BRAM IP核接口存在问题（例如，不正确的BRAM时钟、异步复位、错误的字节使能或不正确的写入使能逻辑）。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>BRAM文档</strong>：查阅Xilinx BRAM IP核文档，了解正确的实例化和接口信号。</li>\n<li><strong>ILA</strong>：在BRAM接口信号（地址、写入使能、数据输入、数据输出）上放置ILA探头，以验证您的逻辑是否向BRAM发送了正确的控制信号。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"13-3-DMA性能和TLP错误\"><a href=\"#13-3-DMA性能和TLP错误\" class=\"headerlink\" title=\"13.3 DMA性能和TLP错误\"></a><strong>13.3 DMA性能和TLP错误</strong></h3><p><strong>问题</strong>：设备已检测到并功能上看起来正常，但在大型DMA操作期间，数据传输速率缓慢，或者系统间歇性崩溃、挂起或报错。PCIe协议分析仪报告TLP格式错误或流控制问题。</p>\n<h4 id=\"可能原因及解决方案：-2\"><a href=\"#可能原因及解决方案：-2\" class=\"headerlink\" title=\"可能原因及解决方案：\"></a><strong>可能原因及解决方案</strong>：</h4><ol>\n<li><p><strong>TLP格式错误（报头&#x2F;载荷）</strong> ：</p>\n<ul>\n<li><strong>原因</strong>：您的固件生成的TLP（特别是您的FPGA作为DMA主设备时发送的完成或出站内存写入）具有不正确的报头、长度、字节使能或载荷。主机系统的PCIe核或驱动程序将其检测为违规。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>PCIe协议分析仪</strong>：这是最好的工具（第12.2.1节）。捕获流量并仔细比较您生成的TLP与PCIe规范，更重要的是，与您<em>真实捐赠设备</em>的捕获进行比较。</li>\n<li><strong>TLP生成逻辑</strong>：审查您的TLP组装代码（<code>pcileech_pcie_tlp_a7.sv</code>及相关模块）。确保所有字段（Fmt、Type、Requester ID、Tag、Completion ID、Length、Byte Enables、Address）都正确派生并打包到TLP结构中。</li>\n<li><strong>错误检查</strong>：在固件中实现基本的错误检查（例如，检查是否存在意外的<code>req_valid</code>而没有<code>req_ready</code>，反之亦然）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>流控制问题</strong>：</p>\n<ul>\n<li><strong>原因</strong>：PCIe使用基于信用的流控制机制。如果您的固件（或PCIe IP核与其的交互）错误地管理信用，可能导致死锁、超时或丢包。症状包括PCIe链路“停滞”、超时或低吞吐量。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>PCIe IP核配置</strong>：确保Vivado PCIe IP核定制中的流控制设置适用于您预期的流量模式。默认设置通常是健壮的。</li>\n<li><strong>用户逻辑反压</strong>：您的用户逻辑向PCIe IP核发送TLP（<code>m_axis_tx_*</code>接口）<em>必须</em>遵守来自IP核的<code>m_axis_tx_tready</code>信号。如果<code>tready</code>被去断言，您<em>必须</em>暂停发送数据。否则将导致核的缓冲区溢出。</li>\n<li><strong>ILA调试</strong>：将ILA探头连接到PCIe IP核的流控制接口信号和您的用户逻辑，以观察<code>tvalid</code>&#x2F;<code>tready</code>握手是否正常工作。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>DMA逻辑效率低下&#x2F;缓冲问题</strong>：</p>\n<ul>\n<li><strong>原因</strong>：FPGA内部的DMA引擎实现（读取&#x2F;写入主机内存数据的部分）未优化，导致瓶颈。这可能涉及：<ul>\n<li>缺少流水线。</li>\n<li>BRAM使用效率低下。</li>\n<li>外部内存访问延迟导致的停滞。</li>\n<li>突发大小过小。</li>\n</ul>\n</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>流水线</strong>：将长组合路径分解为更小、更连续的阶段，使用寄存器。这允许更高的时钟频率和更好的吞吐量。</li>\n<li><strong>缓冲</strong>：使用FIFO（先进先出缓冲区）来解耦发送方和接收方逻辑，平滑数据流并防止停滞。</li>\n<li><strong>突发传输</strong>：利用PCIe执行突发读&#x2F;写的能力以提高效率。确保您的DMA逻辑以适当的突发大小请求和处理数据。</li>\n<li><strong>内存带宽</strong>：确保您的BRAM或外部DDR内存接口能够足够快地提供&#x2F;消耗数据，以满足您所需的DMA速率。</li>\n<li><strong>ILA</strong>：监控您的DMA引擎的内部状态、读写指针和数据路径信号，以识别瓶颈。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>完成超时&#x2F;不支持的请求</strong>：</p>\n<ul>\n<li><strong>原因</strong>：主机发送请求（例如MRd、CfgRd），但您的FPGA设备未在允许的超时时间内响应完成TLP，或者它以错误状态（例如，带有Unsupported Request (UR) 或 Completer Abort (CA) 的完成）进行响应。</li>\n<li><strong>解决方案</strong>：<ul>\n<li><strong>响应逻辑</strong>：验证您的<code>bar_controller</code>（用于MRd）和<code>pcileech_pcie_cfg_a7.sv</code>（用于自定义配置空间的CfgRd）是否正确识别请求并生成适当的完成。</li>\n<li><strong>超时值</strong>：审查您的捐赠设备预期的完成延迟。虽然PCIe定义了默认超时，但某些驱动程序可能对此敏感。</li>\n<li><strong>ILA&#x2F;协议分析仪</strong>：对于查明<em>为什么</em>未发送完成或完成格式错误至关重要。请求TLP是否甚至到达了您的用户逻辑？您的逻辑是否生成了响应？PCIe核是否成功发送了响应？</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"14-仿真精度与优化\"><a href=\"#14-仿真精度与优化\" class=\"headerlink\" title=\"14. 仿真精度与优化\"></a><strong>14. 仿真精度与优化</strong></h2><p>实现真正令人信服的仿真意味着让您的基于FPGA的设备与捐赠设备难以区分，不仅在ID上，而且在行为上。这需要对时序、响应速度和微妙的操作细节进行细致的关注。</p>\n<h3 id=\"14-1-精确定时仿真技术\"><a href=\"#14-1-精确定时仿真技术\" class=\"headerlink\" title=\"14.1 精确定时仿真技术\"></a><strong>14.1 精确定时仿真技术</strong></h3><p>精确的时序在硬件中至关重要，特别是对于PCIe这样的高速接口。不匹配可能导致驱动程序超时、数据解释不正确或系统不稳定。</p>\n<ul>\n<li><p><strong>实现时序约束（XDC文件）</strong> ：</p>\n<ul>\n<li><strong>目的</strong>：时序约束是 Vivado 综合和实现工具的指令，告诉它们您的设计需要运行多快。它们定义了时钟周期、输入&#x2F;输出延迟和路径延迟。</li>\n<li><strong>用法</strong>：PCILeech-FPGA项目包含 XDC 文件（例如，<code>pcileech_squirrel_top.xdc</code>），它们定义了主时钟（例如，<code>create_clock -name sys_clk_p -period 8.0 [get_ports sys_clk_p]</code>）。</li>\n<li><strong>优化</strong>：如果您的仿真需要非常特定的内部时序或对时间敏感的命令做出反应，您可能需要在自定义逻辑中添加进一步的约束（<code>set_max_delay</code>、<code>set_input_delay</code>、<code>set_output_delay</code>）到关键路径。</li>\n<li><strong>目标</strong>：确保 Vivado 在实现后报告所有路径的 <strong>正 WNS（最差负余量）</strong> ，表明设计满足其时序要求。</li>\n</ul>\n</li>\n<li><p><strong>使用时钟域交叉（CDC）技术</strong>：</p>\n<ul>\n<li><strong>目的</strong>：PCIe设计通常涉及多个时钟域（例如，125MHz PCIe用户时钟，自定义逻辑的单独时钟）。在这些域之间异步移动信号（没有适当的同步）可能导致<strong>亚稳态</strong>，从而导致不可靠的行为。</li>\n<li><strong>实现</strong>：对于跨时钟域的信号，始终使用适当的CDC电路：<ul>\n<li><strong>双触发器同步器</strong>：用于单比特控制信号。</li>\n<li><strong>异步FIFO（先进先出）</strong> ：用于多比特数据路径，提供时钟域之间的数据缓冲和流控制。</li>\n<li><strong>格雷码编码器&#x2F;解码器</strong>：用于跨域的计数器或地址，以确保每次只有一个比特发生变化。</li>\n</ul>\n</li>\n<li><strong>Vivado 工具</strong>：Vivado 包含 CDC 分析工具（例如，<code>report_cdc</code>），可以识别潜在的亚稳态问题。</li>\n</ul>\n</li>\n<li><p><strong>使用时间精确模型仿真设备行为</strong>：</p>\n<ul>\n<li><strong>高级测试平台</strong>：使用 SystemVerilog 测试平台，其中包含真实的定时延迟，甚至提供时间精确的 PCIe 总线功能模型（BFM）。</li>\n<li><strong>验证</strong>：这使您可以观察您的仿真设备的内部状态以及外部 TLP 生成&#x2F;响应时序在各种条件下如何表现，确保它们与您捕获的捐赠设备行为相匹配。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"14-2-对系统调用的动态响应\"><a href=\"#14-2-对系统调用的动态响应\" class=\"headerlink\" title=\"14.2 对系统调用的动态响应\"></a><strong>14.2 对系统调用的动态响应</strong></h3><p>真正精确的仿真不仅能呈现正确的ID；它还能智能且动态地响应主机系统的命令和查询，模仿真实、活动设备的行为。</p>\n<ul>\n<li><p><strong>实现设备控制的状态机</strong>：</p>\n<ul>\n<li><strong>目的</strong>：设计健壮的 SystemVerilog 状态机来管理设备的操作模式、命令处理和数据流。</li>\n<li><strong>响应性</strong>：确保状态机能够逻辑地、快速地响应传入命令（例如，写入 BAR 中的控制寄存器，特定的 TLP）。</li>\n<li><strong>优雅处理</strong>：状态机应能够优雅地处理意外或无序的请求，可能返回错误 TLP 或仅仅忽略无效命令，而不是崩溃或冻结。</li>\n</ul>\n</li>\n<li><p><strong>监控和响应主机命令（超越简单的读写）</strong> ：</p>\n<ul>\n<li><strong>配置写入</strong>：除了初始枚举之外，驱动程序通常会写入配置空间寄存器以启用功能、设置阈值或清除状态位。您的固件必须处理这些写入并相应地更新内部状态。</li>\n<li><strong>厂商特定命令</strong>：如第9.2节所述，如果捐赠设备具有专有命令（通过自定义寄存器或厂商定义消息访问），您的固件必须解析这些命令并触发适当的仿真行为。</li>\n<li><strong>电源管理命令</strong>：通过启用&#x2F;禁用内部逻辑并确认状态更改来响应主机发起的电源状态转换（D0、D1、D3hot 等）。</li>\n<li><strong>中断确认</strong>：如果主机驱动程序通过写入特定寄存器来确认中断，请确保您的固件能够检测到此并清除内部中断请求。</li>\n</ul>\n</li>\n<li><p><strong>优化固件逻辑以提高响应性</strong>：</p>\n<ul>\n<li><strong>降低延迟</strong>：关键数据路径和控制路径应优化，以最小化组合逻辑深度和流水线停顿。</li>\n<li><strong>并行性</strong>：利用 FPGA 固有的并行性来同时执行多个操作，提高吞吐量和响应时间。</li>\n<li><strong>高效内存访问</strong>：优化对内部 BRAM 或外部 DDR 内存的访问，以确保在需要时为 DMA 传输或寄存器读取提供数据。</li>\n<li><strong>硬件加速</strong>：对于捐赠设备执行的复杂计算或数据操作，请考虑在 FPGA 上实现专用的硬件加速器，而不是尝试以缓慢、类似软件的方式执行它们。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"15-固件开发最佳实践\"><a href=\"#15-固件开发最佳实践\" class=\"headerlink\" title=\"15. 固件开发最佳实践\"></a><strong>15. 固件开发最佳实践</strong></h2><p>在定制固件开发中遵循最佳实践对于保持代码质量、促进协作（如果团队合作）、简化调试以及确保项目的长期可维护性和可靠性至关重要。这对于安全敏感的应用尤为如此。</p>\n<h3 id=\"15-1-持续测试与文档\"><a href=\"#15-1-持续测试与文档\" class=\"headerlink\" title=\"15.1 持续测试与文档\"></a><strong>15.1 持续测试与文档</strong></h3><ul>\n<li><p><strong>定期、增量测试</strong>：</p>\n<ul>\n<li><strong>单元测试</strong>：使用专用测试平台隔离测试小型独立模块（例如，TLP解析器、寄存器块）。</li>\n<li><strong>集成测试</strong>：验证不同模块是否协同工作。</li>\n<li><strong>系统测试</strong>：烧录后，与主机系统执行端到端测试，确保整体功能。</li>\n<li><strong>尽早测试，经常测试</strong>：在每次重大更改后，无论多小，都要测试固件，以便尽早发现问题，此时问题更容易调试。</li>\n</ul>\n</li>\n<li><p><strong>自动化测试（高级）</strong> ：</p>\n<ul>\n<li>对于复杂项目，在主机端实现自动化测试脚本（例如，使用Python和硬件抽象层）以重复验证功能和性能。</li>\n<li>在团队环境中，考虑与持续集成（CI）工具（例如，Jenkins、GitLab CI）集成，以自动化每次代码提交的构建、测试和静态分析。</li>\n</ul>\n</li>\n<li><p><strong>维护全面的文档</strong>：</p>\n<ul>\n<li><strong>设计文档</strong>：创建并更新描述固件架构的文档，包括：<ul>\n<li><strong>框图</strong>：说明主要模块及其互连。</li>\n<li><strong>状态机图</strong>：适用于所有有状态逻辑。</li>\n<li><strong>接口规范</strong>：详细说明模块之间的输入&#x2F;输出信号、时序和协议。</li>\n<li><strong>内存映射</strong>：针对所有BAR，定义寄存器地址、位域及其功能。</li>\n</ul>\n</li>\n<li><strong>代码注释</strong>：在SystemVerilog代码中使用清晰、简洁的注释来解释复杂的逻辑、信号的目的以及任何不明显的设计选择。</li>\n<li><strong>更改日志&#x2F;提交消息</strong>：维护更改日志或使用详细的Git提交消息来跟踪所有修改、错误修复和功能添加，解释<em>为什么</em>进行更改。</li>\n<li><strong>用户指南</strong>：对于您的定制固件，一个简单的用户指南，解释如何从主机端构建、烧录和与仿真设备交互，是无价的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-2-管理固件版本\"><a href=\"#15-2-管理固件版本\" class=\"headerlink\" title=\"15.2 管理固件版本\"></a><strong>15.2 管理固件版本</strong></h3><p>正确的版本控制对于跟踪更改、有效协作和管理发布至关重要。</p>\n<ul>\n<li><p><strong>使用版本控制系统（VCS）</strong> ：</p>\n<ul>\n<li><strong>Git</strong>：强烈推荐。使用Git管理您的HDL源代码、约束文件和项目脚本。</li>\n<li><strong>组织仓库</strong>：保持清晰的目录结构（例如，为<code>src</code>、<code>xdc</code>、<code>ip</code>、<code>scripts</code>、<code>doc</code>等设置单独的文件夹）。</li>\n<li><strong>分支</strong>：使用功能分支开发新功能或进行重大更改。在彻底测试后合并回<code>main</code>或<code>develop</code>分支。</li>\n<li><strong>定期提交</strong>：频繁提交，提交内容原子化，提交消息有意义。</li>\n</ul>\n</li>\n<li><p><strong>标记发布和里程碑</strong>：</p>\n<ul>\n<li><strong>稳定版本</strong>：使用Git标签（例如，<code>v1.0.0</code>、<code>v1.0.1_bugfix</code>）标记固件的稳定、经过测试的版本。这使得回溯或部署已知良好状态变得容易。</li>\n<li><strong>里程碑</strong>：标记重要的开发里程碑（例如，“基本枚举工作正常”、“DMA读&#x2F;写功能正常”）。</li>\n</ul>\n</li>\n<li><p><strong>备份和恢复策略</strong>：</p>\n<ul>\n<li><strong>基于云的仓库</strong>：将您的Git仓库托管在GitHub、GitLab或Bitbucket等平台上。这提供了异地备份并促进了协作。</li>\n<li><strong>本地备份</strong>：即使有云仓库，也要定期对整个Vivado项目目录进行本地备份（由于生成的文件，它可能非常大）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-3-安全注意事项\"><a href=\"#15-3-安全注意事项\" class=\"headerlink\" title=\"15.3 安全注意事项\"></a><strong>15.3 安全注意事项</strong></h3><p>开发用于PCIe设备仿真（特别是能够直接内存访问的设备）的定制固件具有重要的安全影响。这项技术本质上是一种“两用”能力，意味着它既可以用于合法目的（例如，硬件测试、安全研究），也可以用于恶意目的（例如，DMA攻击、安全绕过）。<strong>理解并负责任地管理这些风险至关重要。</strong></p>\n<ul>\n<li><p><strong>两用性质与道德影响</strong>：</p>\n<ul>\n<li><strong>道德黑客行为与恶意使用</strong>：明确区分将这些知识用于授权安全测试（红队演练、渗透测试）和未经授权的非法活动。</li>\n<li><strong>负责任的披露</strong>：如果您使用这些技术发现漏洞，请遵循负责任的披露准则。</li>\n<li><strong>法律和许可合规性</strong>：了解并遵守所有与硬件逆向工程和设备修改相关的法律、法规和许可协议（例如，PCIe-SIG规范、Xilinx EULA）。</li>\n<li><strong>“武器化”</strong> ：认识到精确仿真受信任硬件的能力可以被武器化用于高级持久威胁（APTs）或复杂恶意软件。</li>\n</ul>\n</li>\n<li><p><strong>理解攻击向量（攻击视角）</strong> ：</p>\n<ul>\n<li><strong>内存窃取</strong>：恶意仿真设备可以执行DMA读取，以访问任何物理内存地址，包括内核、用户进程中的敏感数据、加密密钥或网络缓冲区。</li>\n<li><strong>内存注入&#x2F;修改</strong>：恶意仿真设备可以执行DMA写入以任意修改内存，从而实现：<ul>\n<li><strong>权限提升</strong>：修改内核数据结构（例如，进程令牌、SID）以获得管理员或系统权限。</li>\n<li><strong>代码注入</strong>：将恶意代码注入正在运行的进程或内核，然后触发其执行。</li>\n<li><strong>安全软件绕过</strong>：通过直接修改内存来禁用或颠覆端点检测和响应（EDR）、防病毒或防火墙软件。</li>\n</ul>\n</li>\n<li><strong>模糊测试和崩溃</strong>：发送格式错误或不符合规范的TLP&#x2F;命令，以触发驱动程序漏洞，导致系统崩溃（蓝屏死机）或潜在的可利用内存损坏。</li>\n<li><strong>固件&#x2F;BIOS操作</strong>：在某些高级场景中，DMA设备可能能够与包含BIOS&#x2F;UEFI的主机SPI闪存进行交互，可能用于持久性修改。</li>\n</ul>\n</li>\n<li><p><strong>防御措施和缓解策略（防御视角）</strong> ：</p>\n<ul>\n<li><strong>IOMMU&#x2F;VT-d&#x2F;AMD-Vi</strong>：如第3.2节所述，这些技术旨在通过为外设提供内存保护来缓解DMA攻击。<strong>对于合法测试，您会禁用它们，但在生产系统中，它们应始终启用。</strong>  它们阻止外设未经授权的内存访问。</li>\n<li><strong>内核DMA保护（Windows）&#x2F; Thunderbolt安全（Linux）</strong> ：现代操作系统功能专门解决“冷启动”DMA攻击（攻击者在系统关闭或锁定时连接恶意设备）。在生产系统上保持这些功能启用。</li>\n<li><strong>安全启动</strong>：虽然不是直接的DMA保护，但安全启动有助于确保只加载受信任的引导加载程序和内核模块，从而减少攻击者注入恶意内核组件以绕过DMA保护的机会。</li>\n<li><strong>物理安全</strong>：最基本但最关键的防御。如果攻击者可以物理访问PCIe插槽或Thunderbolt端口，他们可以绕过许多软件保护。保护对关键系统的物理访问。</li>\n<li><strong>驱动程序强化</strong>：驱动程序应以防御性方式编写，严格验证来自硬件的所有输入并在严格的内存边界内操作。</li>\n<li><strong>内存强化</strong>：操作系统级的内存保护（例如KASLR、DEP、SMAP&#x2F;SMEP）有助于减少内存损坏的影响，但直接DMA攻击会绕过这些保护。</li>\n<li><strong>监控和日志记录</strong>：虽然在硬件层面很难，但异常的DMA活动或未知PCIe设备的枚举应在安全监控系统中触发警报。</li>\n</ul>\n</li>\n<li><p><strong>固件安全编码实践</strong>：</p>\n<ul>\n<li><strong>输入验证</strong>：如果您的固件接受任何输入（例如，通过UART调试接口，或由主机写入的内部寄存器），请严格验证它们，以防止缓冲区溢出、整数溢出或意外行为。</li>\n<li><strong>最小权限</strong>：设计您的固件逻辑，使其仅执行其功能绝对必要的操作。避免授予不必要的功能。</li>\n<li><strong>状态管理</strong>：实现健壮的状态机，以防止由于无效状态转换而导致的意外行为。</li>\n<li><strong>无硬编码秘密</strong>：避免直接在固件中嵌入敏感信息（例如，加密密钥、硬编码凭据），如果它们可以轻易被提取。</li>\n<li><strong>篡改检测</strong>：对于生产固件，考虑实现检测固件本身是否已被篡改或是否加载了未经授权配置的机制。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"16-其他资源\"><a href=\"#16-其他资源\" class=\"headerlink\" title=\"16. 其他资源\"></a><strong>16. 其他资源</strong></h2><p>为了加深您对FPGA开发、PCIe和硬件安全等动态领域的理解并保持更新，请查阅以下资源：</p>\n<ul>\n<li><p><strong>Xilinx (AMD) 文档</strong>：您获取Vivado和Xilinx FPGA所有信息的主要来源。</p>\n<ul>\n<li><strong>主文档门户</strong>：<a href=\"https://docs.amd.com/\">https://docs.amd.com/</a>（原Xilinx.com&#x2F;support&#x2F;documentation）。</li>\n<li><strong>Vivado 设计套件用户指南</strong>：<ul>\n<li><strong>UG900 - 入门指南</strong>：Vivado新用户必备。</li>\n<li><strong>UG901 - 逻辑综合</strong>：深入了解综合。</li>\n<li><strong>UG904 - 实现</strong>：关于放置和布线的详细指南。</li>\n<li><strong>UG912 - Tcl 命令参考指南</strong>：对于脚本编写价值巨大。</li>\n<li><strong>UG939 - 调试</strong>：ILA和其他调试功能的综合指南。</li>\n</ul>\n</li>\n<li><strong>PCI Express IP 核用户指南</strong>：理解Xilinx PCIe IP至关重要（例如，<strong>PG054 for 7 Series Integrated Block for PCI Express</strong>）。在文档门户上搜索“PCI Express”。这详细介绍了核的配置、接口和限制。</li>\n</ul>\n</li>\n<li><p><strong>PCI-SIG 规范</strong>：PCIe 标准的权威来源。</p>\n<ul>\n<li><strong>PCI Express Base Specification</strong>：基础文档。虽然不公开免费，但基于它的摘要和教育材料广泛可用。您通常可以在其网站上找到信息：<a href=\"https://pcisig.com/specifications\">https://pcisig.com/specifications</a>（注意：完整规范通常需要PCI-SIG会员资格）。</li>\n</ul>\n</li>\n<li><p><strong>FPGA 教程和学习平台</strong>：</p>\n<ul>\n<li><strong>FPGA4Fun</strong>：<a href=\"http://www.fpga4fun.com/\">http://www.fpga4fun.com/</a> - 一个经典网站，提供许多实用的FPGA项目和教程。</li>\n<li><strong>Verilog&#x2F;VHDL 教程</strong>：<ul>\n<li><strong>ASIC World Verilog 教程</strong>：<a href=\"https://www.asic-world.com/verilog/index.html\">https://www.asic-world.com/verilog/index.html</a> - 很好的Verilog基础参考。</li>\n<li><strong>VHDLwhiz</strong>：<a href=\"https://www.vhdlwhiz.com/\">https://www.vhdlwhiz.com/</a> - VHDL 参考和教程。</li>\n</ul>\n</li>\n<li><strong>Stack Overflow (FPGA&#x2F;Verilog&#x2F;PCIe 标签)</strong> ：<a href=\"https://stackoverflow.com/questions/tagged/fpga\">https://stackoverflow.com/questions/tagged/fpga</a> - 社区驱动的针对特定技术问题的问答。</li>\n</ul>\n</li>\n<li><p><strong>PCIe 协议分析工具</strong>：</p>\n<ul>\n<li><strong>Teledyne LeCroy Protocol Analyzers</strong>：<a href=\"https://teledynelecroy.com/protocolanalyzer/\">https://teledynelecroy.com/protocolanalyzer/</a> - 探索他们的高性能PCIe分析仪和软件系列。</li>\n<li><strong>Telescan PE Software</strong>：<a href=\"https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software\">https://www.teledynelecroy.com/protocolanalyzer/pci-express/telescan-pe-software/resources/analysis-software</a> - 一款免费软件工具，提供一些PCIe分析功能（需要注册）。</li>\n</ul>\n</li>\n<li><p><strong>PCILeech 社区和资源</strong>：</p>\n<ul>\n<li><code>ufrisk/pcileech</code> GitHub 仓库是核心。积极关注其更新和问题。</li>\n<li>寻找致力于PCILeech或类似开源DMA项目的社区论坛或Discord服务器。</li>\n</ul>\n</li>\n<li><p><strong>硬件安全与逆向工程</strong>：</p>\n<ul>\n<li>关于硬件黑客、逆向工程和低级系统利用的书籍。</li>\n<li>Black Hat、DEF CON、Recon 和 Troopers 等会议通常会举办关于 PCIe 和 DMA 攻击的讲座。</li>\n<li>专注于硬件的安全研究人员的博客和研究论文。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"17-联系方式\"><a href=\"#17-联系方式\" class=\"headerlink\" title=\"17. 联系方式\"></a><strong>17. 联系方式</strong></h2><p>如果您需要帮助、有疑问或希望就本指南、固件开发或硬件安全相关主题进行合作，请随时联系。我乐意提供指导、解决复杂问题或详细讨论想法。</p>\n<h3 id=\"Discord：\"><a href=\"#Discord：\" class=\"headerlink\" title=\"Discord：\"></a><strong>Discord</strong>：</h3><ul>\n<li><strong>用户</strong>：**<a href=\"https://discord.com/users/196741541094621184\">VCPU</a>**</li>\n<li><strong>服务器邀请链接</strong>：**<a href=\"https://discord.gg/dS2gDUDQmV\">加入硬件黑客与固件开发Discord</a>**</li>\n</ul>\n<hr>\n<h2 id=\"18-支持与贡献\"><a href=\"#18-支持与贡献\" class=\"headerlink\" title=\"18. 支持与贡献\"></a><strong>18. 支持与贡献</strong></h2><p>您的支持有助于维护和改进本指南及相关项目。创建和更新全面的技术文档以及开源硬件项目需要大量时间和精力。</p>\n<h3 id=\"捐赠\"><a href=\"#捐赠\" class=\"headerlink\" title=\"捐赠\"></a><strong>捐赠</strong></h3><p>如果您觉得本指南有帮助并希望支持正在进行的工作，请考虑捐赠。每一笔捐款，无论大小，都有助于我们继续通过进一步的研究、开发和文档工作来创建、分享和支持社区。</p>\n<ul>\n<li><strong>加密货币捐赠（LTC - 莱特币）</strong> ：<ul>\n<li><strong>地址</strong>：<code>MPMyQD5zgy2b2CpDn1C1KZ31KmHpT7AwRi</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>特别奖励</strong>：如果您捐赠，请随时在Discord上（VCPU）与我联系，以获得个人感谢，并可能获得额外资源、新内容的早期访问或项目上的个性化帮助。</p>\n<p><strong>注意</strong>：如果您需要我审查您实现的特定部分、解决问题或提供详细的代码反馈，请在您的代码中用<code>//VCPU-REVIEW//</code>注释标记相关部分，并提供您遇到的问题或疑问的详细说明。这有助于我集中精力并提供最有效的支持。</p>\n<p>愿上帝保佑您的灵魂。</p>\n<hr>\n<p><strong>指南结束</strong></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmclcaf3j0003p8vwg7k2efso","category_id":"cmclcaf3t000cp8vw4m753liv","_id":"cmclcaf42000kp8vwfvhe6bwq"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","category_id":"cmclcaf3x000gp8vw9hhb9w60","_id":"cmclcaf4l001bp8vwd4677qw4"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","category_id":"cmclcaf4j0016p8vwhlzq97vh","_id":"cmclcaf4m001ep8vwggtteajy"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","category_id":"cmclcaf3l0004p8vwe8fc96bf","_id":"cmclcaf4o001np8vwaxzzgecm"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","category_id":"cmclcaf42000lp8vw82x80qgg","_id":"cmclcaf4o001qp8vw1og78tst"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","category_id":"cmclcaf4m001hp8vw4zmn06oz","_id":"cmclcaf4p001rp8vwe1lo0p6n"},{"post_id":"cmclcaf4e000zp8vw6fgy2i1w","category_id":"cmclcaf4t0022p8vw1r9y8zxt","_id":"cmclcaf4u0027p8vwdhrx4ztt"},{"post_id":"cmclcaf4i0015p8vwd9w20w35","category_id":"cmclcaf4u002ap8vw1maqdkb8","_id":"cmclcaf4y002ip8vw7ftj5oh9"},{"post_id":"cmclcaf3v000ep8vw24bg498u","category_id":"cmclcaf47000pp8vw45ua4oq9","_id":"cmclcaf54002zp8vw6b4b7syo"},{"post_id":"cmclcaf3v000ep8vw24bg498u","category_id":"cmclcaf4p001sp8vw5wj27mja","_id":"cmclcaf540032p8vw2hzpeio4"},{"post_id":"cmclcaf3v000ep8vw24bg498u","category_id":"cmclcaf50002rp8vw1ioz0m7x","_id":"cmclcaf550033p8vw5wxm6ziq"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","category_id":"cmclcaf4r001up8vwetb45loh","_id":"cmclcaf550036p8vw30295vma"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","category_id":"cmclcaf53002vp8vwds5680rc","_id":"cmclcaf550037p8vwehgahxb5"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","category_id":"cmclcaf4b000up8vw3evcbhe2","_id":"cmclcaf56003ap8vwey0g603d"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","category_id":"cmclcaf4r001yp8vw3sw54rfz","_id":"cmclcaf56003bp8vw2anc0rr4"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","category_id":"cmclcaf540030p8vwdrlaftqd","_id":"cmclcaf57003ep8vwbkdvceun"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","category_id":"cmclcaf4f0010p8vwgds8goru","_id":"cmclcaf57003ip8vwe66dd8lx"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","category_id":"cmclcaf4u0028p8vw4m845q3e","_id":"cmclcaf58003lp8vw4etshomv"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","category_id":"cmclcaf550039p8vw1ew53cbf","_id":"cmclcaf58003np8vw96br5x1p"},{"post_id":"cmclcaf40000jp8vwf5h7929p","category_id":"cmclcaf4k0019p8vw1mjq0r4n","_id":"cmclcaf59003rp8vw30qfd83k"},{"post_id":"cmclcaf40000jp8vwf5h7929p","category_id":"cmclcaf4y002fp8vw2lxua9u6","_id":"cmclcaf59003sp8vwh2ai3ywe"},{"post_id":"cmclcaf40000jp8vwf5h7929p","category_id":"cmclcaf56003dp8vw84b1bu2m","_id":"cmclcaf5a003vp8vwcgmr43qf"},{"post_id":"cmclcaf45000op8vwdzo14onn","category_id":"cmclcaf4l001cp8vw0oi9dtez","_id":"cmclcaf5a003wp8vw6gfi0zjm"},{"post_id":"cmclcaf45000op8vwdzo14onn","category_id":"cmclcaf4z002kp8vw81pbcl2o","_id":"cmclcaf5b003zp8vwb5prfh67"},{"post_id":"cmclcaf45000op8vwdzo14onn","category_id":"cmclcaf58003jp8vw0hbod8ah","_id":"cmclcaf5b0040p8vwep3c3xxi"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","category_id":"cmclcaf4n001lp8vwczvtavvq","_id":"cmclcaf5b0042p8vwfetfdzzs"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","category_id":"cmclcaf4z002np8vwhiag7ml3","_id":"cmclcaf5c0044p8vw9xkx9s74"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","category_id":"cmclcaf59003qp8vwg0ywbl5x","_id":"cmclcaf5c0047p8vw2sckf5gt"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","category_id":"cmclcaf4o001op8vw6kz3ceiu","_id":"cmclcaf5c0049p8vw5y3m3cu4"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","category_id":"cmclcaf50002pp8vw5kck6w5v","_id":"cmclcaf5c004bp8vw1o9i0kt4"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","category_id":"cmclcaf5a003up8vwh13qgpjd","_id":"cmclcaf5d004ep8vwd1po61id"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","category_id":"cmclcaf4t0025p8vwdsu2hj2q","_id":"cmclcaf5d004fp8vwcfhy4jgw"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","category_id":"cmclcaf550035p8vwhv2ogb04","_id":"cmclcaf5d004hp8vw99njhnpm"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","category_id":"cmclcaf5b003yp8vw6ip5aqvi","_id":"cmclcaf5d004ip8vwgm2oetjf"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","category_id":"cmdxvwf0y00010wsd7s5c6js6","_id":"cmdxvwf1d000d0wsdbrmo3o5g"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","category_id":"cmdxvwf1400050wsdeci2fiuj","_id":"cmdxvwf1e000f0wsd3ou3g8h1"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","category_id":"cmdxvwf1900090wsdgies1mvd","_id":"cmdxvwf1f000j0wsd8pxkd4yh"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","category_id":"cmdxvwf1700070wsd8zml77ed","_id":"cmdxvwf1g000o0wsdg4gn8f9i"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","category_id":"cmdxvwf1b000b0wsd5xuz6b71","_id":"cmdxvwf1g000q0wsdekoc4ya8"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","category_id":"cmdxvwf1e000h0wsd4xtra0ac","_id":"cmdxvwf1g000r0wsd6sqah06w"}],"PostTag":[{"post_id":"cmclcaf3e0001p8vw5cy92vgv","tag_id":"cmclcaf3n0005p8vw89gfei2a","_id":"cmclcaf4d000wp8vwcf7sbq8k"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","tag_id":"cmclcaf3u000dp8vwdc42fhze","_id":"cmclcaf4e000yp8vw8h83er6t"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","tag_id":"cmclcaf3y000hp8vw8yaldaq7","_id":"cmclcaf4g0012p8vw17c66kok"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","tag_id":"cmclcaf43000mp8vw6qjafu4c","_id":"cmclcaf4h0014p8vw64dlbih9"},{"post_id":"cmclcaf3e0001p8vw5cy92vgv","tag_id":"cmclcaf47000qp8vw4r7pejb3","_id":"cmclcaf4k0018p8vw44kbgh1q"},{"post_id":"cmclcaf3j0003p8vwg7k2efso","tag_id":"cmclcaf4c000vp8vw5kye813e","_id":"cmclcaf4m001fp8vwb8og337o"},{"post_id":"cmclcaf3j0003p8vwg7k2efso","tag_id":"cmclcaf4f0011p8vwel1ahb8i","_id":"cmclcaf4m001gp8vw5wdw0gl8"},{"post_id":"cmclcaf3j0003p8vwg7k2efso","tag_id":"cmclcaf4k0017p8vwdeng81fc","_id":"cmclcaf4n001jp8vw472r28jk"},{"post_id":"cmclcaf3j0003p8vwg7k2efso","tag_id":"cmclcaf4l001ap8vwd996e78t","_id":"cmclcaf4n001kp8vwhzp4gbup"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","tag_id":"cmclcaf4m001dp8vwhqoy9nzg","_id":"cmclcaf4r001wp8vwb8f6cu0j"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","tag_id":"cmclcaf4n001ip8vwc42kbgvx","_id":"cmclcaf4r001xp8vw3di31rik"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","tag_id":"cmclcaf4n001mp8vw66umdeni","_id":"cmclcaf4s0020p8vwg6df33bm"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","tag_id":"cmclcaf4o001pp8vwaxyucbpz","_id":"cmclcaf4s0021p8vw8v4h1hqd"},{"post_id":"cmclcaf3q0009p8vw9oj28ohx","tag_id":"cmclcaf4q001tp8vwcnhrfwx4","_id":"cmclcaf4t0024p8vwgsg76m5r"},{"post_id":"cmclcaf3v000ep8vw24bg498u","tag_id":"cmclcaf4r001vp8vw8xpsh23a","_id":"cmclcaf4x002cp8vw1kxwe4lb"},{"post_id":"cmclcaf3v000ep8vw24bg498u","tag_id":"cmclcaf4s001zp8vw3d8df0iq","_id":"cmclcaf4x002dp8vw2aalhbi0"},{"post_id":"cmclcaf3v000ep8vw24bg498u","tag_id":"cmclcaf4t0023p8vwcrlo2rw2","_id":"cmclcaf4y002gp8vw4xsd5u42"},{"post_id":"cmclcaf3v000ep8vw24bg498u","tag_id":"cmclcaf4t0026p8vwftaefann","_id":"cmclcaf4y002hp8vwdqljauw0"},{"post_id":"cmclcaf3v000ep8vw24bg498u","tag_id":"cmclcaf4u0029p8vwanx9bc8q","_id":"cmclcaf4z002lp8vw55us5xxb"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","tag_id":"cmclcaf4r001vp8vw8xpsh23a","_id":"cmclcaf52002sp8vw2aye7vve"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","tag_id":"cmclcaf4x002ep8vwc0r220fe","_id":"cmclcaf52002tp8vw59v784yt"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","tag_id":"cmclcaf4y002jp8vwh4dhbdlg","_id":"cmclcaf53002wp8vwaagw2tmr"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","tag_id":"cmclcaf4z002mp8vwg7jb1m4g","_id":"cmclcaf53002xp8vw63ca4xzv"},{"post_id":"cmclcaf3w000fp8vwafhyflhh","tag_id":"cmclcaf50002op8vwe4md13wq","_id":"cmclcaf540031p8vw3rz0b2e0"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","tag_id":"cmclcaf4r001vp8vw8xpsh23a","_id":"cmclcaf57003fp8vwddjb488h"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","tag_id":"cmclcaf52002up8vw25lu7jex","_id":"cmclcaf57003gp8vw18ufgwvn"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","tag_id":"cmclcaf54002yp8vwb2j763qv","_id":"cmclcaf58003kp8vw3ubv9efn"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","tag_id":"cmclcaf550034p8vw2fg08mpi","_id":"cmclcaf58003mp8vwbpxr48h7"},{"post_id":"cmclcaf3z000ip8vwhmu58oq5","tag_id":"cmclcaf550038p8vwgbc306n0","_id":"cmclcaf59003pp8vw8jym78c7"},{"post_id":"cmclcaf40000jp8vwf5h7929p","tag_id":"cmclcaf56003cp8vw1nxp819h","_id":"cmclcaf5c0043p8vw6w63e427"},{"post_id":"cmclcaf40000jp8vwf5h7929p","tag_id":"cmclcaf57003hp8vwdocqempn","_id":"cmclcaf5c0045p8vwhzn8041y"},{"post_id":"cmclcaf40000jp8vwf5h7929p","tag_id":"cmclcaf4t0023p8vwcrlo2rw2","_id":"cmclcaf5c0048p8vwhy13477v"},{"post_id":"cmclcaf40000jp8vwf5h7929p","tag_id":"cmclcaf59003tp8vw6xeu16ve","_id":"cmclcaf5c004ap8vw6gj63wey"},{"post_id":"cmclcaf40000jp8vwf5h7929p","tag_id":"cmclcaf5a003xp8vw2j2f0dsf","_id":"cmclcaf5d004dp8vwapxyapft"},{"post_id":"cmclcaf44000np8vw767c3kp2","tag_id":"cmclcaf5b0041p8vw2ke73xnm","_id":"cmclcaf5e004lp8vw29ry7eia"},{"post_id":"cmclcaf44000np8vw767c3kp2","tag_id":"cmclcaf5c0046p8vw6j7obqxm","_id":"cmclcaf5e004mp8vw3zl07x9w"},{"post_id":"cmclcaf44000np8vw767c3kp2","tag_id":"cmclcaf5c004cp8vw1x1k7b0n","_id":"cmclcaf5f004op8vw75oigmjf"},{"post_id":"cmclcaf44000np8vw767c3kp2","tag_id":"cmclcaf5d004gp8vw72im8c6j","_id":"cmclcaf5f004pp8vwajuzbw1b"},{"post_id":"cmclcaf44000np8vw767c3kp2","tag_id":"cmclcaf5d004jp8vwhjma8vvz","_id":"cmclcaf5f004rp8vw25rnelth"},{"post_id":"cmclcaf45000op8vwdzo14onn","tag_id":"cmclcaf5e004kp8vw427fdxt3","_id":"cmclcaf5g004vp8vw5q9ldkfw"},{"post_id":"cmclcaf45000op8vwdzo14onn","tag_id":"cmclcaf5f004np8vwezf9fums","_id":"cmclcaf5h004wp8vw2katdx91"},{"post_id":"cmclcaf45000op8vwdzo14onn","tag_id":"cmclcaf5f004qp8vw1rozgb6g","_id":"cmclcaf5i004yp8vwhbele3sd"},{"post_id":"cmclcaf45000op8vwdzo14onn","tag_id":"cmclcaf5f004sp8vw9woxeecy","_id":"cmclcaf5i004zp8vwbyl11ics"},{"post_id":"cmclcaf45000op8vwdzo14onn","tag_id":"cmclcaf5g004tp8vw15z9hjt9","_id":"cmclcaf5j0051p8vwgcxwh2wg"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","tag_id":"cmclcaf5g004up8vwg6bjgfi8","_id":"cmclcaf5k0055p8vw96qof2yf"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","tag_id":"cmclcaf52002up8vw25lu7jex","_id":"cmclcaf5k0056p8vwfmvf6zz0"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","tag_id":"cmclcaf5i0050p8vw4kwi4nmn","_id":"cmclcaf5k0058p8vwg69h0smq"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","tag_id":"cmclcaf5j0052p8vw1wq2egwj","_id":"cmclcaf5k0059p8vw14y1atxv"},{"post_id":"cmclcaf49000rp8vw76yr1ndh","tag_id":"cmclcaf5j0053p8vw83ptbebo","_id":"cmclcaf5k005bp8vw9rooewda"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","tag_id":"cmclcaf5j0054p8vw7t7zadoo","_id":"cmclcaf5l005fp8vwdsp02mw6"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","tag_id":"cmclcaf5k0057p8vwgkb588bh","_id":"cmclcaf5l005gp8vw7pgh2kok"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","tag_id":"cmclcaf5k005ap8vw1io8ba9e","_id":"cmclcaf5m005ip8vw28ox3dxu"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","tag_id":"cmclcaf5k005cp8vw51jm1ql6","_id":"cmclcaf5m005jp8vwf1wabtff"},{"post_id":"cmclcaf4a000sp8vw1tm6dp4t","tag_id":"cmclcaf5l005dp8vwe7zcczdb","_id":"cmclcaf5n005lp8vw77wndl24"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","tag_id":"cmclcaf5l005ep8vwcik48r4z","_id":"cmclcaf5o005pp8vw6yy34h70"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","tag_id":"cmclcaf5l005hp8vwdkm8hym2","_id":"cmclcaf5o005qp8vw591q3rf4"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","tag_id":"cmclcaf5m005kp8vwdbws9lia","_id":"cmclcaf5o005sp8vw1t9z3p28"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","tag_id":"cmclcaf5n005mp8vw289achbl","_id":"cmclcaf5p005tp8vw6p7qetr8"},{"post_id":"cmclcaf4d000xp8vwbzhphejq","tag_id":"cmclcaf5n005np8vw7arzfzil","_id":"cmclcaf5p005vp8vw6do7c8e2"},{"post_id":"cmclcaf4e000zp8vw6fgy2i1w","tag_id":"cmclcaf5o005op8vw1kiccj6h","_id":"cmclcaf5q005zp8vwdjco6o71"},{"post_id":"cmclcaf4e000zp8vw6fgy2i1w","tag_id":"cmclcaf5o005rp8vwfz4d7rci","_id":"cmclcaf5q0060p8vw436g3g9z"},{"post_id":"cmclcaf4e000zp8vw6fgy2i1w","tag_id":"cmclcaf5p005up8vw0mpvenbm","_id":"cmclcaf5q0062p8vw1s6r2okw"},{"post_id":"cmclcaf4e000zp8vw6fgy2i1w","tag_id":"cmclcaf5p005wp8vw7m8275at","_id":"cmclcaf5r0063p8vwa5jo3vnr"},{"post_id":"cmclcaf4e000zp8vw6fgy2i1w","tag_id":"cmclcaf5p005xp8vw8sevfmv8","_id":"cmclcaf5r0065p8vwar5108fd"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","tag_id":"cmclcaf5q005yp8vw5j9z4umi","_id":"cmclcaf5s0069p8vwdg16abmw"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","tag_id":"cmclcaf5q0061p8vw6xnz7qyi","_id":"cmclcaf5t006ap8vwei3a0uc2"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","tag_id":"cmclcaf5r0064p8vw6n1l3u0u","_id":"cmclcaf5t006bp8vwfi2xeadc"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","tag_id":"cmclcaf5r0066p8vwa27ifr0s","_id":"cmclcaf5t006cp8vw2cae05tr"},{"post_id":"cmclcaf4g0013p8vwdgse7yq2","tag_id":"cmclcaf5s0067p8vw4jtg6els","_id":"cmclcaf5t006dp8vwcms589j8"},{"post_id":"cmclcaf4i0015p8vwd9w20w35","tag_id":"cmclcaf5s0068p8vw47apatur","_id":"cmclcaf5t006ep8vw4ah108v5"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","tag_id":"cmdxvwf1100020wsd740t82j6","_id":"cmdxvwf1d000e0wsd8d091h2i"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","tag_id":"cmdxvwf1300030wsdchb3h69z","_id":"cmdxvwf1e000g0wsd9dhx8gyt"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","tag_id":"cmdxvwf1600060wsd67krhox1","_id":"cmdxvwf1f000k0wsdexfl6tg8"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","tag_id":"cmdxvwf1800080wsdf4qvf3k7","_id":"cmdxvwf1g000l0wsd3i58dbhn"},{"post_id":"cmdxvwf0v00000wsdhygc5lds","tag_id":"cmdxvwf1a000a0wsdawiw79yk","_id":"cmdxvwf1g000n0wsd71p7dsh3"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","tag_id":"cmdxvwf1d000c0wsdg49fe6z0","_id":"cmdxvwf1h000t0wsd4h6gh99t"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","tag_id":"cmdxvwf1f000i0wsd0yny3q5x","_id":"cmdxvwf1h000u0wsd5cee04gs"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","tag_id":"cmdxvwf1g000m0wsd88t04zzn","_id":"cmdxvwf1h000v0wsd46rvcwjv"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","tag_id":"cmdxvwf1g000p0wsd1iwahlzc","_id":"cmdxvwf1h000w0wsdht4vhrm2"},{"post_id":"cmdxvwf1300040wsd2ns9f5k9","tag_id":"cmdxvwf1g000s0wsdf2c51ywe","_id":"cmdxvwf1h000x0wsd9d3v0n8w"}],"Tag":[{"name":"spring事务","_id":"cmclcaf3n0005p8vw89gfei2a"},{"name":"异步操作","_id":"cmclcaf3u000dp8vwdc42fhze"},{"name":"事务提交","_id":"cmclcaf3y000hp8vw8yaldaq7"},{"name":"编程技巧","_id":"cmclcaf43000mp8vw6qjafu4c"},{"name":"java开发","_id":"cmclcaf47000qp8vw4r7pejb3"},{"name":"计算机状态","_id":"cmclcaf4c000vp8vw5kye813e"},{"name":"电源管理","_id":"cmclcaf4f0011p8vwel1ahb8i"},{"name":"S3睡眠","_id":"cmclcaf4k0017p8vwdeng81fc"},{"name":"S4休眠","_id":"cmclcaf4l001ap8vwd996e78t"},{"name":"Java","_id":"cmclcaf4m001dp8vwhqoy9nzg"},{"name":"List","_id":"cmclcaf4n001ip8vwc42kbgvx"},{"name":"分片","_id":"cmclcaf4n001mp8vw66umdeni"},{"name":"分组","_id":"cmclcaf4o001pp8vwaxyucbpz"},{"name":"工具类","_id":"cmclcaf4q001tp8vwcnhrfwx4"},{"name":"nginx","_id":"cmclcaf4r001vp8vw8xpsh23a"},{"name":"rtsp","_id":"cmclcaf4s001zp8vw3d8df0iq"},{"name":"配置","_id":"cmclcaf4t0023p8vwcrlo2rw2"},{"name":"流媒体","_id":"cmclcaf4t0026p8vwftaefann"},{"name":"认证","_id":"cmclcaf4u0029p8vwanx9bc8q"},{"name":"tcp代理","_id":"cmclcaf4x002ep8vwc0r220fe"},{"name":"配置指南","_id":"cmclcaf4y002jp8vwh4dhbdlg"},{"name":"负载均衡","_id":"cmclcaf4z002mp8vwg7jb1m4g"},{"name":"性能监控","_id":"cmclcaf50002op8vwe4md13wq"},{"name":"docker","_id":"cmclcaf52002up8vw25lu7jex"},{"name":"源码部署","_id":"cmclcaf54002yp8vwb2j763qv"},{"name":"包管理","_id":"cmclcaf550034p8vw2fg08mpi"},{"name":"开机自启","_id":"cmclcaf550038p8vwgbc306n0"},{"name":"Nginx","_id":"cmclcaf56003cp8vw1nxp819h"},{"name":"WebDAV","_id":"cmclcaf57003hp8vwdocqempn"},{"name":"安全","_id":"cmclcaf59003tp8vw6xeu16ve"},{"name":"服务","_id":"cmclcaf5a003xp8vw2j2f0dsf"},{"name":"端口占用","_id":"cmclcaf5b0041p8vw2ke73xnm"},{"name":"错误处理","_id":"cmclcaf5c0046p8vw6j7obqxm"},{"name":"Windows","_id":"cmclcaf5c004cp8vw1x1k7b0n"},{"name":"Linux","_id":"cmclcaf5d004gp8vw72im8c6j"},{"name":"进程管理","_id":"cmclcaf5d004jp8vwhjma8vvz"},{"name":"复制组件","_id":"cmclcaf5e004kp8vw427fdxt3"},{"name":"vue","_id":"cmclcaf5f004np8vwezf9fums"},{"name":"element-plus","_id":"cmclcaf5f004qp8vw1rozgb6g"},{"name":"剪贴板","_id":"cmclcaf5f004sp8vw9woxeecy"},{"name":"国际化","_id":"cmclcaf5g004tp8vw15z9hjt9"},{"name":"思源笔记","_id":"cmclcaf5g004up8vwg6bjgfi8"},{"name":"一键部署","_id":"cmclcaf5i0050p8vw4kwi4nmn"},{"name":"云备份","_id":"cmclcaf5j0052p8vw1wq2egwj"},{"name":"解锁版","_id":"cmclcaf5j0053p8vw83ptbebo"},{"name":"springboot","_id":"cmclcaf5j0054p8vw7t7zadoo"},{"name":"本地jar","_id":"cmclcaf5k0057p8vwgkb588bh"},{"name":"maven","_id":"cmclcaf5k005ap8vw1io8ba9e"},{"name":"依赖管理","_id":"cmclcaf5k005cp8vw51jm1ql6"},{"name":"项目配置","_id":"cmclcaf5l005dp8vwe7zcczdb"},{"name":"磁盘测试","_id":"cmclcaf5l005ep8vwcik48r4z"},{"name":"iozone","_id":"cmclcaf5l005hp8vwdkm8hym2"},{"name":"dd命令","_id":"cmclcaf5m005kp8vwdbws9lia"},{"name":"文件系统","_id":"cmclcaf5n005mp8vw289achbl"},{"name":"性能优化","_id":"cmclcaf5n005np8vw7arzfzil"},{"name":"mybatis-plus","_id":"cmclcaf5o005op8vw1kiccj6h"},{"name":"in语法","_id":"cmclcaf5o005rp8vwfz4d7rci"},{"name":"查询","_id":"cmclcaf5p005up8vw0mpvenbm"},{"name":"空列表处理","_id":"cmclcaf5p005wp8vw7m8275at"},{"name":"lambda","_id":"cmclcaf5p005xp8vw8sevfmv8"},{"name":"redis","_id":"cmclcaf5q005yp8vw5j9z4umi"},{"name":"消息队列","_id":"cmclcaf5q0061p8vw6xnz7qyi"},{"name":"java","_id":"cmclcaf5r0064p8vw6n1l3u0u"},{"name":"阻塞消费","_id":"cmclcaf5r0066p8vwa27ifr0s"},{"name":"发布订阅","_id":"cmclcaf5s0067p8vw4jtg6els"},{"name":"yum源更换","_id":"cmclcaf5s0068p8vw47apatur"},{"name":"mysql","_id":"cmdxvwf1100020wsd740t82j6"},{"name":"后缀匹配","_id":"cmdxvwf1300030wsdchb3h69z"},{"name":"索引优化","_id":"cmdxvwf1600060wsd67krhox1"},{"name":"正则表达式","_id":"cmdxvwf1800080wsdf4qvf3k7"},{"name":"虚拟列","_id":"cmdxvwf1a000a0wsdawiw79yk"},{"name":"固件开发","_id":"cmdxvwf1d000c0wsdg49fe6z0"},{"name":"硬件仿真","_id":"cmdxvwf1f000i0wsd0yny3q5x"},{"name":"pcie","_id":"cmdxvwf1g000m0wsd88t04zzn"},{"name":"dma","_id":"cmdxvwf1g000p0wsd1iwahlzc"},{"name":"嵌入式","_id":"cmdxvwf1g000s0wsdf2c51ywe"}]}}